// Game.cpp: implementation of the CGame class.
//
//////////////////////////////////////////////////////////////////////

#include "Game.h"

class CDebugWindow *DbgWnd;

extern void PutLogList(char * cMsg);
extern char G_cTxt[512];
extern char	G_cData50000[50000];	// ´ë¿ë·®ÀÇ µ¥ÀÌÅÍ¸¦ Á¢±ÙÇÏ±â À§ÇÔ.

extern void PutLogFileList(char * cStr);
extern void PutAdminLogFileList(char * cStr);
extern void PutItemLogFileList(char * cStr);
extern void PutLogEventFileList(char * cStr);

extern FILE * pLogFile;
extern HWND	G_hWnd;

// ¸Þ½ÃÁö ÀÛ¼º¿ë ÂüÁ¶È­ÀÏ. 
int _tmp_iMoveLocX[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 1
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1},
	//3
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{20,20,20,20,20,20,20,20,20,20,
	 20,20,20,20,20,20,19,18,17,16,
	 15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,-1},
	//5
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,16,17,18,19,
	 20,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1},
	//7
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//8
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,1,2,3,4,
	 5,6,7,8,9,10,11,12,13,14,
	 15,16,17,18,19,20,-1}
};

int _tmp_iMoveLocY[9][37] = {
	// 0
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//1
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//2
	{0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1},
	//3
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//4
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//5
	{15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,-1,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	//6
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,15,15,15,15,
	 15,15,15,15,15,15,15,15,15,15,
	 15,15,15,15,15,15,-1},
	//7
	{0,1,2,3,4,5,6,7,8,9,
	 10,11,12,13,14,15,-1,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,0},
	// 8
	{15,14,13,12,11,10,9,8,7,6,
	 5,4,3,2,1,0,0,0,0,0,
	 0,0,0,0,0,0,0,0,0,0,
	 0,0,0,0,0,0,-1}
};

char _tmp_cTmpDirX[9] = { 0,0,1,1,1,0,-1,-1,-1 };
char _tmp_cTmpDirY[9] = { 0,-1,-1,0,1,1,1,0,-1 };



//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

extern BOOL	G_bIsThread;
extern void ThreadProc(void *ch);

CGame::CGame(HWND hWnd)
{
 int i;
	
	m_bIsGameStarted = FALSE;
	m_hWnd           = hWnd;
	m_pMainLogSock   = NULL;
	m_pGateSock      = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));

	m_iPlayerMaxLevel = DEF_PLAYERMAXLEVEL;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
		m_pDupItemIDList[i] = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;

	m_iAutoRebootingCount = 0;

	//Show Debug Window
	DbgWnd = new CDebugWindow();
	//DbgWnd->Startup();
	DbgWnd->AddEventMsg("CGame Startup");
}

CGame::~CGame()
{
	DbgWnd->Shutdown();
	delete DbgWnd;
}

BOOL CGame::bAccept(class XSocket * pXSock)
{
 register int i;
 class XSocket * pTmpSock;
 char  cTxt[120];

	if ((m_bIsGateSockAvailable == FALSE) || (m_bIsLogSockAvailable == FALSE)   || 
		(m_bIsItemAvailable == FALSE)     || (m_bIsNpcAvailable == FALSE)       || 
		(m_bIsMagicAvailable == FALSE)    || (m_bIsSkillAvailable == FALSE)     || 
		(m_bIsPortionAvailable == FALSE)  || (m_bOnExitProcess == TRUE)         || 
		(m_bIsQuestAvailable == FALSE)    || (m_bIsBuildItemAvailable == FALSE) ||
		(m_bIsGameStarted == FALSE)) 
		goto CLOSE_ANYWAY;

	// ºñ¾îÀÖ´Â ¹è¿­À» Ã£´Â´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] == NULL) {
		
		m_pClientList[i] = new class CClient(m_hWnd);
		// Å¬¶óÀÌ¾ðÆ® ÀÎµ¦½º ¸®½ºÆ®¿¡ ±â·Ï 
		bAddClientShortCut(i);
		// Á¢¼Ó½Ã°£ ±â·Ï - Àå½Ã°£ ÀÀ´ä¾ø´Â Å¬¶óÀÌ¾ðÆ®¸¦ Á¦°ÅÇÏ±â À§ÇÔÀÌ´Ù. 
		m_pClientList[i]->m_dwSPTime = m_pClientList[i]->m_dwMPTime = 
			m_pClientList[i]->m_dwHPTime = m_pClientList[i]->m_dwAutoSaveTime = 
				m_pClientList[i]->m_dwTime = m_pClientList[i]->m_dwHungerTime = m_pClientList[i]->m_dwExpStockTime = 
					m_pClientList[i]->m_dwRecentAttackTime = m_pClientList[i]->m_dwAutoExpTime = m_pClientList[i]->m_dwSpeedHackCheckTime = timeGetTime();
		
		pXSock->bAccept(m_pClientList[i]->m_pXSock, WM_ONCLIENTSOCKETEVENT + i); 
	
		// Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÁöÀÇ ÁÖ¼Ò¸¦ ¾ò¾î¿Â´Ù.
		ZeroMemory(m_pClientList[i]->m_cIPaddress, sizeof(m_pClientList[i]->m_cIPaddress));
		m_pClientList[i]->m_pXSock->iGetPeerAddress(m_pClientList[i]->m_cIPaddress);

		// Å¬¶óÀÌ¾ðÆ® Á¢¼ÓµÊÀ» Ç¥½Ã.
		wsprintf(G_cTxt,"<%d> New client: %s", i, m_pClientList[i]->m_cIPaddress);
		PutLogList(G_cTxt);

		m_iTotalClients++;

		if (m_iTotalClients > m_iMaxClients) { 
			// ÃÖ´ë »ç¿ëÀÚ ¼ö°¡ °»½ÅµÇ¾ú´Ù. 
			m_iMaxClients = m_iTotalClients;
			GetLocalTime(&m_MaxUserSysTime);
			wsprintf(cTxt, "Maximum Players: %d", m_iMaxClients);
			//PutLogFileList(cTxt);
		}

		// Á¢¼ÓÀº ¹Þ¾ÒÁö¸¸ ¾ÆÁ÷ °ÔÀÓµ¥ÀÌÅÍ´Â Àü¼ÛÀÌ ºÒ°¡´ÉÇÑ »óÅÂÀÌ´Ù. µ¥ÀÌÅÍ°¡ ÃÊ±âÈ­ µÈ ÈÄ¿¡ °¡´ÉÇØÁø´Ù.
		//m_pClientList[iClientH]->m_bIsInitComplete °ªÀ» ÂüÁ¶ÇØ¾ß ÇÑ´Ù.
		return TRUE;
	}

CLOSE_ANYWAY:;

	// ºñ¾îÀÖ´Â ¹è¿­ÀÌ ¾ø¾î Á¢¼ÓÀ» ¹ÞÀ» ¼ö ¾ø´Ù. AcceptÇÏÀÚ ¸¶ÀÚ ²÷´Â´Ù.
	pTmpSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	pXSock->bAccept(pTmpSock, NULL); 
	delete pTmpSock;

	return FALSE;
}


void CGame::OnClientSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iClientH, iRet;
 DWORD dwTime = timeGetTime();

	iTmp = WM_ONCLIENTSOCKETEVENT;
	iClientH = message - iTmp;
	
	if (m_pClientList[iClientH] == NULL) return;

	iRet = m_pClientList[iClientH]->m_pXSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_READCOMPLETE:
		// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù. 
		OnClientRead(iClientH);
		// ÀÀ´ä ½Ã°£À» ±â·ÏÇÑ´Ù.
		m_pClientList[iClientH]->m_dwTime = timeGetTime();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("Socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		wsprintf(G_cTxt,"<%d> Confirmcode notmatch!", iClientH);
		PutLogList(G_cTxt);
		DeleteClient(iClientH, FALSE, TRUE);
		break;

	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// ¼ö½ÅÇØ¾ß ÇÒ ¸Þ½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
		wsprintf(G_cTxt,"<%d> Client connection Lost! (%s)", iClientH, m_pClientList[iClientH]->m_cCharName);
		PutLogList(G_cTxt);
		

		// v1.43 ¸¸¾à ÅÚ·¹Æ÷Æ®¿¡ ÀÇÇÑ Å¬¶óÀÌ¾ðÆ®ÃøÀÇ ¼ÒÄÏ Á¾·á¶ó¸é µ¥ÀÌÅÍ ÀúÀå ¹× Ä«¿îÆ®´Â ÇÏÁö ¾Ê´Â´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		break;
	}													    
}

BOOL CGame::bInit()		   
{
 char * cp, cTxt[120];
 DWORD * dwp;
 WORD * wp;
 int  i;
 SYSTEMTIME SysTime;
 DWORD dwTime = timeGetTime();

	//m_Misc.Temp();

	PutLogList("(!) INITIALIZING GAME SERVER...");
	//

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
		m_iClientShortCut[i] = 0;

	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_iNpcConstructionPoint[i] = NULL;
	
	// ÀÏ´Ü ¿©±â¼­ ¼³Á¤ 
	m_iNpcConstructionPoint[1]  = 100; // MS
	m_iNpcConstructionPoint[2]  = 100; // MS
	m_iNpcConstructionPoint[3]  = 100; // MS
	m_iNpcConstructionPoint[4]  = 100; // MS
	m_iNpcConstructionPoint[5]  = 100; // MS
	m_iNpcConstructionPoint[6]  = 100; // MS
		
	m_iNpcConstructionPoint[43] = 1000; // LWB
	m_iNpcConstructionPoint[44] = 2000; // GHK
	m_iNpcConstructionPoint[45] = 3000; // GHKABS
	m_iNpcConstructionPoint[46] = 2000; // TK
	m_iNpcConstructionPoint[47] = 3000; // BG
	//

	m_bIsGameStarted = FALSE;

	m_pMainLogSock  = NULL;
	m_pGateSock = NULL;
	m_bIsLogSockAvailable   = FALSE;
	m_bIsGateSockAvailable  = FALSE;
	m_bIsItemAvailable      = FALSE;
	m_bIsBuildItemAvailable = FALSE;
	m_bIsNpcAvailable       = FALSE;
	m_bIsMagicAvailable     = FALSE;
	m_bIsSkillAvailable     = FALSE;
	m_bIsQuestAvailable     = FALSE;
	m_bIsPortionAvailable   = FALSE;

	ZeroMemory(m_cServerName, sizeof(m_cServerName));
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
		m_pClientList[i] = NULL;
	
	for (i = 0; i < DEF_MAXMAPS; i++)
		m_pMapList[i] = NULL;

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
		m_pItemConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
		m_pNpcConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXNPCS; i++)
		m_pNpcList[i] = NULL;

	for (i = 0; i < DEF_MSGQUENESIZE; i++)
		m_pMsgQuene[i] = NULL;

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
		m_pMagicConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		m_pSkillConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		m_pQuestConfigList[i] = NULL;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
		m_pDynamicObjectList[i] = NULL;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
		m_pDelayEventList[i] = NULL;

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
		m_pNoticeMsgList[i] = NULL;

	for (i = 0; i < DEF_MAXFISHS; i++)
		m_pFish[i] = NULL;

	for (i = 0; i < DEF_MAXMINERALS; i++)
		m_pMineral[i] = NULL;

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
		m_pPortionConfigList[i] = NULL;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++) {
		m_pSubLogSock[i] = NULL;
		m_bIsSubLogSockAvailable[i] = FALSE;
	}

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
		m_pBuildItemList[i] = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		ZeroMemory(m_stCrusadeStructures[i].cMapName, sizeof(m_stCrusadeStructures[i].cMapName));
		m_stCrusadeStructures[i].cType = NULL;
		m_stCrusadeStructures[i].dX    = NULL;
		m_stCrusadeStructures[i].dY    = NULL;
	}

	for (i = 0; i < DEF_MAXGUILDS; i++)
		m_pGuildTeleportLoc[i].m_iV1 = NULL;

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
		m_stMiddleCrusadeStructureInfo[i].cType = NULL;
		m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
		m_stMiddleCrusadeStructureInfo[i].sX = NULL;
		m_stMiddleCrusadeStructureInfo[i].sY = NULL;
	}
	m_iTotalMiddleCrusadeStructures = 0;
	
	m_pNoticementData = NULL;

	m_iQueneHead = 0;
	m_iQueneTail = 0;

	m_iTotalClients = 0;
	m_iMaxClients   = 0;
	m_iTotalMaps    = 0;

	m_iTotalGameServerClients    = 0;
	m_iTotalGameServerMaxClients = 0;

	m_MaxUserSysTime.wHour   = 0;
	m_MaxUserSysTime.wMinute = 0;

	m_bIsServerShutdowned = FALSE;
	m_cShutDownCode = 0;

	m_iMiddlelandMapIndex = -1;
	m_iAresdenMapIndex    = -1;
	m_iElvineMapIndex     = -1;
	m_iAresdenOccupyTiles = 0;
	m_iElvineOccupyTiles  = 0;

	m_iSubLogSockInitIndex   = 0;

	m_iCurMsgs = 0;
	m_iMaxMsgs = 0;

	m_stCityStatus[1].iCrimes = 0;
	m_stCityStatus[1].iFunds  = 0;
	m_stCityStatus[1].iWins   = 0;

	m_stCityStatus[2].iCrimes = 0;
	m_stCityStatus[2].iFunds  = 0;
	m_stCityStatus[2].iWins   = 0;
 
	m_iStrategicStatus = 0;

	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;

	m_iAresdenMana = 0;
	m_iElvineMana  = 0;
	//

	m_dwSpecialEventTime = m_dwWhetherTime = m_dwGameTime1 = 
		m_dwGameTime2 = m_dwGameTime3 = m_dwGameTime4 = m_dwGameTime5 = m_dwGameTime6 = m_dwFishTime = dwTime;

	m_bIsSpecialEventTime = FALSE;

	GetLocalTime(&SysTime);
	// dwTime - ³²Àº ¿¹¾à °¡´ÉÇÑ ½Ã°£ 
	m_dwCanFightzoneReserveTime =  dwTime -  ((SysTime.wHour%2)*60*60 + SysTime.wMinute*60) *1000 ;
		
	// v1.4311-3 Ãß°¡ º¯¼ö ÃÊ±âÈ­ »çÅõÀå ¿¹¾à °ü·Ã 
	for(i =0; i < DEF_MAXFIGHTZONE; i++) 
		m_iFightZoneReserve[i] = 0 ;

	// v1.4311-3 Ãß°¡ º¯¼ö ÃÊ±âÈ­ »çÅõÀå °­ÄÝ °ü·Ã 
	m_iFightzoneNoForceRecall = 0;

	// °¢ ·¹º§º° °æÇèÄ¡ ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
	for (i = 1; i < 300; i++) {
		m_iLevelExpTable[i] = iGetLevelExp(i);
		//testcode
		//wsprintf(G_cTxt, "Level:%d --- Exp:%d", i, m_iLevelExpTable[i]);
		//PutLogFileList(G_cTxt);
	}

	m_iLimitedUserExp = m_iLevelExpTable[DEF_LEVELLIMIT+1]; // Ã¼ÇèÆÇ À¯Àú´Â 20·¹º§ÀÌ»óÀÇ °æÇèÄ¡´Â ¾òÀ» ¼ö ¾ø´Ù.  ÀÓ½Ã·Î ·¹º§ 60±îÁö
	m_iLevelExp20     = m_iLevelExpTable[20]; 

	if (bReadProgramConfigFile("GServer.cfg") == FALSE) {
		PutLogList(" ");
		PutLogList("(!!!) CRITICAL ERROR! Cannot execute server! config file contents error!");
		return FALSE;	
	}
	
	srand( (unsigned)time( NULL ) );   
	// Main Log Socket·ÎÀÇ ¿¬°á ½Ãµµ 
	m_pMainLogSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pMainLogSock->bConnect(m_cLogServerAddr, m_iLogServerPort, WM_ONLOGSOCKETEVENT);
	m_pMainLogSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	
	wsprintf(cTxt, "(!) Try to Connect main-log-socket... Addr:%s  Port:%d", m_cLogServerAddr, m_iLogServerPort);
	PutLogList(cTxt);
	//Sleep(100);

	// Gate Server·ÎÀÇ ¿¬°á½Ãµµ 

	m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
	m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
	m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
	// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
	m_iGateSockConnRetryTimes = 1;

	wsprintf(cTxt, "(!) Try to Connect Gate Server... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
	PutLogList(cTxt);
	Sleep(100);
	m_bF1pressed = m_bF4pressed = m_bF12pressed = FALSE;
	
	// ¼­¹ö ¼Ë´Ù¿î ÇÁ·Î¼¼½º º¯¼ö. ÀÌº¯¼ö°¡ ÄÑÁö¸é ´õÀÌ»ó »õ Á¢¼ÓÀ» ¹ÞÁö ¾ÊÀ¸¸ç Å¸ÀÌ¸Ó´ç 50¸í¾¿ °­Á¦ Á¢¼Ó Á¾·á½ÃÅ²´Ù.
	m_bOnExitProcess = FALSE;
	
	// SkillSSN Æ÷ÀÎÆ®¸¦ ¹Ì¸® °è»êÇØ ³õ´Â´Ù.
	for (i = 0; i <= 100; i++) {
		m_iSkillSSNpoint[i] = _iCalcSkillSSNpoint(i);
	}

	// ÁÖ, ¾ß°£ ¸ðµå ¼³Á¤ 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	// °øÁö»çÇ× ¸Þ½ÃÁö¸¦ ÀÐ´Â´Ù.
	bReadNotifyMsgListFile("notice.txt");
	m_dwNoticeTime = dwTime;

	m_iCurSubLogSockIndex    = 0;
	m_iSubLogSockFailCount   = 0;
	m_iSubLogSockActiveCount = 0;

	m_pNoticementData      = NULL;
	m_dwNoticementDataSize = 0;

	m_dwMapSectorInfoTime = dwTime;
	m_iMapSectorInfoUpdateCount = 0;

	m_iCrusadeCount  = NULL;
	m_bIsCrusadeMode = FALSE;
	m_wServerID_GSS = iDice(1,65535);

	ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
	cp = (char *)m_cGateServerStockMsg;
	dwp = (DWORD *)cp;
	*dwp = MSGID_SERVERSTOCKMSG;
	cp += 4;
	wp = (WORD *)cp;
	*wp = DEF_MSGTYPE_CONFIRM;
	cp += 2;

	m_iIndexGSS = 6;
	m_dwCrusadeGUID = NULL;
	m_iCrusadeWinnerSide = NULL;
	
	return TRUE;
}

void CGame::OnClientRead(int iClientH)
{
 char  * pData, cKey;
 DWORD  dwMsgSize;
	
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = m_pClientList[iClientH]->m_pXSock->pGetRcvDataPointer(&dwMsgSize, &cKey); // v1.4
	
	if (bPutMsgQuene(DEF_MSGFROM_CLIENT, pData, dwMsgSize, iClientH, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}
}


void CGame::DisplayInfo(HDC hdc)
{
 char cTxt[350], cTemp[30], cDave[350];  
 int  i, ix, iy, iLine;

	// NT¿¡¼­ ¿¡·¯³²! ÁÖÀÇ 
	wsprintf(cTxt, "Server-Name(%s) Max.Level(%d) Players(%d/%d - %d/%d) Crusade(%d:%d) SLSock(%d:%d) GTSock(%d) RBT(%d)", m_cServerName, m_iPlayerMaxLevel, m_iTotalClients, m_iMaxClients, m_iTotalGameServerClients, m_iTotalGameServerMaxClients, m_dwCrusadeGUID, (int)m_bIsCrusadeMode, m_iSubLogSockActiveCount, m_iSubLogSockFailCount, m_iGateSockConnRetryTimes, m_iAutoRebootingCount);
	TextOut(hdc, 5, 10, cTxt, strlen(cTxt));

//#ifdef DEF_TESTSERVER
//	ZeroMemory(cTxt, sizeof(cTxt));
//	strcpy(cTxt, "Helbreath Version 3.2 By Zero of HBx ********** TEST SERVER MODE **********");
//	TextOut(hdc, 5, 25, cTxt, strlen(cTxt));
//#endif

	GayDave(cDave, "Bobobob");
	TextOut(hdc, 5, 25, cDave, strlen(cDave));


	iLine = 0;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {

		ZeroMemory(G_cTxt, sizeof(G_cTxt));
		wsprintf(G_cTxt, "Map(%s)    Object(%d)    P(%d, %d)    N(%d, %d)    A(%d, %d)    E(%d, %d)    M(%d, %d)", 
			     m_pMapList[i]->m_cName, m_pMapList[i]->m_iTotalActiveObject,  m_pMapList[i]->m_iMaxPx*20+10, m_pMapList[i]->m_iMaxPy*20+10, 
				 m_pMapList[i]->m_iMaxNx*20+10, m_pMapList[i]->m_iMaxNy*20+10, m_pMapList[i]->m_iMaxAx*20+10, m_pMapList[i]->m_iMaxAy*20+10, 
				 m_pMapList[i]->m_iMaxEx*20+10, m_pMapList[i]->m_iMaxEy*20+10, m_pMapList[i]->m_iMaxMx*20+10, m_pMapList[i]->m_iMaxMy*20+10);
		
		TextOut(hdc, 5, 400 + iLine*15, G_cTxt, strlen(G_cTxt));
		iLine++;
	}
}

void CGame::GayDave(char cDave[350], char cInput[350])
{
 char * pDisplay, * wdap, * pInput;
	pInput = cInput;
	pDisplay = cDave;

	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "B", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "Z", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "H", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "p", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ",", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "A", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "A", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "d", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "K", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "L", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "K", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "-", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "w", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "x", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, ".", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "m", 1); pDisplay++;
	wdap = (char *)pDisplay; memcpy(wdap, "       ********** TEST SERVER MODE **********               ", 60); pDisplay++;
	return;
}
void CGame::ClientMotionHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand, wTargetObjectID;
 DWORD * dwp, dwTime;
 short * sp, sX, sY, dX, dY, wType;
 char  * cp, cDir;
 int   iRet, iTemp;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
  
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;

	sp = (short *)cp;
	dX = *sp;
	cp += 2;

	sp = (short *)cp;
	dY = *sp;
	cp += 2;

	sp = (short *)cp;
	wType = *sp;
	cp += 2;

	if ((wCommand == DEF_OBJECTATTACK) || (wCommand == DEF_OBJECTATTACKMOVE)) { // v1.4
		wp = (WORD *)cp;
		wTargetObjectID = *wp;
		cp += 2;
	}
	
	switch (wCommand) {
	case DEF_OBJECTSTOP:
		// ÇÃ·¹ÀÌ¾î°¡ ¹æÇâÀ» ¹Ù²Ù¾ú´Ù.
		iRet = iClientMotion_Stop_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¹æÇâÀüÈ¯ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTSTOP, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTRUN:
		// ´Þ¸°°Í¿¡ ´ëÇÑ È¿°ú¸¦ Ã³¸®ÇÑ´Ù. Ã¼·Â°¨¼Òµîµî
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, TRUE);
		if (iRet == 1) {
			// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTRUN, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if (iRet == 1) {
			// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTDAMAGEMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if (iRet == 1) {
			// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù.                                                      
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[iClientH]->m_iLastDamage, NULL, NULL);
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACKMOVE:
		iRet = iClientMotion_Move_Handler(iClientH, sX, sY, cDir, FALSE);
		if ((iRet == 1) && (m_pClientList[iClientH] != NULL)) {
			// ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÀÌµ¿ ÀÌº¥Æ®¸¦ ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACKMOVE, NULL, NULL, NULL);
			// °ø°Ý È¿°ú¸¦ °è»ê
			iClientMotion_Attack_Handler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, wType, cDir, wTargetObjectID, FALSE); // v1.4
		}
		if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_iHP <= 0)) ClientKilledHandler(iClientH, NULL, NULL, 1); // v1.4
		break;

	case DEF_OBJECTATTACK:
		// ÀÌ À§¿¡¼­ wTypeÀÌ ÇÕ´çÇÑÁö¸¦ ¸ÕÀú Ã³¸®ÇÑ´Ù. 
		_CheckAttackType(iClientH, &wType);
		iRet = iClientMotion_Attack_Handler(iClientH, sX, sY, dX, dY, wType, cDir, wTargetObjectID); // v1.4
		if (iRet == 1) {
			if (wType >= 20) {
				// ÇÊ»ì±â Ä«¿îÆ®¸¦ °¨¼ÒÇÑ´Ù.
				m_pClientList[iClientH]->m_iSuperAttackLeft--;
				// Ä«¿îÆ®°¡ ¸¶ÀÌ³Ê½º°¡ µÉ ÀÏÀº ¾ø°ÚÁö¸¸ ¿¡·¯ ¹æÁö¿ë
				if (m_pClientList[iClientH]->m_iSuperAttackLeft < 0) m_pClientList[iClientH]->m_iSuperAttackLeft = 0;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, wType);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTGETITEM:
		iRet = iClientMotion_GetItem_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTGETITEM, NULL, NULL, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	case DEF_OBJECTMAGIC:
		iRet = iClientMotion_Magic_Handler(iClientH, sX, sY, cDir);
		if (iRet == 1) {
			// CastingÇÑ ¸¶¹ý ¹øÈ£(dX)¸¦ ÇÔ²² º¸³½´Ù.
			// v1.41 CastingÇÑ ÇÃ·¹ÀÌ¾îÀÇ ¸¶¹ý´É·Â ¼öÁØÀ» ÇÔ²² º¸³½´Ù. 
			iTemp = 10;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTMAGIC, dX, iTemp, NULL);
		}
		else if (iRet == 2) SendObjectMotionRejectMsg(iClientH);
		break;

	default:
		break;
	}
}

int CGame::iClientMotion_Move_Handler(int iClientH, short sX, short sY, char cDir, BOOL bIsRun)
{
 char  * cp, cData[3000];
 class CTile * pTile;
 DWORD * dwp, dwTime;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sTemp, sTemp2, sDOtype;
 int   * ip, iRet, iSize, iDamage;
 BOOL  bRet;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	// ÁËÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â ¸í·ÉÀº ¹«½ÃÇÑ´Ù. Reject¸Þ½ÃÁö¸¦ ¹Þ±â ÀÌÀü¿¡ Àü¼ÛµÈ ¸Þ½ÃÁöµéÀÌ´Ù.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	dwTime = timeGetTime();
	
#ifndef NO_MSGSPEEDCHECK
	if (bIsRun == FALSE) {
		m_pClientList[iClientH]->m_iMoveMsgRecvCount++;
		// Crusade ¼Óµµ Á¶ÀÛ Ã¼Å©
		if (m_pClientList[iClientH]->m_iMoveMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwMoveLAT != 0) {
				// 7¹ø ¿òÁ÷ÀÎ °æ¿ì ÃÖ¼Ò ¼Ò¿ä ½Ã°£Àº 72*8*7 = 4032ms. Çã¿ë ¿ÀÂ÷ 3000ms
				if ((dwTime - m_pClientList[iClientH]->m_dwMoveLAT) < (72*8*7 -3000)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwMoveLAT = dwTime;
			m_pClientList[iClientH]->m_iMoveMsgRecvCount = 0;
		}
	}
	else {
		m_pClientList[iClientH]->m_iRunMsgRecvCount++;
		// Crusade ¼Óµµ Á¶ÀÛ Ã¼Å©
		if (m_pClientList[iClientH]->m_iRunMsgRecvCount >= 7) {
			if (m_pClientList[iClientH]->m_dwRunLAT != 0) {
				// 7¹ø ´Þ¸° °æ¿ì ÃÖ¼Ò ¼Ò¿ä ½Ã°£Àº 43*8*7 = 2408ms. Çã¿ë ¿ÀÂ÷ 1500ms
				if ((dwTime - m_pClientList[iClientH]->m_dwRunLAT) < (43*8*7 -1500)) {
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
			m_pClientList[iClientH]->m_dwRunLAT	= dwTime;
			m_pClientList[iClientH]->m_iRunMsgRecvCount = 0;
		}
	}
#endif
	
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	
	// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
	ClearSkillUsingStatus(iClientH);
	
	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetMoveable(dX, dY, &sDOtype);
	
	// ÀÌµ¿ ºÒ´É »óÅÂ¶ó¸é
	if (m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)
		bRet = FALSE;
  
	if (bRet == TRUE) {

		// Quest ¿©ºÎ¸¦ ÆÇ´ÜÇÑ´Ù.
		if (m_pClientList[iClientH]->m_iQuest != NULL) _bCheckIsQuestCompleted(iClientH);

		// ÀÌµ¿ÀÌ °¡´ÉÇÏ´Ù. °ú°ÅÀÇ À§Ä¡¿¡¼­ Áö¿î´Ù.
		// ÇÚµé°ªÀÌ ÀÏÄ¡ÇÏ¸é ClearOwner¿¡¼­ DeadOwnerµµ »èÁ¦ÇÑ´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

		m_pClientList[iClientH]->m_sX   = dX;
		m_pClientList[iClientH]->m_sY   = dY;
		m_pClientList[iClientH]->m_cDir = cDir;
		// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH,
			                                                       DEF_OWNERTYPE_PLAYER,
																   dX, dY);

		//v1.4 ¹Ù´Ú¿¡ ½ºÆÄÀÌÅ©°¡ ±ò·Á ÀÖ´Ù¸é È¿°ú¸¦ °è»êÇÑ´Ù. 
		if (sDOtype == DEF_DYNAMICOBJECT_SPIKE) {
			if ((m_pClientList[iClientH]->m_bIsNeutral == TRUE) && ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0)) {
				// Áß¸³ÀÌ°í ÆòÈ­¸ðµå¸é ´ë¹ÌÁö¸¦ ¾òÁö ¾Ê´Â´Ù.
			}
			else {
				iDamage = iDice(2,4);
				m_pClientList[iClientH]->m_iHP -= iDamage;
			}
		}
		
		if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 0;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
		sp  = (short *)cp;
		*sp = dX - 10; 
		cp += 2;
		
		sp  = (short *)cp;
		*sp = dY - 7; 
		cp += 2;
		
		*cp = cDir;
		cp++;
		
		if (bIsRun == TRUE) {// Staminar °¨¼ÒÄ¡ ÀÔ·Â 
			if (m_pClientList[iClientH]->m_iSP > 0) {
				*cp = 0; // 1
				//v1.42 
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
			}
			else {
				*cp = 0; // 1
				//v1.42 
				if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
					m_pClientList[iClientH]->m_iSP--;
					*cp = 1;
				}
				if (m_pClientList[iClientH]->m_iSP < -10) {
					// HACKING¿¡ ÀÇÇØ Å¬¶óÀÌ¾ðÆ®ÀÇ Staminar point°¡ °íÁ¤µÇ¾î °è¼Ó ¶Û¼ö ÀÖ´Â »óÅÂÀÎ µíÇÏ´Ù. 
					// ¾î¶² Á¾·ùÀÇ Æä³ÎÆ¼°¡ ÇÊ¿äÇÏ´Ù.
					m_pClientList[iClientH]->m_iSP = 0;
					DeleteClient(iClientH, TRUE, TRUE);
					return 0;
				}
			}
		}
		else *cp = 0;
		cp++;
		
		//v1.3 ÇöÀç µó°í ÀÖ´Â ºÎºÐÀÇ Á¡·É¿©ºÎ¸¦ º¸³»ÁØ´Ù.
		pTile = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + dX + dY*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
		*cp = (char)pTile->m_iOccupyStatus;
		cp++;
		
		// v1.4 ÀÌµ¿½Ã¿¡ HP°¡ ¶³¾îÁö´Â Áö¿ª¿¡ ´ëºñÇØ¼­ HP°ªÀ» º¸³»ÁØ´Ù.
		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iHP;
		cp += 4;
		
		iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}
	else {
		// ÀÌµ¿ÀÌ ºÒ°¡´ÉÇÏ´Ù. 
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOVE_REJECT;

		wObjectID = iClientH;

		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		ip  = (int *)cp; // v1.4
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp+= 4;

		sp  = (short *)cp;
		
		// m_pClientList[i]¿Í m_pClientList[sOwnerH]ÀÇ °ü°è¸¦ ÀÔ·ÂÇÑ´Ù.
		// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
		sTemp = m_pClientList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		
		sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		sTemp2 = (short)iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
		sTemp  = (sTemp | (sTemp2 << 12));
		*sp = sTemp;
		cp += 2;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 40); // v1.4 
		
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
		return 0;
	}

	return 1;
}


void CGame::RequestInitPlayerHandler(int iClientH, char * pData, char cKey)
{
 register int i;
 char * cp, cCharName[11], cAccountName[11], cAccountPassword[11], cTxt[120];
 BOOL bIsObserverMode;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return;

	// ÇÃ·¹ÀÌ¾îÀÇ ÀÌ¸§, °èÁ¤ÀÇ ÀÌ¸§, ÆÐ½º¿öµå¸¦ ±â·ÏÇÏ°í ·Î±× ¼­¹ö·Î ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ Àü¼ÛÀ» ¿äÃ»ÇÑ´Ù.

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	ZeroMemory(m_pClientList[iClientH]->m_cCharName, sizeof(m_pClientList[iClientH]->m_cCharName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountName, sizeof(m_pClientList[iClientH]->m_cAccountName));
	ZeroMemory(m_pClientList[iClientH]->m_cAccountPassword, sizeof(m_pClientList[iClientH]->m_cAccountPassword));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cCharName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cCharName, sizeof(cCharName));
	memcpy(cCharName, cTxt, 10);

	//testcode
	if (strlen(cTxt) == 0) PutLogList("RIPH - cTxt: Char NULL!");

	memcpy(cAccountName, cp, 10);
	cp += 10;
	
	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountName, sizeof(cAccountName));
	memcpy(cAccountName, cTxt, 10);

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cAccountPassword, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	memcpy(cAccountPassword, cTxt, 10);
	
	bIsObserverMode = (BOOL)*cp;
	cp++;

	// Áßº¹µÈ °èÁ¤À» °®°íÀÖ´Â Ä³¸¯ÅÍ¸¦ »èÁ¦ÇÑ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cAccountName, cAccountName, 10) == 0)) {
		// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏ¸é ¶Õ°í µé¾î°¥ ¼ö ÀÖ´Ù. ±×·¯³ª ´Ù¸£¸é Á¢¼Ó ºÒ°¡. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÑ´Ù. 
			wsprintf(G_cTxt, "<%d> Duplicate account player! Deleted with data save : CharName(%s) AccntName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	// 3¹øÂ° FALSE:·Î±× ¼­¹ö·Î Ä«¿îÆÃ ´Ù¿îÀº ÇÏÁö ¸»¶ó´Â ¸Þ½ÃÁö 
		}
		else {
			// v1.4 °èÁ¤ Á¤º¸¸¦ ÀÔ·ÂÇØ¾ß ·Î±×ÀÎ ¼­¹ö·Î Åëº¸°¡ °¡´ÉÇÏ´Ù.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.  Á¢¼Ó ºÒ°¡. 
			DeleteClient(iClientH, FALSE, FALSE, FALSE);
			return;
		}
	}	
	
	// Áßº¹µÈ ÀÌ¸§À» °®°í ÀÖ´Â Ä³¸¯ÅÍ°¡ ÀÖ´Ù¸é ¸¶Âù°¡Áö·Î »èÁ¦ 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (iClientH != i) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏ¸é ¶Õ°í µé¾î°¥ ¼ö ÀÖ´Ù. ±×·¯³ª ´Ù¸£¸é Á¢¼Ó ºÒ°¡. 
		if (memcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword, 10) == 0) { 
			wsprintf(G_cTxt, "<%d> Duplicate player! Deleted with data save : CharName(%s) IP(%s)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cIPaddress);
			PutLogList(G_cTxt);
			//PutLogFileList(G_cTxt);
			DeleteClient(i, TRUE, TRUE, FALSE);	
		}
		else {
			// v1.4 °èÁ¤ Á¤º¸¸¦ ÀÔ·ÂÇØ¾ß ·Î±×ÀÎ ¼­¹ö·Î Åëº¸°¡ °¡´ÉÇÏ´Ù.  
			memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
			memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
			
			// ÆÐ½º¿öµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.  Á¢¼Ó ºÒ°¡. 
			DeleteClient(iClientH, FALSE, FALSE);
			return;
		}
	}

	// Á¤º¸ ÀÔ·Â  
	memcpy(m_pClientList[iClientH]->m_cCharName, cCharName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountName, cAccountName, 10);
	memcpy(m_pClientList[iClientH]->m_cAccountPassword, cAccountPassword, 10);
	
	m_pClientList[iClientH]->m_bIsObserverMode = bIsObserverMode;
		
	// Log Server·Î µ¥ÀÌÅÍ ¿äÃ» ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
	bSendMsgToLS(MSGID_REQUEST_PLAYERDATA, iClientH);
}

void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey)
{
	char  * pBuffer = NULL;
	short * sp;
	signed long * sl;
	DWORD * dwp;
	WORD  * wp;
	float * fp;
	char  * cp, * sec, cPlayerName[11], cTxt[120];
	int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet, iStats;
	SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// ÃÖÃÊ Á¢¼Ó µ¥ÀÌÅÍ¸¦ Àü¼ÛÇØ ÁØ´Ù. ¿©±â¼­ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´ÂÁö È®ÀÎÇÒ ¼öµµ ÀÖ´Ù.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´ÂÁö °Ë»çÇÑ´Ù. ÀÏÄ¡ÇÏÁö ¾ÊÀ¸¸é »èÁ¦ÇÏ°í ±ÍÈ¯ÇÑ´Ù. 
	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, FALSE, TRUE);
		return;
	}

	// Ä³¸¯ÅÍÀÇ ½Å»óÁ¤º¸¸¦ Àü¼ÛÇÑ´Ù.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS; // 0x0FA40000 = 262406144
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	//*ip  = m_pClientList[iClientH]->m_iHP;
	//*ip  = 1;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	//*ip  = 1;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	//*ip  = 1;
	cp  += 4;

	ip   = (int *)cp;
	//*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	//*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	//ip = (int *)cp;
	//*ip = -1;
	iStats = (m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit +  
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma); 

	ip = (int *)cp; 
	*ip = m_pClientList[iClientH]->m_iLevel*3 - (iStats - 70); 
	cp += 6;



	//*cp = m_pClientList[iClientH]->m_iLU_Pool;
	//sec = (char *)cp;
	//memcpy(sec, "", 1);
	//	*cp = 0;
	//	cp += 4;


//	*cp = 6;
//	cp++;
//	*cp = 7;
//	cp++;
//	^^ 2 extra bytes Zabuza fix doesn't have

	//*cp = m_pClientList[iClientH]->m_cLU_Str;
	//*cp = m_pClientList[iClientH]->m_cLU_Vit;
	//*cp = m_pClientList[iClientH]->m_cLU_Dex;
	//*cp = m_pClientList[iClientH]->m_cLU_Int;
	//*cp = m_pClientList[iClientH]->m_cLU_Mag;
	//*cp = m_pClientList[iClientH]->m_cLU_Char;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	ip = (int *)cp;
	*ip = 0;
	cp += 1;

	ip = (int *)cp;
	*ip = 0;
	cp += 1;

	ip = (int *)cp;
	*ip = 0;
	cp += 1;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 Ãß°¡ »çÅõÀå¿¹¾à ¿©ºÎ¸¦ Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;

	//Syntax : ======HP==MP==SP==DRatHRatLVL=STR=INT=VIT=DEX=MAG=CHR=LUstatEXP=EK==PK==RewaLocation==GuildName=RankAF
	//Syntax : 1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345
	//Syntax : ......145212521152........376.200=200=200=200=200=195=......big.8...17......aresden...NONE......NONE30
	// 0x0FA40000 = 262406144
	// ¸Þ½ÃÁö Àü¼Û 

	//Debug Event
	DbgWnd->AddEventMsg(MSG_SEND,pBuffer,180,0);

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 180);// Original : 115
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// Ä³¸¯ÅÍÀÇ ¾ÆÀÌÅÛ Á¤º¸¸¦ Àü¼ÛÇÑ´Ù. 
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	// ¸ÕÀú ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛ 
	// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö 
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
			iTotalItemA++;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	*cp = iTotalItemA;
	cp++;

	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// ¿¡·¯ ¹æÁö¿ë ÄÚµåÀÌ´Ù. ¹®Á¦°¡ ÀÖ´Â Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ¸¦ ºÐ¼®ÇÒ°Í. ¿Ö ³ÎÀÏ±î?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
	}

	// ´ÙÀ½ º¸°üÁßÀÎ ¾ÆÀÌÅÛ 
	// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö 
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
			iTotalItemB++;

	*cp = iTotalItemB;
	cp++;

	for (i = 0; i < iTotalItemB; i++) {
		// ### ÀÇ½É½º·¯¿î ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// ¿¡·¯ ¹æÁö¿ë ÄÚµåÀÌ´Ù. ¹®Á¦°¡ ÀÖ´Â Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ¸¦ ºÐ¼®ÇÒ°Í. ¿Ö ³ÎÀÏ±î?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}

	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// ¸Êµ¥ÀÌÅÍ¸¦ Àü¼ÛÇÑ´Ù.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// ÇÃ·¹ÀÌ¾îÀÇ À§Ä¡¸¦ È®Á¤ÇÑ´Ù. v1.41 °ü¶÷ÀÚ ¸ðµå¶ó¸é ±×À§Ä¡ ±×´ë·Î ³õ´Â´Ù.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	// Àü¼ÛÇÒ ¸Ê µ¥ÀÌÅÍÀÇ ±âÁØÀ§Ä¡. ÇÃ·¹ÀÌ¾î´Â ±âÁØÀ§Ä¡ (x, y)·ÎºÎÅÍ (x+14, y+12)¿¡ À§Ä¡ÇÑ´Ù.
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sStatus;
	cp += 4;// Original : 2

	// (!) ÇÃ·¹ÀÌ¾î°¡ À§Ä¡ÇÏ´Â ¸ÊÀÌ¸§À» ±â·ÏÇÑ´Ù.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// ¸íÄª»óÀÇ ¸Ê ÀÌ¸§À» ÀÔ·ÂÇÑ´Ù. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// ÁÖ¾ß°£ ¸ðµå¸¦ »ðÀÔ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ±â»ó »óÅÂ ¸ðµå¸¦ »ðÀÔ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		*cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ ÇÃ·¹ÀÌ¾î¸¦ ¸Ê»ó¿¡ ÃÖÃÊ·Î À§Ä¡½ÃÅ²´Ù.

	// v1.41 ¿©±â¼­ °ü¶÷ÀÚ ¸ðµå¶ó¸é À§Ä¡½ÃÅ°Áö ¾Ê´Â´Ù. 
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			DEF_OWNERTYPE_PLAYER, 
			m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;


	// ¸ÊÀÇ Á¤º¸¸¦ Ãß°¡ÇÑ´Ù. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );

	// ¸Þ½ÃÁö Àü¼Û 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4+3); // Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 59 + iSize +4 +4 +1 +4 +4); // v1.41
	//	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô »õ ÇÃ·¹ÀÌ¾î Á¢¼ÓÀ» ¾Ë¸°´Ù. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	int iTL_;

	// ÇÃ·¹ÀÌ¾î°¡ ´Ù¸¥ ¸Ê¿¡ µé¾î°¬´Ù. ¸¸¾à Àû±¹ÀÌ¶ó¸é ½Ã°£À» ¼³Á¤ÇÑ´Ù.
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) && 
		(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ) {

			m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
			m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
			// v1.42
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
				// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
				// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
				GetLocalTime(&SysTime);
				switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¿ù¿äÀÏ 2ºÐ
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //È­¿äÀÏ 2ºÐ
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¼ö¿äÀÏ 2ºÐ
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¸ñ¿äÀÏ 2ºÐ
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
				}
			}
			else {
				// ÀÜÁ¸½Ã°£ÀÌ ÀÖ´Ù. ¿äÀÏº° ÀÜÁ¸½Ã°£º¸´Ù Å©¸é 1·Î ÃÊ±âÈ­ 
				GetLocalTime(&SysTime);
				switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	iTL_ = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	iTL_ = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	iTL_ = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	iTL_ = 20*10+100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	iTL_ = 20*30+300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	iTL_ = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
				}

				if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
					m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
			}
		}
	else
		if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) && 
			(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ) {

				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

				// v1.42
				if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
					// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
					// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
					GetLocalTime(&SysTime);
					switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
					}
				}
				else {
					// ÀÜÁ¸½Ã°£ÀÌ ÀÖ´Ù. ¿äÀÏº° ÀÜÁ¸½Ã°£º¸´Ù Å©¸é 1·Î ÃÊ±âÈ­ 
					GetLocalTime(&SysTime);
					switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	iTL_ = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	iTL_ = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	iTL_ = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	iTL_ = 20*10 +100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	iTL_ = 20*30 +300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	iTL_ = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
					}

					if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
						m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
				}
			}

			// ´Ù¸¥ ¼­¹ö¿¡ ÀÖ´Â »çÅõÀåÀ¸·Î ÀÔÀåÇÏ´Â °æ¿ì 
			// v1.4311-3 Ãß°¡ »çÅõÀå¿¡ ÀÔÀåÇÏ¸é °­ÄÝÅ¸ÀÓÀ» ½ÃÀÛÇÑ´Ù.
		else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
			(m_iFightzoneNoForceRecall == 0)) {  // ¿î¿µÀÚ°¡ °­ÄÝ¸ðµå¸¦ ¼³Á¤ÇÏÁö ¾Ê´Â°æ¿ì¿¡¸¸ °­ÄÝÅ¸ÀÓÀÌ ¼³Á¤µÈ´Ù.

				m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
				m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

				// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
				// 0 ½ÃºÎÅÍ 2½Ã°£ °£°ÝÀ¸·Î °è»êµÈ´Ù Áï 0½Ã¿¡ ÀÔÀåÇÏ¸é 2½Ã°£µ¿¾È ³²¾Æ ÀÖÀ»¼ö ÀÖ´Ù.
				// ¼­¹ö°£ÀÇ ½Ã°£ Â÷ÀÌ¸¦ °í·ÁÇÏ¿© ¿©À¯½Ã°£ 2ºÐ ÀÖ´Ù. Áï 2½Ã°£ µÇ±â 2ºÐÀüºÎÅÍ ¸®ÄÝµÈ´Ù.
				GetLocalTime(&SysTime);
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 

			} else {
				m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
				// v1.42
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
			}

			// Ãß°¡·Î º¸³»Áà¾ß ÇÒ Á¤º¸¸¦ º¸³½´Ù. v1.1
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
			// v1.3
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
			// V1.3
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
			// v1.4 
			_SendQuestContents(iClientH);
			_CheckQuestEnvironment(iClientH);

			// v1.432
			if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
			}

			// Crusade ÇöÀç Å©·ç¼¼ÀÌµå ¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ CrusadeGUID°¡ 0 È¤Àº ÇöÀç¿Í ´Ù¸£´Ù¸é Ã³À½ ÇÒ´çµÇ´Â °ÍÀÌ´Ù. Å©·ç¼¼ÀÌµå ¿ªÇÒ ÃÊ±âÈ­.
			if (m_bIsCrusadeMode == TRUE) {
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
					// Å©·ç¼¼ÀÌµå¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ GUID°¡ 0ÀÌ¶õ °ÍÀº Ã³À½ Å©·ç¼¼ÀÌµå ¸ðµå¿¡ µé¾î¿Ô´Ù´Â ÀÇ¹Ì. ¿ªÇÒ ÃÊ±âÈ­.
					m_pClientList[iClientH]->m_iCrusadeDuty = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
				}
				else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
					// Å©·ç¼¼ÀÌµå¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ GUID°¡ ÇöÀç Å©·ç¼¼ÀÌµå ¾ÆÀÌµð¿Í ´Ù¸£´Ù´Â °ÍÀº Àú¹ø¿¡ ¹ú¾îÁ³´ø Å©·ç¼¼ÀÌµåÀÇ °á°úÀÌ´Ù.
					// ÀÌ·± °æ¿ì Àü°ø¿¡ µû¸¥ Æ÷»óÀ» ÇÒ ¼ö ¾ø´Ù. ÃÖ¼ÒÇÑ Å©·ç¼¼ÀÌµå ¸ðµå°¡ Á¾·áµÈ ´ÙÀ½ ´ÙÀ½ Àü¸éÀüÀÌ ½ÃÀÛµÇ±â Àü¿¡ Á¢¼ÓÀ» ÇØ¾ß Æ÷»óÀ» ¾òÀ» ¼ö ÀÖ´Ù.
					// ÀÌÀü¿¡ ÇÒ´çµÇ¾ú´ø ¿ªÇÒ, °Ç¼³ Æ÷ÀÎÆ®, ÀüÀï °øÇåµµ ÃÊ±âÈ­.
					m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
					// Å©·ç¼¼ÀÌµå GUID°¡ ´Ù¸£´Ù. Æ÷»ó ºÒ°¡.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
				}
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
			}
			else {
				// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ñ °æ¿ì ¿ªÇÒ°ú °øÇå Æ÷ÀÎÆ®¸¸ ÃÊ±âÈ­. ÀüÀï °øÇåµµ´Â Àá½ÃÈÄ¿¡ °è»êµÇ¾î¼­ Æ÷»óµÈ´Ù.
				if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
					m_pClientList[iClientH]->m_iCrusadeDuty = 0;
					m_pClientList[iClientH]->m_iConstructionPoint = 0;
				}
				else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
					// Å©·ç¼¼ÀÌµå GUID°¡ ´Ù¸£´Ù. Æ÷»ó ºÒ°¡.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
					m_pClientList[iClientH]->m_iWarContribution   = 0;
					m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
				}
			}

			// v1.42
			if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
				wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
				PutLogEventFileList(G_cTxt);
			}

			// Crusade
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
			//Fix Sprite Bug
//			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

}

/*void CGame::RequestInitDataHandler(int iClientH, char * pData, char cKey)
{
 char  * pBuffer = NULL;
 short * sp;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cPlayerName[11], cTxt[120];
 int   * ip, i, iTotalItemA, iTotalItemB, iSize, iRet;
 SYSTEMTIME SysTime;
	
	if (m_pClientList[iClientH] == NULL) return;

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);

	// ÃÖÃÊ Á¢¼Ó µ¥ÀÌÅÍ¸¦ Àü¼ÛÇØ ÁØ´Ù. ¿©±â¼­ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´ÂÁö È®ÀÎÇÒ ¼öµµ ÀÖ´Ù.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cp, 10);

	ZeroMemory(cTxt, sizeof(cTxt)); // v1.4
	memcpy(cTxt, cPlayerName, 10);
	m_Misc.bDecode(cKey, cTxt);
	ZeroMemory(cPlayerName, sizeof(cPlayerName));
	memcpy(cPlayerName, cTxt, 10);

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´ÂÁö °Ë»çÇÑ´Ù. ÀÏÄ¡ÇÏÁö ¾ÊÀ¸¸é »èÁ¦ÇÏ°í ±ÍÈ¯ÇÑ´Ù. 
	if (memcmp(m_pClientList[iClientH]->m_cCharName, cPlayerName, 10) != 0) {
		DeleteClient(iClientH, FALSE, TRUE);
		return;
	}
	
	// Ä³¸¯ÅÍÀÇ ½Å»óÁ¤º¸¸¦ Àü¼ÛÇÑ´Ù.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERCHARACTERCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iSP;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDefenseRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iHitRatio;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iLevel;
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iStr;		
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iInt;					
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iVit;								
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iDex;			
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iMag;						
	cp  += 4;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iCharisma;
	cp  += 4;

	*cp = m_pClientList[iClientH]->m_cLU_Str;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Vit;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Dex;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Int;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Mag;
	cp++;
	*cp = m_pClientList[iClientH]->m_cLU_Char;
	cp++;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iExp;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iEnemyKillCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iPKCount;
	cp  += 4;

	ip = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iRewardGold;
	cp  += 4;

	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp  += 10;

	memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
	cp  += 20;

	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iGuildRank;
	cp  += 4;

	// v1.4311
	*cp = (char)m_pClientList[iClientH]->m_iSuperAttackLeft;
	cp++;

	// v1.4311-3 Ãß°¡ »çÅõÀå¿¹¾à ¿©ºÎ¸¦ Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
	ip   = (int *)cp;
	*ip  = m_pClientList[iClientH]->m_iFightzoneNumber;
	cp  += 4;
	
	//Debug Event
	DbgWnd->AddEventMsg(MSG_SEND,pBuffer,120,0);

	// ¸Þ½ÃÁö Àü¼Û 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 120);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// Ä³¸¯ÅÍÀÇ ¾ÆÀÌÅÛ Á¤º¸¸¦ Àü¼ÛÇÑ´Ù. 
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_PLAYERITEMLISTCONTENTS;
	wp   = (WORD *) (pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	// ¸ÕÀú ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛ 
	// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö 
	iTotalItemA = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) 
		iTotalItemA++;

	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	
	*cp = iTotalItemA;
	cp++;
	
	for (i = 0; i < iTotalItemA; i++) {
		// ### ERROR POINT!!!
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
			// ¿¡·¯ ¹æÁö¿ë ÄÚµåÀÌ´Ù. ¹®Á¦°¡ ÀÖ´Â Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ¸¦ ºÐ¼®ÇÒ°Í. ¿Ö ³ÎÀÏ±î?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos;
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_bIsItemEquipped[i];
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute;
		cp += 4;
		
		//*cp = (char)(m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		//cp++;
		
	}

	// ´ÙÀ½ º¸°üÁßÀÎ ¾ÆÀÌÅÛ 
	// ¾ÆÀÌÅÛÀÇ ÃÑ °¹¼ö 
	iTotalItemB = 0;
	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) 
		iTotalItemB++;
	
	*cp = iTotalItemB;
	cp++;
	
	for (i = 0; i < iTotalItemB; i++) {
		// ### ÀÇ½É½º·¯¿î ERROR POINT
		if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
			// ¿¡·¯ ¹æÁö¿ë ÄÚµåÀÌ´Ù. ¹®Á¦°¡ ÀÖ´Â Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ¸¦ ºÐ¼®ÇÒ°Í. ¿Ö ³ÎÀÏ±î?
			wsprintf(G_cTxt, "RequestInitDataHandler error: Client(%s) Bank-Item(%d)", m_pClientList[iClientH]->m_cCharName, i);
			PutLogFileList(G_cTxt);

			DeleteClient(iClientH, FALSE, TRUE);
			if(pBuffer != NULL) delete pBuffer;
			return;
		}
		memcpy(cp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName, 20);
		cp += 20;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount;
		cp += 4;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemType;
		cp++;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cEquipPos;
		cp++;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sLevelLimit;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cGenderLimit;
		cp++;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan;
		cp += 2;
		wp = (WORD *)cp;
		*wp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_wWeight;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSprite;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_sSpriteFrame;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor; // v1.4
		cp++;
		*cp = (char)m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		dwp =(DWORD *)cp;
		*dwp = m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute;
		cp += 4;
		
		//*cp = (char)(m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		//cp++;
		
	}

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cMagicMastery[i];
		cp++;
	}
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		*cp = m_pClientList[iClientH]->m_cSkillMastery[i];
		cp++;
	}

	//Debug Event
	DbgWnd->AddEventMsg(MSG_SEND,pBuffer,6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE,0);
	// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 6 + 1 + iTotalItemA*44 + iTotalItemB*43 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	// ¸Êµ¥ÀÌÅÍ¸¦ Àü¼ÛÇÑ´Ù.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);
	
	// ÇÃ·¹ÀÌ¾îÀÇ À§Ä¡¸¦ È®Á¤ÇÑ´Ù. v1.41 °ü¶÷ÀÚ ¸ðµå¶ó¸é ±×À§Ä¡ ±×´ë·Î ³õ´Â´Ù.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// ObjectID
	wp  = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	// Àü¼ÛÇÒ ¸Ê µ¥ÀÌÅÍÀÇ ±âÁØÀ§Ä¡. ÇÃ·¹ÀÌ¾î´Â ±âÁØÀ§Ä¡ (x, y)·ÎºÎÅÍ (x+14, y+12)¿¡ À§Ä¡ÇÑ´Ù.
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;

	ip  = (int *)cp; // v1.4
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sStatus;
	//Map Fix Here
	cp += 4;
	
	// (!) ÇÃ·¹ÀÌ¾î°¡ À§Ä¡ÇÏ´Â ¸ÊÀÌ¸§À» ±â·ÏÇÑ´Ù.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// ¸íÄª»óÀÇ ¸Ê ÀÌ¸§À» ÀÔ·ÂÇÑ´Ù. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// ÁÖ¾ß°£ ¸ðµå¸¦ »ðÀÔ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// ±â»ó »óÅÂ ¸ðµå¸¦ »ðÀÔ 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;

	// @@@ ÇÃ·¹ÀÌ¾î¸¦ ¸Ê»ó¿¡ ÃÖÃÊ·Î À§Ä¡½ÃÅ²´Ù.
	
	// v1.41 ¿©±â¼­ °ü¶÷ÀÚ ¸ðµå¶ó¸é À§Ä¡½ÃÅ°Áö ¾Ê´Â´Ù. 
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
	

	// ¸ÊÀÇ Á¤º¸¸¦ Ãß°¡ÇÑ´Ù. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );

	//Debug Event
	DbgWnd->AddEventMsg(MSG_SEND,pBuffer,46 + iSize +4 +4 +1 +4 +4 +2,0);

	// ¸Þ½ÃÁö Àü¼Û 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4 +2); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô »õ ÇÃ·¹ÀÌ¾î Á¢¼ÓÀ» ¾Ë¸°´Ù. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);

	int iTL_;

	// ÇÃ·¹ÀÌ¾î°¡ ´Ù¸¥ ¸Ê¿¡ µé¾î°¬´Ù. ¸¸¾à Àû±¹ÀÌ¶ó¸é ½Ã°£À» ¼³Á¤ÇÑ´Ù.
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// v1.42
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
			// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¿ù¿äÀÏ 2ºÐ
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //È­¿äÀÏ 2ºÐ
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¼ö¿äÀÏ 2ºÐ
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;  //¸ñ¿äÀÏ 2ºÐ
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100; break; //±Ý¿äÀÏ 15ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300; break; //Åä¿äÀÏ 45ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
		else {
			// ÀÜÁ¸½Ã°£ÀÌ ÀÖ´Ù. ¿äÀÏº° ÀÜÁ¸½Ã°£º¸´Ù Å©¸é 1·Î ÃÊ±âÈ­ 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	iTL_ = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	iTL_ = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	iTL_ = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	iTL_ = 20*10+100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	iTL_ = 20*30+300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	iTL_ = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
			}
			
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}
	}
	else
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v1.42
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
			// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
			}
		}
		else {
			// ÀÜÁ¸½Ã°£ÀÌ ÀÖ´Ù. ¿äÀÏº° ÀÜÁ¸½Ã°£º¸´Ù Å©¸é 1·Î ÃÊ±âÈ­ 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //¿ù¿äÀÏ 30ÃÊ
			case 2:	iTL_ = 40; break;   //È­¿äÀÏ 30ÃÊ
			case 3:	iTL_ = 40; break;   //¼ö¿äÀÏ 30ÃÊ
			case 4:	iTL_ = 40; break;   //¸ñ¿äÀÏ 30ÃÊ
			case 5:	iTL_ = 20*10 +100; break; //±Ý¿äÀÏ 10ºÐ
			case 6:	iTL_ = 20*30 +300; break; //Åä¿äÀÏ 30ºÐ 
			case 0:	iTL_ = 20*60; break; //ÀÏ¿äÀÏ 60ºÐ
			}
			
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}
	}

	// ´Ù¸¥ ¼­¹ö¿¡ ÀÖ´Â »çÅõÀåÀ¸·Î ÀÔÀåÇÏ´Â °æ¿ì 
	// v1.4311-3 Ãß°¡ »çÅõÀå¿¡ ÀÔÀåÇÏ¸é °­ÄÝÅ¸ÀÓÀ» ½ÃÀÛÇÑ´Ù.
	else if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) &&
		     (m_iFightzoneNoForceRecall == 0)) {  // ¿î¿µÀÚ°¡ °­ÄÝ¸ðµå¸¦ ¼³Á¤ÇÏÁö ¾Ê´Â°æ¿ì¿¡¸¸ °­ÄÝÅ¸ÀÓÀÌ ¼³Á¤µÈ´Ù.
				
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// ³²¾ÆÀÖÀ» ¼ö ÀÖ´Â ÀÜÁ¸ ½Ã°£À» ¼³Á¤ÇØ ÁØ´Ù. 
		// 0 ½ÃºÎÅÍ 2½Ã°£ °£°ÝÀ¸·Î °è»êµÈ´Ù Áï 0½Ã¿¡ ÀÔÀåÇÏ¸é 2½Ã°£µ¿¾È ³²¾Æ ÀÖÀ»¼ö ÀÖ´Ù.
		// ¼­¹ö°£ÀÇ ½Ã°£ Â÷ÀÌ¸¦ °í·ÁÇÏ¿© ¿©À¯½Ã°£ 2ºÐ ÀÖ´Ù. Áï 2½Ã°£ µÇ±â 2ºÐÀüºÎÅÍ ¸®ÄÝµÈ´Ù.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*60*20 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20; 
		
	} else {
		m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
		// v1.42
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// Ãß°¡·Î º¸³»Áà¾ß ÇÒ Á¤º¸¸¦ º¸³½´Ù. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
	}

	// Crusade ÇöÀç Å©·ç¼¼ÀÌµå ¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ CrusadeGUID°¡ 0 È¤Àº ÇöÀç¿Í ´Ù¸£´Ù¸é Ã³À½ ÇÒ´çµÇ´Â °ÍÀÌ´Ù. Å©·ç¼¼ÀÌµå ¿ªÇÒ ÃÊ±âÈ­.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// Å©·ç¼¼ÀÌµå¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ GUID°¡ 0ÀÌ¶õ °ÍÀº Ã³À½ Å©·ç¼¼ÀÌµå ¸ðµå¿¡ µé¾î¿Ô´Ù´Â ÀÇ¹Ì. ¿ªÇÒ ÃÊ±âÈ­.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// Å©·ç¼¼ÀÌµå¸ðµåÀÌ°í ÇÃ·¹ÀÌ¾îÀÇ GUID°¡ ÇöÀç Å©·ç¼¼ÀÌµå ¾ÆÀÌµð¿Í ´Ù¸£´Ù´Â °ÍÀº Àú¹ø¿¡ ¹ú¾îÁ³´ø Å©·ç¼¼ÀÌµåÀÇ °á°úÀÌ´Ù.
			// ÀÌ·± °æ¿ì Àü°ø¿¡ µû¸¥ Æ÷»óÀ» ÇÒ ¼ö ¾ø´Ù. ÃÖ¼ÒÇÑ Å©·ç¼¼ÀÌµå ¸ðµå°¡ Á¾·áµÈ ´ÙÀ½ ´ÙÀ½ Àü¸éÀüÀÌ ½ÃÀÛµÇ±â Àü¿¡ Á¢¼ÓÀ» ÇØ¾ß Æ÷»óÀ» ¾òÀ» ¼ö ÀÖ´Ù.
			// ÀÌÀü¿¡ ÇÒ´çµÇ¾ú´ø ¿ªÇÒ, °Ç¼³ Æ÷ÀÎÆ®, ÀüÀï °øÇåµµ ÃÊ±âÈ­.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// Å©·ç¼¼ÀÌµå GUID°¡ ´Ù¸£´Ù. Æ÷»ó ºÒ°¡.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ñ °æ¿ì ¿ªÇÒ°ú °øÇå Æ÷ÀÎÆ®¸¸ ÃÊ±âÈ­. ÀüÀï °øÇåµµ´Â Àá½ÃÈÄ¿¡ °è»êµÇ¾î¼­ Æ÷»óµÈ´Ù.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// Å©·ç¼¼ÀÌµå GUID°¡ ´Ù¸£´Ù. Æ÷»ó ºÒ°¡.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, 1, NULL);
}*/

int CGame::iComposeInitMapData(short sX, short sY, int iClientH, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal, sTemp, sTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	for (iy = 0; iy < 16; iy++)
	for (ix = 0; ix < 21; ix++) {
		
		if (((sX + ix) == 100) && ((sY + iy) == 100))
			sX = sX;
 		
		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		// @@@ !!! @@@ ÀÌ°÷¿¡ Á¶°ÇÀÌ ÀÔ·ÂµÇ¾ß¸¸ Á¤º¸°¡ Àü´ÞµÈ´Ù!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// À§Ä¡Á¤º¸ ÀÔ·Â 
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			// Çì´õ Á¤º¸¸¦ ÀÛ¼ºÇÑ´Ù.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// °£È¤ ÇÚµéÀÌ ÀÖ´Âµ¥µµ NULLÀÎ °æ¿ì·Î ¿¡·¯¹ß»ý. ¿øÀÎÆÄ¾ÇÁß  ¿¡·¯ º¸¿Ï ±â´É »ðÀÔ. ±×·¯³ª ±Ùº»ÀûÀÎ 
				// ¿øÀÎÀ» ¾Ë¾Æ³»¾ß ÇÑ´Ù.
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else {
						// ###debugcode
						wsprintf(G_cTxt, "Empty player handle: %d", pTile->m_sOwner);
						//PutLogFileList(G_cTxt);
						//
						pTile->m_sOwner = NULL;
					}
				}
				
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL ) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
				   	else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
 					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
					sTemp = m_pClientList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if ((ucHeader & 0x02) != 0) {
				// Á×Àº Ä³¸¯ÅÍ Á¤º¸ »ðÀÔ 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appr2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// ¾ÆÀÌÅÛ Á¤º¸ »ðÀÔ 
				// ½ºÇÁ¶óÀÌÆ® 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// ½ºÇÁ¶óÀÌÆ® ÇÁ·¹ÀÓ 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// ¾ÆÀÌÅÛ »ö Ãß°¡µÊ v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// µ¿Àû °´Ã¼ Á¾·ù ÇÒ´ç 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
				
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		}
	}

	*pTotal = iTileExists;

	// testcode
	//wsprintf(G_cTxt, "ComposeInitMapData: %d", iTileExists);
	//PutLogList(G_cTxt);

	return iSize;
}

void CGame::DeleteClient(int iClientH, BOOL bSave, BOOL bNotify, BOOL bCountLogout, BOOL bForceCloseConn)
{
 int i, iExH;

	if (m_pClientList[iClientH] == NULL) return;
	
	// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ÇÃ·¹ÀÌ¾î Á¢¼ÓÁ¾·á¸¦ ¾Ë¸°´Ù. //!!!!!!! Recursion Error°¡ ¶á´Ù!!!!
	// Àç±ÍÈ£Ãâ ¿¡·¯¶«¿¡ ºñÈ°¼ºÈ­ µÊ. 
	
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) { // v1.4
		// °ÔÀÓ»ó¿¡ ÀÖ¾î¾ß¸¸ Ã³¸®°¡ °¡´ÉÇÑ ºÎºÐ.
		
		// v1.42
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
			wsprintf(G_cTxt, "Char(%s)-Exit(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName);
			PutLogEventFileList(G_cTxt);
		}
	
		// ¸¸¾à ±³È¯ ¸ðµå¶ó¸é ±³È¯À» Ãë¼ÒÇÑ´Ù.
		if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
			iExH = m_pClientList[iClientH]->m_iExchangeH;
			_ClearExchangeStatus(iExH);
			_ClearExchangeStatus(iClientH);
		}

		// ³¬½Ã Ä«¿îÆ® °¨¼Ò.
		if ((m_pClientList[iClientH]->m_iAllocatedFish != NULL) && (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL)) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;
		
		if (bNotify == TRUE)
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
		
		// ÇöÀç ÀÌ ÇÃ·¹ÀÌ¾î¸¦ ¸ñÇ¥·Î »ï°í ÀÖ´Â ¸÷µéÀÇ °ø°ÝÇàµ¿À» ¸ØÃß°Ô ÇÑ´Ù. 
		RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
		
		// ±Ó¼Ó¸» ¸ðµå°¡ ¼³Á¤µÈ ´Ù¸¥ ÇÃ·¹ÀÌ¾îµéÀ» Áö¿î´Ù. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iWhisperPlayerIndex	== iClientH)) {
			m_pClientList[i]->m_iWhisperPlayerIndex = -1;
			// ±Ó¼Ó¸» »óÅÂ°¡ ÇØÁ¦µÇ¾úÀ½À» Åëº¸. 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
		}
			
		// ¸Ê¿¡¼­ Áö¿î´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(2, iClientH, DEF_OWNERTYPE_PLAYER,
		          	                                                 m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY);

		// DelayEvent¸¦ »èÁ¦ 
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, NULL);
	}
	
	// ¸¸¾à bSave°¡ TRUEÀÌ¸é µ¥ÀÌÅÍ¸¦ ÀúÀåÇÑ´Ù. ´Ü ÃÊ±âÈ­ µÇÁö ¾Ê´Â »óÅÂ¶ó¸é ÀúÀåÇØ¼­´Â ¾ÈµÈ´Ù. 
	if ((bSave == TRUE) && (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)) {
		// ·Î±×¼­¹ö·Î ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ ÀúÀåÀ» ¿äÃ»ÇÑ´Ù.

		//¸¸¾à Ä³¸¯ÅÍ°¡ Á×¾îÀÖ´Ù¸é ½ÅºÐ¿¡ µû¶ó ÃÊ±â À§Ä¡¸¦ º¯°æÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			
			if (m_pClientList[iClientH]->m_cSide == 0) {
				// ¿©ÇàÀÚ¶ó¸é  default¸ÊÀ¸·Î °£´Ù.
				strcpy(m_pClientList[iClientH]->m_cMapName, "default");
			}
			else {
				// ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ¼Ò¼Ó ¸¶À»ÀÇ ºÎÈ°Á¸À¸·Î °£´Ù.
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
					if (m_bIsCrusadeMode == TRUE) {
						// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­ »ç¸ÁÇÑ °æ¿ì: ¸¶À» ¸Ê¿¡¼­ ÀÏÁ¤½Ã°£ ³ª°¥ ¼ö ¾ø´Ù.
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "aresden");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
					}
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
				}
				else {
					if (m_bIsCrusadeMode == TRUE) {
						// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­ »ç¸ÁÇÑ °æ¿ì: ¸¶À» ¸Ê¿¡¼­ ÀÏÁ¤½Ã°£ ³ª°¥ ¼ö ¾ø´Ù.
						ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
						strcpy(m_pClientList[iClientH]->m_cLockedMapName, "elvine");
						m_pClientList[iClientH]->m_iLockedMapTime = 60*5;
					}
					memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
				}
			}
		}
		else if (bForceCloseConn == TRUE) {
			// °­Á¦·Î Á¢¼ÓÀÌ Á¾·áµÈ Ä³¸¯ÅÍ¶ó¸é 
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, "bisle", 5);
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
			
			// °ð¹Ù·Î ¸ø³ª¿À°Ô ÇÑ´Ù.
			ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
			strcpy(m_pClientList[iClientH]->m_cLockedMapName, "bisle");
			m_pClientList[iClientH]->m_iLockedMapTime = 60*60;
		}
		
		// v1.41 ¸¸¾à °ü¶÷ÀÚ ¸ðµå¿´´Ù¸é Á¢¼Ó Á¾·á½Ã »ý»ç¿Í °ü°è¾øÀÌ ¼Ò¼Ó ¸¶À»·Î º¸³½´Ù. 
		if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				// ¿©ÇàÀÚ¶ó¸é ·£´ýÇÏ°Ô ¾Æ¹« ¸¶À»·Î³ª °£´Ù.
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				// ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ¼Ò¼Ó ¸¶À»·Î °£´Ù.
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}

		//v1.42 °æ±âÀå¿¡ ÀÖ¾ú´Ù¸é Á¢¼Ó Á¾·á½Ã ¼Ò¼Ó ¸¶À»·Î °£´Ù. 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			if (m_pClientList[iClientH]->m_cSide == 0) {
				// ¿©ÇàÀÚ¶ó¸é ·£´ýÇÏ°Ô ¾Æ¹« ¸¶À»·Î³ª °£´Ù.
				switch (iDice(1,2)) {
				case 1:
					memcpy(m_pClientList[iClientH]->m_cMapName, "aresden", 7);
					break;
				case 2:
					memcpy(m_pClientList[iClientH]->m_cMapName, "elvine", 6);
					break;
				}
			}
			else {
				// ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ¼Ò¼Ó ¸¶À»·Î °£´Ù.
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_cLocation, 10);
			}
			m_pClientList[iClientH]->m_sX = -1;
			m_pClientList[iClientH]->m_sY = -1;
		}
		
		if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) {
			// v1.41 ¸Þ½ÃÁö¸¦ º¸³¾ ¼ö ÀÖ´Â sub-log-socketÀÌ ³²¾ÆÀÖ´Â ÇÑ ¸ðµÎ º¸³½´Ù. 
			if (bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATALOGOUT, iClientH, bCountLogout) == FALSE) LocalSavePlayerData(iClientH);
		}
		else bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
	}
	else {
		// ÀúÀåÇÏÁö ¾Ê°í Á¾·á / ¼­¹ö ÀÌµ¿Áß / È¤Àº µÑ´Ù 
		if (m_pClientList[iClientH]->m_bIsOnServerChange == FALSE)
			bSendMsgToLS(MSGID_REQUEST_NOSAVELOGOUT, iClientH, bCountLogout);
		else bSendMsgToLS(MSGID_REQUEST_SETACCOUNTWAITSTATUS, iClientH, FALSE); // ÅÚ·¹Æ÷Æ® µî¿¡ ÀÇÇÑ ÀÌµ¿ÀÌ¹Ç·Î WLS¿¡ Åëº¸ 
	}

	// Å¬¶óÀÌ¾ðÆ® °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
	delete m_pClientList[iClientH];
	m_pClientList[iClientH] = NULL;
	
	// Å¬¶óÀÌ¾ðÆ® ÀÎµ¦½º ¸®½ºÆ®¿¡¼­ »èÁ¦
	RemoveClientShortCut(iClientH);

	m_iTotalClients--;
}

void CGame::SendEventToNearClient_TypeA(short sOwnerH, char cOwnerType, DWORD dwMsgID, WORD wMsgType, short sV1, short sV2, short sV3)
{
 int * ip, i, iRet, iShortCutIndex;
 char  * cp_a, * cp_s, * cp_sv, cData_All[200], cData_Srt[200],  cData_Srt_Av[200];
 DWORD * dwp;
 WORD  * wp;
 short * sp, sRange, sX, sY, * spStatus, sTemp, sDumm, sTemp2;
 BOOL    bOwnerSend, bFlag;

	ZeroMemory(cData_All, sizeof(cData_All));
	ZeroMemory(cData_Srt, sizeof(cData_Srt));
	ZeroMemory(cData_Srt_Av, sizeof(cData_Srt_Av));
	spStatus = (short *)&sDumm;

	// ¸Þ½ÃÁö Çì´õ ÀÛ¼º 
	// All-Data
	dwp  = (DWORD *)(cData_All + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_All + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data
	dwp  = (DWORD *)(cData_Srt + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	// Short-Data-Additional-value
	dwp  = (DWORD *)(cData_Srt_Av + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp_a  = (char *)(cData_All + DEF_INDEX2_MSGTYPE + 2);
	cp_s  = (char *)(cData_Srt + DEF_INDEX2_MSGTYPE + 2);
	cp_sv = (char *)(cData_Srt_Av + DEF_INDEX2_MSGTYPE + 2);
	
	// ¸Þ½ÃÁö Àü´Þ ¹üÀ§ ¼³Á¤ 
	if ((dwMsgID == MSGID_EVENT_LOG) || (wMsgType == DEF_OBJECTMOVE) || (wMsgType == DEF_OBJECTRUN) || 
		(wMsgType == DEF_OBJECTATTACKMOVE) || (wMsgType == DEF_OBJECTDAMAGEMOVE) || (wMsgType == DEF_OBJECTDYING))
		 sRange = 1;
	else sRange = 0;
	
	if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
		// ÇÃ·¹ÀÌ¾îÀÇ ÀÌº¥Æ®ÀÌ´Ù.
		if (m_pClientList[sOwnerH] == NULL) return;
		
		// º»ÀÎ¿¡°Ôµµ Àü¼ÛµÇ´Â ¸Þ½ÃÁöÀÎ°¡?
		switch (wMsgType) {
		case DEF_OBJECTNULLACTION:
		case DEF_OBJECTDAMAGE:
		case DEF_OBJECTDYING:
			bOwnerSend = TRUE;
			break;
		default:
			bOwnerSend = FALSE;
			break;
		}

		// ¸Þ½ÃÁöÀÇ Á¾·ù¿¡ µû¶ó¼­ Çü½Ä¿¡ ´Þ¶óÁø´Ù. 
		// DEF_MSGTYPE_CONFIRM, DEF_MSGTYPE_REJECT, DEF_OBJECTNULLACTION¿Í ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®ÀÇ ÀÎÁ¢¿µ¿ª¿¡ ÀÖ´Â °æ¿ì´Â 
				
		// ÀüÃ¼ ¸Þ½ÃÁö Çü½Ä ÀÛ¼º 
		wp  = (WORD *)cp_a;
		*wp = sOwnerH;			// ObjectID
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pClientList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pClientList[sOwnerH]->m_cCharName, 10);
		cp_a += 10;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr1;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr3;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pClientList[sOwnerH]->m_sAppr4;
		cp_a += 2;
		// v1.4
		ip = (int *)cp_a;
		*ip = m_pClientList[sOwnerH]->m_iApprColor;
		cp_a += 4;

		sp  = (short *)cp_a;
		spStatus = sp;
		*sp = m_pClientList[sOwnerH]->m_sStatus;
		cp_a += 2;

		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0; 
		}
		else *cp_a = 0;
		cp_a++;

		// ºÎºÐ µ¥ÀÌÅÍ Çü½Ä ÀÛ¼º 
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_s += 2;
				
		*cp_s = m_pClientList[sOwnerH]->m_cDir;
		cp_s++;
		// ¾Æ·¡ºÎºÐÀº OBJECTDAMAGEÀÏ °æ¿ì¿¡¸¸ Àü¼ÛµÈ´Ù. ¸ÔÀº DamegeÀÇ Å©±â¿Í °ø°Ý¹ÞÀº Á¾·ù  
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		// ÁÂÇ¥Á¤º¸´Â Á×´Â µ¿ÀÛ¿¡¸¸ µé¾î°£´Ù.
		sp  = (short *)cp_s;
		sX  = m_pClientList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pClientList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
	
		// ºÎºÐ µ¥ÀÌÅÍ Ãß°¡ Á¤º¸ Çü½Ä ÀÛ¼º OBJECTATTACKÀÇ °æ¿ì 
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 30000;			// ObjectID	(+30000)
		cp_sv += 2;
	
		*cp_sv = m_pClientList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;
		
		//for (i = 1; i < DEF_MAXCLIENTS; i++) {
		bFlag = TRUE;
		iShortCutIndex = 0;
		while (bFlag == TRUE) {
			// DEF_MAXCLIENTS ±îÁö ·çÇÁ¸¦ µ¹Áö ¾Ê±â À§ÇÑ ¹æ¹ý. Å¬¶óÀÌ¾ðÆ® ¼ôÄÆ ¸®½ºÆ®¿¡¼­ 0ÀÌ ³ª¿À¸é ³¡ÀÌ´Ù.
			i = m_iClientShortCut[iShortCutIndex];
			iShortCutIndex++;
			if (i == 0) bFlag = FALSE;

			//if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ((bFlag == TRUE) && (m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE))
			if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				// m_pClientList[i]¿Í m_pClientList[sOwnerH]ÀÇ °ü°è¸¦ ÀÔ·ÂÇÑ´Ù.
				// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
				sTemp = *spStatus;
				sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
				sTemp2 = (short)iGetPlayerABSStatus(sOwnerH, i); //(short)iGetPlayerRelationship_SendEvent(sOwnerH, i);
				sTemp  = (sTemp | (sTemp2 << 12));
				*spStatus = sTemp;
				//

				// °æ°è ¾È¿¡ ¼ÓÇÑ Å¬¶óÀÌ¾ðÆ®°¡ ÀÖ´Ù. 
				if ( (m_pClientList[i]->m_sX >= m_pClientList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pClientList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pClientList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pClientList[sOwnerH]->m_sY + 7) ) {
					// *** ÀÌ¹Ì ÀÌ¸§°ú Æ¯¼ºÄ¡µîÀÇ µ¥ÀÌÅÍ°¡ º¸³»Áø °´Ã¼µéÀÌ´Ù.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// ÀÌ ¸Þ½ÃÁö´Â À§Ä¡¿¡ »ó°ü¾øÀÌ ¸ðµç µ¥ÀÌÅÍ¸¦ º¸³»¾ß ÇÑ´Ù. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					//case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						}
						break;

					case DEF_OBJECTDYING:
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// Ãß°¡ Á¤º¸°¡ ºÙ´Â ÇüÅÂ 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						}
						break;

					default:
						// ObjectID¸¸À» °¡Áø µ¥ÀÌÅÍ¸¦ º¸³½´Ù.
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9);
						}
						break;
					}
					// *** end 
				}
				else {
					// +++ °æ°è ºÎ±Ù¿¡ À§Ä¡ÇÑ Å¬¶óÀÌ¾ðÆ®. ÀÌµ¿°ü·Ã ¸Þ½ÃÁö¸é µ¥ÀÌÅÍ¸¦ ¸ðµÎ º¸³»ÁØ´Ù.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// ÀÌ ¸Þ½ÃÁö´Â À§Ä¡¿¡ »ó°ü¾øÀÌ ¸ðµç µ¥ÀÌÅÍ¸¦ º¸³»¾ß ÇÑ´Ù. 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4 :36
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4 :36
						}
						break;
					
					case DEF_OBJECTMAGIC:
					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
					//case DEF_OBJECTDYING:	
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						}
						break;

					case DEF_OBJECTDYING:	
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						}
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// Ãß°¡ Á¤º¸°¡ ºÙ´Â ÇüÅÂ 
						if (bOwnerSend == TRUE) 
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						}
						break;

					default:
						// ÀÌµ¿°ú °ü·ÃµÈ ¸Þ½ÃÁö. °æ°è ºÎºÐ¿¡ ÀÖÀ¸¹Ç·Î ¸ðµç ¸Þ½ÃÁö¸¦ Àü¼Û.
						if (bOwnerSend == TRUE)
							iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4
						else {
							if (i != sOwnerH)
								iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 41); // v1.4
						}
						break;
					}
					
					// +++ end
  				}
			}
			//
		}
	}
	else {
		// NPCÀÇ ÀÌº¥Æ®ÀÌ´Ù. 
		if (m_pNpcList[sOwnerH] == NULL) return;

		// ÀüÃ¼ ¸Þ½ÃÁö Çü½Ä ÀÛ¼º 
		wp  = (WORD *)cp_a;
		*wp = sOwnerH + 10000;			// ObjectID	(+10000)Àº NPC¶ó´Â ÀÇ¹Ì 
		cp_a += 2;
		sp  = (short *)cp_a;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_a += 2;
		sp  = (short *)cp_a;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_a += 2;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sType;
		cp_a += 2;
		*cp_a = m_pNpcList[sOwnerH]->m_cDir;
		cp_a++;
		memcpy(cp_a, m_pNpcList[sOwnerH]->m_cName, 5);
		cp_a += 5;
		sp  = (short *)cp_a;
		*sp = m_pNpcList[sOwnerH]->m_sAppr2;
		cp_a += 2;
		sp  = (short *)cp_a;
		spStatus = sp;
		*sp = m_pNpcList[sOwnerH]->m_sStatus;
		cp_a += 4;//Original : 2
		if (wMsgType == DEF_OBJECTNULLACTION) {// v1.4
			if (m_pNpcList[sOwnerH]->m_bIsKilled == TRUE)
				 *cp_a = 1; 
			else *cp_a = 0;
		}
		else *cp_a = 0;
		cp_a++;

		// ºÎºÐ µ¥ÀÌÅÍ Çü½Ä ÀÛ¼º 
		wp  = (WORD *)cp_s;
		*wp = sOwnerH + 40000;			// ObjectID	(+40000)
		cp_s += 2;
		
		*cp_s = m_pNpcList[sOwnerH]->m_cDir;
		cp_s++;
		// ¾Æ·¡ºÎºÐÀº OBJECTDAMAGEÀÏ °æ¿ì¿¡¸¸ Àü¼ÛµÈ´Ù. ¸ÔÀº DamegeÀÇ Å©±â¿Í °ø°Ý¹ÞÀº Å¸ÀÔ
		*cp_s = (unsigned char)sV1;
		cp_s++;
		*cp_s = (unsigned char)sV2;
		cp_s++;

		// Á×´Â °æ¿ì¿¡¸¸ ÁÂÇ¥ Àü¼Û 
		sp  = (short *)cp_s;
		sX  = m_pNpcList[sOwnerH]->m_sX;
		*sp = sX;
		cp_s += 2;
		sp  = (short *)cp_s;
		sY  = m_pNpcList[sOwnerH]->m_sY;
		*sp = sY;
		cp_s += 2;
		
		// ºÎºÐ µ¥ÀÌÅÍ Ãß°¡ Á¤º¸ Çü½Ä ÀÛ¼º OBJECTATTACKÀÇ °æ¿ì 
		wp  = (WORD *)cp_sv;
		*wp = sOwnerH + 40000;			// ObjectID	(+40000)
		cp_sv += 2;
		*cp_sv = m_pNpcList[sOwnerH]->m_cDir;
		cp_sv++;
		*cp_sv = sV1 - sX;
		cp_sv++;
		*cp_sv = sV2 - sY;
		cp_sv++;
		sp  = (short *)cp_sv;
		*sp = sV3;
		cp_sv += 2;

		for (i = 1; i < DEF_MAXNPCS; i++) {
			if ((m_pClientList[i] != NULL)) 
			if ( (m_pClientList[i]->m_cMapIndex == m_pNpcList[sOwnerH]->m_cMapIndex) &&
				 (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 10 - sRange) &&
				 (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 10 + sRange) &&
				 (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 8 - sRange) &&
				 (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 8 + sRange) ) {
				
				// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
				sTemp = *spStatus;
				sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
				
				//sTemp2 = (short)iGetNpcRelationship_SendEvent(sOwnerH, i);
				sTemp2 = (short)iGetNpcRelationship(sOwnerH, i);
				sTemp  = (sTemp | (sTemp2 << 12));
				*spStatus = sTemp;
				//

				// °æ°è ¾È¿¡ ¼ÓÇÑ Å¬¶óÀÌ¾ðÆ®°¡ ÀÖ´Ù. 
				if ( (m_pClientList[i]->m_sX >= m_pNpcList[sOwnerH]->m_sX - 9) &&
				     (m_pClientList[i]->m_sX <= m_pNpcList[sOwnerH]->m_sX + 9) &&
				     (m_pClientList[i]->m_sY >= m_pNpcList[sOwnerH]->m_sY - 7) &&
				     (m_pClientList[i]->m_sY <= m_pNpcList[sOwnerH]->m_sY + 7) ) {
					// *** ÀÌ¹Ì ÀÌ¸§°ú Æ¯¼ºÄ¡µîÀÇ µ¥ÀÌÅÍ°¡ º¸³»Áø °´Ã¼µéÀÌ´Ù.
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// ÀÌ ¸Þ½ÃÁö´Â À§Ä¡¿¡ »ó°ü¾øÀÌ ¸ðµç µ¥ÀÌÅÍ¸¦ º¸³»¾ß ÇÑ´Ù. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 27); // v1.4 : 24 // Original : 25
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// Ãß°¡ Á¤º¸¸¦ º¸³½´Ù.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						break;

					default:
						// ObjectID¸¸À» °¡Áø µ¥ÀÌÅÍ¸¦ º¸³½´Ù.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 9);
						break;
					}
				}
				else {
					// °æ°è¿¡ ¼ÓÇÑ NPCµéÀÌ´Ù. ¸ðµç µ¥ÀÌÅÍ¸¦ ´Ù º¸³»¾ß ÇÑ´Ù. +++
					switch (wMsgType) {
					case DEF_MSGTYPE_CONFIRM:
					case DEF_MSGTYPE_REJECT:
					case DEF_OBJECTNULLACTION:
						// ÀÌ ¸Þ½ÃÁö´Â À§Ä¡¿¡ »ó°ü¾øÀÌ ¸ðµç µ¥ÀÌÅÍ¸¦ º¸³»¾ß ÇÑ´Ù. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 25); // v1.4 : 24
						break;
					
					case DEF_OBJECTDYING:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 15);
						break;

					case DEF_OBJECTDAMAGE:
					case DEF_OBJECTDAMAGEMOVE:
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt, 11);
						break;

					case DEF_OBJECTATTACK:
					case DEF_OBJECTATTACKMOVE:
						// Ãß°¡ Á¤º¸¸¦ º¸³½´Ù.
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_Srt_Av, 13);
						break;

					default:
						// ÀÌµ¿ °ü·Ã µ¥ÀÌÅÍ¸é ¸ðµç µ¥ÀÌÅÍ¸¦ º¸³½´Ù. 
						iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData_All, 25); // v1.4
						break;
					}
					// +++
				}
			}
		}
	}
}

int CGame::iComposeMoveMapData(short sX, short sY, int iClientH, char cDir, char * pData)
{
 register int * ip, ix, iy, iSize, iTileExists, iIndex;
 class CTile * pTileSrc, * pTile;
 unsigned char ucHeader;
 short * sp, * pTotal, sTemp, sTemp2;
 WORD  * wp;
 char  * cp;

	if (m_pClientList[iClientH] == NULL) return 0;

	pTotal = (short *)pData;
	cp = (char *)(pData + 2);

	iSize = 2;
	iTileExists = 0;
	pTileSrc = (class CTile *)(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_pTile + 
		                       (sX) + (sY)*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);
	
	iIndex = 0;
	while (1) {
		ix = _tmp_iMoveLocX[cDir][iIndex];
		iy = _tmp_iMoveLocY[cDir][iIndex];
		if ((ix == -1) || (iy == -1)) break;
		iIndex++;

		pTile = (class CTile *)(pTileSrc + ix + iy*m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY);

		// @@@ !!! @@@ ÀÌ°÷¿¡ Á¶°ÇÀÌ ÀÔ·ÂµÇ¾ß¸¸ Á¤º¸°¡ Àü´ÞµÈ´Ù!!!
		if ( (pTile->m_sOwner != NULL) || (pTile->m_sDeadOwner != NULL) || 
			 (pTile->m_pItem[0] != NULL) || (pTile->m_sDynamicObjectType != NULL) ) {
			iTileExists++;
			// À§Ä¡Á¤º¸ ÀÔ·Â 
			sp = (short *)cp;
			*sp = ix;
			cp += 2;
			sp = (short *)cp;
			*sp = iy;
			cp += 2;
			iSize += 4;

			// Çì´õ Á¤º¸¸¦ ÀÛ¼ºÇÑ´Ù.
			ucHeader = 0;
			if (pTile->m_sOwner != NULL) {
				// °£È¤ ÇÚµéÀÌ ÀÖ´Âµ¥µµ NULLÀÎ °æ¿ì·Î ¿¡·¯¹ß»ý. ¿øÀÎÆÄ¾ÇÁß. ¿¡·¯ º¸¿Ï ·çÆ¾ »ðÀÔ. 
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
				if (pTile->m_cOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sOwner] != NULL) ucHeader = ucHeader | 0x01;
					else pTile->m_sOwner = NULL;
				}
			}
			if (pTile->m_sDeadOwner != NULL) {
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_PLAYER) { 
					if (m_pClientList[pTile->m_sDeadOwner] != NULL)	ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
				if (pTile->m_cDeadOwnerClass == DEF_OWNERTYPE_NPC) { 
					if (m_pNpcList[pTile->m_sDeadOwner] != NULL) ucHeader = ucHeader | 0x02;
					else pTile->m_sDeadOwner = NULL;
				}
			}
			if (pTile->m_pItem[0] != NULL)				ucHeader = ucHeader | 0x04;
			if (pTile->m_sDynamicObjectType != NULL)    ucHeader = ucHeader | 0x08;
			//
			*cp = ucHeader;
			cp++;
			iSize++;

			if ((ucHeader & 0x01) != 0) {
				// Ä³¸¯ÅÍ Á¤º¸ »ðÀÔ 
				switch (pTile->m_cOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					sTemp = m_pClientList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
			  		sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sOwner);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000	~
					sp  = (short *)cp;
					*sp	= pTile->m_sOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}
			
			if ((ucHeader & 0x02) != 0) {
				// Á×Àº Ä³¸¯ÅÍ Á¤º¸ »ðÀÔ 
				switch (pTile->m_cDeadOwnerClass) {
				case DEF_OWNERTYPE_PLAYER:
					// Object ID number(Player) : 1~10000
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pClientList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance1
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr1;
					cp += 2;
					iSize += 2;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Appearance3
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr3;
					cp += 2;
					iSize += 2;
					// Appearance4
					sp  = (short *)cp;
					*sp	= m_pClientList[pTile->m_sDeadOwner]->m_sAppr4;
					cp += 2;
					iSize += 2;
					// v1.4 ApprColor
					ip = (int *)cp;
					*ip = m_pClientList[pTile->m_sDeadOwner]->m_iApprColor;
					cp += 4;
					iSize += 4;

					// Status
					sp  = (short *)cp;
					
					sTemp = m_pClientList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
			  
					sTemp2 = (short)iGetPlayerABSStatus(pTile->m_sDeadOwner, iClientH); //(short)iGetPlayerRelationship(iClientH, pTile->m_sDeadOwner);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pClientList[pTile->m_sDeadOwner]->m_cCharName, 10);
					cp    += 10;
					iSize += 10;
					break;
				
				case DEF_OWNERTYPE_NPC:
					// Object ID number(NPC) : 10000~
					sp  = (short *)cp;
					*sp	= pTile->m_sDeadOwner + 10000;
					cp += 2;
					iSize += 2;
					// object type
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sType;
					cp += 2;
					iSize += 2;
					// dir
					*cp = m_pNpcList[pTile->m_sDeadOwner]->m_cDir;
					cp++;
					iSize++;
					// Appearance2
					sp  = (short *)cp;
					*sp	= m_pNpcList[pTile->m_sDeadOwner]->m_sAppr2;
					cp += 2;
					iSize += 2;
					// Status
					sp  = (short *)cp;
					
					sTemp = m_pNpcList[pTile->m_sDeadOwner]->m_sStatus;
					sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
					sTemp2 = iGetNpcRelationship(pTile->m_sDeadOwner, iClientH);
					sTemp  = (sTemp | (sTemp2 << 12));
					*sp = sTemp;
					cp += 2;
					iSize += 2;
					// Name
					memcpy(cp, m_pNpcList[pTile->m_sDeadOwner]->m_cName, 5);
					cp    += 5;
					iSize += 5;
					break;
				}
			}

			if (pTile->m_pItem[0] != NULL) {
				// ¾ÆÀÌÅÛ Á¤º¸ »ðÀÔ 
				// ½ºÇÁ¶óÀÌÆ® 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSprite;
				cp += 2;
				iSize += 2;
				// ½ºÇÁ¶óÀÌÆ® ÇÁ·¹ÀÓ 
				sp  = (short *)cp;
				*sp	= pTile->m_pItem[0]->m_sSpriteFrame;
				cp += 2;
				iSize += 2;
				// ¾ÆÀÌÅÛ »ö Ãß°¡µÊ v1.4 
				*cp = pTile->m_pItem[0]->m_cItemColor;
				cp++;
				iSize++;
			}

			if (pTile->m_sDynamicObjectType != NULL) {
				// µ¿Àû °´Ã¼ Á¾·ù ÇÒ´ç 
				wp  = (WORD *)cp;
				*wp = pTile->m_wDynamicObjectID;
				cp += 2;
				iSize += 2;
							
				sp  = (short *)cp;
				*sp	= pTile->m_sDynamicObjectType;
				cp += 2;
				iSize += 2;
			}
		}

	}

	*pTotal = iTileExists;
	return iSize;
}



void CGame::OnTimer(char cType)
{
 DWORD dwTime;

	dwTime = timeGetTime();

	//if ((dwTime - m_dwGameTime1) > 200) {
	GameProcess();
	//	m_dwGameTime1 = dwTime;
	//}
	

	if ((dwTime - m_dwGameTime2) > 3000) {
		CheckClientResponseTime();
		SendMsgToGateServer(MSGID_GAMESERVERALIVE, NULL);
		CheckDayOrNightMode();
		// È­¸é °»½Å 
		InvalidateRect(G_hWnd, NULL, TRUE);
		m_dwGameTime2 = dwTime;
		// v1.41 
		_CheckGateSockConnection();
		
		// v1.41
		if ((m_bIsGameStarted == FALSE)     && (m_bIsItemAvailable == TRUE)      && 
			(m_bIsNpcAvailable == TRUE)     && (m_bIsGateSockAvailable == TRUE)  &&
			(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE)     &&
			(m_bIsSkillAvailable == TRUE)   && (m_bIsPortionAvailable == TRUE)   &&
			(m_bIsQuestAvailable == TRUE)   && (m_bIsBuildItemAvailable == TRUE) && 
			(m_iSubLogSockActiveCount == DEF_MAXSUBLOGSOCK)) {
			// °ÔÀÓÀ» ½ÃÀÛÇÒ ÁØºñ°¡ µÇ¾ú´Ù. ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
			m_bIsGameStarted = TRUE;
		}
	}

	if ((dwTime - m_dwGameTime6) > 1000) {
		DelayEventProcessor();
		SendStockMsgToGateServer();
		m_dwGameTime6 = dwTime;
	}

	if ((dwTime - m_dwGameTime3) > 3000) {
		SyncMiddlelandMapInfo();
		CheckDynamicObjectList();
		DynamicObjectEffectProcessor();
		NoticeHandler();
		SpecialEventHandler();
		EnergySphereProcessor();
		m_dwGameTime3 = dwTime;
	}

	if ((dwTime - m_dwGameTime4) > 600) {
		MobGenerator();

		// v1.432-3 Sub-Log-SocketÀ» ÇÑ²¨¹ø¿¡ ¸¸µå´Â °ÍÀÌ ¾Æ´Ï¶ó ³ª´©¾î ¸¸µç´Ù.
		if (m_iSubLogSockInitIndex < DEF_MAXSUBLOGSOCK) {
			m_pSubLogSock[m_iSubLogSockInitIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
			m_pSubLogSock[m_iSubLogSockInitIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iSubLogSockInitIndex + 1));
			m_pSubLogSock[m_iSubLogSockInitIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);
			wsprintf(G_cTxt, "(!) Try to connect sub-log-socket(%d)... Addr:%s  Port:%d", m_iSubLogSockInitIndex, m_cLogServerAddr, m_iLogServerPort);
			PutLogList(G_cTxt);
			m_iSubLogSockInitIndex++;
		}

		m_dwGameTime4 = dwTime;
	}

	if ((dwTime - m_dwGameTime5) > 1000*60*3) {
		
		if (m_iMiddlelandMapIndex >= 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		m_dwGameTime5 = dwTime;

		// v1.41 ·£´ý ½Ãµå°ª ÃÊ±âÈ­.
		srand( (unsigned)time( NULL ) );   
	}

	if ((dwTime - m_dwFishTime) > 4000) {
		FishProcessor();
		FishGenerator();
		MineralGenerator();
		SendCollectedMana();
		m_dwFishTime = dwTime;
	}
	
	if ((dwTime - m_dwWhetherTime) > 1000*20) {
		WhetherProcessor();
		m_dwWhetherTime = dwTime;
	}

	// v1.4311-3 Ãß°¡  µÎ½Ã°£¸¶´Ù »çÅõÀå ¿¹¾àÀ» ÃÊ±âÈ­ÇÏ°í ¿¹¾àÇÑ À¯Àú¿¡°Ô »ç½ÇÀ» ¾Ë·ÁÁØ´Ù. 1000*60*60*2 = 7200000
	if ((dwTime - m_dwCanFightzoneReserveTime) > 7200000) {
		FightzoneReserveProcessor();
		m_dwCanFightzoneReserveTime = dwTime;
	}

	if ((m_bIsServerShutdowned == FALSE) && (m_bOnExitProcess == TRUE) && ((dwTime - m_dwExitProcessTime) > 1000*2)) {
		if (_iForcePlayerDisconect(15) == 0) {
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS COMPLETED! All players are disconnected.");
			m_bIsServerShutdowned = TRUE;

			// v1.41 ¸¸¾à ¼ÒÄÏÀÌ ²÷¾îÁ®¼­ ÀÚµ¿ ¼Ë´Ù¿î µÈ °ÍÀÌ¶ó¸é ´Ù½Ã ¼­¹ö¸¦ ±âµ¿½ÃÅ²´Ù. 
			if ((m_cShutDownCode == 3) || (m_cShutDownCode == 4)) {
				PutLogFileList("(!!!) AUTO-SERVER-REBOOTING!");
				bInit();
				m_iAutoRebootingCount++;
			}
			else {
				// v1.432 ¼­¹ö ¼Ë´Ù¿îÀÌ ³¡³ª¸é ÇÁ·Î±×·¥À» Á¾·á½ÃÅ²´Ù.
				Sleep(1000);
				PostQuitMessage(0);
			}
		}
		m_dwExitProcessTime = dwTime;
	}

	// v1.432-2 10ÃÊ¸¶´Ù ¼½ÅÍ Á¤º¸ ºÐ¼® 
	if ((dwTime - m_dwMapSectorInfoTime) > 1000*10) {
		m_dwMapSectorInfoTime = dwTime;
		UpdateMapSectorInfo();

		m_iMapSectorInfoUpdateCount++;
		if (m_iMapSectorInfoUpdateCount >= 5) {
			// ½Ã°£ÀÌ Áö³²¿¡ µû¶ó È°µ¿ ºóµµ Ä«¿îÆ®¸¦ °¨¼Ò½ÃÅ´.
			AgingMapSectorInfo();
			m_iMapSectorInfoUpdateCount = 0;
		}
	}
}

void CGame::CheckClientResponseTime()
{
 register int i, iPlusTime, iMaxSuperAttack, iValue;
 short sTemp;
 DWORD dwTime;
 //SYSTEMTIME SysTime;

	/*
	// ½Ã°£À» ±¸ÇÑ´ÙÀ½ iWarPeriod¸¦ ±¸ÇÑ´Ù.
	GetLocalTime(&SysTime);
	switch (SysTime.wDayOfWeek) {
	case 1:	iWarPeriod = 30; break; //¿ù¿äÀÏ 
	case 2:	iWarPeriod = 30; break; //È­¿äÀÏ 
	case 3:	iWarPeriod = 60; break; //¼ö¿äÀÏ 
	case 4:	iWarPeriod = 60*2;  break; //¸ñ¿äÀÏ 
	case 5:	iWarPeriod = 60*5;  break; //±Ý¿äÀÏ 
	case 6:	iWarPeriod = 60*10; break; //Åä¿äÀÏ 
	case 0:	iWarPeriod = 60*20; break; //ÀÏ¿äÀÏ 
	}
	*/
	
   	dwTime = timeGetTime();
	
	// ÀÏÁ¤½Ã°£µ¿¾È ¸Þ½ÃÁö¸¦ º¸³»¿ÀÁö ¾Ê´Â Å¬¶óÀÌ¾ðÆ®´Â »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if (m_pClientList[i] != NULL) {
			
			if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT ) {
				if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
					// °ÔÀÓÁßÀÎ Å¬¶óÀÌ¾ðÆ®°¡ ÀÀ´äÀÌ ¾øÀ¸¹Ç·Î »èÁ¦ÇÑ´Ù.
					//Testcode 
					wsprintf(G_cTxt, "Client Timeout: %s", m_pClientList[i]->m_cIPaddress);
					PutLogList(G_cTxt);

					DeleteClient(i, TRUE, TRUE);
				}
				else if ((dwTime - m_pClientList[i]->m_dwTime) > DEF_CLIENTTIMEOUT) {
					// ÃÊ±âÈ­ µÇÁö ¾Ê°í ´ë±âÁßÀÎ Å¬¶óÀÌ¾ðÆ®ÀÌ´Ù. Àå½Ã°£µ¿¾È Ã³¸®°¡ ÁøÇàµÇÁö ¾ÊÀ¸¸é »èÁ¦ÇÑ´Ù. 
					DeleteClient(i, FALSE, FALSE); // ÃÊ±âÈ­ µÇÁö ¾Ê¾ÒÀ¸¹Ç·Î µ¥ÀÌÅÍ¸¦ ÀúÀåÇÒ ÇÊ¿ä°¡ ¾ø´Ù. 
				}
			}
			else if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// ÇÃ·¹ÀÌ¾îÀÇ ÀüÃ¼ Ã¤ÆÃ ºÒ°¡´É Áö¼Ó½Ã°£À» ÁÙÀÎ´Ù. 
				m_pClientList[i]->m_iTimeLeft_ShutUp--;
				if (m_pClientList[i]->m_iTimeLeft_ShutUp < 0) m_pClientList[i]->m_iTimeLeft_ShutUp = 0;
				
				// ÆòÆÇÀ» ³»¸± ¼ö ÀÖ´Â ½Ã°£À» ÁÙÀÎ´Ù.
				m_pClientList[i]->m_iTimeLeft_Rating--;
				if (m_pClientList[i]->m_iTimeLeft_Rating < 0) m_pClientList[i]->m_iTimeLeft_Rating = 0;
				
				// ¹è°íÆÄÁú ½Ã°£ÀÌ µÇ¸é Ä«¿îÆ®¸¦ ÇÏ³ª ±ï´Â´Ù.
				if (((dwTime - m_pClientList[i]->m_dwHungerTime) > DEF_HUNGERTIME) && (m_pClientList[i]->m_bIsKilled == FALSE)) {
					// ½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
					if (m_pClientList[i]->m_iLevel < DEF_LEVELLIMIT) {
						// ·¹º§ÀÌ DEF_LEVELLIMITÀÌÇÏÀÌ¸é ¹è°íÇÄ Áö¼ö¸¦ ±ïÁö ¾Ê´Â´Ù.
					}
					else m_pClientList[i]->m_iHungerStatus--;
					if (m_pClientList[i]->m_iHungerStatus <= 0) m_pClientList[i]->m_iHungerStatus = 0;
					m_pClientList[i]->m_dwHungerTime = dwTime;
					
					if ( (m_pClientList[i]->m_iHP > 0) && (m_pClientList[i]->m_iHungerStatus < 30) ) {
						// ¹è°íÇÄÀ» ´À³¢´Â »óÅÂÀÌ´Ù. Å¬¶óÀÌ¾ðÆ®¿¡°Ô Åëº¸ÇÑ´Ù. 
						SendNotifyMsg(NULL, i, DEF_NOTIFY_HUNGER, m_pClientList[i]->m_iHungerStatus, NULL, NULL, NULL);
					}
				}
				
				// ¹è°¡ °íÇÁ¸é ¿À¸£´Â ½Ã°£ÀÌ ±æ¾îÁø´Ù.
				if ((m_pClientList[i]->m_iHungerStatus <= 30) && (m_pClientList[i]->m_iHungerStatus >= 0)) 
					iPlusTime = (30 - m_pClientList[i]->m_iHungerStatus)*1000;
				else iPlusTime = 0;
				
				iPlusTime = abs(iPlusTime);
				
				// HP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwHPTime) > (DWORD)(DEF_HPUPTIME + iPlusTime)) {
					TimeHitPointsUp(i);
					m_pClientList[i]->m_dwHPTime = dwTime;
				}
				
				// MP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwMPTime) > (DWORD)(DEF_MPUPTIME + iPlusTime)) {
					TimeManaPointsUp(i);
					m_pClientList[i]->m_dwMPTime = dwTime;
				}
				
				// SP°¡ ¿Ã¶ó°¥ ½Ã°£ÀÌ µÇ¸é ¿Ã¸°´Ù.
				if ((dwTime - m_pClientList[i]->m_dwSPTime) > (DWORD)(DEF_SPUPTIME + iPlusTime)) {
					TimeStaminarPointsUp(i);
					m_pClientList[i]->m_dwSPTime = dwTime;
				}
				
				// Áßµ¶ È¿°ú¸¦ °è»êÇÑ´Ù.
				if ((m_pClientList[i]->m_bIsPoisoned == TRUE) && ((dwTime - m_pClientList[i]->m_dwPoisonTime) > DEF_POISONTIME)) {
					PoisonEffect(i, NULL);
					m_pClientList[i]->m_dwPoisonTime = dwTime;
				}
				
				// ÀÚµ¿ ÀúÀå ½Ã°£ÀÌ µÇ¸é ÀúÀåÇÑ´Ù. ´Ü »çÅõÀå¿¡¼­´Â ÀúÀå ¾ÈÇÔ 
				if ((m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFightZone == FALSE) &&
					((dwTime - m_pClientList[i]->m_dwAutoSaveTime) > (DWORD)DEF_AUTOSAVETIME)) {
										
					bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, i);
					m_pClientList[i]->m_dwAutoSaveTime = dwTime;
				}
				
				// ExpStockÀ» °è»êÇÒ ½ÃÁ¡ÀÌ¸é 
				if ((dwTime - m_pClientList[i]->m_dwExpStockTime) > (DWORD)DEF_EXPSTOCKTIME) {
					m_pClientList[i]->m_dwExpStockTime = dwTime;
					CalcExpStock(i);
					CheckUniqueItemEquipment(i);
					CheckCrusadeResultCalculation(i);
				}

				// AutoExe °è»ê ½ÃÁ¡ÀÌ¸é 
				if ((dwTime - m_pClientList[i]->m_dwAutoExpTime) > (DWORD)DEF_AUTOEXPTIME) {
					iValue = (m_pClientList[i]->m_iLevel/2);
					if (iValue <= 0) iValue = 1;
					if (m_pClientList[i]->m_iAutoExpAmount < iValue) {
						// ÀÚµ¿ ½Ã°£ °è»ê °æÇèÄ¡·Î´Â ·¹º§ÀÌ ¿À¸£Áö ¾ÊÀ¸¹Ç·Î Ã³¸®ÇÑ´Ù.
						if ((m_pClientList[i]->m_iExp + iValue) < m_iLevelExpTable[m_pClientList[i]->m_iLevel+1]) {
							m_pClientList[i]->m_iExpStock += iValue;
							CalcExpStock(i);
						}
					}
			
					m_pClientList[i]->m_iAutoExpAmount = 0;
					m_pClientList[i]->m_dwAutoExpTime = dwTime;
				}
						
				// v1.432 Æ¯¼ö ´É·Â »ç¿ë °¡´É ½Ã°£À» ÁÙÀÎ´Ù. 3¾¿ ÁÙ¾îµç´Ù.
				if (m_pClientList[i]->m_iSpecialAbilityTime == 3) {
					// »ç¿ëÀÚ¿¡°Ô ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);
				}
				m_pClientList[i]->m_iSpecialAbilityTime -= 3;
				if (m_pClientList[i]->m_iSpecialAbilityTime < 0) m_pClientList[i]->m_iSpecialAbilityTime = 0;
				
				// v1.432 Æ¯¼ö ´É·Â »ç¿ëÁßÀÎ ½Ã°£À» Ã¼Å© 
				if (m_pClientList[i]->m_bIsSpecialAbilityEnabled == TRUE) {
					if (((dwTime - m_pClientList[i]->m_dwSpecialAbilityStartTime)/1000) > m_pClientList[i]->m_iSpecialAbilityLastSec) {
						// »ç¿ë½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
						m_pClientList[i]->m_bIsSpecialAbilityEnabled = FALSE;
						// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
						m_pClientList[i]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
						// È¿°ú ºñÆ® Å¬¸®¾î
						sTemp = m_pClientList[i]->m_sAppr4;
						sTemp = sTemp & 0xFF0F;
						m_pClientList[i]->m_sAppr4 = sTemp;
						// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
						SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					}
				}

				//Crusade
				m_pClientList[i]->m_iLockedMapTime -= 3;
				if (m_pClientList[i]->m_iLockedMapTime < 0) {
					// ¸Ê °¤Èû ½Ã°£ Á¾·á. Å¬¸®¾îÇÑ´Ù.
					m_pClientList[i]->m_iLockedMapTime = 0;
					ZeroMemory(m_pClientList[i]->m_cLockedMapName, sizeof(m_pClientList[i]->m_cLockedMapName));
					strcpy(m_pClientList[i]->m_cLockedMapName, "NONE");
				}
			
				if ( (m_pClientList[i]->m_bIsWarLocation == TRUE) ) {
					// Crusade
					if (m_bIsCrusadeMode == FALSE)
						m_pClientList[i]->m_iTimeLeft_ForceRecall--;

					if (m_pClientList[i]->m_iTimeLeft_ForceRecall <= 0) {
						// ½Ã°£ÀÌ ´Ù µÇ¾ú´Ù. °­Á¦ ¸®ÄÝÇÑ´Ù.
						m_pClientList[i]->m_iTimeLeft_ForceRecall = 0;
						m_pClientList[i]->m_dwWarBeginTime = dwTime;
						m_pClientList[i]->m_bIsWarLocation = FALSE;
											
						// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
						RequestTeleportHandler(i, "1   ");
					}
				}
				
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_iSkillMsgRecvCount >= 2) {
					// ¾ÆÀÌÅÛ Á¦ÀÛ ¸í·ÉÀÌ 2°³ ÀÌ»ó Á¢¼öµÇ¾ú´Ù¸é ÀÌ»óÇÑ °ÍÀÌ´Ù. Á¤»óÀûÀÌ¶ó¸é 1°³ ±îÁö ¿Ã ¼ö ÀÖ´Ù.
					//wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ¼Óµµ Á¶ÀÛ", m_pClientList[i]->m_cCharName);
					//PutLogFileList(G_cTxt);
					DeleteClient(i, TRUE, TRUE);
				}
				else {
					m_pClientList[i]->m_iSkillMsgRecvCount = 0;
				}

				// ¼Óµµ¹ö±× Ã¼Å©¿ë. ´ÜÀ§½Ã°£´ç Áö³ªÄ¡°Ô ¸¹Àº °æÇèÄ¡¸¦ ¾òÀº Ä³¸¯Àº ºí·ÏµÈ´Ù.
#ifndef DEF_TESTSERVER
				if (m_pClientList[i] == NULL) break;
				if ((dwTime - m_pClientList[i]->m_dwSpeedHackCheckTime) > (DWORD)1000*60*60) {
					if ((m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp) > 200000) {
						// 1½Ã°£¿¡ °æÇèÄ¡¸¦ 6¸¸ ÀÌ»ó ¾ò¾ú´Ù. 
						wsprintf(G_cTxt, "(!) ¼Óµµ Á¶ÀÛ ¿ëÀÇ Ä³¸¯ÅÍ(%s) 1½Ã°£¿¡ %dExp?", m_pClientList[i]->m_cCharName, (m_pClientList[i]->m_iExp - m_pClientList[i]->m_iSpeedHackCheckExp));
						
						SYSTEMTIME SysTime;
						GetLocalTime(&SysTime);
												
						if ((SysTime.wMonth+1) >= 13) {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear+1;
							m_pClientList[i]->m_iPenaltyBlockMonth = 1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						else {
							m_pClientList[i]->m_iPenaltyBlockYear = SysTime.wYear;
							m_pClientList[i]->m_iPenaltyBlockMonth = SysTime.wMonth+1;
							m_pClientList[i]->m_iPenaltyBlockDay = SysTime.wDay;
						}
						
						PutLogList(G_cTxt);
						PutLogFileList(G_cTxt);
						DeleteClient(i, TRUE, TRUE);
					}
					else {
						m_pClientList[i]->m_dwSpeedHackCheckTime = dwTime;
						m_pClientList[i]->m_iSpeedHackCheckExp = m_pClientList[i]->m_iExp;
					}
				}
#endif
				if (m_pClientList[i] == NULL) break;
				// ÇÏÀ§ ·¹º§ Á¦ÇÑ¿¡ °É¸°´Ù¸é 
				//if (m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) {
				if ((m_pClientList[i]->m_iLevel < m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2) ) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// »óÀ§ ·¹º§ Á¦ÇÑ¿¡ °É¸°´Ù¸é 
				//if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
				//	 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) ) {
				if ( (m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit != 0) &&
					 (m_pClientList[i]->m_iLevel > m_pMapList[m_pClientList[i]->m_cMapIndex]->m_iUpperLevelLimit) && (m_pClientList[i]->m_iAdminUserLevel < 2) ) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// ³ó°æÁö¸Ê¿¡ ÀûÀÌ µé¾î°¡¸é ¸®ÄÝ
				if ((strcmp(m_pClientList[i]->m_cLocation, "aresden") == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// ³ó°æÁö¸Ê¿¡ ÀûÀÌ µé¾î°¡¸é ¸®ÄÝ
				if ((strcmp(m_pClientList[i]->m_cLocation, "elvine") == 0) &&
					(strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "arefarm") == 0)) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// Áß¸³ÀÌ Á¢°æÁö³ª ¹Ìµé·£µå¿¡ ÀÖ´Ù¸é ¸®ÄÝ 
				if ( ((strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "middleland") == 0) ||
					  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aremidl") == 0) ||
					  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "aremidr") == 0) ||
					  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvmidl") == 0) ||
					  (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cName, "elvmidr") == 0)) &&
					 (strcmp(m_pClientList[i]->m_cLocation, "NONE") == 0) &&
					 (m_pClientList[i]->m_iAdminUserLevel == 0) ) {
					// ¼ÒÈ¯µÈ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»°í °­Á¦ ¸®ÄÝ.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_TOBERECALLED, NULL, NULL, NULL, NULL);
					RequestTeleportHandler(i, "0   ");
				}

				if (m_pClientList[i] == NULL) break;
				// ÇÊ»ì±â Ä«¿îÆ® Áõ°¡ 
				m_pClientList[i]->m_iSuperAttackCount++;
				if (m_pClientList[i]->m_iSuperAttackCount > 12) { //39ÃÊ¸¶´Ù ÇÑ°³¾¿ ÃàÀû µÈ´Ù.
					
					m_pClientList[i]->m_iSuperAttackCount = 0;
					// ÇÊ»ì±â´Â ÃÖ´ë Level/10 °³ ±îÁö ÃàÀûµÈ´Ù.
					iMaxSuperAttack = (m_pClientList[i]->m_iLevel / 10);
					if (m_pClientList[i]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[i]->m_iSuperAttackLeft++;
						
					// v1.12 ¼­¹ö¿Í Å¬¶óÀÌ¾ðÆ® °£¿¡ Ä«¿îÆ®°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â °æ¿ì°¡ ÀÖÀ» ¼ö ÀÖÀ¸¹Ç·Î °¡°¨¿¡ »ó°ü¾øÀÌ º¸³½´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
				}

				// v1.42 °íÁ¤ ½ºÅÂ¹Ì³Ê Ä«¿îÆ® °¨¼Ò 
				m_pClientList[i]->m_iTimeLeft_FirmStaminar--;
				if (m_pClientList[i]->m_iTimeLeft_FirmStaminar < 0) m_pClientList[i]->m_iTimeLeft_FirmStaminar = 0;

				// Crusade ¸ÊÁ¤º¸¸¦ º¸³»´Â ÁßÀÌ¾ú´Ù¸é °è¼Ó º¸³½´Ù.
				if (m_pClientList[i] == NULL) break;
				if (m_pClientList[i]->m_bIsSendingMapStatus == TRUE) _SendMapStatus(i);

				if (m_pClientList[i]->m_iConstructionPoint > 0) {
					// ´©ÀûµÈ °Ç¼³ Æ÷ÀÎÆ®°¡ ÀÖ´Ù.
					CheckCommanderConstructionPoint(i);
				}
			}
		}
	}
}

void CGame::OnMainLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pMainLogSock == NULL) return;

	iRet = m_pMainLogSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// ·Î±×¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³À¸¹Ç·Î °ÔÀÓ¼­¹ö µî·Ï ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		PutLogList("(!!!) Main-log-socket connected!");
		bSendMsgToLS(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù. 
		OnMainLogRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		PutLogList("(!!!) Main-log-socket BLOCKED!");
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// È®ÀÎÄÚµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù. 
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// ¼ö½ÅÇØ¾ß ÇÒ ¸Þ½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
		delete m_pMainLogSock;
		m_pMainLogSock = NULL;
		PutLogList("(!!!) Main-log-socket connection lost!");
		m_bIsLogSockAvailable = FALSE;

		// ·Î±× ¼­¹ö¿ÍÀÇ ¿¬°áÀÌ ²÷°åÀ¸¹Ç·Î º¹±¸ÇÒ ¼ö ¾ø´Ù. ÀÚµ¿À¸·Î ¼­¹ö¸¦ ¼Ë´Ù¿îÇÑ´Ù.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!!!) GAME SERVER SHUTDOWN PROCESS BEGIN(by main-log-socket connection Lost)!!!");
		}
		break;
	}
}

void CGame::OnMainLogRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pMainLogSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}


BOOL CGame::bSendMsgToLS(DWORD dwMsg, int iClientH, BOOL bFlag)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, iSize;
 char    cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;
 char    cGuildLoc[11], cTemp[120];
 int   * ip, iSendSize;
 

	/*
	// ¸Þ½ÃÁö¸¦ º¸³¾ Sub-log-socket ÀÎµ¦½º ÀüÁø 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;


	// ¸Þ½ÃÁö¸¦ º¸³»±â¿¡ Àû´çÇÑ Sub-log-socketÀ» Ã£´Â´Ù.
	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if (m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// º¸³¾ ¼ö ÀÖ´Â Sub-log-socketÀÌ ÇÏ³ªµµ ¾ø´Ù. °­Á¦ ¼Ë´Ù¿î ¸ðµå·Î ÀüÈ¯ 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}
	*/
	

	// v1.41
	ZeroMemory(G_cData50000, sizeof(G_cData50000));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,   sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));
	ZeroMemory(cGuildLoc,  sizeof(cGuildLoc));

	switch (dwMsg) {
	case MSGID_SENDSERVERSHUTDOWNMSG:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_SENDSERVERSHUTDOWNMSG;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		break;
	
	case MSGID_GAMESERVERSHUTDOWNED:
		if (m_pMainLogSock == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERSHUTDOWNED;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 6);
		return TRUE;

	case MSGID_REQUEST_SETACCOUNTWAITSTATUS:
	case MSGID_REQUEST_SETACCOUNTINITSTATUS:
		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;
	
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 20);
		iSendSize = 16;
		break;

	case MSGID_ENTERGAMECONFIRM:
		
		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_ENTERGAMECONFIRM;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cp, m_pClientList[iClientH]->m_cAccountName, 10);
		cp += 10;

		memcpy(cp, m_pClientList[iClientH]->m_cAccountPassword, 10);
		cp += 10;

		memcpy(cp, m_cServerName, 10);
		cp += 10;

		ZeroMemory(cTxt, sizeof(cTxt));
		m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTxt);
		memcpy(cp, cTxt, 16);
		cp += 16;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iLevel;
		cp += 4;

		//testcode
		wsprintf(G_cTxt, "(TestLog) Enter Game Confirm Level: %d", m_pClientList[iClientH]->m_iLevel);
		PutLogList(G_cTxt);

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// ·Î±× ¼­¹ö¿¡°Ô °ÔÀÓ¼­¹ö µî·ÏÀ» ¿äÃ»ÇÑ´Ù.
		if (m_pMainLogSock == NULL) return FALSE;
				
		wsprintf(cTxt, "(!) Try to register game server(%s)", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}

		// ÀÌ ¸Þ½ÃÁö´Â m_pMainLogSockÀ¸·Î º¸³»¾ß ÇÑ´Ù. 
		iRet = m_pMainLogSock->iSendMsg(G_cData50000, 35 + m_iTotalMaps*11);
		return TRUE;

	case MSGID_REQUEST_PLAYERDATA:
		
		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;

		// ·Î±× ¼­¹ö·Î ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ¸¦ ¿äÃ»ÇÑ´Ù.
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_PLAYERDATA;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		//testcode
		if (strlen(m_pClientList[iClientH]->m_cCharName) == 0) PutLogList("(X) CharName NULL!");

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		ZeroMemory(cTemp, sizeof(cTemp));
		iRet = m_pClientList[iClientH]->m_pXSock->iGetPeerAddress(cTemp);
		memcpy((char *)cp, cTemp, 15);
		cp += 15;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 52);
		iSendSize = 52;
		break;

	case MSGID_REQUEST_SAVEPLAYERDATA_REPLY:
	case MSGID_REQUEST_SAVEPLAYERDATA:
	case MSGID_REQUEST_SAVEPLAYERDATALOGOUT:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = dwMsg;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		*cp = (char)bFlag; // Ä«¿îÆÃ ÇÃ·¡±× 
		cp++;
		
		iSize = _iComposePlayerDataFileContents(iClientH, cp);
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37 + iSize);
		iSendSize = 37 + iSize;
		break;

	case MSGID_REQUEST_NOSAVELOGOUT:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_NOSAVELOGOUT;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;
		
		*cp = (char)bFlag; // Ä«¿îÆÃ ÇÃ·¡±× 
		cp++;
		
		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 37);
		iSendSize = 37;
		break;

	case MSGID_REQUEST_CREATENEWGUILD:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_CREATENEWGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);
		memcpy(cGuildLoc, m_pClientList[iClientH]->m_cLocation, 10);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;
		memcpy((char *)cp, cGuildLoc, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 75);
		iSendSize = 75;
		break;

	case MSGID_REQUEST_DISBANDGUILD:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_DISBANDGUILD;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cAccountName, m_pClientList[iClientH]->m_cAccountName, 10);
		memcpy(cAccountPassword, m_pClientList[iClientH]->m_cAccountPassword, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountName, 10);
		cp += 10;

		memcpy((char *)cp, cAccountPassword, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 56);
		iSendSize = 56;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;
		
		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;

	case MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN:

		// Sub-log-socketÀ» »ç¿ëÇÑ Àü¼Û¿¡¼­´Â ¹Ýµå½Ã Ã¼Å©ÇØ¾ß ÇÏ´Â ·çÆ¾.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		
		if (m_pClientList[iClientH] == NULL) return FALSE;

		dwp  = (DWORD *)(G_cData50000 + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN;
		wp   = (WORD *)(G_cData50000 + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp = (char *)(G_cData50000 + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cCharName, m_pClientList[iClientH]->m_cCharName, 10);
		memcpy(cGuildName, m_pClientList[iClientH]->m_cGuildName, 20);

		memcpy((char *)cp, cCharName, 10);
		cp += 10;

		memcpy((char *)cp, cGuildName, 20);
		cp += 20;

		iRet = m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, 36);
		iSendSize = 36;
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// Sub-log-socketÀ» »ç¿ëÇØ¼­ ·Î±× ¼­¹ö·Î ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù.
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) send error!", m_iCurSubLogSockIndex);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);

		delete m_pSubLogSock[m_iCurSubLogSockIndex];
		m_pSubLogSock[m_iCurSubLogSockIndex] = NULL;
		m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] = FALSE;
		m_iSubLogSockActiveCount--;
				
		// ´Ù½Ã ¿¬°áÀ» ½Ãµµ
		m_pSubLogSock[m_iCurSubLogSockIndex] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[m_iCurSubLogSockIndex]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + m_iCurSubLogSockIndex + 1));
		m_pSubLogSock[m_iCurSubLogSockIndex]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", m_iCurSubLogSockIndex, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		// v1.41 sub-log-socket Àü¼Û ½ÇÆÐ Ä«¿îÆ® Áõ°¡ 
		m_iSubLogSockFailCount++;

		// v1.41 º¸³»·Á´Ù ½ÇÆÐÇÑ ¸Þ½ÃÁö´Â ´Ù¸¥ ¼ÒÄÏÀ» »ç¿ëÇÏ¿© Àü¼ÛÇØ¾ß ÇÑ´Ù. 
		// ÀÌ ¹æ¹ýÀÌ ¸ðµç ¸Þ½ÃÁöÀÇ Àü¼ÛÀ» º¸ÀåÇÏÁö´Â ¾Ê´Â´Ù. ÃÖ¼ÒÇÑÀÇ ÀåÄ¡ÀÎ ¼À.
		if (_bCheckSubLogSocketIndex() == FALSE) return FALSE;
		m_pSubLogSock[m_iCurSubLogSockIndex]->iSendMsg(G_cData50000, iSendSize);

		return FALSE;
	}

	return TRUE;
}

void CGame::ResponsePlayerDataHandler(char * pData, DWORD dwSize)
{
 WORD * wp;
 char * cp, cCharName[11], cTxt[120];
 int  i; 
 
 	// ·Î±× ¼­¹ö·ÎºÎÅÍ ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ® ¹è¿­À» °Ë»öÇÑ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
			switch (*wp) {
			case DEF_LOGRESMSGTYPE_CONFIRM:
				// Å¬¶óÀÌ¾ðÆ® µ¥ÀÌÅÍ°¡ Á¤»óÀûÀ¸·Î ¼ö½ÅµÇ¾ú´Ù. 
				InitPlayerData(i, pData, dwSize); 
				break;
	
			case DEF_LOGRESMSGTYPE_REJECT:
				// ÀÌ Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ ÃÊ±âÈ­°¡ °ÅºÎµÇ¾ú´Ù. Á¢¼ÓÀ» ²÷´Â´Ù.
				wsprintf(G_cTxt, "(HACK?) Not existing character(%s) data request! Rejected!", m_pClientList[i]->m_cCharName);
				PutLogList(G_cTxt);
				//PutLogFileList(G_cTxt); // v1.4

				DeleteClient(i, FALSE, FALSE);
				break;
			
			default:
				break;
			}				
			
			return;
		}	
	}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server: CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::InitPlayerData(int iClientH, char * pData, DWORD dwSize)
{
	char  * cp, cName[11], cData[256], cTxt[256], cGuildStatus;
	DWORD * dwp;
	WORD  * wp;
	int     iRet;
	BOOL    bRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == TRUE) return; // ÀÌ¹Ì ÃÊ±âÈ­ µÈ Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍÀÌ´Ù. ÀÌ·±ÀÏÀÌ ÀÖÀ» ¼ö ÀÖÀ»±î?

	// Log Server·ÎºÎÅÍÀÇ ¸Þ½ÃÁö¸¦ ºÐ¼®ÇÏ¿© ÇÃ·¹ÀÌ¾îÀÇ µ¥ÀÌÅÍ¸¦ ÃÊ±âÈ­ÇÑ´Ù. 
	// ¸¸¾à ·Î±×¼­¹ö·ÎºÎÅÍÀÇ ¸Þ½ÃÁö°¡ ÆÄÀÏ¼Õ»óµîÀÇ ÀÌÀ¯·Î ³»¿ëÀÌ Á¤È®ÇÏ°Ô ¸ÂÁö ¾ÊÀ¸¸é ÃÊ±âÈ­ ÇÏÁö ¾Ê°í Å¬¶óÀÌ¾ðÆ®¸¦ »èÁ¦ÇÑ´Ù.

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);
	cp += 10;

	// °èÁ¤Á¤º¸ ÀúÀå  v1.43	ºÎÅÍ ´õÀÌ»óÀÇ °èÁ¤ Á¤º¸´Â ÇÊ¿ä¾ø´Ù. 
	//m_pClientList[iClientH]->m_cAccountStatus = *cp;
	cp++;

	// ±æµå Á¤º¸ ÀÐ´Â´Ù. ÀÌ °ªÀÌ 0ÀÌ¸é ±æµåÀÌ¸§°ú ·©Å©´Â ¹«È¿´Ù.  
	cGuildStatus = *cp;
	cp++;

	// ±âº» ¸íÁß·üÀº 0%(¹æ¾î·ü°ú´Â ¾à°£ ÀÇ¹Ì°¡ ´Ù¸§. ¸Ç¼Õ°ø°Ý½ÃÀÇ ¸íÁß·üÀº µû·Î °è»êµÈ´Ù)
	m_pClientList[iClientH]->m_iHitRatio     = 0;
	m_pClientList[iClientH]->m_iDefenseRatio = 0;
	m_pClientList[iClientH]->m_cSide         = 0;

	bRet = _bDecodePlayerDatafileContents(iClientH, cp, dwSize - 19);
	// ¸®ÅÏ°ªÀÌ FALSEÀÌ¸é Å¬¶óÀÌ¾ðÆ® µ¥ÀÌÅÍ°¡ ¹«¾ð°¡ Àß¸øµÈ °Í. Å¬¶óÀÌ¾ðÆ®¸¦ »èÁ¦ÇÏ°í ¸®ÅÏÇÑ´Ù.
	if (bRet == FALSE) {
		wsprintf(G_cTxt, "(HACK?) Character(%s) data error!", m_pClientList[iClientH]->m_cCharName);
		DeleteClient(iClientH, FALSE, TRUE); //!!!
		return;
	}

	// *******^^^^^^^^^^^^^^^^^^^^Æ¯¼ºÄ¡°ª ·Îµù ¿Ï·á^^^^^^^^^^^^^^^^^^^^^********
	//***************************************************************************

	// (!) Æ¯¼ºÄ¡¸¦ º¹±¸ÇÑ´Ù. 
	___RestorePlayerCharacteristics(iClientH);

	// (!) Àß¸øµÈ Æ¯¼ºÄ¡¸¦ º¹±¸ÇÑ´Ù. 
	___RestorePlayerRating(iClientH);

	if ((m_pClientList[iClientH]->m_sX == -1) && (m_pClientList[iClientH]->m_sY == -1)) {
		// ÁÂÇ¥°¡ ¸ðµÎ -1ÀÌ¸é À§Ä¡ÇÑ ¸ÊÀÇ InitialPoint·Î °£´Ù.
		GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
	}

	// ÇÃ·¹ÀÌ¾îÀÇ ¼Ò¼Ó¿¡ µû¶ó Side¸¦ °áÁ¤ÇÑ´Ù. ¿©ÇàÀÚ¶ó¸é 0À» À¯ÁöÇÏ°í AresdenÀÌ¸é 1, ElvineÀÌ¸é 2¸¦ ÇÒ´çÇÑ´Ù.
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	// ´ÙÀ½ ·¹º§ÀÇ °æÇèÄ¡¸¦ ±¸ÇÑ´Ù.
	m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);

	// Æ¯¼ºÄ¡ Àç°è»ê.
	CalcTotalItemEffect(iClientH, -1, TRUE); //FALSE
	// ¹«°Ô °è»ê
	iCalcTotalWeight(iClientH);

	// Æ¯¼ö ÀÌº¥Æ® °è»ê 
	CheckSpecialEvent(iClientH);

	// GuildNameÀÌ NONEÀÌ ¾Æ´Ï°í GuildStatus°¡ 0ÀÌ¸é Á¢¼ÓÁßÀÌ ¾Æ´Ò¶§ ±æµå°¡ Áö¿öÁ³´Ù´Â ÀÇ¹Ì.
	if ((cGuildStatus == 0) && (memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0)) {
		// ±æµå°¡ ºñÁ¢¼ÓÁßÀÏ¶§ »ç¶óÁ³À¸¹Ç·Î Áö±Ý ¾Ë·ÁÁØ´Ù.
		ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
		strcpy(m_pClientList[iClientH]->m_cGuildName, "NONE");
		m_pClientList[iClientH]->m_iGuildRank = -1;
		m_pClientList[iClientH]->m_iGuildGUID = -1;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL, m_pClientList[iClientH]->m_cGuildName);
	}

	// ¸Þ½ÃÁö Àü¼Û µµÁß ¿¡·¯°¡ ¹ß»ýÇÏ¿© Å¬¶óÀÌ¾ðÆ®°¡ »èÁ¦µÇ¾ú´Ù¸é Ã³¸® Á¾·á 
	if (m_pClientList[iClientH] == NULL) {
		wsprintf(cTxt, "<%d> InitPlayerData error - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITPLAYER;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;

	// µ¥ÀÌÅÍ ÃÊ±âÈ­ È®ÀÎ ¸Þ½ÃÁö Àü¼Û
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		// ## BUG POINT!!! ¸ÕÀú ·Î±× ¸Þ½ÃÁö Ãâ·ÂÈÄ »èÁ¦ÇÑ´Ù.
		wsprintf(cTxt, "<%d> InitPlayerData - Socket error! Disconnected.", iClientH);
		PutLogList(cTxt);

		DeleteClient(iClientH, FALSE, TRUE); //!!!!!
		return;
	}

	// Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ°¡ ÃÊ±âÈ­ µÇ¾ú´Ù. 
	m_pClientList[iClientH]->m_bIsInitComplete = TRUE;

	// ·Î±× ¼­¹ö¿¡°Ô ÀÌ °èÁ¤ÀÇ ÇÃ·¹ÀÌ¾î°¡ °ÔÀÓÁß¿¡ µé¾î¿ÔÀ½À» ¾Ë·ÁÁØ´Ù. 
	bSendMsgToLS(MSGID_ENTERGAMECONFIRM, iClientH);

	// ¼­¹ö ´Ù¿îÀ» ¸·±âÀ§ÇÑ ÃÖÈÄÀÇ Á¶Ä¡ÀÌ´Ù.
	if (m_iTotalClients > DEF_MAXONESERVERUSERS) {
		switch (iDice(1,2)) {
		case 1: 
			RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
			break;
		case 2: 
			switch (m_pClientList[iClientH]->m_cSide) {
		case 0: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
		case 1: RequestTeleportHandler(iClientH, "2   ", "resurr1", -1, -1); break;
		case 2: RequestTeleportHandler(iClientH, "2   ", "resurr2", -1, -1); break;
			}
			break;
		}
	}

	return;
}

void CGame::GameProcess()
{
	NpcProcess();
	MsgProcess();
	DelayEventProcess();
}

BOOL CGame::bReadProgramConfigFile(char * cFn)
{
	FILE * pFile;
	HANDLE hFile;
	DWORD  dwFileSize;
	char * cp, * token, cReadMode, cTxt[120];
	char seps[] = "= \t\n";
	class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		//	PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {

			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// ¼­¹öÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					// v2.04 °ÔÀÓ¼­¹ö IP ÀÚµ¿À¸·Î ÀÎ½Ä 
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					char ServerAddr[50];
					::gethostname(ServerAddr,50); 
					struct hostent *pHostEnt;
					pHostEnt = ::gethostbyname(ServerAddr);
					if( pHostEnt != NULL ){
						wsprintf(ServerAddr, "%d.%d.%d.%d",
							( pHostEnt->h_addr_list[0][0] & 0x00ff ),
							( pHostEnt->h_addr_list[0][1] & 0x00ff ),
							( pHostEnt->h_addr_list[0][2] & 0x00ff ),
							( pHostEnt->h_addr_list[0][3] & 0x00ff ) );
					}
					strcpy(m_cGameServerAddr,ServerAddr );

					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);

					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					// ¸ÊÀ» µî·ÏÇÑ´Ù.
					if (strlen(token) > 10) {
						// ¸ÊÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 6:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (strlen(token) > 15) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 7:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 2;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 3;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 4;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 5;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 6;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 7;
			}

			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
/*
BOOL CGame::bReadProgramConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120];
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					ZeroMemory(m_cServerName, sizeof(m_cServerName));
					if (strlen(token) > 10) {
						// ¼­¹öÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù. 
						wsprintf(cTxt, "(!!!) Game server name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cServerName, token);
					wsprintf(cTxt, "(*) Game server name : %s", m_cServerName);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 2:
					ZeroMemory(m_cGameServerAddr, sizeof(m_cGameServerAddr));
					if (strlen(token) > 15) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Game server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGameServerAddr, token);
					wsprintf(cTxt, "(*) Game server address : %s", m_cGameServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 3:
					m_iGameServerPort = atoi(token);
					wsprintf(cTxt, "(*) Game server port : %d", m_iGameServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 4:
					ZeroMemory(m_cLogServerAddr, sizeof(m_cLogServerAddr));
					if (strlen(token) > 15) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Log server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cLogServerAddr, token);
					wsprintf(cTxt, "(*) Log server address : %s", m_cLogServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 5:
					m_iLogServerPort = atoi(token);
					wsprintf(cTxt, "(*) Log server port : %d", m_iLogServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
					
				case 6:
					// ¸ÊÀ» µî·ÏÇÑ´Ù.
					if (strlen(token) > 10) {
						// ¸ÊÀÇ ÀÌ¸§ÀÌ ³Ê¹« ±æ´Ù.
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map name(%s) must within 10 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					if (_bRegisterMap(token) == FALSE) {
						return FALSE;
					}
					cReadMode = 0;
					break;

				case 7:
					ZeroMemory(m_cGateServerAddr, sizeof(m_cGateServerAddr));
					if (strlen(token) > 15) {
						// ÁÖ¼Ò°¡ 15¹ÙÀÌÆ® ÀÌ»ó. ¿À·ù´Ù. 
						wsprintf(cTxt, "(!!!) Gate server address(%s) must within 15 chars!", token);
						PutLogList(cTxt);
						return FALSE;
					}
					strcpy(m_cGateServerAddr, token);
					wsprintf(cTxt, "(*) Gate server address : %s", m_cGateServerAddr);
					PutLogList(cTxt);
					cReadMode = 0;
					break;

				case 8:
					m_iGateServerPort = atoi(token);
					wsprintf(cTxt, "(*) Gate server port : %d", m_iGateServerPort);
					PutLogList(cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "game-server-name", 16) == 0)			cReadMode = 1;
				if (memcmp(token, "game-server-address", 19) == 0)		cReadMode = 2;
				if (memcmp(token, "game-server-port", 16) == 0)			cReadMode = 3;
				if (memcmp(token, "log-server-address", 18) == 0)		cReadMode = 4;
				if (memcmp(token, "internal-log-server-port", 24) == 0) cReadMode = 5;
				if (memcmp(token, "game-server-map", 15) == 0)			cReadMode = 6;
				if (memcmp(token, "gate-server-address", 19) == 0)		cReadMode = 7;
				if (memcmp(token, "gate-server-port", 16) == 0)			cReadMode = 8;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
*/

BOOL CGame::bReadCrusadeStructureConfigFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadModeA, cReadModeB, cTxt[120];
 char seps[] = "= \t\n";
 int   iIndex;
 class CStrTok * pStrTok;

	cReadModeA = 0;
	cReadModeB = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open Crusade configuration file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Crusade configuration file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		iIndex = 0;
		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		while( token != NULL ) {
			if (cReadModeA != 0) {
				switch (cReadModeA) {
				case 1:
					switch (cReadModeB) {
					case 1:
						// ½ºÆ®·°ÃÄ ¹øÈ£
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format(1).");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						iIndex = atoi(token);

						if (m_stCrusadeStructures[iIndex].cType != NULL) {
							// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Duplicate portion number.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						
						cReadModeB = 2;
						break;

					case 2:
						// ¸Ê ÀÌ¸§
						ZeroMemory(m_stCrusadeStructures[iIndex].cMapName, sizeof(m_stCrusadeStructures[iIndex].cMapName));
						memcpy(m_stCrusadeStructures[iIndex].cMapName, token, strlen(token));
						cReadModeB = 3;
						break;

					
					case 3:
						// Á¾·ù
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].cType = atoi(token);
						cReadModeB = 4;
						break;

					case 4:
						// À§Ä¡
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dX = atoi(token);
						cReadModeB = 5;
						break;
	
					case 5:
						// À§Ä¡
						if (_bGetIsStringIsNumber(token) == FALSE) {
							PutLogList("(!!!) CRITICAL ERROR!  Crusade configuration file error - Wrong Data format.");
							delete cp;
							delete pStrTok;
							return FALSE;
						}
						m_stCrusadeStructures[iIndex].dY = atoi(token);
						cReadModeA = 0;
						cReadModeB = 0;
						break;
					}
					break;

				default: 
					break;
				}
			}
			else {
				if (memcmp(token, "crusade-structure", 17) == 0) {
					cReadModeA = 1;
					cReadModeB = 1;
				}
			
			}
			token = pStrTok->pGet();
		}	

		delete pStrTok;
		delete cp;

		if ((cReadModeA != 0) || (cReadModeB != 0)) {
			PutLogList("(!!!) CRITICAL ERROR! Crusade Structure configuration file contents error!");
			return FALSE;
		}
	}
	
	if (pFile != NULL) fclose(pFile);
	return TRUE;
}



BOOL CGame::_bRegisterMap(char * pName)
{
 int i;
 char cTmpName[11], cTxt[120];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);
	// ¸ÕÀú ÀÌ¹Ì µî·ÏµÈ ¸ÊÀÎÁö °Ë»öÇÑ´Ù. 
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
		// ÀÌ¹Ì µî·ÏµÈ ¸ÊÀÌ´Ù. 
		wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) is already installed! cannot add.", cTmpName);
		PutLogList(cTxt);
		return FALSE;
	}

	// µî·ÏµÇ¾î ÀÖÁö ¾ÊÀº ¸ÊÀÌ¹Ç·Î µî·ÏÇÑ´Ù.	
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] == NULL) {
		m_pMapList[i] = (class CMap *)new class CMap(this);
		wsprintf(cTxt, "(*) Add map (%s)   - Loading map info files...", pName);
		PutLogList(cTxt);
		// ¸ÊÀÇ Á¤º¸¿Í NPC¸®½ºÆ®, ÀÌº¥Æ® ¸®½ºÆ®µîÀ» ·ÎµåÇÑ´Ù.
		// ¸Ê µ¥ÀÌÅÍ ÆÄÀÏ ·Îµå. 
		if (m_pMapList[i]->bInit(pName) == FALSE) {
			wsprintf(cTxt, "(!!!) Data file loading fail!", pName);
			PutLogList(cTxt);
			return FALSE;	
		};
		
		PutLogList("(*) Data file loading success.");
		// ¸Ê ÀÌº¥Æ® ÆÄÀÏ ·Îµå´Â NPC ÄÁÇÇ±Ô·¹ÀÌ¼Ç µ¥ÀÌÅÍ°¡ ¼ö½ÅµÈ ÈÄ¿¡  
		
		// v1.3 ¹Ìµé·£µå¶ó¸é ÀÎµ¦½º¸¦ Ç¥½ÃÇØ³õ´Â´Ù.
		if ((m_iMiddlelandMapIndex == -1) && (strcmp("middleland", pName) == 0)) 
			m_iMiddlelandMapIndex = i;

		// v1.3 ¾Æ·¹½ºµ§ ÀÎµ¦½º¸¦ Ç¥½ÃÇØ³õ´Â´Ù.
		if ((m_iAresdenMapIndex == -1) && (strcmp("aresden", pName) == 0)) 
			m_iAresdenMapIndex = i;

		// v1.3 ¿¤¹ÙÀÎ ÀÎµ¦½º¸¦ Ç¥½ÃÇØ³õ´Â´Ù.
		if ((m_iElvineMapIndex == -1) && (strcmp("elvine", pName) == 0)) 
			m_iElvineMapIndex = i;
	
		m_iTotalMaps++;
		return TRUE;
	}

	wsprintf(cTxt, "(!!!) CRITICAL ERROR! Map (%s) canot be added - no more map space.", pName);
	PutLogList(cTxt);
	return FALSE;
}

BOOL CGame::_bDecodePlayerDatafileContents(int iClientH, char * pData, DWORD dwSize)
{
	char * pContents, * token, * pOriginContents, cTmpName[11], cTxt[120];
	char   seps[] = "= \t\n";
	char   cReadModeA, cReadModeB;
	int    i, iItemIndex, iItemInBankIndex, iTotalGold, iNotUsedItemPrice;
	class  CStrTok * pStrTok;
	short  sTmpType, sTmpAppr1;
	BOOL   bRet;
	int    iTemp;
	SYSTEMTIME SysTime;
	__int64 iDateSum1, iDateSum2;
	BOOL   bIsNotUsedItemFound = FALSE;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// ¼ÒÁöÇ° °Ë»ç¿ë 
	iTotalGold = 0;
	iItemIndex = 0;
	iItemInBankIndex  = 0;
	iNotUsedItemPrice = 0;

	cReadModeA = 0;
	cReadModeB = 0;

	pContents = new char[dwSize+2];
	ZeroMemory(pContents, dwSize+2);
	memcpy(pContents, pData, dwSize);

	pOriginContents = pContents;

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();

	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				// ÇÃ·¹ÀÌ¾î°¡ ¼ÓÇØÀÖ´Â ¸Ê ÀÌ¸§À» ¾ò´Â´Ù. 
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				strcpy(m_pClientList[iClientH]->m_cMapName, token);
				// ÀÌÁ¦ ÀÌ ¸ÊÀÇ ÀÎµ¦½º°ªÀ» Ã£¾Æ ÇÒ´çÇÑ´Ù. 
				ZeroMemory(cTmpName, sizeof(cTmpName));
				strcpy(cTmpName, token);
				for (i = 0; i < DEF_MAXMAPS; i++)
					if ((m_pMapList[i] != NULL)	&& (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0)) {
						// ¸ÊÀÇ ÀÎµ¦½º´Â iÀÌ´Ù.
						m_pClientList[iClientH]->m_cMapIndex = (char)i;
					}

					if (m_pClientList[iClientH]->m_cMapIndex == -1) {
						// ¸¸¾à ÇÃ·¹ÀÌ¾î°¡ ¼ÓÇÑ ¸ÊÀÌ Á¸ÀçÇÏÁö ¾Ê´Â´Ù¸é (ÀÌ·± °æ¿ì´Â ¹ß»ýÇÏ±â Èûµé´Ù. ·Î±× ¼­¹ö¿¡¼­ ¸ÕÀú °Ë»öÇÑ ÈÄ Á¢¼ÓÇÏ±â ¶§¹®)
						wsprintf(cTxt, "(!) Player(%s) tries to enter unknown map : %s", m_pClientList[iClientH]->m_cCharName, cTmpName); 
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeA = 0;
					break;

			case 2:
				// ÇÃ·¹ÀÌ¾îÀÇ ¸Ê»óÀÇ À§Ä¡ X
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sX = atoi(token);
				cReadModeA = 0;
				break;

			case 3:
				// ÇÃ·¹ÀÌ¾îÀÇ ¸Ê»óÀÇ À§Ä¡ Y
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_sY = atoi(token);
				cReadModeA = 0;
				break;

			case 4:
				// ÇÃ·¹ÀÌ¾îÀÇ °èÁ¤ »óÅÂ¸¦ ¾ò´Â´Ù. <- ÀÌ ±â´ÉÀº ÇöÀç ¾²Áö ¾Ê´Â´Ù. °èÁ¤Á¤º¸´Â º°µµ·Î Àü´ÞµÇ¹Ç·Î 
				/*
				if (_bGetIsStringIsNumber(token) == FALSE) {
				wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
				PutLogList(cTxt);
				delete pContents;
				delete pStrTok;
				return FALSE;
				}
				m_pClientList[iClientH]->m_cAccountStatus = atoi(token);
				*/
				cReadModeA = 0;
				break;

			case 5:
				// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛ Á¤º¸¸¦ ÀÐ¾î ÃÊ±âÈ­ ÇÑ´Ù.
				switch(cReadModeB) {
			case 1:
				// token°ªÀº ¾ÆÀÌÅÛÀÇ ÀÌ¸§. ÀÌ ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÇ Æ¯¼ºÀ» m_pItemConfigList¿¡¼­ Ã£¾Æ ÇÒ´çÇÑ´Ù.
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemList[iItemIndex], token) == FALSE) {
					// ÇÃ·¹ÀÌ¾î°¡ ¼ÒÁöÇÑ ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Ù. ¿¡·¯
					wsprintf(cTxt, "(!!!) Client(%s)-Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// °¹¼ö°¡ ¸¶ÀÌ³Ê½ºÀÌ¸é 1À¸·Î ¼¼ÆÃµÈ´Ù.
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;
				//¸¸¾à Áß·®ÀÌ ÃÊ°úµÇ¾ú´Ù¸é 1°³·Î ÁÙÀÎ´Ù.
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¾ÆÀÌÅÛ(%s) °³¼ö ¿À¹öÇÃ·Î¿ì", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3 ¼ÒÁöÇÏ°í ÀÖ´Â °ñµåÀÇ ÃÑ ÇÕÀ» °Ë»çÇÑ´Ù. 
				if (memcmp(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute = atoi(token);

				// v1.4 °³ÀÎ °íÀ¯ ¾ÆÀÌÅÛÀ» È®ÀÎÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) {
					if ( (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1 != m_pClientList[iClientH]->m_sCharIDnum1) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2 != m_pClientList[iClientH]->m_sCharIDnum2) ||
						(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3 != m_pClientList[iClientH]->m_sCharIDnum3) ) {
							// ÀÚ½ÅÀÇ °ÍÀÌ ¾Æ´Ñ ¾ÆÀÌÅÛÀ» °®°í ÀÖ´Ù. 
							wsprintf(cTxt, "(!) ´Ù¸¥ »ç¶÷ÀÇ ¾ÆÀÌÅÛ ¼ÒÁö: Player(%s) Item(%s) %d %d %d - %d %d %d", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue1,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue2,
								m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sTouchEffectValue3,
								m_pClientList[iClientH]->m_sCharIDnum1,
								m_pClientList[iClientH]->m_sCharIDnum2,
								m_pClientList[iClientH]->m_sCharIDnum3); 
							PutLogList(cTxt);
							//PutLogFileList(cTxt);
						}
				}

				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41 ¾ÆÀÌÅÛÀÌ Custom-Made¶ó¸é ¼³Á¤Ä¡¸¦ ÀçÁ¶Á¤ÇÑ´Ù. 
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute & 0x00000001 ) != NULL) {
					// ÃÖ´ë ¼ö¸íÀÌ ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue1;
					// ¹«±â³ª ¹æ¾î±¸ÀÇ °æ¿ì °¡ÁßÄ¡ ItemSpecialEffectValue2
				}

				// v1.42 Èñ±Í ¾ÆÀÌÅÛ ÇÃ·¡±×°¡ ¼³Á¤µÇ¾î ÀÖ´Ù¸é ÃÖ´ë ¼ö¸í, ½ºÇÇµå, ¹«°Ô µîÀ» Àç¼³Á¤ ÇØ¾ß ÇÑ´Ù. 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemList[iItemIndex]);

				// v1.41 ÇöÀç ¼ö¸í ÃÖ´ë ¼ö¸íÀ» ´É°¡ÇÏ¸é ¹ö±×ÀÌ¹Ç·Î µÇµ¹¸°´Ù.
				if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan;

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// ·Î±× ³²±ä´Ù. 
						wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// ¼ö¸í 1·Î È¯¿ø 
						m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan = 1;
					}

					// v1.4 ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀÌ ÇöÀç »ç¿ëÀÌ ÀÎÁ¤µÈ ¾ÆÀÌÅÛÀÎ°¡¸¦ Ã£´Â´Ù. 
					if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
						m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;

						// v1.41
						bIsNotUsedItemFound = TRUE;
					}
					else
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemList[iItemIndex]) == TRUE) {
							// v1.42 º¹Á¦µÈ ¾ÆÀÌÅÛµéÀ» »èÁ¦ÇÑ´Ù.
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[iItemIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemList[iItemIndex];
							m_pClientList[iClientH]->m_pItemList[iItemIndex] = NULL;
						}
						else iItemIndex++;
						break;
				}
				break;

			case 6:
				// Ä³¸¯ÅÍÀÇ ¼ºº° 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSex = atoi(token);
				cReadModeA = 0;
				break;

			case 7:
				// Ä³¸¯ÅÍÀÇ ÇÇºÎ»ö 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkin = atoi(token);
				cReadModeA = 0;
				break;

			case 8:
				// Ä³¸¯ÅÍÀÇ Çì¾î ½ºÅ¸ÀÏ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairStyle = atoi(token);
				cReadModeA = 0;
				break;

			case 9:
				// Ä³¸¯ÅÍÀÇ ¸Ó¸®»ö 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cHairColor = atoi(token);
				cReadModeA = 0;
				break;

			case 10:
				// Ä³¸¯ÅÍÀÇ ¼Ó¿Ê»ö
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cUnderwear = atoi(token);
				cReadModeA = 0;
				break;

			case 11:
				// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ°¡ ¹Ýµå½Ã ¸¶Áö¸·ÀÌ¾î¾ß ÇÑ´Ù!!!!!

				// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ ÃÊ±âÈ­ÇÑ ÈÄ ¼³Á¤ÇÑ´Ù.
				for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++) 
					m_pClientList[iClientH]->m_sItemEquipmentStatus[i] = -1;

				// ¾ÆÀÌÅÛ ÀåÂø»óÅÂ¸¦ ÃÊ±âÈ­ÇÑ´Ù.
				for (i = 0; i < DEF_MAXITEMS; i++) 
					m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

				// v1.41 »ç¿ëÇÏÁö ¾Ê´Â ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÏ°í ÀÖ¾ú´Ù¸é ÀåÂø»óÅÂ¸¦ ¸ðµÎ ¹«½Ã. 
				if (bIsNotUsedItemFound == FALSE) {
					for (i = 0; i < DEF_MAXITEMS; i++) {
						wsprintf(cTxt, "%d", token[i]);
						if ((token[i] == '1') && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
							// ÀåÂøµÉ ¼ö ÀÖ´Â ¼ºÁúÀÇ ¾ÆÀÌÅÛÀÌ¶ó¸é ÀåÂø 
							if (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP) 
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = TRUE;
							else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
						}
						else m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;

						if ((m_pClientList[iClientH] != NULL) && (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE)) {
							// ¾ÆÀÌÅÛÀÌ ÀåÂøµÇ¾î ÀÖ´Ù¸é ÀåÂø È¿°ú¸¦ °è»êÇÑ´Ù.
							if (bEquipItemHandler(iClientH, i) == FALSE) // FALSE
								m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE; // ¸¸¾à Æ¯¼ºÄ¡ º¯µ¿À¸·Î ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ ÀåÂøµÇÁö ¾Ê¾Æ¾ß ÇÑ´Ù¸é ÀåÂø ¾ÈÇÑ°ÍÀ» Ç¥½Ã 
						}
					}
				}

				cReadModeA = 0;
				break;

			case 12:
				// ¼Ò¼Ó ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù.
				// ±æµå ÀÌ¸§Àº ÃÖ´ë 20ÀÚ 
				ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
				strcpy(m_pClientList[iClientH]->m_cGuildName, token);
				cReadModeA = 0;
				break;

			case 13:
				// ±æµå ·©Å© 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildRank = atoi(token);
				cReadModeA = 0;
				break;

			case 14:
				// HP 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHP = atoi(token);
				cReadModeA = 0;
				break;

			case 15:
				// DefenseRatio »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«ÀÇ¹ÌÇØ Áü 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginDefenseRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurDefenseRatio = m_pClientList[iClientH]->m_iOriginDefenseRatio;
				cReadModeA = 0;
				break;

			case 16:
				// HitRatio  »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«ÀÇ¹ÌÇØ Áü 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				//m_pClientList[iClientH]->m_iOriginHitRatio = atoi(token);
				//m_pClientList[iClientH]->m_iCurHitRatio = m_pClientList[iClientH]->m_iOriginHitRatio;
				cReadModeA = 0;
				break;

			case 17:
				// Level  
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 18:
				// Str 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iStr = atoi(token);
				cReadModeA = 0;
				break;

			case 19:
				// Int 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iInt = atoi(token);
				cReadModeA = 0;
				break;

			case 20:
				// Vit 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iVit = atoi(token);
				cReadModeA = 0;
				break;

			case 21:
				// Dex 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDex = atoi(token);
				cReadModeA = 0;
				break;

			case 22:
				// Mag 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMag = atoi(token);
				cReadModeA = 0;
				break;

			case 23:
				// Charisma 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iCharisma = atoi(token);
				cReadModeA = 0;
				break;

			case 24:
				// Luck 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLuck = atoi(token);
				cReadModeA = 0;
				break;

			case 25:
				// Exp 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iExp = atoi(token);
				cReadModeA = 0;
				break;

			case 26:
				// Magic-Mastery ¼³Á¤ÇÑ´Ù. // 0ÀÌ¸é »ç¿ë ºÒ°¡. 1ÀÌ¸é ¹è¿î »óÅÂ.
				for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
					m_pClientList[iClientH]->m_cMagicMastery[i] = token[i] - 48;
				}
				cReadModeA = 0;
				break;

			case 27:
				// Skill-Mastery ¼³Á¤ÇÑ´Ù.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cSkillMastery[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;
				//
			case 28:
				// Warehouse¿¡ ¸Ã°Ü³í ¾ÆÀÌÅÛ Á¤º¸¸¦ ÀÐ¾î ÃÊ±âÈ­ ÇÑ´Ù.
				switch(cReadModeB) {
			case 1:
				// token°ªÀº ¾ÆÀÌÅÛÀÇ ÀÌ¸§. ÀÌ ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÇ Æ¯¼ºÀ» m_pItemConfigList¿¡¼­ Ã£¾Æ ÇÒ´çÇÑ´Ù.
				if (_bInitItemAttr(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], token) == FALSE) {
					// ÇÃ·¹ÀÌ¾î°¡ ÀúÀåÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Ù. ¿¡·¯
					wsprintf(cTxt, "(!!!) Client(%s)-Bank Item(%s) is not existing Item! Conection closed.", m_pClientList[iClientH]->m_cCharName, token); 
					PutLogList(cTxt);

					// Debug code @@@@@@@@@@@@@@@
					HANDLE hFile;
					DWORD  nWrite;
					hFile = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
					WriteFile(hFile, (char *)pOriginContents, dwSize+2, &nWrite, NULL);
					CloseHandle(hFile);
					///////////// @@@@@@@@@@@@@@@

					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				cReadModeB = 2;
				break;

			case 2:
				// m_dwCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				// °¹¼ö°¡ ¸¶ÀÌ³Ê½ºÀÌ¸é 1À¸·Î ¼¼ÆÃµÈ´Ù.
				iTemp = atoi(token);
				if (iTemp < 0) iTemp = 1;

				// ¸¸¾à °¡Áú ¼ö ÀÖ´Â Áß·®ÀÌ ÃÊ°úµÈ ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é 1°³·Î ÁÙÀÎ´Ù.
				if ( iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex], iTemp) > _iCalcMaxLoad(iClientH) ) {
					iTemp = 1;
					wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¾ÆÀÌÅÛ(%s) °³¼ö ¿À¹öÇÃ·Î¿ì", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName);
					PutLogFileList(G_cTxt);
					PutLogList(G_cTxt);
				}

				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwCount = (DWORD)iTemp;
				cReadModeB = 3;

				// v1.3 ¼ÒÁöÇÏ°í ÀÖ´Â °ñµåÀÇ ÃÑ ÇÕÀ» °Ë»çÇÑ´Ù. 
				if (memcmp(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cName, "Gold", 4) == 0)
					iTotalGold += iTemp;
				break;

			case 3:
				// m_sTouchEffectType
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectType = atoi(token);
				cReadModeB = 4;
				break;

			case 4:
				// m_sTouchEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue1 = atoi(token);
				cReadModeB = 5;
				break;

			case 5:
				// m_sTouchEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue2 = atoi(token);
				cReadModeB = 6;
				break;

			case 6:
				// m_sTouchEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sTouchEffectValue3 = atoi(token);
				cReadModeB = 7;
				break;

			case 7:
				// m_cItemColor
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemColor = atoi(token);
				cReadModeB = 8;
				break;

			case 8:
				// m_sItemSpecEffectValue1
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1 = atoi(token);
				cReadModeB = 9;
				break;

			case 9:
				// m_sItemSpecEffectValue2
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue2 = atoi(token);
				cReadModeB = 10;
				break;

			case 10:
				// m_sItemSpecEffectValue3
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue3 = atoi(token);
				cReadModeB = 11;
				break;

			case 11:
				// m_wCurLifeSpan
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = atoi(token);

				cReadModeB = 12;
				break;

			case 12:
				// m_dwAttribute
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;

				// v1.41 ¾ÆÀÌÅÛÀÌ Custom-Made¶ó¸é ¼³Á¤Ä¡¸¦ ÀçÁ¶Á¤ÇÑ´Ù. 
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_dwAttribute & 0x00000001) != NULL) {
					// ÃÖ´ë ¼ö¸íÀÌ ItemSpecialEffectValue1
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemSpecEffectValue1;
					// ¹«±â³ª ¹æ¾î±¸ÀÇ °æ¿ì °¡ÁßÄ¡ ItemSpecialEffectValue2

				}

				// v1.42 Èñ±Í ¾ÆÀÌÅÛ ÇÃ·¡±×°¡ ¼³Á¤µÇ¾î ÀÖ´Ù¸é ÃÖ´ë ¼ö¸í, ½ºÇÇµå, ¹«°Ô µîÀ» Àç¼³Á¤ ÇØ¾ß ÇÑ´Ù. 
				_AdjustRareItemValue(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

				// v1.41 ¼ö¸íÀÌ ÃÖ´ë¼ö¸íÀ» ÃÊ°úÇÑ´Ù¸é ¹ö±×ÀÌ¹Ç·Î µÇµ¹¸°´Ù.
				if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan > m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan)
					m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wMaxLifeSpan;

				// v1.433
				if ((m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan == 0) && 
					(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP)) {
						// ·Î±× ³²±ä´Ù. 
						wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼ö¸í 0Â¥¸® Èñ»ý¼® ¼ÒÁö!", m_pClientList[iClientH]->m_cCharName);
						PutLogFileList(G_cTxt);
						// ¼ö¸í 1·Î È¯¿ø 
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wCurLifeSpan = 1;
					}

					// v1.4 ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀÌ ÇöÀç »ç¿ëÀÌ ÀÎÁ¤µÈ ¾ÆÀÌÅÛÀÎ°¡¸¦ Ã£´Â´Ù. 
					if (m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_cItemType == DEF_ITEMTYPE_NOTUSED) {
						iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
						delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
						m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;
					}
					else 
						if (_bCheckDupItemID(m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]) == TRUE) {
							// v1.42 º¹Á¦µÈ ¾ÆÀÌÅÛµéÀ» »èÁ¦ÇÑ´Ù.
							_bItemLog(DEF_ITEMLOG_DUPITEMID, iClientH, NULL, m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]);

							iNotUsedItemPrice += m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex]->m_wPrice;
							delete m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex];
							m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = NULL;		
						}
						else iItemInBankIndex++;
						break;
				}
				break;
				//
			case 29:
				// ÇÃ·¹ÀÌ¾î ¼Ò¼ÓÀÇ ¸¶À»À» ÃÊ±âÈ­ÇÑ´Ù.
				ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
				strcpy(m_pClientList[iClientH]->m_cLocation, token);
				cReadModeA = 0;
				break;

			case 30:
				// m_iMP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iMP = atoi(token);
				cReadModeA = 0;
				break;

			case 31:
				// m_iSP
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSP = atoi(token);
				cReadModeA = 0;
				break;

			case 32:
				// m_cLU_Pool
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iLU_Pool = atoi(token);
				cReadModeA = 0;
				break;
			/*
			case 33:
				// m_cLU_Vit
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Vit = atoi(token);
				cReadModeA = 0;
				break;

			case 34:
				// m_cLU_Dex
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Dex = atoi(token);
				cReadModeA = 0;
				break;

			case 35:
				// m_cLU_Int
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Int = atoi(token);
				cReadModeA = 0;
				break;

			case 36:
				// m_cLU_Mag
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Mag = atoi(token);
				cReadModeA = 0;
				break;

			case 37:
				// m_cLU_Char
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_cLU_Char = atoi(token);
				cReadModeA = 0;
				break;
*/
			case 38:
				// m_iEnemyKillCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iEnemyKillCount = atoi(token);
				cReadModeA = 0;
				break;

			case 39:
				// m_iPKCount
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPKCount = atoi(token);
				cReadModeA = 0;
				break;

			case 40:
				// m_iRewardGold
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRewardGold = atoi(token);
				cReadModeA = 0;
				break;

			case 41:
				// Skill-SSN ¼³Á¤ÇÑ´Ù.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iSkillSSN[cReadModeB] = atoi(token);
				cReadModeB++;

				if (cReadModeB >= DEF_MAXSKILLTYPE) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 42:
				if (token != NULL) {
					ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
					strcpy(m_pClientList[iClientH]->m_cProfile, token);
				}
				cReadModeA = 0;
				break;

			case 43:
				// Hunger-Status ¼³Á¤ÇÑ´Ù.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iHungerStatus = atoi(token);
				cReadModeA = 0;
				break;

			case 44:
				// AdminUserLevel
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iAdminUserLevel = atoi(token);
				cReadModeA = 0;
				break;

			case 45:
				// TimeLeft_ShutUp
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_ShutUp = atoi(token);
				cReadModeA = 0;
				break;

			case 46:
				// TimeLeft_Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iTimeLeft_Rating = atoi(token);
				cReadModeA = 0;
				break;

			case 47:
				// Rating
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iRating = atoi(token);
				cReadModeA = 0;
				break;

			case 48:
				// Guild GUID: ÀÌÀü¿¡ »ý¼ºµÇ¾ú´ø ±æµåµéÀº ¸ðµÎ -1ÀÌ µÇ ¹ö¸± °ÍÀÌ´Ù.
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iGuildGUID = atoi(token);
				cReadModeA = 0;
				break;

			case 49:
				// Down Skill Index
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iDownSkillIndex = atoi(token);
				cReadModeA = 0;
				break;

			case 50:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].x = atoi(token);
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 51:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = atoi(token);
				// v1.3 Àß¸øµÈ À§Ä¡°ªÀ» º¸Á¤ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y < -10) m_pClientList[iClientH]->m_ItemPosList[cReadModeB-1].y = -10;
				cReadModeB++;
				if (cReadModeB > 50) {
					cReadModeA = 0;
					cReadModeB = 0;
				}
				break;

			case 52:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum1 = atoi(token);
				cReadModeA = 0;
				break;

			case 53:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum2 = atoi(token);
				cReadModeA = 0;
				break;

			case 54:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_sCharIDnum3 = atoi(token);
				cReadModeA = 0;
				break;

			case 55:
				switch (cReadModeB) {
			case 1:
				// Penalty Block Year
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockYear = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// Penalty Block Month
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockMonth = atoi(token);

				cReadModeB = 3;
				break;

			case 3:
				// Penalty Block day
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iPenaltyBlockDay = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;
				}
				break;

			case 56:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuest = atoi(token);
				cReadModeA = 0;
				break;

			case 57:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCurQuestCount = atoi(token);
				cReadModeA = 0;
				break;

			case 58:
				cReadModeA = 0;
				break;

			case 59:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardType = atoi(token);
				cReadModeA = 0;
				break;

			case 60:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestRewardAmount = atoi(token);
				cReadModeA = 0;
				break;

			case 61:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 62:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iQuestID = atoi(token);
				cReadModeA = 0;
				break;

			case 63:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_bIsQuestCompleted = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 64:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 65:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 66:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialEventID = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

				// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à¿¡ °ü°èµÈ ÆÄÀÏ ³»¿ë ÀÐ±â 
			case 67:
				switch (cReadModeB) {
			case 1:
				// FightZone Number
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightzoneNumber = atoi(token);

				cReadModeB = 2;
				break;

			case 2:
				// ¿¹¾àÇÑ ½Ã°£ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iReserveTime = atoi(token);


				cReadModeB = 3;
				break;
			case 3:
				// ³²Àº Æ¼ÄÏ¼ýÀÚ 
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pClientList[iClientH]->m_iFightZoneTicketNumber = atoi(token);

				cReadModeA = 0;
				cReadModeB = 0;
				break;

				}
				break;

			case 70:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSuperAttackLeft = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 71:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iSpecialAbilityTime = atoi(token);
				cReadModeA = 0;
				break;

			case 72:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iWarContribution = atoi(token);
				cReadModeA = 0;
				break;

			case 73:
				if (strlen(token) > 10) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				ZeroMemory(m_pClientList[iClientH]->m_cLockedMapName, sizeof(m_pClientList[iClientH]->m_cLockedMapName));
				strcpy(m_pClientList[iClientH]->m_cLockedMapName, token);
				cReadModeA = 0;
				break;

			case 74:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iLockedMapTime = atoi(token);
				cReadModeA = 0;
				break;

			case 75:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iCrusadeDuty = atoi(token);
				cReadModeA = 0;
				break;

			case 76:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_iConstructionPoint = atoi(token);
				cReadModeA = 0;
				break;

			case 77:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					wsprintf(cTxt, "(!!!) Player(%s) data file error! wrong Data format - Connection closed. ", m_pClientList[iClientH]->m_cCharName); 
					PutLogList(cTxt);
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pClientList[iClientH]->m_dwCrusadeGUID = atoi(token);
				cReadModeA = 0;
				break;
			}
		}
		else {
			if (memcmp(token, "character-loc-map", 17) == 0)		 cReadModeA = 1;
			if (memcmp(token, "character-loc-x", 15) == 0)			 cReadModeA = 2;
			if (memcmp(token, "character-loc-y", 15) == 0)			 cReadModeA = 3;
			if (memcmp(token, "character-account-status", 21) == 0)  cReadModeA = 4;
			if (memcmp(token, "character-item", 14) == 0) {
				cReadModeA = 5;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemList[iItemIndex] = new class CItem;
			}

			if (memcmp(token, "character-bank-item", 18) == 0) {
				cReadModeA = 28;
				cReadModeB = 1;
				m_pClientList[iClientH]->m_pItemInBankList[iItemInBankIndex] = new class CItem;
			}

			if (memcmp(token, "sex-status", 10) == 0)        cReadModeA = 6;
			if (memcmp(token, "skin-status", 11) == 0)       cReadModeA = 7;
			if (memcmp(token, "hairstyle-status", 16) == 0)  cReadModeA = 8;
			if (memcmp(token, "haircolor-status", 16) == 0)  cReadModeA = 9;
			if (memcmp(token, "underwear-status", 16) == 0)  cReadModeA = 10;

			if (memcmp(token, "item-equip-status", 17) == 0)    cReadModeA = 11;
			if (memcmp(token, "character-guild-name", 20) == 0) cReadModeA = 12;
			if (memcmp(token, "character-guild-rank", 20) == 0) cReadModeA = 13;
			if (memcmp(token, "character-HP", 12) == 0)         cReadModeA = 14;
			if (memcmp(token, "character-DefenseRatio",22)==0)  cReadModeA = 15;
			if (memcmp(token, "character-HitRatio", 18) == 0)   cReadModeA = 16;
			if (memcmp(token, "character-LEVEL", 15) == 0)      cReadModeA = 17;
			if (memcmp(token, "character-STR", 13) == 0)        cReadModeA = 18;
			if (memcmp(token, "character-INT", 13) == 0)        cReadModeA = 19;
			if (memcmp(token, "character-VIT", 13) == 0)        cReadModeA = 20;
			if (memcmp(token, "character-DEX", 13) == 0)        cReadModeA = 21;
			if (memcmp(token, "character-MAG", 13) == 0)        cReadModeA = 22;
			if (memcmp(token, "character-CHARISMA", 18) == 0)   cReadModeA = 23;
			if (memcmp(token, "character-LUCK", 14) == 0)       cReadModeA = 24;
			if (memcmp(token, "character-EXP", 13) == 0)        cReadModeA = 25;
			if (memcmp(token, "magic-mastery", 13) == 0)        cReadModeA = 26;

			if (memcmp(token, "skill-mastery", 13) == 0) {
				cReadModeA = 27;
				cReadModeB = 0;
			}

			if (memcmp(token, "character-location", 18) == 0)   cReadModeA = 29;

			if (memcmp(token, "character-MP", 12) == 0)         cReadModeA = 30;
			if (memcmp(token, "character-SP", 12) == 0)         cReadModeA = 31;

			if (memcmp(token, "character-LU_Pool", 17) == 0)     cReadModeA = 32;

			/*
			if (memcmp(token, "character-LU_Str", 16) == 0)     cReadModeA = 32;
			if (memcmp(token, "character-LU_Vit", 16) == 0)     cReadModeA = 33;
			if (memcmp(token, "character-LU_Dex", 16) == 0)     cReadModeA = 34;
			if (memcmp(token, "character-LU_Int", 16) == 0)     cReadModeA = 35;
			if (memcmp(token, "character-LU_Mag", 16) == 0)     cReadModeA = 36;
			if (memcmp(token, "character-LU_Char",17) == 0)     cReadModeA = 37;
			*/

			if (memcmp(token, "character-EK-Count",18) == 0)    cReadModeA = 38;
			if (memcmp(token, "character-PK-Count",18) == 0)    cReadModeA = 39;

			if (memcmp(token, "character-reward-gold",21) == 0) cReadModeA = 40;
			if (memcmp(token, "skill-SSN", 9) == 0) 			cReadModeA = 41;
			if (memcmp(token, "character-profile", 17) == 0)	cReadModeA = 42;

			if (memcmp(token, "hunger-status", 13) == 0) 		cReadModeA = 43;
			if (memcmp(token, "admin-user-level", 16) == 0) 	cReadModeA = 44;
			if (memcmp(token, "timeleft-shutup", 15) == 0) 		cReadModeA = 45;
			if (memcmp(token, "timeleft-rating", 15) == 0) 		cReadModeA = 46;
			if (memcmp(token, "character-RATING", 16) == 0)	    cReadModeA = 47;

			if (memcmp(token, "character-guild-GUID", 20) == 0) cReadModeA = 48;

			if (memcmp(token, "character-downskillindex", 24) == 0) cReadModeA = 49;
			if (memcmp(token, "item-position-x", 16) == 0) {
				cReadModeA = 50;
				cReadModeB = 1;
			}
			if (memcmp(token, "item-position-y", 16) == 0) {
				cReadModeA = 51;
				cReadModeB = 1;
			}
			if (memcmp(token, "character-IDnum1",16) == 0)		cReadModeA = 52;
			if (memcmp(token, "character-IDnum2",16) == 0)		cReadModeA = 53;
			if (memcmp(token, "character-IDnum3",16) == 0)		cReadModeA = 54;
			if (memcmp(token, "penalty-block-date",18) == 0) {
				cReadModeA = 55;
				cReadModeB = 1;
			}

			if (memcmp(token, "character-quest-number",22) == 0) cReadModeA = 56;
			if (memcmp(token, "current-quest-count",19) == 0)	 cReadModeA = 57;

			if (memcmp(token, "quest-reward-type", 17) == 0)    cReadModeA = 59;
			if (memcmp(token, "quest-reward-amount", 19) == 0)  cReadModeA = 60;

			if (memcmp(token, "character-contribution", 22) == 0)   cReadModeA = 61;
			if (memcmp(token, "character-quest-ID",18) == 0)        cReadModeA = 62;
			if (memcmp(token, "character-quest-completed",25) == 0) cReadModeA = 63;

			if (memcmp(token, "timeleft-force-recall", 21) == 0)	cReadModeA = 64;
			if (memcmp(token, "timeleft-firm-staminar", 22) == 0)	cReadModeA = 65;
			if (memcmp(token, "special-event-id", 16) == 0)			cReadModeA = 66;
			if (memcmp(token, "super-attack-left", 17) == 0)		cReadModeA = 70;

			// v1.4311-3 Ãß°¡ ¿ùµå ¼­¹ö·Î ºÎÅÍ¿Â ¸Þ¼¼Áö·ÎºÎÅÍ ¿¹¾àµÈ »çÅõÀå¿¡ °üÇÑ °ª ÀÐ±â reserved-fightzone-id
			if (memcmp(token, "reserved-fightzone-id", 21) == 0)	{
				cReadModeA = 67;
				cReadModeB = 1;
			}

			if (memcmp(token, "special-ability-time", 20) == 0)       cReadModeA = 71; 
			if (memcmp(token, "character-war-contribution", 26) == 0) cReadModeA = 72; 

			if (memcmp(token, "locked-map-name", 15) == 0) cReadModeA = 73;
			if (memcmp(token, "locked-map-time", 15) == 0) cReadModeA = 74;
			if (memcmp(token, "crusade-job", 11) == 0)     cReadModeA = 75;
			if (memcmp(token, "construct-point", 15) == 0) cReadModeA = 76;
			if (memcmp(token, "crusade-GUID", 12) == 0)    cReadModeA = 77;

			if (memcmp(token, "[EOF]", 5) == 0) goto DPDC_STOP_DECODING;
		}

		token = pStrTok->pGet();
		//token = strtok( NULL, seps );							    
	}													  

DPDC_STOP_DECODING:;	

	delete pStrTok;
	delete pContents;
	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		wsprintf(cTxt, "(!!!) Player(%s) data file contents error(%d %d)! Connection closed.", m_pClientList[iClientH]->m_cCharName, cReadModeA, cReadModeB);
		PutLogList(cTxt);

		// Debug code @@@@@@@@@@@@@@@
		HANDLE hFile2;
		DWORD  nWrite2;
		hFile2 = CreateFile("Error.Log", GENERIC_WRITE, NULL, NULL, CREATE_ALWAYS, NULL, NULL);
		WriteFile(hFile2, (char *)pOriginContents, dwSize+2, &nWrite2, NULL);
		CloseHandle(hFile2);
		///////////// @@@@@@@@@@@@@@@

		return FALSE;
	}

	// ÀÐÇôÁø ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ¸¦ °Ë»çÇØ¼­ ¿À·ù°¡ ¾ø´ÂÁö¸¦ È®ÀÎÇÏ¿© ¸®ÅÏ°ªÀ» °áÁ¤ÇÑ´Ù.
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bIsValidLoc(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	if (bRet == FALSE) {
		if ((m_pClientList[iClientH]->m_sX != -1) || (m_pClientList[iClientH]->m_sY != -1)) {
			wsprintf(cTxt, "Invalid location error! %s (%d, %d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY); 
			PutLogList(cTxt);
			return FALSE;
		}
	}

	// Æ¯¼ºÄ¡ °ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»ç ==========================================================================
	/*	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
	return FALSE;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
	return FALSE;
	*/
	//	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	//  		  m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) 
	if ((m_pClientList[iClientH]->m_iLU_Pool < 0) || (m_pClientList[iClientH]->m_iLU_Pool > DEF_CHARPOINTLIMIT))
		return FALSE;	

	if ((m_pClientList[iClientH]->m_iStr < 10) || (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iDex < 10) || (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iVit < 10) || (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iInt < 10) || (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iMag < 10) || (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT))
		return FALSE;

	if ((m_pClientList[iClientH]->m_iCharisma < 10) || (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT))
		return FALSE;

	//Æ¯¼ºÄ¡ÀÇ ÃÑ ÇÕÀÌ ¸ÂÁö ¾Ê´Ù¸é ¿ª½Ã Á¢¼Ó ºÒ°¡. 
	//	if ((m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
	//		 m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma) 
	//		 !=	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) return FALSE;


	// Ã¼ÇèÆÇ »ç¿ëÀÚÀÇ µ¥ÀÌÅÍÀÎµ¥ Á¦ÇÑ ·¹º§ ÀÌ»óÀÌ´Ù. Á¢¼ÓÀÌ ºÒ°¡´É. v1.43ºÎÅÍ »ç¿ëÇÏÁö ¾Ê´Â´Ù.
	//if ((m_pClientList[iClientH]->m_cAccountStatus != 2) && (m_pClientList[iClientH]->m_iLevel > DEF_LEVELLIMIT)) 
	//	return FALSE;

	// v1.4 °èÁ¤ÀÌ¸§ÀÌ³ª Ä³¸¯ÅÍ ÀÌ¸§¿¡ Àß¸øµÈ ÄÚµå°¡ µé¾î°¡ ÀÖ´Ù¸é Á¢¼Ó ºÒ°¡.
	if ((m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cCharName) == FALSE) || (m_Misc.bCheckValidName(m_pClientList[iClientH]->m_cAccountName) == FALSE)) 
		return FALSE;

	// v1.4 Â¡°è ¸ÔÀº Ä³¸¯ÅÍÀÇ Â¡°è±â°£ ¾ÈÀÌ¸é Á¢¼Ó ºÒ°¡
	if (m_pClientList[iClientH]->m_iPenaltyBlockYear != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)(m_pClientList[iClientH]->m_iPenaltyBlockYear*10000 + m_pClientList[iClientH]->m_iPenaltyBlockMonth*100 + m_pClientList[iClientH]->m_iPenaltyBlockDay);
		iDateSum2 = (__int64)(SysTime.wYear*10000 + SysTime.wMonth*100 + SysTime.wDay);
		if (iDateSum1 >= iDateSum2) return FALSE;
	}

	// v1.4311-3 Ãß°¡ À¯È¿ÇÏÁö ¾ÊÀº »çÅõÀå ¿¹¾àÀ» °¡Áö°í ÀÖÀ¸¸é ÃÊ±âÈ­ 
	if (m_pClientList[iClientH]->m_iReserveTime != 0) {
		GetLocalTime(&SysTime);
		iDateSum1 = (__int64)m_pClientList[iClientH]->m_iReserveTime;
		iDateSum2 = (__int64)(SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour);
		if (iDateSum2 >= iDateSum1) {
			// ¿¹¾àÀÌ Ãë¼ÒµÊ 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_iFightzoneNumber = 0; 
			m_pClientList[iClientH]->m_iReserveTime = 0;
			m_pClientList[iClientH]->m_iFightZoneTicketNumber = 0;
		}
	}

	// v1.42 Àß¸ø ÀÔ·ÂµÈ ¿î¿µÀÚ ·¹º§ °ªÀ» Å¬¸®¾î 
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 0) m_pClientList[iClientH]->m_iAdminUserLevel = 0;

	// ============================================================================================================


	// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
	if (m_pClientList[iClientH]->m_cSex == 1) {
		// ³²ÀÚÀÌ´Ù. 
		sTmpType = 1;
	}
	else if (m_pClientList[iClientH]->m_cSex == 2) {
		// ¿©ÀÚÀÌ´Ù.
		sTmpType = 4; 
	}

	switch (m_pClientList[iClientH]->m_cSkin) {
	case 1:
		// ¹éÀÎÀÌ¸é ±×´ë·Î.
		break;
	case 2:
		sTmpType += 1;
		break;
	case 3:
		sTmpType += 2;
		break;
	}

	// v1.41 ¿î¿µÀÚ ¾ÏÇà¿ë 
	if (m_pClientList[iClientH]->m_iAdminUserLevel >= 10) 
		sTmpType = m_pClientList[iClientH]->m_iAdminUserLevel;

	sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);

	m_pClientList[iClientH]->m_sType  = sTmpType;
	m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1;

	// ¼ÒÁöÇ° ÃÑ Áß·®°è»ê 
	iCalcTotalWeight(iClientH);

	// v1.3 Áö³ªÄ¡°Ô ¸¹Àº µ·À» ¼ÒÁöÇÑ Ä³¸¯ÅÍ ÀÌ¸§À» Àû´Â´Ù. 
	//if (iTotalGold > 800000) {
	//	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Gold(%d)", m_pClientList[iClientH]->m_cCharName, iTotalGold);
	//PutLogFileList(G_cTxt);
	//}

	// v.135 
	/*
	if ((m_pClientList[iClientH]->m_cSkillMastery[0] >= 70) || (m_pClientList[iClientH]->m_cSkillMastery[1] >= 70) ||
	(m_pClientList[iClientH]->m_cSkillMastery[12] >= 70)) {
	wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) ³ôÀº ½ºÅ³ (%d %d %d)", m_pClientList[iClientH]->m_cCharName, 
	m_pClientList[iClientH]->m_cSkillMastery[0], m_pClientList[iClientH]->m_cSkillMastery[1],
	m_pClientList[iClientH]->m_cSkillMastery[12]);
	PutLogFileList(G_cTxt);
	}
	*/

	if (m_pClientList[iClientH]->m_sCharIDnum1 == 0) {
		// v1.3 ÀÌ Ä³¸¯ÅÍÀÇ ID ¹øÈ£°¡ ºÎ¿©µÇÁö ¾ÊÀº »óÅÂÀÌ´Ù. ÇÒ´çÇÑ´Ù. 
		int _i, _iTemp1, _iTemp2;
		short _sID1, _sID2, _sID3;

		_iTemp1 = 1;
		_iTemp2 = 1;
		for (_i = 0; _i < 10; _i++) {
			_iTemp1 += m_pClientList[iClientH]->m_cCharName[_i];
			_iTemp2 += abs(m_pClientList[iClientH]->m_cCharName[_i] ^ m_pClientList[iClientH]->m_cCharName[_i]);
		}

		_sID1 = (short)timeGetTime(); 
		_sID2 = (short)_iTemp1; 
		_sID3 = (short)_iTemp2; 

		m_pClientList[iClientH]->m_sCharIDnum1 = _sID1;
		m_pClientList[iClientH]->m_sCharIDnum2 = _sID2;
		m_pClientList[iClientH]->m_sCharIDnum3 = _sID3;
	}

	// v1.4 ¾ø¾îÁø ¾ÆÀÌÅÛ¿¡ ´ëÇÑ º¸»ó±ÝÀ» Áö±Þ. 
	m_pClientList[iClientH]->m_iRewardGold += iNotUsedItemPrice;

	// 
	m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;

	// v1.41 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) m_pClientList[iClientH]->m_bIsNeutral = TRUE;

	return TRUE;
}

int CGame::_iComposePlayerDataFileContents(int iClientH, char * pData)
{
 SYSTEMTIME SysTime;
 char  cTxt[120], cTmp[21];
 POINT TempItemPosList[DEF_MAXITEMS];
 int   i, iPos;

	if (m_pClientList[iClientH] == NULL) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n");
		
	// ÀÌ¸§ ÀúÀå
	strcat(pData, "[NAME-ACCOUNT]\n\n");
	strcat(pData, "character-name     = ");
	strcat(pData, m_pClientList[iClientH]->m_cCharName);
	strcat(pData, "\n");
	strcat(pData, "account-name       = ");
	strcat(pData, m_pClientList[iClientH]->m_cAccountName);
	strcat(pData, "\n\n");

	strcat(pData, "[STATUS]\n\n");
	// Ä³¸¯ÅÍ ÇÁ·ÎÇÊ 
	strcat(pData, "character-profile 	=");
	if (strlen(m_pClientList[iClientH]->m_cProfile) == 0) {
		// Ä³¸¯ÅÍ ÇÁ·ÎÇÊÀÌ ¼³Á¤µÇÁö ¾Ê¾Ò´Ù¸é 
		strcat(pData, "__________");
	}
	else strcat(pData, m_pClientList[iClientH]->m_cProfile);
	strcat(pData, "\n");

	// ÇÃ·¹ÀÌ¾î ¼Ò¼Ó À§Ä¡
	strcat(pData, "character-location   = ");
	strcat(pData, m_pClientList[iClientH]->m_cLocation);
	strcat(pData, "\n");
	/// ±æµå »óÅÂ 
	strcat(pData, "character-guild-name = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank°¡ -1ÀÌ¸é ±æµåÀÌ¸§Àº ¹«ÀÇ¹ÌÇÏ´Ù.
		strcat(pData, m_pClientList[iClientH]->m_cGuildName);
	}
	else strcat(pData, "NONE");
	strcat(pData, "\n");
	
	// ±æµå GUID 
	strcat(pData, "character-guild-GUID = ");
	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// GuildRank°¡ -1ÀÌ¸é ±æµåGUID´Â ¹«ÀÇ¹ÌÇÏ´Ù.
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d", m_pClientList[iClientH]->m_iGuildGUID);
		strcat(pData, cTxt);
	}
	else strcat(pData, "-1");
	strcat(pData, "\n");
		
	// ±æµå ¼øÀ§
	strcat(pData, "character-guild-rank = ");
	itoa( m_pClientList[iClientH]->m_iGuildRank, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	strcat(pData, "character-loc-map = ");
	strcat(pData, m_pClientList[iClientH]->m_cMapName);
	strcat(pData, "\n");
	// XÁÂÇ¥ ÀúÀå 
	strcat(pData, "character-loc-x   = ");
	itoa( m_pClientList[iClientH]->m_sX, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// YÁÂÇ¥ ÀúÀå 
	strcat(pData, "character-loc-y   = ");
	itoa( m_pClientList[iClientH]->m_sY, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	//
	if (m_pClientList[iClientH]->m_iHP <= 0)  
		m_pClientList[iClientH]->m_iHP = 30;

	wsprintf(cTxt, "character-HP       = %d", m_pClientList[iClientH]->m_iHP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MP       = %d",  m_pClientList[iClientH]->m_iMP);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	if (m_pClientList[iClientH]->m_iSP < 0) m_pClientList[iClientH]->m_iSP = 0; // v1.1
	wsprintf(cTxt, "character-SP       = %d",  m_pClientList[iClientH]->m_iSP);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-LEVEL    = %d", m_pClientList[iClientH]->m_iLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-RATING   = %d", m_pClientList[iClientH]->m_iRating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-STR      = %d", m_pClientList[iClientH]->m_iStr);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-INT      = %d", m_pClientList[iClientH]->m_iInt);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-VIT      = %d", m_pClientList[iClientH]->m_iVit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-DEX      = %d", m_pClientList[iClientH]->m_iDex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-MAG      = %d", m_pClientList[iClientH]->m_iMag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-CHARISMA = %d", m_pClientList[iClientH]->m_iCharisma);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LUCK     = %d", m_pClientList[iClientH]->m_iLuck);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-EXP      = %d", m_pClientList[iClientH]->m_iExp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Pool  = %d", m_pClientList[iClientH]->m_iLU_Pool);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*	
	wsprintf(cTxt, "character-LU_Str   = %d", m_pClientList[iClientH]->m_cLU_Str);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Vit   = %d", m_pClientList[iClientH]->m_cLU_Vit);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Dex   = %d", m_pClientList[iClientH]->m_cLU_Dex);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Int   = %d", m_pClientList[iClientH]->m_cLU_Int);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Mag   = %d", m_pClientList[iClientH]->m_cLU_Mag);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-LU_Char  = %d", m_pClientList[iClientH]->m_cLU_Char);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	*/
	wsprintf(cTxt, "character-EK-Count = %d", m_pClientList[iClientH]->m_iEnemyKillCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-PK-Count = %d", m_pClientList[iClientH]->m_iPKCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-reward-gold = %d", m_pClientList[iClientH]->m_iRewardGold);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-downskillindex = %d", m_pClientList[iClientH]->m_iDownSkillIndex);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "character-IDnum1 = %d", m_pClientList[iClientH]->m_sCharIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum2 = %d", m_pClientList[iClientH]->m_sCharIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-IDnum3 = %d", m_pClientList[iClientH]->m_sCharIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	/*
	wsprintf(cTxt, "party-rank = %d", m_pClientList[iClientH]->m_iPartyRank);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum1 = %d", m_pClientList[iClientH]->m_sPartyIDnum1);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum2 = %d", m_pClientList[iClientH]->m_sPartyIDnum2);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "party-IDnum3 = %d", m_pClientList[iClientH]->m_sPartyIDnum3);
	strcat(pData, cTxt);
	strcat(pData,"\n\n");
	*/

	//
	// ÇÃ·¹ÀÌ¾î Æ¯¼ºÄ¡ ÀÔ·Â 
	strcat(pData, "sex-status       = ");
	itoa( m_pClientList[iClientH]->m_cSex, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "skin-status      = ");
	itoa( m_pClientList[iClientH]->m_cSkin, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "hairstyle-status = ");
	itoa( m_pClientList[iClientH]->m_cHairStyle, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "haircolor-status = ");
	itoa( m_pClientList[iClientH]->m_cHairColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "underwear-status = ");
	itoa( m_pClientList[iClientH]->m_cUnderwear, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");

	wsprintf(cTxt, "hunger-status    = %d", m_pClientList[iClientH]->m_iHungerStatus);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-shutup  = %d", m_pClientList[iClientH]->m_iTimeLeft_ShutUp);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-rating  = %d", m_pClientList[iClientH]->m_iTimeLeft_Rating);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-force-recall  = %d", m_pClientList[iClientH]->m_iTimeLeft_ForceRecall);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "timeleft-firm-staminar = %d", m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "admin-user-level = %d", m_pClientList[iClientH]->m_iAdminUserLevel);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "penalty-block-date = %d %d %d", m_pClientList[iClientH]->m_iPenaltyBlockYear, m_pClientList[iClientH]->m_iPenaltyBlockMonth, m_pClientList[iClientH]->m_iPenaltyBlockDay);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-number = %d", m_pClientList[iClientH]->m_iQuest);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-ID     = %d", m_pClientList[iClientH]->m_iQuestID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "current-quest-count    = %d", m_pClientList[iClientH]->m_iCurQuestCount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-type      = %d", m_pClientList[iClientH]->m_iQuestRewardType);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "quest-reward-amount    = %d", m_pClientList[iClientH]->m_iQuestRewardAmount);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-contribution = %d", m_pClientList[iClientH]->m_iContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-war-contribution = %d", m_pClientList[iClientH]->m_iWarContribution);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "character-quest-completed = %d", (int)m_pClientList[iClientH]->m_bIsQuestCompleted);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "special-event-id = %d", (int)m_pClientList[iClientH]->m_iSpecialEventID);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	wsprintf(cTxt, "super-attack-left = %d", (int)m_pClientList[iClientH]->m_iSuperAttackLeft);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// v1.4311-3 Ãß°¡ ¿ùµå¼­¹ö¿¡ »çÅõÀå °ü·Ã º¯¼ö¸¦ º¸³½´Ù.
	// »çÅõÀå ¿¹¾à °ü·ÃµÈ ³»¿ë ÀúÀå reserved-fightzone-id ¿¹¾àµÈ »çÅõÀå¹øÈ£/³¯Â¥¹×½Ã°£/³²ÀºÆ¼ÄÏ°¹¼ö
	wsprintf(cTxt, "reserved-fightzone-id = %d %d %d", m_pClientList[iClientH]->m_iFightzoneNumber, m_pClientList[iClientH]->m_iReserveTime,m_pClientList[iClientH]->m_iFightZoneTicketNumber  );
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Æ¯¼ö ´É·Â ¹ßÈÖ¿ë ³²Àº ½Ã°£
	wsprintf(cTxt, "special-ability-time = %d", m_pClientList[iClientH]->m_iSpecialAbilityTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Àá±ä ¸Ê ÀÌ¸§
	wsprintf(cTxt, "locked-map-name = %s", m_pClientList[iClientH]->m_cLockedMapName);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Àá±ä ¸Ê ½Ã°£
	wsprintf(cTxt, "locked-map-time = %d", m_pClientList[iClientH]->m_iLockedMapTime);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Å©·ç¼¼ÀÌµå¿¡¼­ ¸ÃÀº Á÷Ã¥.
	wsprintf(cTxt, "crusade-job = %d", m_pClientList[iClientH]->m_iCrusadeDuty);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	// Å©·ç¼¼ÀÌµå °íÀ¯ ¾ÆÀÌµð 
	wsprintf(cTxt, "crusade-GUID = %d", m_pClientList[iClientH]->m_dwCrusadeGUID);
	strcat(pData, cTxt);
	strcat(pData,"\n");
	
	wsprintf(cTxt, "construct-point = %d", m_pClientList[iClientH]->m_iConstructionPoint);
	strcat(pData, cTxt);
	strcat(pData,"\n");

	strcat(pData,"\n\n");

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÇ¥Çö Appr4°³¸¦ ÀúÀåÇÑ´Ù. ÀÌ°ÍÀº °ÔÀÓ¼­¹ö¿¡¼­´Â »ç¿ëÇÏÁö ¾ÊÀ¸¸ç ·Î±×¼­¹ö->Å¬¶óÀÌ¾ðÆ®°£¿¡ »ç¿ëµÈ´Ù.
	strcat(pData, "appr1 = ");
	itoa( m_pClientList[iClientH]->m_sAppr1, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr2 = ");
	// ÀüÅõ¸ðµå ÇÃ·¡±×¸¦ Å¬¸®¾îÇÑ´Ù.
	//m_pClientList[iClientH]->m_sAppr2 = m_pClientList[iClientH]->m_sAppr2 & 0x0FFF;
	itoa( m_pClientList[iClientH]->m_sAppr2, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr3 = ");
	itoa( m_pClientList[iClientH]->m_sAppr3, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	strcat(pData, "appr4 = ");
	itoa( m_pClientList[iClientH]->m_sAppr4, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n");
	// v1.4 ApprColor
	strcat(pData, "appr-color = ");
	itoa( m_pClientList[iClientH]->m_iApprColor, cTxt, 10);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");

	// ¾ÆÀÌÅÛ Á¤º¸ ÀúÀå 
	strcat(pData, "[ITEMLIST]\n\n");

	for (i = 0; i < DEF_MAXITEMS; i++) { // v1.4
		TempItemPosList[i].x = 40;
		TempItemPosList[i].y = 30;
	}
	iPos = 0;

	// °¢°¢ÀÇ ¾ÆÀÌÅÛÀ» ÀúÀåÇÑ´Ù.
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		// v1.4 ¾ÆÀÌÅÛ ¼ø¼­¸¦ Àç¹èÄ¡ÇÑ´Ù. 
		TempItemPosList[iPos].x = m_pClientList[iClientH]->m_ItemPosList[i].x;
		TempItemPosList[iPos].y = m_pClientList[iClientH]->m_ItemPosList[i].y;
		iPos++;
		
		strcat(pData, "character-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	// v1.4 Àç °è»êµÈ ¾ÆÀÌÅÛ À§Ä¡ ±â¾ï 
	for (i = 0; i < DEF_MAXITEMS; i++) {
		m_pClientList[iClientH]->m_ItemPosList[i].x = TempItemPosList[i].x; 
		m_pClientList[iClientH]->m_ItemPosList[i].y = TempItemPosList[i].y;
	}

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] != NULL) {
		strcat(pData, "character-bank-item = ");
		memset(cTmp, ' ', 21);
		strcpy(cTmp, m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName);
		cTmp[strlen(m_pClientList[iClientH]->m_pItemInBankList[i]->m_cName)] = (char)' ';
		cTmp[20] = NULL;
		strcat(pData, cTmp);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwCount, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectType, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sTouchEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_cItemColor, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue1, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue2, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_sItemSpecEffectValue3, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_wCurLifeSpan, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, " ");
		itoa( m_pClientList[iClientH]->m_pItemInBankList[i]->m_dwAttribute, cTxt, 10);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}
	strcat(pData, "\n\n");

	
	strcat(pData, "[MAGIC-SKILL-MASTERY]\n\n");

	strcat(pData, "//------------------012345678901234567890123456789012345678901234567890");
	strcat(pData,"\n");

	strcat(pData, "magic-mastery     = ");
	for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
		wsprintf(cTxt,"%d", (int)m_pClientList[iClientH]->m_cMagicMastery[i]);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "skill-mastery     = ");
			
	
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_cSkillMastery[i]);

		strcat(pData, cTxt); // ÃÊ±â°ª ÀÔ·Â
	}
	strcat(pData,"\n");
			
	strcat(pData, "skill-SSN     = ");
	for (i = 0; i < 60; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_iSkillSSN[i]);

		strcat(pData, cTxt); // ÃÊ±â°ª ÀÔ·Â
	}
	strcat(pData,"\n");
	
	// ¾ÆÀÌÅÛ ÀåÂø »óÅÂ¸¦ ÀúÀåÇÑ´Ù. ¹Ýµå½Ã ¸Ç ¸¶Áö¸·¿¡ ÀÖ¾î¾ß ÇÔ.
	strcat(pData, "[ITEM-EQUIP-STATUS]\n\n");
	strcat(pData, "item-equip-status = ");
	
	ZeroMemory(cTxt, sizeof(cTxt));
	strcpy(cTxt, "00000000000000000000000000000000000000000000000000");
	              
	int iEP = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ((m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) && 
			(m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_EQUIP)) {
			 cTxt[iEP] = '1';
		}
		iEP++;
	}
	strcat(pData, cTxt);
	strcat(pData, "\n");

	
	strcat(pData, "item-position-x = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].x);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n");
	
	strcat(pData, "item-position-y = ");
	for (i = 0; i < DEF_MAXITEMS; i++) {
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "%d ", m_pClientList[iClientH]->m_ItemPosList[i].y);
		strcat(pData, cTxt);
	}
	strcat(pData, "\n\n");
	
	strcat(pData, "[EOF]");
	strcat(pData, "\n\n\n\n");

	return strlen(pData);
}

BOOL CGame::_bDecodeItemConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iItemConfigListIndex, iTemp;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok( pContents, seps );   
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemIDnumber");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iItemConfigListIndex = atoi(token);
					
					//testcode
					if (iItemConfigListIndex == 490)
						iItemConfigListIndex = atoi(token);
					
					// ¸¸¾à ÀÌ¹Ì ÀÌ·± ¾ÆÀÌ °ªÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Á¤ÀÇµÇ¾î ÀÖ´Ù¸é ¿¡·¯ÀÌ´Ù.
					if (m_pItemConfigList[iItemConfigListIndex] != NULL) {
						// ÀÌ¹Ì °°Àº °íÀ¯¹øÈ£¸¦ °¡Áø ¾ÆÀÌÅÛÀÌ Á¤ÀÇµÇ¾î ÀÖ´Ù. Áßº¹ Á¤ÀÇ ¿¡·¯!
						wsprintf(cTxt, "(!!!) CRITICAL ERROR! Duplicate ItemIDnum(%d)", iItemConfigListIndex);
						PutLogList(cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex] = new class CItem;
					m_pItemConfigList[iItemConfigListIndex]->m_sIDnum = iItemConfigListIndex;
					cReadModeB = 2;
					break;
				case 2:
					// m_cName 
					ZeroMemory(m_pItemConfigList[iItemConfigListIndex]->m_cName, sizeof(m_pItemConfigList[iItemConfigListIndex]->m_cName));
					memcpy(m_pItemConfigList[iItemConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;
				case 3:
					// m_cItemType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemType = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_cEquipPos
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - EquipPos");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cEquipPos = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_sItemEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectType");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectType = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_sItemEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue1");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue1 = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_sItemEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue2");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue2 = atoi(token);
					cReadModeB = 8;
					break;
				case 8:
					// m_sItemEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue3");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue3 = atoi(token);
					cReadModeB = 9;
					break;
				case 9:
					// m_sItemEffectValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue4");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue4 = atoi(token);
					cReadModeB = 10;
					break;
				case 10:
					// m_sItemEffectValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue5");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue5 = atoi(token);
					cReadModeB = 11;
					break;
				case 11:
					// m_sItemEffectValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ItemEffectValue6");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sItemEffectValue6 = atoi(token);
					cReadModeB = 12;
					break;
				case 12:
					// m_wMaxLifeSpan
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxLifeSpan");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wMaxLifeSpan = (WORD)atoi(token);
					cReadModeB = 13;
					break;
				case 13:
					// m_sSpecialEffect
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - MaxFixCount");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffect = atoi(token);
					cReadModeB = 14;
					break;
				case 14:
					// m_sSprite
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Sprite");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSprite = atoi(token);
					cReadModeB = 15;
					break;
				case 15:
					// m_sSpriteFrame
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SpriteFrame");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpriteFrame = atoi(token);
					cReadModeB = 16;
					break;
				case 16:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Price");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iTemp = atoi(token);
					if (iTemp < 0) 
						 m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = FALSE;
					else m_pItemConfigList[iItemConfigListIndex]->m_bIsForSale = TRUE;
					
					m_pItemConfigList[iItemConfigListIndex]->m_wPrice = abs(iTemp);
					cReadModeB = 17;
					break;
				case 17:
					// m_wWeight
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Weight");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_wWeight = atoi(token);
					cReadModeB = 18;
					break;
				case 18:
					// Appr Value
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - ApprValue");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cApprValue = atoi(token);
					cReadModeB = 19;
					break;
				case 19:
					// m_cSpeed
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Speed");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cSpeed = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// m_sLevelLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - LevelLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sLevelLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_cGederLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - GenderLimit");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cGenderLimit = atoi(token);
					cReadModeB = 22;
					break;
				
				case 22:
					// m_sSpecialEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - SM_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue1 = atoi(token);
					cReadModeB = 23;
					break;

				case 23:
					// m_sSpecialEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - L_HitRatio");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sSpecialEffectValue2 = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					// m_sRelatedSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - RelatedSkill");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_sRelatedSkill = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					// m_cItemColor
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file error - Category");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pItemConfigList[iItemConfigListIndex]->m_cItemColor = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Item", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "[ENDITEMLIST]", 13) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto DICFC_STOPDECODING;
			}
		}
		token = pStrTok->pGet();
		//token = strtok( NULL, seps );
	}
	
DICFC_STOPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! ITEM configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) ITEM(Total:%d) configuration - success!", iItemConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


BOOL CGame::_bInitItemAttr(class CItem * pItem, char * pItemName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMTYPES; i++) 
	if (m_pItemConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pItemConfigList[i]->m_cName, 20) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛ ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ» º¹»çÇÑ´Ù.
			ZeroMemory(pItem->m_cName, sizeof(pItem->m_cName));
			strcpy(pItem->m_cName, m_pItemConfigList[i]->m_cName);
			pItem->m_cItemType         = m_pItemConfigList[i]->m_cItemType;
			pItem->m_cEquipPos         = m_pItemConfigList[i]->m_cEquipPos;
			pItem->m_sItemEffectType   = m_pItemConfigList[i]->m_sItemEffectType;
			pItem->m_sItemEffectValue1 = m_pItemConfigList[i]->m_sItemEffectValue1;
			pItem->m_sItemEffectValue2 = m_pItemConfigList[i]->m_sItemEffectValue2;
			pItem->m_sItemEffectValue3 = m_pItemConfigList[i]->m_sItemEffectValue3;
			pItem->m_sItemEffectValue4 = m_pItemConfigList[i]->m_sItemEffectValue4;
			pItem->m_sItemEffectValue5 = m_pItemConfigList[i]->m_sItemEffectValue5;
			pItem->m_sItemEffectValue6 = m_pItemConfigList[i]->m_sItemEffectValue6;
			pItem->m_wMaxLifeSpan      = m_pItemConfigList[i]->m_wMaxLifeSpan;
			pItem->m_wCurLifeSpan	   = pItem->m_wMaxLifeSpan;					// ÃÖÃÊ·Î »ý¼ºµÈ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀº ÃÖ´ëÄ¡ÀÌ´Ù.
			pItem->m_sSpecialEffect    = m_pItemConfigList[i]->m_sSpecialEffect;
			
			pItem->m_sSprite           = m_pItemConfigList[i]->m_sSprite;
			pItem->m_sSpriteFrame      = m_pItemConfigList[i]->m_sSpriteFrame;
			pItem->m_wPrice            = m_pItemConfigList[i]->m_wPrice;
			pItem->m_wWeight           = m_pItemConfigList[i]->m_wWeight;
			pItem->m_cApprValue        = m_pItemConfigList[i]->m_cApprValue;
			pItem->m_cSpeed            = m_pItemConfigList[i]->m_cSpeed;
			pItem->m_sLevelLimit       = m_pItemConfigList[i]->m_sLevelLimit;
			pItem->m_cGenderLimit      = m_pItemConfigList[i]->m_cGenderLimit;
			
			pItem->m_sSpecialEffectValue1 = m_pItemConfigList[i]->m_sSpecialEffectValue1;
			pItem->m_sSpecialEffectValue2 = m_pItemConfigList[i]->m_sSpecialEffectValue2;

			pItem->m_sRelatedSkill     = m_pItemConfigList[i]->m_sRelatedSkill;
			pItem->m_cCategory         = m_pItemConfigList[i]->m_cCategory;
			pItem->m_sIDnum			   = m_pItemConfigList[i]->m_sIDnum;

			pItem->m_bIsForSale	       = m_pItemConfigList[i]->m_bIsForSale;
			pItem->m_cItemColor        = m_pItemConfigList[i]->m_cItemColor;
	
			return TRUE;
		}
	}

	// ¾ÆÀÌÅÛ¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù. 
 	return FALSE;
}


BOOL CGame::_bGetIsStringIsNumber(char * pStr)
{
 int i;
	for (i = 0; i < (int)strlen(pStr); i++)
	if ((pStr[i] != '-') && ((pStr[i] < (char)'0') || (pStr[i] > (char)'9'))) return FALSE;
	
	return TRUE;
}


BOOL CGame::_bReadMapInfoFiles(int iMapIndex)
{
	if (__bReadMapInfo(iMapIndex) == FALSE) {
		return FALSE;
	}

	return TRUE;
}

BOOL CGame::bSetNpcFollowMode(char * pName, char * pFollowName, char cFollowOwnerType)
{
 register int i, iIndex, iMapIndex, iFollowIndex;
 char cTmpName[11], cFollowSide;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	iMapIndex    = -1;
	iFollowIndex = -1;

	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pName, 5) == 0) ) {
		iIndex = i;
		iMapIndex = m_pNpcList[i]->m_cMapIndex;
		goto NEXT_STEP_SNFM1;
	}

NEXT_STEP_SNFM1:;

	switch (cFollowOwnerType) {
	case DEF_OWNERTYPE_NPC:
		for (i = 1; i < DEF_MAXNPCS; i++)
		if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, pFollowName, 5) == 0) ) {
			// µû¶ó´Ù´Ò ´ë»óÀ» ¹ß°ßÇß´Ù.
			// ´Ù¸¥ ¸Ê¿¡ Á¸ÀçÇÏ´Â ´ë»óÀº µû¶ó´Ù´Ò ¼ö ¾ø´Ù. 
			if (m_pNpcList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pNpcList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	
	case DEF_OWNERTYPE_PLAYER:
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pFollowName, 10) == 0) ) {
			// µû¶ó´Ù´Ò ´ë»óÀ» ¹ß°ßÇß´Ù.
			// ´Ù¸¥ ¸Ê¿¡ Á¸ÀçÇÏ´Â ´ë»óÀº µû¶ó´Ù´Ò ¼ö ¾ø´Ù. 
			if (m_pClientList[i]->m_cMapIndex != iMapIndex) return FALSE;
			iFollowIndex = i;
			cFollowSide = m_pClientList[i]->m_cSide;
			goto NEXT_STEP_SNFM2;
		}
		break;
	}

NEXT_STEP_SNFM2:;

	if ((iIndex == -1) || (iFollowIndex == -1)) return FALSE;

	m_pNpcList[iIndex]->m_cMoveType = DEF_MOVETYPE_FOLLOW;
	m_pNpcList[iIndex]->m_cFollowOwnerType  = cFollowOwnerType;
	m_pNpcList[iIndex]->m_iFollowOwnerIndex = iFollowIndex;
	m_pNpcList[iIndex]->m_cSide             = cFollowSide;


	return TRUE;
}


BOOL CGame::bCreateNewNpc(char * pNpcName, char * pName, char * pMapName, short sClass, char cSA, char cMoveType, int * poX, int * poY, char * pWaypointList, RECT * pArea, int iSpotMobIndex, char cChangeSide, BOOL bHideGenMode, BOOL bIsSummoned, BOOL bFirmBerserk, BOOL bIsMaster, int iGuildGUID)
{
 register int i, t, j, k, iMapIndex;
 char  cTmpName[11], cTxt[120];
 short sX, sY, sRange;
 BOOL  bFlag;
 SYSTEMTIME SysTime;

	if (strlen(pName) == 0)   return FALSE;
	if (strlen(pNpcName) == 0) return FALSE;

	GetLocalTime(&SysTime);

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);
	iMapIndex = -1;

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, cTmpName, 10) == 0) 
			iMapIndex = i;
	}
	
	if (iMapIndex == -1) return FALSE;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] == NULL) {
		m_pNpcList[i] = new class CNpc(pName);
		
		if (_bInitNpcAttr(m_pNpcList[i], pNpcName, sClass, cSA) == FALSE) {
			// ÀÌ·± ÀÌ¸§ÀÇ NPC´Â ¾ø´Ù.
			wsprintf(cTxt, "(!) Not existing NPC creation request! (%s) Ignored.", pNpcName);
			PutLogList(cTxt);
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		// »ý¼º½Ã ¿äÀÏÁ¦ÇÑ¿¡ °É¸®´ÂÁö °Ë»çÇØ¾ß ÇÑ´Ù. 10º¸´Ù Å©¸é ¸ðµç ¿äÀÏ¿¡ ´Ù »ý¼º°¡´É. 0ÀÌ¸é ÀÏ¿äÀÏ, 1ÀÌ¸é ¿ù¿äÀÏ...
		if (m_pNpcList[i]->m_cDayOfWeekLimit < 10) {
			if (m_pNpcList[i]->m_cDayOfWeekLimit != SysTime.wDayOfWeek)	{
				// Áö±Ý »ý¼ºÀÌ ºÒ°¡´ÉÇÑ NPCÀÌ´Ù.
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;	
			}
		}

		// Ã³À½ »ý¼ºÀ§Ä¡ °áÁ¤ 
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
		case DEF_MOVETYPE_RANDOM:
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// Æ÷ÀÎÅÍµµ NULLÀÌ ¾Æ´Ï°í ±× °ªµµ NULLÀÌ ¾Æ´Ï¶ó¸é ½ÃÀÛ À§Ä¡¸¦ ÇÒ´çÇÑ´Ù.
				sX = *poX;
				sY = *poY;
			}
			else {
				for ( j = 0; j <= 30; j++) {
					// ¸¸µé ¼ö ÀÖ´Â ÁÂÇ¥°¡ ³ª¿Ã¶§ ±îÁö 30¹ø ¹Ýº¹ 
					sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
					sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

					bFlag = TRUE;
					for (k = 0; k < DEF_MAXMGAR; k++)
					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left != -1) {
						// ÇÇÇØ¾ß ÇÒ ÁÂÇ¥°¡ ÀÖ´Ù. 
						if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].left) &&
							(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].right) &&
							(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].top) &&
							(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[k].bottom)) {
							// Avoid Rect¾ÈÀÌ¹Ç·Î ÀÌ À§Ä¡¿¡´Â »ý¼º½ÃÅ³ ¼ö ¾ø´Ù.	
							bFlag = FALSE;
						}
					}
					if (bFlag == TRUE) goto GET_VALIDLOC_SUCCESS;

				}
				// ½ÇÆÐ!
				delete m_pNpcList[i];
				m_pNpcList[i] = NULL;
				return FALSE;

GET_VALIDLOC_SUCCESS:;
				// sX, sY¿¡ »ý¼º °¡´ÉÇÏ´Ù.
			}
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			// pArea ¿µ¿ª ¾È¿¡¼­ »ý¼ºÇÑ´Ù. 
			sRange = (short)(pArea->right - pArea->left);
			sX     = (short)((rand() % sRange) + pArea->left);
			sRange = (short)(pArea->bottom - pArea->top);
			sY     = (short)((rand() % sRange) + pArea->top);
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			// 10°³ÀÇ »ý¼ºÀ§Ä¡Áß ÇÑ°÷À» ·£´ýÇÏ°Ô ¼±ÅÃ 
			sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].x;
			sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[iDice(1,10) - 1]].y;
			break;

		default:
			// poX, poY°¡ NULLÀÌ ¾Æ´Ï¶ó¸é WaypointList 0¹øÀÌ ½ÃÀÛÀ§Ä¡ 
			if ( (poX != NULL) && (poY != NULL) && (*poX != NULL) && (*poY != NULL) ) {
				// Æ÷ÀÎÅÍµµ NULLÀÌ ¾Æ´Ï°í ±× °ªµµ NULLÀÌ ¾Æ´Ï¶ó¸é ½ÃÀÛ À§Ä¡¸¦ ÇÒ´çÇÑ´Ù.
				sX = *poX;
				sY = *poY;
			}
			else {
				sX = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].x;
				sY = (short)m_pMapList[iMapIndex]->m_WaypointList[pWaypointList[0]].y;
			}
			break;
		}
		
		// À§Ä¡½ÃÅ³¸¸ÇÑ ÁÂÇ¥¸¦ ±¸ÇÑ´Ù. À§Ä¡½ÃÅ³ ¼ö ¾ø´Ù¸é ¸¸µéÁö ¾Ê´Â´Ù.
		if (bGetEmptyPosition(&sX, &sY, iMapIndex) == FALSE) {
			
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;
		}

		if ( (bHideGenMode == TRUE) && (_iGetPlayerNumberOnSpot(sX, sY, iMapIndex, 7) != 0) ) {
			// ÇÃ·¹ÀÌ¾î°¡ ÀÖ´Â ÀÚ¸®¿¡¼­´Â »ý¼ºµÇÁö ¾Ê´Â ¸ðµå¶ó¸é 
			delete m_pNpcList[i];
			m_pNpcList[i] = NULL;
			return FALSE;	
		}

		if ((poX != NULL) && (poY != NULL)) {
			// Æ÷ÀÎÅÍ°¡ NULLÀÌ ¾Æ´Ï¶ó¸é »ý¼ºÁÂÇ¥¸¦ ÀÔ·ÂÇÑ´Ù.
			*poX = sX;
			*poY = sY;
		}

		m_pNpcList[i]->m_sX = sX;
		m_pNpcList[i]->m_sY = sY;
		
		// Á¦ÀÚ¸®¿¡¼­ ¸Éµ¹°í ÀÖ´ÂÁö¸¦ È®ÀÎÇÏ±â À§ÇÑ ÁÂÇ¥ º¯¼ö 
		m_pNpcList[i]->m_vX = sX;
		m_pNpcList[i]->m_vY = sY;

		// WaypointIndex¸¦ Ä«ÇÇÇÑ´Ù.
		for (t = 0; t < 10; t++)
			m_pNpcList[i]->m_iWayPointIndex[t] = pWaypointList[t];

		// ÃÑ WaypointIndexÀÇ ¼ö¸¦ °è»êÇÑ´Ù.
		m_pNpcList[i]->m_cTotalWaypoint = 0;
		for (t = 0; t < 10; t++)
		if (m_pNpcList[i]->m_iWayPointIndex[t] != -1) m_pNpcList[i]->m_cTotalWaypoint++;

		if (pArea != NULL) {
			// RANDOMAREA Copy
			SetRect(&m_pNpcList[i]->m_rcRandomArea, pArea->left, pArea->top, pArea->right, pArea->bottom);
		}

		// ¿òÁ÷ÀÌ´Â ¹æ½Ä¿¡ µû¶ó ½ÃÀÛ DestinationÀ» °áÁ¤ÇÑ´Ù.
		switch (cMoveType) {
		case DEF_MOVETYPE_GUARD:
			m_pNpcList[i]->m_dX = m_pNpcList[i]->m_sX;
			m_pNpcList[i]->m_dY = m_pNpcList[i]->m_sY;
			break;
		
		case DEF_MOVETYPE_SEQWAYPOINT: 
			m_pNpcList[i]->m_cCurWaypoint = 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMWAYPOINT:
			m_pNpcList[i]->m_cCurWaypoint = (rand() % (m_pNpcList[i]->m_cTotalWaypoint - 1)) + 1;
			
			m_pNpcList[i]->m_dX  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].x;
			m_pNpcList[i]->m_dY  = (short)m_pMapList[iMapIndex]->m_WaypointList[ m_pNpcList[i]->m_iWayPointIndex[ m_pNpcList[i]->m_cCurWaypoint ] ].y;
			break;

		case DEF_MOVETYPE_RANDOMAREA:
			m_pNpcList[i]->m_cCurWaypoint = 0;
			
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.right - m_pNpcList[i]->m_rcRandomArea.left);
			m_pNpcList[i]->m_dX = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.left);
			sRange = (short)(m_pNpcList[i]->m_rcRandomArea.bottom - m_pNpcList[i]->m_rcRandomArea.top);
			m_pNpcList[i]->m_dY = (short)((rand() % sRange) + m_pNpcList[i]->m_rcRandomArea.top);
			break;

		case DEF_MOVETYPE_RANDOM:
			m_pNpcList[i]->m_dX = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15);
			m_pNpcList[i]->m_dY = (short)((rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15);
			break;
		}

		m_pNpcList[i]->m_tmp_iError  = 0;

		// NPCÀÇ Çàµ¿¾ç½Ä ÃÊ±âÈ­ 
		m_pNpcList[i]->m_cMoveType          = cMoveType;

		switch (m_pNpcList[i]->m_cActionLimit) {
		case 2:
		case 3:
		case 5:
			// Á¦ÀÚ¸®¿¡¼­ ¿ÏÀü STOPÇÑ »óÅÂÀÇ NPC 
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_STOP;
			
			switch (m_pNpcList[i]->m_sType) {
			case 15: // ShopKeeper-W
			case 19: // Gandlf
			case 20: // Howard
			case 24: // Tom
			case 25: // William
			case 26: // Kennedy
				m_pNpcList[i]->m_cDir      = 4 + iDice(1,3) -1;
				break;

			default:
				m_pNpcList[i]->m_cDir      = iDice(1,8);
				break;
			}
			break;

		default: 
			// ÀÌµ¿ °¡´ÉÇÑ NPC
			m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
			m_pNpcList[i]->m_cDir      = 5;
			break;
		}

		m_pNpcList[i]->m_iFollowOwnerIndex  = NULL;
		m_pNpcList[i]->m_iTargetIndex	    = NULL;
		m_pNpcList[i]->m_cTurn              = (rand() % 2);
		
		switch (m_pNpcList[i]->m_sType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
		case 6:
			// ÀÎ°£Çü NPC¶ó¸é ÀüÅõ¸ðµå, ¹«±â, ¹æÆÐ ÇÃ·¡±×¸¦ ¼³Á¤ÇÑ´Ù.
			m_pNpcList[i]->m_sAppr2 = 0xF000;
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | ((rand() % 13) << 4); // ¹«±â
			m_pNpcList[i]->m_sAppr2 = m_pNpcList[i]->m_sAppr2 | (rand() % 9); // ¹æÆÐ 
			break;

		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
			// Å©·ç¼¼ÀÌµå¿ë °ÇÃà¹°ÀÌ¶ó¸é 3´Ü°è·Î ¿Ï¼ºµÈ´Ù.
			m_pNpcList[i]->m_sAppr2 = 3;
			break;

		default:
			m_pNpcList[i]->m_sAppr2 = 0;
			break;
		}
		
		m_pNpcList[i]->m_cMapIndex          = (char)iMapIndex;
		m_pNpcList[i]->m_dwTime             = timeGetTime() + (rand() % 10000);
		m_pNpcList[i]->m_dwActionTime      += (rand() % 300);
		m_pNpcList[i]->m_dwMPupTime			= timeGetTime();
		m_pNpcList[i]->m_dwHPupTime			= m_pNpcList[i]->m_dwMPupTime;
		m_pNpcList[i]->m_sBehaviorTurnCount	= 0;
		m_pNpcList[i]->m_bIsSummoned        = bIsSummoned;
		m_pNpcList[i]->m_bIsMaster          = bIsMaster;
		// ¼ÒÈ¯¸÷ »ý¼º ½Ã°£À» ±â·ÏÇÑ´Ù.
		if (bIsSummoned == TRUE) 
			m_pNpcList[i]->m_dwSummonedTime = timeGetTime();

		// °íÁ¤ Berserk »óÅÂ Ãß°¡.
		if (bFirmBerserk == TRUE) {
			m_pNpcList[i]->m_cMagicEffectStatus[DEF_MAGICTYPE_BERSERK] = 1;
			m_pNpcList[i]->m_sStatus = m_pNpcList[i]->m_sStatus | 0x20;
			// °íÁ¤ Berserk »óÅÂÀÇ ¸÷Àº °æÇèÄ¡¸¦ 2¹è ´õ ¸¹ÀÌ °®´Â´Ù. 
			m_pNpcList[i]->m_iExpDice *= 2;
		}

		// !!!
		if (cChangeSide != -1) m_pNpcList[i]->m_cSide = cChangeSide;

		m_pNpcList[i]->m_cBravery = (rand() % 3) + m_pNpcList[i]->m_iMinBravery;
		m_pNpcList[i]->m_iSpotMobIndex		= iSpotMobIndex;
		m_pNpcList[i]->m_iGuildGUID         = iGuildGUID;
		//testcode
		if (iGuildGUID != 0) {
			wsprintf(G_cTxt, "Summon War Unit(%d) GUID(%d)", m_pNpcList[i]->m_sType, iGuildGUID);
			PutLogList(G_cTxt);
		}
		
		m_pMapList[iMapIndex]->SetOwner(i, DEF_OWNERTYPE_NPC, sX, sY);
		m_pMapList[iMapIndex]->m_iTotalActiveObject++;
		m_pMapList[iMapIndex]->m_iTotalAliveObject++;

		// Å©·ç¼¼ÀÌµå¿ë °ÇÃà¹°ÀÌ¶ó¸é ÁöÈÖ°ü Åëº¸¿ë °ÇÃà¹° ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
		switch (m_pNpcList[i]->m_sType) {
		case 36: // AGT-Aresden/AGT-Elvine
		case 37: // CGT-Aresden/CGT-Elvine
		case 38: // MS-Aresden/MS-Elvine
		case 39: // DT-Aresden/DT-Elvine
		case 42: // ManaStone
			m_pMapList[iMapIndex]->bAddCrusadeStructureInfo(m_pNpcList[i]->m_sType, sX, sY, m_pNpcList[i]->m_cSide);
			break;
		}
		
		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë¸°´Ù.
		SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		return TRUE;
	}

	return FALSE;
}

void CGame::NpcProcess()
{
 register int i, iMaxHP;
 DWORD dwTime, dwActionTime;

	dwTime = timeGetTime();

	for (i = 1; i < DEF_MAXNPCS; i++) { 
		
		if (m_pNpcList[i] != NULL) {
			// ¼Óµµ¸¦ Á¶Á¤ÇÑ´Ù. °ø°Ý½Ã¿¡´Â ¸ó½ºÅÍµéÀÇ ¼Óµµ°¡ »¡¶óÁø´Ù.
			if (m_pNpcList[i]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
				switch (iDice(1,7)) {
				case 1: dwActionTime = m_pNpcList[i]->m_dwActionTime; break;
				case 2: dwActionTime = m_pNpcList[i]->m_dwActionTime - 100; break;
				case 3: dwActionTime = m_pNpcList[i]->m_dwActionTime - 200; break;
				case 4: dwActionTime = m_pNpcList[i]->m_dwActionTime - 300; break;
				case 5: dwActionTime = m_pNpcList[i]->m_dwActionTime - 400; break;
				case 6: dwActionTime = m_pNpcList[i]->m_dwActionTime - 600; break;
				case 7: dwActionTime = m_pNpcList[i]->m_dwActionTime - 700; break;
				}
				if (dwActionTime < 600) dwActionTime = 600;
			}
			else dwActionTime = m_pNpcList[i]->m_dwActionTime; 

			// v1.42 ³Ãµ¿ »óÅÂ¶ó¸é ¿òÁ÷ÀÓÀÌ 50% ´À·ÁÁø´Ù.
			if (m_pNpcList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] != 0) 
				dwActionTime += (dwActionTime/2);
		}
		
		if ((m_pNpcList[i] != NULL) && ((dwTime - m_pNpcList[i]->m_dwTime) > dwActionTime)) {
			// ½Ã°£ ÀúÀå.
			m_pNpcList[i]->m_dwTime = dwTime;
			
			if (abs(m_pNpcList[i]->m_cMagicLevel) > 0) {
				// ¸¶³ª¸¦ ¿Ã¸± ½Ã°£ÀÌ µÇ¾úÀ¸¸é ¿Ã¸°´Ù. 
				if ((dwTime - m_pNpcList[i]->m_dwMPupTime) > DEF_MPUPTIME) {
					m_pNpcList[i]->m_dwMPupTime = dwTime;	
					
					//if (m_pNpcList[i]->m_bIsSummoned == FALSE) // ¼ÒÈ¯µÈ ¸ó½ºÅÍ´Â MP°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù. 
					m_pNpcList[i]->m_iMana += iDice(1, (m_pNpcList[i]->m_iMaxMana/5));
					
					if (m_pNpcList[i]->m_iMana > m_pNpcList[i]->m_iMaxMana)
						m_pNpcList[i]->m_iMana = m_pNpcList[i]->m_iMaxMana;
				}
			}
			
			// HP¸¦ ¿Ã¸± ½Ã°£ÀÌ µÇ¾úÀ¸¸é ¿Ã¸°´Ù. 
			if (((dwTime - m_pNpcList[i]->m_dwHPupTime) > DEF_HPUPTIME) && (m_pNpcList[i]->m_bIsKilled == FALSE)) {
				// ½Ã°£ Àç °»½Å 
				m_pNpcList[i]->m_dwHPupTime = dwTime;	
				
				iMaxHP = iDice(m_pNpcList[i]->m_iHitDice, 8) + m_pNpcList[i]->m_iHitDice;
				if (m_pNpcList[i]->m_iHP < iMaxHP) {
					
					if (m_pNpcList[i]->m_bIsSummoned == FALSE) // ¼ÒÈ¯µÈ ¸ó½ºÅÍ´Â HP°¡ ¿Ã¶ó°¡Áö ¾Ê´Â´Ù. 
						m_pNpcList[i]->m_iHP += iDice(1, m_pNpcList[i]->m_iHitDice); // Hit Point´Â 17ÃÊ¸¶´Ù 1D3¾¿ ¿Ã¶ó°£´Ù.
					
					if (m_pNpcList[i]->m_iHP > iMaxHP) m_pNpcList[i]->m_iHP = iMaxHP;
					if (m_pNpcList[i]->m_iHP <= 0)     m_pNpcList[i]->m_iHP = 1;
				}
			}
			
			switch (m_pNpcList[i]->m_cBehavior) {
			case DEF_BEHAVIOR_DEAD:
				NpcBehavior_Dead(i);
				break;
			case DEF_BEHAVIOR_STOP:
				NpcBehavior_Stop(i);
				break;
			case DEF_BEHAVIOR_MOVE:
				NpcBehavior_Move(i);
				break;
			case DEF_BEHAVIOR_ATTACK:
				NpcBehavior_Attack(i);
				break;
			case DEF_BEHAVIOR_FLEE:
				NpcBehavior_Flee(i);
				break;
			}

			// !!! m_pNpcList´Â NULLÀÏ ¼ö ÀÖ´Ù. 
			if ((m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_iHP != 0) && (m_pNpcList[i]->m_bIsSummoned == TRUE)) {
				// ¸ó½ºÅÍÀÇ Á¾·ù¿¡ µû¶ó ¼ÒÈ¯ ½Ã°£ÀÌ ´Þ¶óÁø´Ù. 
				switch (m_pNpcList[i]->m_sType) {
				case 29: // ¿À¿ì°Å: 1ºÐ 30ÃÊ  
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > 1000*90) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				
				default: // ÀÏ¹ÝÀûÀÎ °æ¿ì: ¼ÒÈ¯¸÷ÀÌ ½Ã°£ÀÌ ´Ù µÇ¾î »ç¶óÁ®¾ß ÇÑ´Ù.
					if ((dwTime - m_pNpcList[i]->m_dwSummonedTime) > DEF_SUMMONTIME) 
						NpcKilledHandler(NULL, NULL, i, 0);
					break;
				}
			}
		}
	}
}


void CGame::ChatMsgHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 WORD * wp;
 int  * ip;
 char * cp, * cp2;
 char   cBuffer[256], cTemp[256], cTemp2[256], cSendMode = NULL;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (dwMsgSize > 83 +30) return;
 
	// v1.41 ShutUp TimeÀÌ °É·Á ÀÖÀ¸¸é ¿ÏÀüÈ÷ ¸»À» ÇÒ ¼ö ¾ø´Ù. °­·Â Á¦Àç 
	if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) return;
	
	// º»ÀÎÀÇ ÀÌ¸§ÀÌ ±âÀÔµÇ¾î ÀÖÁö ¾Ê´Ù¸é ¸®ÅÏ
	if (memcmp((pData + 10), m_pClientList[iClientH]->m_cCharName, strlen(m_pClientList[iClientH]->m_cCharName)) != 0) return;
 
	// °ü¶÷ÀÚ¶ó¸é Ã¤ÆÃÀ» ÇÒ ¼ö ¾ø´Ù.
	if ((m_pClientList[iClientH]->m_bIsObserverMode == TRUE) && (m_pClientList[iClientH]->m_iAdminUserLevel == 0)) return;
 
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
	 
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
	// Ã¤ÆÃ ¸Þ½ÃÁöÀÇ ½ÃÀÛ À§Ä¡. ()
	cp = (char *)(pData + 21);
			
	// ¸Þ½ÃÁö¿¡ ¸í·É¾î°¡ ¼¯¿© ÀÖ´ÂÁö °Ë»çÇÑ´Ù. 
	switch (*cp) {
	case '@':
		// °°Àº ±æµå¿¡°Ô º¸³»´Â ¸Þ½ÃÁö 
		*cp = 32;
		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iGuildRank == 0)) {
			// ´Ù¸¥ ¼­¹ö¿¡ ±æµå ¸Þ½ÃÁö Àü¼Û 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 1; // ±æµå ¸Þ½ÃÁö
			cp2++;
			ip = (int *)cp2;
			*ip = m_pClientList[iClientH]->m_iGuildGUID;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}
				
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 1;
		}
		else cSendMode = NULL;
		
		// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		break;
	
	case '!':
		// ÀüÃ¼ »ç¿ëÀÚ¿¡°Ô Àü´ÞµÇ´Â ¸Þ½ÃÁöÀÌ´Ù.
		// °°Àº ±æµå¿¡°Ô º¸³»´Â ¸Þ½ÃÁö 
		*cp = 32;
		
		if ((strlen(cp) < 90) && (m_pClientList[iClientH]->m_iAdminUserLevel > 0)) {
			// ´Ù¸¥ ¼­¹ö¿¡ ±æµå ¸Þ½ÃÁö Àü¼Û 
			ZeroMemory(cTemp, sizeof(cTemp));
			cp2 = (char *)cTemp;
			*cp2 = GSM_CHATMSG;
			cp2++;
			*cp2 = 10; // °øÁö ¸Þ½ÃÁö
			cp2++;
			ip = (int *)cp2;
			*ip = NULL;
			cp2 += 4;
			memcpy(cp2, m_pClientList[iClientH]->m_cCharName, 10);
			cp2 += 10;
			wp  = (WORD *)cp2;
			*wp = (WORD)strlen(cp);
			cp2 += 2;
			strcpy(cp2, cp);
			cp2 += strlen(cp);
			bStockMsgToGateServer(cTemp, strlen(cp) + 18);
		}

		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 10) && 
			 (m_pClientList[iClientH]->m_iSP >= 5) ) {
			// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 5;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 2;	// ¸Þ½ÃÁö Ã¢¿¡ ¶ç¿î´Ù.
		}
		else cSendMode = NULL;
		
		// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		
		// v1.4334 ÀüÃ¼ ¿ÜÄ¡±â ¸·±â
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;

		// ¸¸¾à °ü¸®±ÇÇÑÀÌ ÀÖ´Ù¸é 
		if (m_pClientList[iClientH]->m_iAdminUserLevel > 0) cSendMode = 10;
		break;

	case '~':
		// °°Àº Æí¿¡°Ô º¸³»´Â ¸Þ½ÃÁö
		*cp = 32;
		if ( (m_pClientList[iClientH]->m_iTimeLeft_ShutUp == 0) && (m_pClientList[iClientH]->m_iLevel > 1) && 
			 (m_pClientList[iClientH]->m_iSP >= 3) ) {
			// ½ºÅ×¹Ì³Ê°¡ ÃæºÐÇÏ¸é ÀüÃ¼ ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
			//v1.42 
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[iClientH]->m_iSP -= 3;
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
			cSendMode = 3;
		}
		else cSendMode = NULL;
		
		// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é 
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
		// v1.4334 ÀüÃ¼ ¿ÜÄ¡±â ¸·±â
		if (m_pClientList[iClientH]->m_iHP <= 0) cSendMode = NULL;
		break;

	case '/':
		// ¸í·É¾îÀÌ´Ù. 
		ZeroMemory(cBuffer, sizeof(cBuffer));
		memcpy(cBuffer, cp, dwMsgSize - 21);
		cp = (char *)(cBuffer);
		
		if (memcmp(cp, "/who", 4) == 0) {
			// ÀüÃ¼ »ç¿ëÀÚ ¼ö¸¦ ¹¯´Â °ÍÀÌ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TOTALUSERS, NULL, NULL, NULL, NULL);
			return;
		}

		if (memcmp(cp, "/fi ", 4) == 0) {
			// Æ¯Á¤ »ç¿ëÀÚ°¡ Á¢¼ÓÁßÀÎÁö¸¦ ¹¯´Â °ÍÀÌ´Ù. 
			CheckAndNotifyPlayerConnection(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/to", 3) == 0) {
			// ±Ó¼Ó¸»À» ¼³Á¤ÇÑ´Ù.
			ToggleWhisperPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setpf ", 7) == 0) {
			// ÇÃ·¹ÀÌ¾î ÇÁ·ÎÇÊÀ» ¼³Á¤ÇÑ´Ù. 
			SetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

		//ArchAngel Addition
		if (memcmp(cp, "/weather", 8) == 0) { 
			AdminOrder_Weather(iClientH, cp, dwMsgSize - 21); 
			return; 
		}

		if (memcmp(cp, "/pf ", 4) == 0) {
			// ÇÃ·¹ÀÌ¾îÀÇ ÇÁ·ÎÇÊÀ» º¸°íÀÚ ÇÑ´Ù. 
			GetPlayerProfile(iClientH, cp, dwMsgSize - 21);
			return;
		}

//		if (memcmp(cp, "/shutup ", 8) == 0) {
//			// ÇÃ·¹ÀÌ¾îÀÇ ÀüÃ¼ Ã¤ÆÃ±â´ÉÀ» ¸·´Â´Ù. 
//			ShutUpPlayer(iClientH, cp, dwMsgSize - 21);
//			return;
//		}

		if (memcmp(cp, "/rep+ ", 6) == 0) {
			// ÇÃ·¹ÀÌ¾îÀÇ ÁÁÀº Æò°¡¸¦ ³»¸°´Ù. 
			SetPlayerReputation(iClientH, cp, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/rep- ", 6) == 0) {
			// ÇÃ·¹ÀÌ¾îÀÇ ³ª»Û Æò°¡¸¦ ³»¸°´Ù. 
			SetPlayerReputation(iClientH, cp, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/hold", 5) == 0) {
			SetSummonMobAction(iClientH, 1, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/tgt ", 5) == 0) {
			SetSummonMobAction(iClientH, 2, dwMsgSize - 21, cp);
			return;
		}

		if (memcmp(cp, "/free", 5) == 0) {
			SetSummonMobAction(iClientH, 0, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonall ", 11) == 0) {
			AdminOrder_SummonAll(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summonplayer ", 14) == 0) {
			AdminOrder_SummonPlayer(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/storm ", 7) == 0) {
			AdminOrder_SummonStorm(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondeath ", 13) == 0) {
			AdminOrder_SummonDeath(iClientH);
			return;
		}

		if (memcmp(cp, "/kill ", 6) == 0) {
			AdminOrder_Kill(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/revive ", 8) == 0) {
			AdminOrder_Revive(iClientH, cp, dwMsgSize - 21);
			return;
		}

//		if (memcmp(cp, "/closeconn ", 11) == 0) {
//			// °æºñ¸¦ ¼ÒÈ¯ÇÏ¿© °ø°ÝÇÑ´Ù. 
//			AdminOrder_CloseConn(iClientH, cp, dwMsgSize - 21);
//			return;
//		}

		// v1.4311-3 º¯°æ expire -> ban
		if (memcmp(cp, "/ban", 4) == 0) {
			UserCommand_BanGuildsman(iClientH, cp, dwMsgSize - 21);
			return;
		}

		// v1.4311-3 Ãß°¡ reservefightzone ¿î¿µÀÚ°¡ »çÅõÀåÀ» ¿¹¾àÇØ ³õ´Â´Ù.
		if (memcmp(cp, "/reservefightzone", 17) == 0) {
			AdminOrder_ReserveFightzone(iClientH, cp, dwMsgSize - 21);
			return;
		}
		
		if (memcmp(cp, "/dissmiss ", 9) == 0) {
			UserCommand_DissmissGuild(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/attack ", 8) == 0) {
			// °æºñ¸¦ ¼ÒÈ¯ÇÏ¿© °ø°ÝÇÑ´Ù. 
			AdminOrder_CallGuard(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/createfish ", 12) == 0) {
			AdminOrder_CreateFish(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/teleport ", 10) == 0 || memcmp(cp, "/tp ", 4) == 0) {
			AdminOrder_Teleport(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/summondemon ", 13) == 0) {
			AdminOrder_SummonDemon(iClientH);
			return;
		}

		if (memcmp(cp, "/unsummonall ", 13) == 0) {
			AdminOrder_UnsummonAll(iClientH);
			return;			
		}

		if (memcmp(cp, "/unsummondemon ", 15) == 0) {
			AdminOrder_UnsummonDemon(iClientH);
			return;			
		}

//		if (memcmp(cp, "/checkip ", 9) == 0) {
//			AdminOrder_CheckIP(iClientH, cp, dwMsgSize - 21);
//			return;
//		}

		if (memcmp(cp, "/polymorph ", 11) == 0) {
			AdminOrder_Polymorph(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setinvi ", 9) == 0) {
			AdminOrder_SetInvi(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/gns ", 4) == 0) {
			AdminOrder_GetNpcStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setattackmode ", 15) == 0) {
			AdminOrder_SetAttackMode(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/summon ", 8) == 0) {
			AdminOrder_Summon(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/setzerk ", 9) == 0) {
			AdminOrder_SetZerk(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/msg ", 5) == 0) {
			AdminOrder_SendMSG(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setfreeze ", 11) == 0) {
			AdminOrder_SetFreeze(iClientH, cp, dwMsgSize - 21);
			return;	
		}

		if (memcmp(cp, "/setstatus ", 11) == 0) {
			AdminOrder_SetStatus(iClientH, cp, dwMsgSize - 21);
			return;	
		}

//		if (memcmp(cp, "/disconnectall ", 15) == 0) {
//			AdminOrder_DisconnectAll(iClientH, cp, dwMsgSize - 21);
//			return;
//		}

		if (memcmp(cp, "/createitem ", 12) == 0) {
			AdminOrder_CreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/enableadmincreateitem 147258 ", 30) == 0) {
			AdminOrder_EnableAdminCreateItem(iClientH, cp, dwMsgSize - 21);
			return;
		}

		if (memcmp(cp, "/energysphere ", 14) == 0) {
			if (m_pClientList[iClientH]->m_iAdminUserLevel >= 4) EnergySphereProcessor(TRUE, iClientH);
			return;
		}

		if ((memcmp(cp, "/shutdownthisserverrightnow ", 28) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 3)) {
			// Ä¿¸Çµå¿¡ ÀÇÇÑ ¼­¹ö ¼Ë´Ù¿î ¸í·É ºñ»ó»çÅÂ¿¡ ´ëºñÇÏ±â À§ÇÔÀÌ´Ù.
			m_cShutDownCode      = 2;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Admin-Command)!!!");
			// ·Î±× ¼­¹ö¿¡°Ô ÇöÀç ¼­¹ö°¡ ¼Ë´Ù¿î ÁßÀÓÀ» ¾Ë¸°´Ù. 
			bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
			// OccupyFlag µ¥ÀÌÅÍ ÀúÀå 
			if (m_iMiddlelandMapIndex > 0) {
				// Crusade
				SaveOccupyFlagData();
				//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
				//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
			}
			return;
		}

		if ((memcmp(cp, "/setobservermode ", 17) == 0) && (m_pClientList[iClientH]->m_iAdminUserLevel >= 3)) {
			// °ü¶÷ÀÚ ¸ðµå·Î ÀüÈ¯
			AdminOrder_SetObserverMode(iClientH);
			return;
		}

		return;
	}

	// ¸ÕÀú ½ºÆ®¸µÀÇ ³¡¿¡ NULL ´Ù½Ã Áý¾î ³Ö¾î È®ÀÎÇÑ´Ù.
	pData[dwMsgSize-1] = NULL;
		
	if ((m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] == 1) && (iDice(1,3) != 2)) {
		// Confuse Language¿¡ °É¸° »óÅÂ. ¸Þ½ÃÁö¸¦ ¿Ö°î½ÃÅ²´Ù. 
		cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
		
		while (*cp != NULL) {
			if ((cp[0] != NULL) && (cp[0] != ' ') && (cp[1] != NULL) && (cp[1] != ' ')) {
				switch (iDice(1,3)) {
				case 1:	memcpy(cp, "¿ö", 2); break;
				case 2:	memcpy(cp, "¿ì", 2); break;
				case 3:	memcpy(cp, "¿ù", 2); break;
				}
				cp += 2;
			}
			else cp++; 
		}
	}
		
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 17);
	
	if ((cSendMode == NULL) && (m_pClientList[iClientH]->m_iWhisperPlayerIndex != -1)) {
		// ÀÏ¹Ý ¸Þ½ÃÁöÀÌ°í ±Ó¼Ó¸» ¸ðµå¶ó¸é º»ÀÎ°ú »ó´ë¹æ¿¡°Ô¸¸ Àü¼ÛÇÑ´Ù.
		cSendMode = 20;
		
		// ±Ó¼Ó¸» Å»Äð ÄÚµå°¡ ÀÖ´Ù¸é ÀÏ¹Ý ´ëÈ­°¡ µÈ´Ù.
		if (*cp == '#') cSendMode = NULL;

		// ÀüÃ¼ Ã¤ÆÃ ¸Þ½ÃÁö¸¦ »ç¿ëÇÒ ¼ö ¾ø´Â °æ¿ì¶ó¸é ±Ó¼Ó¸» ¶ÇÇÑ ÇÒ ¼ö ¾ø´Ù.
		if (m_pClientList[iClientH]->m_iTimeLeft_ShutUp > 0) cSendMode = NULL;
	}

	// Ã¤ÆÃ ¸Þ½ÃÁö¸¦ ±×´ë·Î ÀÎÁ¢ÇÑ ÇÃ·¹ÀÌ¾îµé¿¡°Ô ¹ß¼ÛÇÑ´Ù.
	// ´Ü, MSGTYPEÀ§Ä¡¿¡ ¿ÀºêÁ§Æ® ¾ÆÀÌµð¸¦ ÀÔ·ÂÇÑ´Ù. 
	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	*wp = (WORD)iClientH;
	// ±×¸®°í ¸Þ½ÃÁö Å¸ÀÔÀ» ÀÔ·ÂÇÑ´Ù.
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 16);
	*cp = cSendMode;

	if (cSendMode != 20) {
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			switch (cSendMode) {
			case NULL:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
				
				if ( (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex) &&
					 (m_pClientList[i]->m_sX > m_pClientList[iClientH]->m_sX - 10) &&
					 (m_pClientList[i]->m_sX < m_pClientList[iClientH]->m_sX + 10) &&
					 (m_pClientList[i]->m_sY > m_pClientList[iClientH]->m_sY - 7) &&
					 (m_pClientList[i]->m_sY < m_pClientList[iClientH]->m_sY + 7) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 1:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

				if ( (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) &&
					 (memcmp(m_pClientList[i]->m_cGuildName, "NONE", 4) != 0) ) {
					
					// Crusade
					if (m_bIsCrusadeMode == TRUE) {
						if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
							 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
							// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
						}
						else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				break;
					
			case 2:
			case 10:
				// Crusade
				if (m_bIsCrusadeMode == TRUE) {
					if ( (m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[i]->m_cSide != 0) && 
						 (m_pClientList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
						// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ¼­·Î ÆíÀÌ ´Ù¸£¸é ¸»À» ÇÒ ¼ö ¾ø´Ù.
					}
					else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				}
				else iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
					
			case 3:
				if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;

				if ( (m_pClientList[i]->m_cSide == m_pClientList[iClientH]->m_cSide) ) 
					iRet = m_pClientList[i]->m_pXSock->iSendMsg(pData, dwMsgSize);
				break;
			}
				
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				// Á¦°ÅÇÏÁö ¾Ê°í ³ÀµÐ´Ù. Time OutÀ¸·Î Á¦°ÅµÇ´Â °ÍÀ» À¯µµ. 
				//DeleteClient(i, TRUE, TRUE);
				break;
			}
		}
	}
	else {
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pData, dwMsgSize);	
		
		if (m_pClientList[ m_pClientList[iClientH]->m_iWhisperPlayerIndex ] != NULL)
			iRet = m_pClientList[m_pClientList[iClientH]->m_iWhisperPlayerIndex]->m_pXSock->iSendMsg(pData, dwMsgSize);	

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			// Á¦°ÅÇÏÁö ¾Ê°í ³ÀµÐ´Ù. Time OutÀ¸·Î Á¦°ÅµÇ´Â °ÍÀ» À¯µµ. 
			//DeleteClient(i, TRUE, TRUE);
			break;
		}
	}
}


void CGame::ChatMsgHandlerGSM(int iMsgType, int iV1, char * pName, char * pData, DWORD dwMsgSize)
{
 register int i, iRet;
 DWORD * dwp;
 WORD * wp;
 short * sp;
 char * cp, cTemp[256], cSendMode = NULL;

	ZeroMemory(cTemp, sizeof(cTemp));
	
	dwp = (DWORD *)cTemp;
	*dwp = MSGID_COMMAND_CHATMSG;
	
	wp  = (WORD *)(cTemp + DEF_INDEX2_MSGTYPE);
	*wp = NULL;

	cp  = (char *)(cTemp + DEF_INDEX2_MSGTYPE + 2);
	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;

	sp  = (short *)cp;
	*sp = NULL;
	cp += 2;
	
	memcpy(cp, pName, 10);
	cp += 10;

	*cp = (char)iMsgType;
	cp++;

	memcpy(cp, pData, dwMsgSize);
	cp += dwMsgSize;

	switch (iMsgType) {
	case 1:	// ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â ±æµå ¸Þ½ÃÁö
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			if (m_pClientList[i]->m_bIsInitComplete == FALSE) break;
			if ( (m_pClientList[i]->m_iGuildGUID == iV1) && (m_pClientList[i]->m_iGuildGUID != 0)) {
				// °°Àº ±æµå ¸Þ½ÃÁö Àü¼Û 			
				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
			}
		}
		break;

	case 2: // ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â ÀüÃ¼ ¸Þ½ÃÁö
	case 10: // ´Ù¸¥ ¼­¹ö¿¡¼­ ¿Â °øÁö ¸Þ½ÃÁö 
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cTemp, dwMsgSize +22);
		}
		break;
	}
}


int CGame::iClientMotion_Attack_Handler(int iClientH, short sX, short sY, short dX, short dY, short wType, char cDir, WORD wTargetObjectID, BOOL bResponse)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet, iExp, tdX, tdY;
 short   sOwner, sAbsX, sAbsY;
 char    cOwnerType;
 BOOL    bNearAttack = FALSE;
	
	// Àß¸øµÈ µ¥ÀÌÅÍ¿¡ ´ëÇØ¼­´Â ÀÀ´äÇÏÁö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;

	dwTime = timeGetTime();

#ifndef NO_MSGSPEEDCHECK	
	m_pClientList[iClientH]->m_iAttackMsgRecvCount++;
	if (m_pClientList[iClientH]->m_iAttackMsgRecvCount >= 7) {
		if (m_pClientList[iClientH]->m_dwAttackLAT != 0) {
			// °ø°Ý ¸Þ½ÃÁö 7¹ø 80*8*7 = 4480ms. ¿ÀÂ÷ ÇÑ°è 3000ms.
			if ((dwTime - m_pClientList[iClientH]->m_dwAttackLAT) < (80*8*7 -3000)) {
				
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		m_pClientList[iClientH]->m_dwAttackLAT = dwTime;
		m_pClientList[iClientH]->m_iAttackMsgRecvCount = 0;
	}
#endif
	
	if ((wTargetObjectID != NULL) && (wType != 2)) {
		// v1.4 tdX, tdY ÁÂÇ¥¸¦ wObjectID·ÎºÎÅÍ ÃßÃâÇÑ´Ù. ´Ü ÀÏ¹Ý È° °ø°ÝÀº Àû¿ëµÇÁö ¾Ê´Â´Ù. È° ÇÊ»ì±â´Â Àû¿ëµÈ´Ù. 
		tdX = 0;
		tdY = 0;

		if (wTargetObjectID < DEF_MAXCLIENTS) {
			// Character
			if (m_pClientList[wTargetObjectID] != NULL) {
				tdX = m_pClientList[wTargetObjectID]->m_sX;
				tdY = m_pClientList[wTargetObjectID]->m_sY;
			}
		}
		else if ( (wTargetObjectID > 10000) && (wTargetObjectID < (10000 + DEF_MAXNPCS)) ) {
			// NPC
			if (m_pNpcList[wTargetObjectID - 10000] != NULL) {
				tdX = m_pNpcList[wTargetObjectID - 10000]->m_sX;
				tdY = m_pNpcList[wTargetObjectID - 10000]->m_sY;
			}
		}

		// ÁÂÇ¥°¡ Å©°Ô ¹þ¾î³ªÁö ¾Ê´Â´Ù¸é ÃßÃâµÈ ÁÂÇ¥¸¦ »ç¿ëÇÑ´Ù.
		if ((tdX == dX) && (tdY == dY)) {
			// ÁÂÇ¥°¡ ¿ÏÀü ÀÏÄ¡ÇÏ¸é 
			bNearAttack = FALSE;	
		}
		else if ((abs(tdX - dX) <= 1) && (abs(tdY - dY) <= 1)) {
			dX = tdX;
			dY = tdY;
			bNearAttack = TRUE;
		}
	}

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return 0;
	
	// ÁËÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â ¸í·ÉÀº ¹«½ÃÇÑ´Ù. Reject¸Þ½ÃÁö¸¦ ¹Þ±â ÀÌÀü¿¡ Àü¼ÛµÈ ¸Þ½ÃÁöµéÀÌ´Ù.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;
	
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// ÇÊ»ì±â³ª È°°ø°ÝÀÌ ¾Æ´Ñµ¥ ¿ø°Å¸® °ø°ÝÀ» ÇÑ´Ù¸é ¹«½ÃÇÑ´Ù. (wType = 0) 
	sAbsX = abs(sX - dX);
	sAbsY = abs(sY - dY);
	if ((wType != 2) && (wType < 20)) {
		if ((sAbsX > 1) || (sAbsY > 1)) wType = 0;
	}

	// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
	ClearSkillUsingStatus(iClientH);

	// Á×Àº À§Ä¡¿¡ ÀÖ¾ú´Ù¸é Áö¿î´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// ´Ù½Ã À§Ä¡ ½ÃÅ²´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	m_pClientList[iClientH]->m_cDir = cDir;
	
	iExp = 0;
	
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, dX, dY);
	
	if (sOwner != NULL) {
		// °ø°Ý È¿°ú¸¦ °è»êÇÑ´Ù. ¸¸¾à ºñÁ¤»óÀûÀÎ ¿¬¼Ó°ø°Ý ¸Þ½ÃÁö´Â ¹«½ÃÇÑ´Ù. 
		if ((wType != 0) && ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) > 100)) { 
			iExp = iCalculateAttackEffect(sOwner, cOwnerType, iClientH, DEF_OWNERTYPE_PLAYER, dX, dY, wType, bNearAttack);
			// v1.41: iCalculateAttackEffect¿¡¼­ ¿À·ù·Î ÀÎÇØ Ä³¸¯ÅÍ°¡ Á¢¼ÓÀÌ ²÷±æ ¼ö ÀÖÀ½¿¡ ´ëºñÇÑ °ÍÀÓ.
			if (m_pClientList[iClientH] == NULL) return 0;
			m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;
		}
	}
	else _CheckMiningAction(iClientH, dX, dY); // ±¤¹° Ã¤Ãë µ¿ÀÛÀÎÁö¸¦ °Ë»çÇÑ´Ù.

	// @@@@@@@@@@@@@@@

	if (iExp != 0) {
		// °ø°ÝÀ¸·Î ÀÎÇÑ °æÇèÄ¡ ÇÒ´çÀÌ ÀÖ¾ú´Ù¸é ExpStock¿¡ ´õÇØÁØ´Ù. 
		m_pClientList[iClientH]->m_iExpStock += iExp;
	}

	// Å¬¶óÀÌ¾ðÆ®°¡ MSGID_RESPONSE_MOTION ¸Þ½ÃÁö¸¦ ¹Þ¾Æ¾ß¸¸ °è¼Ó ¸í·ÉÀ» Àü¼ÛÇÒ ¼ö ÀÖ´Ù. 
	if (bResponse == TRUE) {
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_MOTION;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_OBJECTMOTION_ATTACK_CONFIRM;
	
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	return 1;
}




char CGame::cGetNextMoveDir(short sX, short sY, short dstX, short dstY, char cMapIndex, char cTurn, int * pError)
{
 register char  cDir, cTmpDir;
 register int   aX, aY, dX, dY;
 register int   i, iResX, iResY;

	if ((sX == dstX) && (sY == dstY)) return 0;

	dX = sX;
	dY = sY;
 
	if ((abs(dX - dstX) <= 1) && (abs(dY - dstY) <= 1)) {
		iResX = dstX;
		iResY = dstY;
	}
	else m_Misc.GetPoint(dX, dY, dstX, dstY, &iResX, &iResY, pError);

	cDir = m_Misc.cGetNextMoveDir(dX, dY, iResX, iResY);

	if (cTurn == 0)
	for (i = cDir; i <= cDir + 7;i++) {
		cTmpDir = i;
		if (cTmpDir > 8) cTmpDir -= 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	if (cTurn == 1)
	for (i = cDir; i >= cDir - 7;i--) {
		cTmpDir = i;
		if (cTmpDir < 1) cTmpDir += 8;
		aX = _tmp_cTmpDirX[cTmpDir];
		aY = _tmp_cTmpDirY[cTmpDir];
		if (m_pMapList[cMapIndex]->bGetMoveable(dX + aX, dY + aY) == TRUE) return cTmpDir;
	}

	return 0;
}


char _tmp_cEmptyPosX[] = { 0, 1, 1, 0, -1, -1, -1, 0 ,1, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2, -1, 0, 1, 2 };
char _tmp_cEmptyPosY[] = { 0, 0, 1, 1, 1, 0, -1, -1, -1, -1, 0, 1, 2, 2, 2, 2, 2, 1, 0, -1, -2, -2, -2, -2, -2 };

BOOL CGame::bGetEmptyPosition(short * pX, short * pY, char cMapIndex)
{
 register int i;
 short sX, sY;	
	// ÇÃ·¹ÀÌ¾î³ª NPC°¡ À§Ä¡ÇÒ ¼ö ÀÖ´Â ¿µ¿ªÀ» Ã£´Â´Ù.
	
	for (i = 0; i < 25; i++) 
	if ( (m_pMapList[cMapIndex]->bGetMoveable(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == TRUE) &&
		 (m_pMapList[cMapIndex]->bGetIsTeleport(*pX + _tmp_cEmptyPosX[i], *pY + _tmp_cEmptyPosY[i]) == FALSE) ) {
		sX = *pX + _tmp_cEmptyPosX[i];
		sY = *pY + _tmp_cEmptyPosY[i];	
		*pX = sX;
		*pY = sY;
		return TRUE;
	}

	// À§Ä¡½ÃÅ³¸¸ÇÑ ¿µ¿ªÀÌ ¾øÀ¸¹Ç·Î ÇØ´ç ¸ÊÀÇ InitPoint¿¡ ÇÒ´çÇÑ´Ù.
	
	GetMapInitialPoint(cMapIndex, &sX, &sY);
	*pX = sX;
	*pY = sY;

	return FALSE;
}

void CGame::NpcBehavior_Move(int iNpcH)
{
 char  cDir;
 short sX, sY, dX, dY, absX, absY;
 short sTarget, sDistance;
 char  cTargetType;
	
	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	// ¼ÒÈ¯¸÷ÀÇ Á¦¾î »óÅÂ°¡ Hold¶ó¸é ÀÌµ¿ÇÏÁö ¾Ê´Â´Ù.
	if ((m_pNpcList[iNpcH]->m_bIsSummoned == TRUE) && 
		(m_pNpcList[iNpcH]->m_iSummonControlMode == 1)) return;
	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	
	// ÀÌµ¿ÇÒ ¼ö ¾ø´Â NPC´Â ¸®ÅÏ
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 2:
	case 3:
	case 5:
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_STOP;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		return;
	}
	
	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// ÅÏ Ä«¿îÆ® Áõ°¡. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// ¸ÕÀú ÅÏ Ä«¿îÆ® Å¬¸®¾î.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		
		// Á¦ÀÚ¸®¿¡¼­ °è¼Ó ¸Éµ¹°í ÀÖ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
		absX = abs(m_pNpcList[iNpcH]->m_vX - m_pNpcList[iNpcH]->m_sX);
		absY = abs(m_pNpcList[iNpcH]->m_vY - m_pNpcList[iNpcH]->m_sY);
		
		if ((absX <= 2)	&& (absY <= 2)) {
			// Á¦ÀÚ¸®¿¡ ¸Éµ¹°í ÀÖ´Ù. ´ÙÀ½ WayPoint·Î ¸ñÀûÁö¸¦ ¹Ù²Û´Ù. 
			CalcNextWayPointDestination(iNpcH);
		}

		m_pNpcList[iNpcH]->m_vX = m_pNpcList[iNpcH]->m_sX;
		m_pNpcList[iNpcH]->m_vY = m_pNpcList[iNpcH]->m_sY;
	}

	// °ø°ÝÇÒ ´ë»óÀ» °Ë»öÇÑ´Ù.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if ((sTarget != NULL) && (iDice(1,3) == 3)) {
		// °ø°Ý¸ñÇ¥ ¹ß°ß. 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û. 
		return;
	}
	
	// ¸¶½ºÅÍ ¸÷Àº ÀÌµ¿ ¼Óµµ°¡ ´À¸®´Ù.
	if ((m_pNpcList[iNpcH]->m_bIsMaster == TRUE) && (iDice(1,3) == 2)) return;
	
	if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
		// µû¸£´Â °´Ã¼ÀÇ À§Ä¡¿¡ µû¶ó ÀÌµ¿À» °áÁ¤ÇÑ´Ù. 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
		switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
		case DEF_OWNERTYPE_PLAYER:
			// µû¶ó´Ù´Ï´ø °³Ã¼°¡ Á×À¸¸é ·£´ýÀÌµ¿À¸·Î ÀüÈ¯.
			if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}

			dX = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		case DEF_OWNERTYPE_NPC:
			// µû¶ó´Ù´Ï´ø °³Ã¼°¡ Á×À¸¸é ·£´ýÀÌµ¿À¸·Î ÀüÈ¯.
			if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
				m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOM;
				return;
			}
			
			dX = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
			dY = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
			break;
		}

		if (abs(sX - dX) >= abs(sY - dY)) 
			 sDistance = abs(sX - dX);
		else sDistance = abs(sY - dY);

		if (sDistance >= 3) {
			// µû¸£´Â ´ë»óÀÌ ÀÓ°èÄ¡ ÀÌ»ó ¶³¾îÁ® ÀÖÀ¸¸é ÀÌµ¿ÇÑ´Ù. 
			cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				// ÀÌµ¿ÇÒ ¼ö ¾ø´Ù.
			}
			else {
				dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
				dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
				// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(3, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
				// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
				m_pNpcList[iNpcH]->m_sX   = dX;
				m_pNpcList[iNpcH]->m_sY   = dY;
				m_pNpcList[iNpcH]->m_cDir = cDir;
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
			}
		}
	}
	else 
	{
		// ´ÙÀ½ ÀÌµ¿ ¹æÇâÀ» ±¸ÇÑ´Ù.
		cDir = cGetNextMoveDir(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 
			                   m_pNpcList[iNpcH]->m_dX, m_pNpcList[iNpcH]->m_dY, 
				     	       m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
						
		if (cDir == 0) {
			// ´ÙÀ½ ÀÌµ¿Á¡À» ±¸ÇÑ´Ù. ·£´ý°ªÀ» ÁØ °ÍÀº Á¦ÀÚ¸®¿¡¼­ Àá½Ã ¸Ó¹°±â À§ÇÔ 		
			if (iDice(1,10) == 3) CalcNextWayPointDestination(iNpcH);
		}
		else {
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(4, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}

void CGame::TargetSearch(int iNpcH, short * pTarget, char * pTargetType)
{
 register int ix, iy, iPKCount;
 register short sX, sY, rX, rY, dX, dY;
 short sOwner, sTargetOwner, sDistance, sTempDistance;
 char  cOwnerType, cTargetType, cTargetSide;
 int   iInv;

	sTargetOwner = NULL;
	cTargetType  = NULL;
	sDistance    = 100;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	// ÀÎµ¦½º iNpcH¿¡ ÇØ´çÇÏ´Â NPC°¡ °ø°Ý´ë»óÀ» Ã£´Â´Ù. 
	rX = m_pNpcList[iNpcH]->m_sX - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	rY = m_pNpcList[iNpcH]->m_sY - m_pNpcList[iNpcH]->m_cTargetSearchRange;
	
	for (ix = rX; ix < rX + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; ix++)
	for (iy = rY; iy < rY + m_pNpcList[iNpcH]->m_cTargetSearchRange*2 + 1; iy++) {
		
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);
		if (sOwner != NULL) {
			// ¹«¾ð°¡ ¹ß°ßµÇ¾ú´Ù. 
			if ((sOwner == iNpcH) && (cOwnerType == DEF_OWNERTYPE_NPC)) break; // ÀÚ±â ÀÚ½ÅÀÌ¸é ¹«½Ã 
			
			// ¸ñÇ¥ ¼³Á¤
			// À§Ä¡¸¦ ±¸ÇÑ´Ù.
			iPKCount = 0;
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwner] == NULL) {
					// Àß¸øµÈ ÀÎµ¦½º¸¦ °¡Áø °ªÀÌ´Ù. Å¬¸®¾îÇÑ´Ù.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(5, sOwner, DEF_OWNERTYPE_PLAYER, ix, iy);
				}
				else {
					if (m_pClientList[sOwner]->m_iAdminUserLevel > 0) goto SKIP_SEARCH;

					dX = m_pClientList[sOwner]->m_sX;
					dY = m_pClientList[sOwner]->m_sY;
					cTargetSide = m_pClientList[sOwner]->m_cSide;
					iPKCount    = m_pClientList[sOwner]->m_iPKCount;
					iInv        = m_pClientList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwner] == NULL) {
					// Àß¸øµÈ ÀÎµ¦½º¸¦ °¡Áø °ªÀÌ´Ù. Å¬¸®¾îÇÑ´Ù.	
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(6, sOwner, DEF_OWNERTYPE_NPC, ix, iy);
				}
				else {
					dX = m_pNpcList[sOwner]->m_sX;
					dY = m_pNpcList[sOwner]->m_sY;
					cTargetSide = m_pNpcList[sOwner]->m_cSide;
					iPKCount    = 0;
					iInv        = m_pNpcList[sOwner]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ];

					if (m_pNpcList[iNpcH]->m_sType == 21) {
						// ¸¸¾à °æºñ°¡ NPC¸¦ ¸ñÇ¥¹°À» Ã£´Â °ÍÀÌ¶ó¸é NPCÁÖÀ§¿¡ ÇÃ·¹ÀÌ¾î°¡ ¸¹ÀÌ ÀÖ´Ù¸é °ø°ÝÇÏÁö ¾Ê´Â´Ù. 
						if (_iCalcPlayerNum(m_pNpcList[sOwner]->m_cMapIndex, dX, dY, 2) != 0) {
							sOwner     = NULL;
							cOwnerType = NULL;
						}
					}
				}
				break;
			}
			
			if (m_pNpcList[iNpcH]->m_cSide < 10) {
				// NPCÀÇ Side°¡ 10º¸´Ù ÀÛ´Ù´Â °ÍÀº NPC°¡ ÇÑ ¸¶À»¿¡ ¼Ò¼ÓµÇ¾ú´Ù´Â ¶æ.  Ex: Guard È¤Àº ¼ÒÈ¯¸÷  
				if (cTargetSide == 0) {
					// ¸ñÇ¥¹°ÀÌ Áß¸³ÀÌ´Ù. PK°¡ ¾Æ´Ï¶ó¸é °ø°ÝÇÏÁö ¾Ê´Â´Ù. 
					if (iPKCount == 0) goto SKIP_SEARCH;
				}
				else {
					// ¸ñÇ¥¹°ÀÌ ¸¶À» ¼Ò¼ÓÀÌ´Ù. Side°¡ ´Ù¸£´Ù¸é °ø°ÝÇÑ´Ù. v1.12
					if ((iPKCount == 0) && (cTargetSide == m_pNpcList[iNpcH]->m_cSide)) goto SKIP_SEARCH;
					// Áß¸³¸÷Àº ¸¶À» ¼Ò¼Ó ¸ñÇ¥¹°À» °ø°ÝÇÏÁö ¾Ê´Â´Ù. v1.12
					if (m_pNpcList[iNpcH]->m_cSide == 0) goto SKIP_SEARCH;
				}
			}
			else {
				// ÀÏ¹Ý ¸ó½ºÅÍµéÀÌ´Ù. ÀÚ±â¿Í Side°¡ °°À¸¸é ¹«½Ã.
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (cTargetSide == 0)) goto SKIP_SEARCH;
				if (cTargetSide == m_pNpcList[iNpcH]->m_cSide) goto SKIP_SEARCH;
			}

			// ¸¸¾à INVISIBILITY°¡ µÇ¾î ÀÖ°í Åõ¸í Å½Áö ´É·ÂÀÌ ¾ø´Ù¸é 
			if ((iInv != 0) && (m_pNpcList[iNpcH]->m_cSpecialAbility != 1)) goto SKIP_SEARCH;

			if (abs(sX - dX) >= abs(sY - dY)) 
				 sTempDistance = abs(sX - dX);
			else sTempDistance = abs(sY - dY);

			if (sTempDistance <	sDistance) {
				sDistance = sTempDistance;
				sTargetOwner = sOwner;
				cTargetType  = cOwnerType;
			}
SKIP_SEARCH:;
		}
	}

	*pTarget     = sTargetOwner;
	*pTargetType = cTargetType;
	return;
}


void CGame::NpcBehavior_Attack(int iNpcH)
{
 int   iMagicType;
 short sX, sY, dX, dY, dX_follow, dY_follow, sDistance;
 char  cDir;
 WORD  wWeaponType;
 DWORD dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
 	if (m_pNpcList[iNpcH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;
	
	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 1:
	case 2:
	case 3:
	case 4:
		return;

	case 5:
		if (m_pNpcList[iNpcH]->m_iBuildCount > 0) return;
	}
	
	// v1.432-2 맵 섹터 정보를 갱신한다. 
	int iStX, iStY;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex] != NULL) {
		iStX = m_pNpcList[iNpcH]->m_sX / 20;
		iStY = m_pNpcList[iNpcH]->m_sY / 20;
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iMonsterActivity++;  
	}

	// 연속 공격 카운트 초기화 
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount == 0) 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

	// 턴 카운트 증가. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 20) {
		// 20회 이상 공격동작을 수행하면 다시 이동모드로 들어간다. 단 영구 공격 모드가 아니라면 
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
		
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE))
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;

		// 여기서 표효동작이나 여유동작을 취하기 위한 메시지를 발송할 수도 있다.
		return;
	}

	// 위치를 구한다.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex] == NULL) {
			// 목표물이 사라졌다. 
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
			return;
		}
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}

	// 목표물 주위에 적이 많으면 도망친다. 단 건축물(5)는 예외
	if ( (iGetDangerValue(iNpcH, dX, dY) > m_pNpcList[iNpcH]->m_cBravery) && 
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {
		
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 에너지가 낮고 Bravery가 낮으면 도망친다. 단 건축물(5)는 예외
	if ( (m_pNpcList[iNpcH]->m_iHP <= 2) && (iDice(1,m_pNpcList[iNpcH]->m_cBravery) <= 3) &&
		 (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) &&
		 (m_pNpcList[iNpcH]->m_cActionLimit != 5)) {

		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
		return;
	}

	// 목표물의 상태를 판단한다. 
	if ((abs(sX - dX) <= 1) && (abs(sY - dY) <= 1)) {
		// 인접해 있다.	근거리 무기를 장착하고 있다면 공격가능.
		
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		// 방향을 바꾸고 공격동작 
		m_pNpcList[iNpcH]->m_cDir = cDir;				  

		if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
			// 전쟁용 건물인 경우 
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 36: // Crossbow Guard Tower: 활 공격 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 2); // 활
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
				break;

			case 37: // Cannon Guard Tower: 
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
				m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
				NpcMagicHandler(iNpcH, dX, dY, 61);
				break;
			}
		}
		else {
			// 일반 NPC인 경우
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
			iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1); // 공격에 대한 효과를 계산한다. 
		}
		// 연속 공격 카운트 증가.
		m_pNpcList[iNpcH]->m_iAttackCount++;

		// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
		if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
			switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
			case DEF_ATTACKAI_EXCHANGEATTACK:
				// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				break;

			case DEF_ATTACKAI_TWOBYONEATTACK:
				// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
				if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
				}
				break;
			}
		}
	}
	else {
		// 떨어져 있다.  
		cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
		if (cDir == 0) return;
		m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
		// 마법 능력이 있어야 하고 사정거리 내여야 한다.
		if ((m_pNpcList[iNpcH]->m_cMagicLevel > 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			switch (m_pNpcList[iNpcH]->m_cMagicLevel) { // 각 써클별로 마법 사용이 가능한지 판단후 처리. 
			case 1:
				// 매직 미사일 사용 가능 
				if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			case 2:
				// 매직 미사일, 에너지 볼트 
				if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 0;
				break;
			case 3:
				// 에너지 볼트, 파이어 볼
				if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 4:
				// 파이어 스트라이크, 라이트닝 에로우, 파이어 볼, 에너지 볼트 
				if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 5:
				// 라이트닝, 파이어 스트라이크, 라이트닝 에로우, 파이어 볼, 에너지 볼트
				if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 6:
				// 라이트닝 볼트, 라이트닝, 파이어스트라이크, 파이어 볼 
				if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				else if (m_pMagicConfigList[30]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 30;
				else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 37;
				else if (m_pMagicConfigList[20]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 20;
				else if (m_pMagicConfigList[10]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 10;
				break;
			case 7:
				// 블러디-쇽-웨이브, 매스-파이어-스트라이크, 에너지 스트라이크, 라이트닝 볼트, 라이트닝
				if ((m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,5) == 3)) 
					iMagicType = 70;
				else if (m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 61;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;
			case 8:
				// 패럴라이즈, 에너지 스트라이크, 라이트닝 볼트, 라이트닝
				if ((m_pMagicConfigList[35]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 35;
				else if (m_pMagicConfigList[60]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 60;
				else if (m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 51;
				else if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 43;
				break;

			case 9:
				if ((m_pMagicConfigList[74]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 74;
				break;
			
			case 10:
				if ((m_pMagicConfigList[91]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 91;
				break;
			
			case 11:
				if ((m_pMagicConfigList[61]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 61;
				else if (m_pMagicConfigList[70]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
					iMagicType = 70;
				break;
			
			case 12:
				if ((m_pMagicConfigList[51]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) && (iDice(1,3) == 2)) 
					iMagicType = 51;
				break;
}

			if (iMagicType != -1) {
				
				// 몬스터의 AI가 2이상이고 마법 공격 상대가 마법 보호가 걸려 있다면 공격하지 않는다. 
				if (m_pNpcList[iNpcH]->m_iAILevel >= 2) {
					switch (m_pNpcList[iNpcH]->m_cTargetType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하거나 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2) {
							// 마법 보호가 걸려있음 공격하지 않으며 추격하지 않고 이동모드로 전환, 새로운 목표물을 검색
							if ((abs(sX - dX) > m_pNpcList[iNpcH]->m_iAttackRange) || (abs(sY - dY) > m_pNpcList[iNpcH]->m_iAttackRange)) {
								m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
								m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
								return;
							}
							else goto NBA_CHASE;
						}
						// 패럴마법인데 목표물이 이미 패럴상태라면 마법 사용 안함.
						if ((iMagicType == 35) && (m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0)) goto NBA_CHASE;
						break;
					}
				}
				
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// 광범위 마법 사용이 금지된 경우 (MagicLevel이 음수인 경우)
		if ((m_pNpcList[iNpcH]->m_cMagicLevel < 0) && (iDice(1,2) == 1) &&
			(abs(sX - dX) <= 9) && (abs(sY - dY) <= 7)) {
			iMagicType = -1;
			if (m_pMagicConfigList[43]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 43;
			else if (m_pMagicConfigList[37]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 37;
			else if (m_pMagicConfigList[0]->m_sValue1 <= m_pNpcList[iNpcH]->m_iMana) 
				iMagicType = 0;

			if (iMagicType != -1) {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir], m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir], 1); // 1 : 칼등의 근접무기로 공격하는 의미 
				NpcMagicHandler(iNpcH, dX, dY, iMagicType);
				m_pNpcList[iNpcH]->m_dwTime = dwTime + 2000; 
				return;
			}
		}

		// v1.41 마법 능력이 없지만 원거리 공격이 가능하다면 
		if ((m_pNpcList[iNpcH]->m_iAttackRange > 1) && 
			(abs(sX - dX) <= m_pNpcList[iNpcH]->m_iAttackRange) && (abs(sY - dY) <= m_pNpcList[iNpcH]->m_iAttackRange)) {
						
			cDir = m_Misc.cGetNextMoveDir(sX, sY, dX, dY);
			if (cDir == 0) return;
			// 방향을 바꾸고 공격동작 
			m_pNpcList[iNpcH]->m_cDir = cDir;				  
			
			if (m_pNpcList[iNpcH]->m_cActionLimit == 5) {
				// 전쟁용 건물이다. 화살 혹은 포를 쏜다.
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 36: // Crossbow Guard Tower
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 2); 
					iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 2);
					break;

				case 37: // Cannon Guard Tower: 매스 파이어 스트라이크 공격
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 1); 
					//iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 1);
					m_pNpcList[iNpcH]->m_iMagicHitRatio = 1000;
					NpcMagicHandler(iNpcH, dX, dY, 61);
					break;
				}
			}
			else {
				SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, dX, dY, 20); // 20: 필살기 
				// 공격에 대한 효과를 계산한다. 
				iCalculateAttackEffect(m_pNpcList[iNpcH]->m_iTargetIndex, m_pNpcList[iNpcH]->m_cTargetType, iNpcH, DEF_OWNERTYPE_NPC, dX, dY, 20);
			}
			// 연속 공격 카운트 증가.
			m_pNpcList[iNpcH]->m_iAttackCount++;
			
			// 공격 지능 타입에 따른 이후 행동. 고정 공격 모드에는 해당되지 않는다.  
			if ((m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[iNpcH]->m_cActionLimit == 0)) {
				switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
				case DEF_ATTACKAI_EXCHANGEATTACK:
					// 공격 -> 후퇴 -> 공격 -> 후퇴 -> ...
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					break;
			
				case DEF_ATTACKAI_TWOBYONEATTACK:
					// 공격 -> 공격 -> 후퇴 -> 공격 -> 공격 -> 후퇴 -> ...
					if (m_pNpcList[iNpcH]->m_iAttackCount >= 2) {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_FLEE;
					}
					break;
				}
			}
			return;
		}

		// 마법을 사용하지 않았다면 추격한다.
NBA_CHASE:;		

		if (m_pNpcList[iNpcH]->m_cActionLimit != 0) return;

		// 연속 공격 카운트 초기화 
		m_pNpcList[iNpcH]->m_iAttackCount = 0;

		// Crusade 집단 이동 모드일때라도 적은 끝까지 추격하게 변경 
		/*
		if (m_pNpcList[iNpcH]->m_cMoveType == DEF_MOVETYPE_FOLLOW) {
			
			switch (m_pNpcList[iNpcH]->m_cFollowOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
					// 이동모드로 전환 
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
					m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
					return;
				}

				dX_follow = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
				dY_follow = m_pClientList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
				break;
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex] == NULL) {
					// 이동모드로 전환 
					m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
					m_pNpcList[iNpcH]->m_cBehavior    = DEF_BEHAVIOR_MOVE;
					m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
					return;
				}
				
				dX_follow = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sX;
				dY_follow = m_pNpcList[m_pNpcList[iNpcH]->m_iFollowOwnerIndex]->m_sY;
				break;
			}

			if (abs(sX - dX_follow) >= abs(sY - dY_follow)) 
				 sDistance = abs(sX - dX_follow);
			else sDistance = abs(sY - dY_follow);

			if (sDistance < 8) {
				// 따르는 대상과 어느정도 거리가 여유가 있다면 추격한다.
				cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
				if (cDir == 0) {
				// 이동할 수 없다.
				}
				else {
					dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
					dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
					// 예전 위치에서 지운다. 
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(7, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
					// 새 위치에 표시한다. 
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[iNpcH]->m_sX   = dX;
					m_pNpcList[iNpcH]->m_sY   = dY;
					m_pNpcList[iNpcH]->m_cDir = cDir;
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
				}
			}
			else {
				// 단 영구 공격 모드라면 거리와 상관없이 무조건 추격. 전환되지 않는다.
				if (m_pNpcList[iNpcH]->m_bIsPermAttackMode == FALSE) {
					if (iDice(1,5) == 3) {
						// 5분의 1확률로 집단 이동 모드를 벗어나 독자적 행동을 한다.
						m_pNpcList[iNpcH]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
					}
					else {
						m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
					}
				}
				else {
					cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
					if (cDir == 0) {
						// 이동할 수 없다.
					}
					else {
						dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
						dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
						// 예전 위치에서 지운다. 
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(8, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
						// 새 위치에 표시한다. 
						m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
						m_pNpcList[iNpcH]->m_sX   = dX;
						m_pNpcList[iNpcH]->m_sY   = dY;
						m_pNpcList[iNpcH]->m_cDir = cDir;
						SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
					}
	  			}
			}
		}
		else 
		*/
		{
			// 이동모드가 Follow가 아니라면 공격목표를 무조건 추격한다.	움직임에 제한이 없다.
			cDir = cGetNextMoveDir(sX, sY, dX, dY,m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
			if (cDir == 0) {
				return;
			}
			dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
			dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
			// 예전 위치에서 지운다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(9, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
			// 새 위치에 표시한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
			m_pNpcList[iNpcH]->m_sX   = dX;
			m_pNpcList[iNpcH]->m_sY   = dY;
			m_pNpcList[iNpcH]->m_cDir = cDir;
			SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
		}
	}
}


void CGame::RemoveFromTarget(short sTargetH, char cTargetType, int iCode)
{
 register int i;
 DWORD dwTime = timeGetTime();

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		// Crusade ¸¸¾à ÁöÈÖ°üÀÌ »ç¸ÁÇÑ °æ¿ì ÁöÈÖ°ü »êÇÏ NPCµéÀº ¼ÒÈ¯¸÷ ¸ðµå·Î ÀüÈ¯µÇ¾î ÀÏÁ¤½Ã°£ 
		// ÀÌÈÄ¿¡ ÀÚµ¿ ÆøÆÄµÈ´Ù. ¸÷ÀÌ ³ÑÃÄ³ª´Â °ÍÀ» ¸·±â À§ÇÔ.
		if ((m_pNpcList[i]->m_iGuildGUID != NULL) && (cTargetType == DEF_OWNERTYPE_PLAYER) &&
			(m_pClientList[sTargetH]->m_iGuildGUID == m_pNpcList[i]->m_iGuildGUID)) {
			
			if (m_pNpcList[i]->m_cActionLimit == 0) {
				// ÀÌµ¿ °¡´ÉÇÑ NPC¸¸ ¼ÒÈ¯ ¸ðµå·Î ÀüÈ¯
				m_pNpcList[i]->m_bIsSummoned = TRUE;
				m_pNpcList[i]->m_dwSummonedTime = dwTime;
			}
		}
		
		if ((m_pNpcList[i]->m_iTargetIndex == sTargetH) && 
			(m_pNpcList[i]->m_cTargetType == cTargetType)) {
			
			switch (iCode) {
			case DEF_MAGICTYPE_INVISIBILITY:
				if (m_pNpcList[i]->m_cSpecialAbility == 1) {
					// Åõ¸í Å½Áö ´É·ÂÀÌ ÀÖ´Â ¸ó½ºÅÍ´Â ¸ñÇ¥¸¦ ³õÄ¡Áö ¾Ê´Â´Ù. 
				}
				else {
					m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
					m_pNpcList[i]->m_iTargetIndex = NULL;
					m_pNpcList[i]->m_cTargetType  = NULL;
				}
				break;

			default:
				m_pNpcList[i]->m_cBehavior = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_iTargetIndex = NULL;
				m_pNpcList[i]->m_cTargetType  = NULL;
				break;
			}
		}
	}
}


int CGame::iCalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType, int tdX, int tdY, int iAttackMode, BOOL bNearAttack)
{
 int    iAP_SM, iAP_L, i, iAttackerHitRatio, iTargetDefenseRatio, iDestHitRatio, iResult, iAP_Abs_Armor, iAP_Abs_Shield;
 char   cAttackerName[21], cAttackerDir, cAttackerSide, cTargetDir, cProtect;
 short  sWeaponIndex, sAttackerWeapon, dX, dY, sX, sY, aX, aY, sAtkX, sAtkY, sTgtX, sTgtY;
 DWORD  dwTime = timeGetTime();
 WORD   wWeaponType;
 double dTmp1, dTmp2, dTmp3;
 BOOL   bKilled = FALSE;
 BOOL   bNormalMissileAttack = FALSE;
 BOOL   bIsAttackerBerserk;
 int    iKilledDice, iDamage, iExp, iWepLifeOff, iSideCondition, iMaxSuperAttack, iWeaponSkill, iComboBonus, iTemp;
 int    iAttackerHP, iMoveDamage;
 class  CTile * pTile;
 char   cAttackerSA;
 int    iAttackerSAvalue, iHitPoint;
 char   cDamageMoveDir;
 int    iConstructionPoint, iWarContribution, tX, tY, iDst1, iDst2;

	iExp = 0;

	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	cAttackerSA      = NULL;
	iAttackerSAvalue = NULL;
	wWeaponType      = NULL;

	// °ø°ÝÇÑ ÀÚÀÇ Attack Point¿Í HitRatio¸¦ ¾ò´Â´Ù.
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		
		if (m_pClientList[sAttackerH] == NULL) return 0;
		// °ø°ÝÀ§Ä¡°¡ °ø°Ý ºÒ°¡´É ¸ÊÀÌ¶ó¸é °ø°Ý ºÒ°¡´É 
		if (m_pMapList[ m_pClientList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
			
		// Åõ¸í ¸ðµå¿´´Ù¸é °ø°Ý½Ã¿¡ ÇØÁ¦µÈ´Ù.
		if ( (m_pClientList[sAttackerH]->m_sStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_PLAYER, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
			m_pClientList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
		
		// ÀüÅõ¸ðµå°¡ ¾Æ´Ñ »óÅÂ¶ó¸é °ø°ÝÀÇ ÀÇ¹Ì°¡ ¾ø´Ù.
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return 0;

		iAP_SM = 0;
		iAP_L  = 0;
		// °ø°Ý±¼¸²
		
		// ÇÃ·¹ÀÌ¾î°¡ ¼ÒÁöÇÑ ¹«±â Á¾·ù¸¦ ºÐ¼®ÇÑ´Ù.
		wWeaponType = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);

		// °ø°ÝÀÚÀÇ »çÀÌµå
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;

		if (wWeaponType == 0) {
			// ¸Ç¼ÕÀÌ´Ù.
			iAP_SM = iAP_L    = iDice(1, (m_pClientList[sAttackerH]->m_iStr / 12));
			if (iAP_SM <= 0) iAP_SM = 1;
			if (iAP_L  <= 0) iAP_L  = 1;
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio + m_pClientList[sAttackerH]->m_cSkillMastery[5];
		}
		else if ((wWeaponType >= 1) && (wWeaponType < 40)) {
			// Ä®, ¸ÅÀÌ½º Á¾·ù
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// º¸³Ê½º °¡»ê 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			// Str º¸³Ê½º µ¥¹ÌÁö¸¦ °¡»êÇÑ´Ù. +0.5f´Â ¹Ý¿Ã¸²
			dTmp1 = (double)iAP_SM;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_SM = (int)(dTmp3 +0.5f);

			dTmp1 = (double)iAP_L;
			if (m_pClientList[sAttackerH]->m_iStr <= 0)
				 dTmp2 = 1.0f;
			else dTmp2 = (double)m_pClientList[sAttackerH]->m_iStr;
			
			dTmp2 = dTmp2 / 5.0f;
			dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
			iAP_L = (int)(dTmp3 +0.5f);
			//
		}
		else if (wWeaponType >= 40) {
			// È° Á¾·ù
			iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
			iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

			// º¸³Ê½º °¡»ê 
			iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
			iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
			iAttackerHitRatio = m_pClientList[sAttackerH]->m_iHitRatio;

			bNormalMissileAttack = TRUE;

			// Str º¸³Ê½º °¡»ê 
			iAP_SM += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			iAP_L  += iDice(1, (m_pClientList[sAttackerH]->m_iStr / 20));
			//
		}

		// v1.41 Custom-Made ÀåÂøÀ¸·Î ÀÎÇÑ °ø°Ý¹«±â ¾ÆÀÌÅÛÀÇ È¿°ú°¡ ÀÖ´Ù¸é Ã³¸® 
		if (m_pClientList[sAttackerH]->m_iCustomItemValue_Attack != 0) {
			// ÃÖÀú ´ë¹ÌÁö º¸Á¤ 
			if ((m_pClientList[sAttackerH]->m_iMinAP_SM != 0) && (iAP_SM < m_pClientList[sAttackerH]->m_iMinAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMinAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMinAP_L != 0) && (iAP_L < m_pClientList[sAttackerH]->m_iMinAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMinAP_L;
			}
			// ÃÖ´ë ´ë¹ÌÁö º¸Á¤
			if ((m_pClientList[sAttackerH]->m_iMaxAP_SM != 0) && (iAP_SM > m_pClientList[sAttackerH]->m_iMaxAP_SM)) {
				iAP_SM = m_pClientList[sAttackerH]->m_iMaxAP_SM;
			}
			if ((m_pClientList[sAttackerH]->m_iMaxAP_L != 0) && (iAP_L > m_pClientList[sAttackerH]->m_iMaxAP_L)) {
				iAP_L = m_pClientList[sAttackerH]->m_iMaxAP_L;
			}
		}
		
		cAttackerDir = m_pClientList[sAttackerH]->m_cDir;
		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		
		if (m_pClientList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.2 ¿©±â¼­ ÇÊ»ì±â¿¡ µû¸¥ ´ë¹ÌÁö °¡ÁßÀ» °áÁ¤ÇÑ´Ù.
		if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
			// ±âº»ÀûÀ¸·Î ÆÄ¿ö°¡ ·¹º§%¸¸Å­ Áõ°¡ÇÑ´Ù.
			dTmp1 = (double)iAP_SM;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_SM += iTemp;
			
			dTmp1 = (double)iAP_L;
			dTmp2 = (double)m_pClientList[sAttackerH]->m_iLevel;
			dTmp3 = dTmp2 / 100.0f;
			dTmp2 = dTmp1 * dTmp3;
			iTemp = (int)(dTmp2 +0.5f);
			iAP_L += iTemp;

			// v1.3 ÇÊ»ì±âÀÇ °æ¿ì ±âº»ÀûÀ¸·Î ¸íÁß°ªÀÌ 100 ¿Ã¶ó°£´Ù.
			iAttackerHitRatio += 100;

			// v1.41 ÇÊ»ì±âÀÇ ¸íÁß°ªÀ» Á¶Á¤ÇÑ´Ù.
			iAttackerHitRatio += m_pClientList[sAttackerH]->m_iCustomItemValue_Attack;
		}

		// v1.41
		iAttackerHP = m_pClientList[sAttackerH]->m_iHP;

		// v1.42 Ãß°¡ Attack Rating 
		iAttackerHitRatio += m_pClientList[sAttackerH]->m_iAddAR;

		//v1.43
		sAtkX = m_pClientList[sAttackerH]->m_sX;
		sAtkY = m_pClientList[sAttackerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sAttackerH] == NULL) return 0;
		// °ø°ÝÀ§Ä¡°¡ °ø°Ý ºÒ°¡´É ¸ÊÀÌ¶ó¸é °ø°Ý ºÒ°¡´É 
		if (m_pMapList[ m_pNpcList[sAttackerH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return 0;
		
		// Åõ¸í ¸ðµå¿´´Ù¸é °ø°Ý½Ã¿¡ ÇØÁ¦µÈ´Ù.
		if ( (m_pNpcList[sAttackerH]->m_sStatus & 0x10) != 0 ) {
			SetInvisibilityFlag(sAttackerH, DEF_OWNERTYPE_NPC, FALSE);
			
			bRemoveFromDelayEventList(sAttackerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);
			m_pNpcList[ sAttackerH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
		}
	
		// °ø°ÝÀÚÀÇ »çÀÌµå
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;

		iAP_SM = 0;
		iAP_L  = 0;
		
		// Crusade
		if (m_pNpcList[sAttackerH]->m_cAttackDiceThrow != 0) 
			iAP_L = iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);
		
		iAttackerHitRatio = m_pNpcList[sAttackerH]->m_iHitRatio;
		
		cAttackerDir = m_pNpcList[sAttackerH]->m_cDir;
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);
		
		if (m_pNpcList[sAttackerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0)
			 bIsAttackerBerserk = TRUE;
		else bIsAttackerBerserk = FALSE;

		// v1.41
		iAttackerHP = m_pNpcList[sAttackerH]->m_iHP;

		// v1.411
		cAttackerSA = m_pNpcList[sAttackerH]->m_cSpecialAbility;

		//v1.43
		sAtkX = m_pNpcList[sAttackerH]->m_sX;
		sAtkY = m_pNpcList[sAttackerH]->m_sY;
		break;
	}

	// °ø°Ý´çÇÑ ´ë»óÀÇ ¹æ¾î·üÀ» ¾ò´Â´Ù. 
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// Á¸ÀçÇÏÁö ¾Ê´Â Ä³¸¯ÅÍ´Â °ø°ÝÇÒ ¼ö ¾ø´Ù. 
		if (m_pClientList[sTargetH] == NULL) return 0;
		// Á×ÀºÀÚ¿¡ ´ëÇÑ °ø°ÝÀº ¹«ÀÇ¹ÌÇÏ´Ù.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return 0;
		
		// °ø°ÝÀÚÀÇ ÁÂÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«ÀÇ¹ÌÇÏ´Ù. 
		if ((m_pClientList[sTargetH]->m_sX != tdX) || (m_pClientList[sTargetH]->m_sY != tdY)) return 0;
		
		// v1.4 ¿î¿µÀÚ¿¡°Ô´Â °ø°ÝÀÌ ÅëÇÏÁö ¾Ê´Â´Ù. 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return 0;

		// v1.41 °ø°ÝÀÚ°¡ Áß¸³ÀÌ¸é ´ëÀÎ °ø°ÝÀÌ ºÒ°¡´ÉÇÏ´Ù. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return 0;
		
		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pClientList[sTargetH]->m_iDefenseRatio;
		
		// ¸¸¾à °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í °ø°ÝÀÚ°¡ ¾ÈÀü °ø°Ý ¸ðµå¶ó¸é °ø°ÝÀÇ ÀÇ¹Ì°¡ ¾ø´Ù. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE)) { 
			iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
			if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
				// °ø°Ý·Â Àý¹Ý 
				iAP_SM = iAP_SM / 2;
				iAP_L  = iAP_L / 2;
			}
			else {
				// ¾ÈÀü °ø°Ý¸ðµå·Î °°ÀºÆíÀ» °ø°ÝÇßÀ»¶§. ¸¸¾à »çÅõÀå ³»¶ó¸é ±æµå°¡ ´Ù¸¥ °æ¿ì ´ë¹ÌÁö¸¦ ÁÖ°ÔµÈ´Ù.
				if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
					if (m_pClientList[sAttackerH]->m_iGuildGUID == m_pClientList[sTargetH]->m_iGuildGUID) return 0;
					else {
						// °ø°Ý·Â Àý¹Ý 
						iAP_SM = iAP_SM / 2;
						iAP_L  = iAP_L / 2;
					}
				}
				else return 0;
			}
		}
		
		// v1.3 °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// Á¡·ÉÁö¿ª ¸íÁß·ü º¸³Ê½º¸¦ °è»êÇÑ´Ù. 
			if ((m_pClientList[sAttackerH]->m_cMapIndex == m_iMiddlelandMapIndex) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				aX = m_pClientList[sAttackerH]->m_sX;
				aY = m_pClientList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_iMiddlelandMapIndex]->m_pTile + aX + aY*m_pMapList[m_iMiddlelandMapIndex]->m_sSizeY);	
				if (pTile->m_iOccupyStatus != 0) {
					// Á¡·É ¿µÇâÀÌ ÀÖ´Ù¸é 
					if (pTile->m_iOccupyStatus < 0) {
						// -°ªÀº ¾Æ·¹½ºµ§
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							// °ø°ÝÀÚ°¡ ÀÚ½ÅÀÇ Á¡·ÉÁö À§¿¡ ¼­ÀÖ´Ù. 100 ÀÌ»óÀº ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 100;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus);
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						// +°ªÀº ¿¤¹ÙÀÎ
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							// °ø°ÝÀÚ°¡ ÀÚ½ÅÀÇ Á¡·ÉÁö À§¿¡ ¼­ÀÖ´Ù. 100 ÀÌ»óÀº ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 100;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus);
						}
					}
				}
			}
		}

		// v1.42 Ãß°¡ ¹æ¾î°ª 
		iTargetDefenseRatio += m_pClientList[sTargetH]->m_iAddDR;

		//v1.43
		sTgtX = m_pClientList[sTargetH]->m_sX;
		sTgtY = m_pClientList[sTargetH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		// Á¸ÀçÇÏÁö ¾Ê´Â Ä³¸¯ÅÍ´Â °ø°ÝÇÒ ¼ö ¾ø´Ù. 
		if (m_pNpcList[sTargetH] == NULL) return 0;
		// Á×ÀºÀÚ¿¡ ´ëÇÑ °ø°ÝÀº ¹«ÀÇ¹ÌÇÏ´Ù.
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return 0;
		// °ø°ÝÀÚÀÇ ÁÂÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«ÀÇ¹ÌÇÏ´Ù. 
		if ((m_pNpcList[sTargetH]->m_sX != tdX) || (m_pNpcList[sTargetH]->m_sY != tdY)) return 0;
		
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetDefenseRatio = m_pNpcList[sTargetH]->m_iDefenseRatio;

		// v1.3 °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			
			// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ¾Æ±ºÀÌ³ª Áß¸³ÀÇ °ø°Ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return 0;
				break;
			}
			
			// Á¡·ÉÁö¿ª ¸íÁß·ü º¸³Ê½º¸¦ °è»êÇÑ´Ù. 
			if ((m_pClientList[sAttackerH]->m_cMapIndex == m_iMiddlelandMapIndex) && (m_pClientList[sAttackerH]->m_cSide > 0)) {
				aX = m_pClientList[sAttackerH]->m_sX;
				aY = m_pClientList[sAttackerH]->m_sY;
				pTile = (class CTile *)(m_pMapList[m_iMiddlelandMapIndex]->m_pTile + aX + aY*m_pMapList[m_iMiddlelandMapIndex]->m_sSizeY);	
				if (pTile->m_iOccupyStatus != 0) {
					// Á¡·É ¿µÇâÀÌ ÀÖ´Ù¸é 
					if (pTile->m_iOccupyStatus < 0) {
						// -°ªÀº ¾Æ·¹½ºµ§
						if (m_pClientList[sAttackerH]->m_cSide == 1) {
							// °ø°ÝÀÚ°¡ ÀÚ½ÅÀÇ Á¡·ÉÁö À§¿¡ ¼­ÀÖ´Ù.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 50;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus)/2;
						}
					}
					else if (pTile->m_iOccupyStatus > 0) {
						// +°ªÀº ¿¤¹ÙÀÎ
						if (m_pClientList[sAttackerH]->m_cSide == 2) {
							// °ø°ÝÀÚ°¡ ÀÚ½ÅÀÇ Á¡·ÉÁö À§¿¡ ¼­ÀÖ´Ù.
							if (abs(pTile->m_iOccupyStatus) > 100) 
								 iAttackerHitRatio += 50;
							else iAttackerHitRatio += abs(pTile->m_iOccupyStatus)/2;
						}
					}
				}
			}

			// ¸¸¾à ÇÃ·¹ÀÌ¾îÀÇ °ø°Ý ¹«±â°¡ °î±ªÀÌ°í NPC°¡ °Ç¹° °Ç¼³ÁßÀÌ¶ó¸é iBuildCount¸¦ ÁÙÀÎ´Ù.
			if ((wWeaponType == 25) && (m_pNpcList[sTargetH]->m_cActionLimit == 5) && (m_pNpcList[sTargetH]->m_iBuildCount > 0)) {
				
				// ¿î¿µÀÚµµ ¾Æ´Ï°í °Ç¼³ÀÚµµ ¾Æ´Ñµ¥ °î±ªÀÌÁúÀ» ÇÏ¸é ¼Ò¿ë¾ø´Ù.
				if ((m_pClientList[sAttackerH]->m_iCrusadeDuty != 2) && (m_pClientList[sAttackerH]->m_iAdminUserLevel == 0)) break;
								
				switch (m_pNpcList[sTargetH]->m_sType) {
				case 36:
				case 37:
				case 38:
				case 39:
					switch (m_pNpcList[sTargetH]->m_iBuildCount) {
					case 1: // ¿Ï¼ºµÇ¾ú´Ù.
						m_pNpcList[sTargetH]->m_sAppr2 = 0;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

						switch (m_pNpcList[sTargetH]->m_sType) {
						case 36: iConstructionPoint = 700; iWarContribution = 1400; break;	// ¾Ö·Î¿ì °¡µå Å¸¿ö 
						case 37: iConstructionPoint = 700; iWarContribution = 1400; break;	// Ä³³í °¡µå Å¸¿ö
						case 38: iConstructionPoint = 500; iWarContribution = 1000; break;	// ¸¶³ª ÄÝ·ºÅÍ
						case 39: iConstructionPoint = 500; iWarContribution = 1000; break;	// µðÅØÅÍ
						}
										
						m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
						if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
							m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

						//testcode
						wsprintf(G_cTxt, "Construction Complete! WarContribution: +%d", iWarContribution);
						PutLogList(G_cTxt);

						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
						break;

					case 5: // µÎ¹øÂ° ¾÷±×·¹ÀÌµå 
						m_pNpcList[sTargetH]->m_sAppr2 = 1;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					case 10: // Ã³À½ ¾÷±×·¹ÀÌµå
						m_pNpcList[sTargetH]->m_sAppr2 = 2;
						SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
						break;
					}
					break;
				}
				
				m_pNpcList[sTargetH]->m_iBuildCount--;
				if (m_pNpcList[sTargetH]->m_iBuildCount <= 0) {
					m_pNpcList[sTargetH]->m_iBuildCount = 0;
				}
				return 0;
			}
		}

		//v1.43
		sTgtX = m_pNpcList[sTargetH]->m_sX;
		sTgtY = m_pNpcList[sTargetH]->m_sY;
		break;
	}

	// °ø°Ý´ë»óÀÇ À§Ä¡°¡ No-Attack-Area¶ó¸é ÇÃ·¹ÀÌ¾î°£ °ø°ÝÀº Àý´ë ¼º°øÇÏÁö ¸øÇÑ´Ù. 
	if ( (cAttackerType == DEF_OWNERTYPE_PLAYER) && (cTargetType == DEF_OWNERTYPE_PLAYER) ) {
		
		sX = m_pClientList[sAttackerH]->m_sX;
		sY = m_pClientList[sAttackerH]->m_sY;

		dX = m_pClientList[sTargetH]->m_sX;
		dY = m_pClientList[sTargetH]->m_sY;
		
		// ¹°¸® º¸È£ È¤Àº ¾ÈÀü ¿µ¿ªÀÌ¶ó¸é °ø°Ý ¼º°ø ¸øÇÔ 
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000006) != 0) return 0;
		if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(dX, dY, 0x00000006) != 0) return 0;
	}
		
	// Dex¿¡ ÀÇÇÑ º¸³Ê½º ¸íÁß°ª Ãß°¡ 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (m_pClientList[sAttackerH]->m_iDex > 50) {
			iAttackerHitRatio += (m_pClientList[sAttackerH]->m_iDex - 50); 	
		}
	}
	
	// È° ¹«±âÀÇ °æ¿ì ³¯¾¾¿¡ ÀÇÇÑ ¸íÁß·ü º¯°æ. 5, 10, 25% °¨¼Ò 
	if (wWeaponType >= 40) {
		switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
		case 0:	break;
		case 1:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 20); break;
		case 2:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 10); break;
		case 3:	iAttackerHitRatio = iAttackerHitRatio - (iAttackerHitRatio / 4);  break;
		}
	}
	// ¸íÁß°ª ¿À·ù °¡´É¼º º¸Á¤ 
	if (iAttackerHitRatio < 0)   iAttackerHitRatio = 0;    
			
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ];
		
		break;

	case DEF_OWNERTYPE_NPC:
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;
	}

	//ArchAngel Fix
	
	  // °ø°Ý ¼º°ø ¿©ºÎ¿Í´Â »ó°ü¾øÀÌ È°À» ½ú´Ù¸é È­»ìÀ» °¨¼Ò½ÃÅ²´Ù. 
  // ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ°í È°ÀÌ¶ó¸é 
  if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
     // BUG POINT! Item == NULL 
     if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) { 
        //#ERROR POINT! 
        if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ] == NULL) { 
           // v1.4 ¿¡·¯ º¸Á¤ ÄÚµå 
           m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE; 
           DeleteClient(sAttackerH, TRUE, TRUE); 
           return 0; 
        } 

        if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) { 
           if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) { 
              // È°¿¡ ÇÒ´çµÈ È­»ìÀÌ ¾ø´Ù.   °ø°ÝÀÌ ¼º°øÇÏµç ½ÇÆÐÇÏµç ¾Æ¹«·± È¿°ú¸¦ º¸Áö ¸øÇÑ´Ù. 
              return 0; 
           } 
           else { 
              // È­»ì ¾ÆÀÌÅÛ ÀÎµ¦½º°¡ Àß¸øµÇ¾ú´Ù~! ¿À·ù»óÈ² 
              if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ] == NULL) 
                 return 0; 
                                       
              iTemp = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]; 

              if (memcmp(m_pClientList[sAttackerH]->m_pItemList[iTemp]->m_cName, "Fire-Bow", 8) == 0){ 

                 short sOwner = sAttackerH; 
                 char cOwnerType = DEF_OWNERTYPE_PLAYER_INDIRECT; 
                 short sType = 1; 
                 char cMapIndex = m_pClientList[sAttackerH]->m_cMapIndex; 
                 short sX = m_pNpcList[sTargetH]->m_sX; 
                 short sY = m_pNpcList[sTargetH]->m_sY; 
                 DWORD dwLastTime = 30; 
                 int iV1 = 8; 
               
                 iAddDynamicObjectList(sOwner, DEF_OWNERTYPE_PLAYER_INDIRECT, sType, cMapIndex, sX, sY, dwLastTime*1000, iV1);    
              } 
              // È­»ìÀÌ ÇÏ³ª ÁÙ¾ú´Ù. 
              m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount--; 
              if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) { 
                 // È­»ìÀÌ ´Ù ¼Ò¸ðµÆ´Ù. Count°¡ 0ÀÌµÈ È­»ì ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù. 
                  
                 ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE); 
                 // ´Ù¸¥ Á¾·ùÀÇ È­»ìÀÌ ÀÖ´Ù¸é Àç ÇÒ´ç. 
                 m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH); 
              } 
              else { 
                 // È­»ìÀÌ ÁÙ¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
                 SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, (char)FALSE, NULL); 
                 // È­»ì ¹«°Ô¸¦ ÁÙÀÎ´Ù. 
                 // ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
                 iCalcTotalWeight(sAttackerH); 
              } 
           } 
           // ¹æ¾îÀÚ°¡ ¹Ì»çÀÏ°ø°Ý¿¡ ´ëÇÑ º¸È£°¡ µÈ »óÅÂ¶ó¸é ¹«Á¶°Ç ¸íÁßÇÏÁö ¾Ê´Â´Ù. 
           if (cProtect == 1) return 0; 
        }

	
	/*
	// °ø°Ý ¼º°ø ¿©ºÎ¿Í´Â »ó°ü¾øÀÌ È°À» ½ú´Ù¸é È­»ìÀ» °¨¼Ò½ÃÅ²´Ù. 
	// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ°í È°ÀÌ¶ó¸é 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// BUG POINT! Item == NULL
		if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) {
			//#ERROR POINT!
			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ] == NULL) {
				// v1.4 ¿¡·¯ º¸Á¤ ÄÚµå 
				m_pClientList[sAttackerH]->m_bIsItemEquipped[m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND]] = FALSE;
				DeleteClient(sAttackerH, TRUE, TRUE);
				return 0;
			}

			if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] ]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_ARROW) {
				if (m_pClientList[sAttackerH]->m_cArrowIndex == -1) {
					// È°¿¡ ÇÒ´çµÈ È­»ìÀÌ ¾ø´Ù.	°ø°ÝÀÌ ¼º°øÇÏµç ½ÇÆÐÇÏµç ¾Æ¹«·± È¿°ú¸¦ º¸Áö ¸øÇÑ´Ù.
					return 0;
				}
				else {
					// È­»ì ¾ÆÀÌÅÛ ÀÎµ¦½º°¡ Àß¸øµÇ¾ú´Ù~! ¿À·ù»óÈ² 
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ] == NULL) 
						return 0;
				
					// È­»ìÀÌ ÇÏ³ª ÁÙ¾ú´Ù.
					m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount--;
					if (m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount <= 0) {
						// È­»ìÀÌ ´Ù ¼Ò¸ðµÆ´Ù. Count°¡ 0ÀÌµÈ È­»ì ¾ÆÀÌÅÛÀ» »èÁ¦ÇÑ´Ù.
					
						ItemDepleteHandler(sAttackerH, m_pClientList[sAttackerH]->m_cArrowIndex, FALSE);
						// ´Ù¸¥ Á¾·ùÀÇ È­»ìÀÌ ÀÖ´Ù¸é Àç ÇÒ´ç.
						m_pClientList[sAttackerH]->m_cArrowIndex = _iGetArrowItemIndex(sAttackerH);
					}
					else {
						// È­»ìÀÌ ÁÙ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_SETITEMCOUNT, m_pClientList[sAttackerH]->m_cArrowIndex, m_pClientList[sAttackerH]->m_pItemList[ m_pClientList[sAttackerH]->m_cArrowIndex ]->m_dwCount, (char)FALSE, NULL);
						// È­»ì ¹«°Ô¸¦ ÁÙÀÎ´Ù. 
						// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
						iCalcTotalWeight(sAttackerH);
					}
				}
				// ¹æ¾îÀÚ°¡ ¹Ì»çÀÏ°ø°Ý¿¡ ´ëÇÑ º¸È£°¡ µÈ »óÅÂ¶ó¸é ¹«Á¶°Ç ¸íÁßÇÏÁö ¾Ê´Â´Ù.
				if (cProtect == 1) return 0;
			}
			*/
			else {
				// ÀÏ¹Ý ¹«±â¸¦ »ç¿ëÇÑ °ø°ÝÀÌ´Ù. ¸¶¹ý ¹æÆÐ°¡ ±¸ÇöµÇ¾î ÀÖ´Ù¸é ¹æ¾î°ª Áõ°¡½ÃÅ²´Ù. 
				// Ä®, µµ³¢, ¸Ç¼Õ 
				switch (cProtect) {
				case 3: iTargetDefenseRatio += 30;  break; //  Magic Shield
				case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
				}
				if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
			}
		}
	}
	else {
		// NPCÀÇ °ø°ÝÀÌ´Ù.
		switch (cProtect) {
		case 3: iTargetDefenseRatio += 30;  break; //  Magic Shield
		case 4: iTargetDefenseRatio += 100; break; //  Great Magic Shield
		}
		if (iTargetDefenseRatio < 0) iTargetDefenseRatio = 1;
	}

	//--------------
	// ¸¸¾à °ø°ÝÀÚ°¡ ¸ñÇ¥ÀÇ µî µÚ¿¡¼­ °ø°ÝÇß´Ù¸é ¹æ¾î·üÀº 50%°¨¼Ò 	
	if (cAttackerDir == cTargetDir) iTargetDefenseRatio = iTargetDefenseRatio / 2;
	
	// ¹æ¾î°ª ¿À·ù °¡´É¼º º¸Á¤   
	if (iTargetDefenseRatio < 1)   iTargetDefenseRatio = 1;

	// ÃÖÁ¾ °ø°Ý ¸íÁß·üÀ» ±¸ÇÑ´Ù. 
	dTmp1 = (double)(iAttackerHitRatio);
	dTmp2 = (double)(iTargetDefenseRatio);

	dTmp3 = (dTmp1 / dTmp2) * 50.0f;
	iDestHitRatio = (int)(dTmp3); 

	// ÃÖ¼Ò °ø°Ý ¸íÁß·üÀ» º¸ÀåÇÑ´Ù. 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	// ÃÖ´ë °ø°Ý ¸íÁß·üÀ» Á¦ÇÑÇÑ´Ù.
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;

	// Berserk °ø°ÝÀÌ¶ó¸é Å¸°ÝÄ¡°¡ µÎ¹è°¡ µÈ´Ù. ´Ü ÇÊ»ì±â´Â µÎ¹è°¡ µÇÁö ¾Ê´Â´Ù.
	if ((bIsAttackerBerserk == TRUE) && (iAttackMode < 20)) {
		iAP_SM = iAP_SM * 2;
		iAP_L  = iAP_L  * 2;
	}

	// ÇÃ·¹ÀÌ¾î¶ó¸é °íÁ¤ ´ë¹ÌÁö Ãß°¡ 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
		iAP_L  += m_pClientList[sAttackerH]->m_iAddPhysicalDamage;
	}

	// v1.4 ±ÙÁ¢ °ø°Ý¿¡ ÀÇÇÑ ¸íÁßÀÌ¶ó¸é ´ë¹ÌÁö¸¦ °¨¼Ò½ÃÅ²´Ù. 
	
	if (bNearAttack == TRUE) {
		// ÃÊ±â ¼³Á¤Àº 50% 
		iAP_SM = iAP_SM / 2;
		iAP_L  = iAP_L / 2;
	}
	
	// v1.4 VIT¿¡ µû¸¥ ´ë¹ÌÁö °¨¼Ò 
	if (cTargetType == DEF_OWNERTYPE_PLAYER) {
		iAP_SM -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
		iAP_L  -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
	}

	// v1.4 ´ë¹ÌÁö °ª ÃÖÁ¾ º¸Á¤ Crusade
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		if (iAP_SM <= 1) iAP_SM = 1;
		if (iAP_L  <= 1) iAP_L  = 1;
	}
	else {
		// ¸ó½ºÅÍÀÇ °ø°ÝÀÎ °æ¿ì ÃÖÀú ´ë¹ÌÁö´Â 0: ´õ¹ÌÀÇ °ø°Ý¶§¹®ÀÌ´Ù.
		if (iAP_SM <= 0) iAP_SM = 0;
		if (iAP_L  <= 0) iAP_L  = 0;
	}

	iResult = iDice(1, 100);
	//------------

  	if (iResult <= iDestHitRatio) {
		// °ø°ÝÀº ¼º°øÇß´Ù.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é Ã³¸®ÇØ¾ß ÇÒ °ÍÀÌ ÀÖ´Ù.
			
			// 1. ¹è°¡ ³Ê¹« °íÇÁ´Ù°Å³ª SP°¡ ³·À¸¸é 1/10 ½ÇÆÐ °¡´É¼ºÀÌ ÀÖ´Ù.
			if ( ((m_pClientList[sAttackerH]->m_iHungerStatus <= 10) || (m_pClientList[sAttackerH]->m_iSP <= 0)) && 
				 (iDice(1,10) == 5) ) return FALSE;	
			
			// 2. ¿¬Å¸ Ä«¿îÆ® Áõ°¡
			m_pClientList[sAttackerH]->m_iComboAttackCount++;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount < 0) m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
			if (m_pClientList[sAttackerH]->m_iComboAttackCount > 4) m_pClientList[sAttackerH]->m_iComboAttackCount = 1;

			// ¿¬Å¸ Ä«¿îÆ®¿¡ µû¸¥ º¸³Ê½º ´ë¹ÌÁö Áõ°¡ 
			iWeaponSkill = _iGetWeaponSkillType(sAttackerH);
			iComboBonus = iGetComboAttackBonus(iWeaponSkill, m_pClientList[sAttackerH]->m_iComboAttackCount);
			
			//v1.42 ¿¬¼Ó °ø°Ý ´ë¹ÌÁö °öÇÏ±â?
			if ((m_pClientList[sAttackerH]->m_iComboAttackCount > 1) && (m_pClientList[sAttackerH]->m_iAddCD != NULL))
				iComboBonus += m_pClientList[sAttackerH]->m_iAddCD;

			iAP_SM += iComboBonus;
			iAP_L  += iComboBonus;

			// v1.42 Èñ±Í °ø°Ý ¹«±â ¾ÆÀÌÅÛ È¿°ú °è»ê 
			switch (m_pClientList[sAttackerH]->m_iSpecialWeaponEffectType) {	// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ
			case 0: break;
			case 1: // ÇÊ»ìÀÇ~
				if ((m_pClientList[sAttackerH]->m_iSuperAttackLeft > 0) && (iAttackMode >= 20)) {
					iAP_SM += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
					iAP_L  += m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue;
				}
				break;

			case 2: // Áßµ¶ÀÇ~
				cAttackerSA = 61; // cAttackerSA°¡ 61ÀÌ¸é Áßµ¶ Á¤µµ°¡ ÁöÁ¤µÈ °ÍÀ» ÀÇ¹Ì 
				iAttackerSAvalue = m_pClientList[sAttackerH]->m_iSpecialWeaponEffectValue*5; 
				break;

			case 3: // Á¤ÀÇÀÇ~
				cAttackerSA = 62;
				break;
			}

			// v1.44 »çÅõÀå ³»ÀÌ¸é °ø°Ý·Â 1.5¹è 
			if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				iAP_SM += iAP_SM/2;
				iAP_L  += iAP_L/2;
			}

			// Crusade : Àü¸éÀü ¸ðµåÀÏ¶§ ±ºÀÎ °ø°Ý·Â 1.33¹è 
			if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) {
				iAP_SM += iAP_SM/3;
				iAP_L  += iAP_L/3;
			}
		}

		switch (cTargetType) {
		case DEF_OWNERTYPE_PLAYER:
			// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
			ClearSkillUsingStatus(sTargetH);
					
			// ¸¸¾à °ø°Ý¹ÞÀº Å¬¶óÀÌ¾ðÆ®°¡ DEF_RAGPROTECTIONTIMEÃÊµ¿¾È ÀÀ´äÀÌ ¾ø¾ú´Ù¸é º¸È£¸¦ ¹Þ´Â´Ù.
			if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) {
				// °ø°Ý È¿°ú°¡ ¾ø´Ù. ·¢À¸·Î ÀÎÇÑ Áö¿¬. 
				return 0;
			}
			else {
				// v1.42 
				switch (cAttackerSA) {
				case 62: // Á¤ÀÇÀÇ~
					if (m_pClientList[sTargetH]->m_iRating < 0) {
						// °ø°Ý¹ÞÀº Ä³¸¯ÅÍÀÇ ÆòÆÇÀÌ ³·À¸¹Ç·Î Ãß°¡ Å¸°ÝÄ¡ °è»ê 
						iTemp = abs(m_pClientList[sTargetH]->m_iRating) / 10;
						if (iTemp > 10) iTemp = 10;
						iAP_SM += iTemp;
					}
					break;
				}
				
				// °ø°Ý¹ÞÀº ÇÃ·¹ÀÌ¾îÀÇ Ãæ°Ý Èí¼ö·ü°ú Parrying ¼º°ø¿©ºÎ¸¦ °è»êÇÑ´Ù. 
				iAP_Abs_Armor  = 0;
				iAP_Abs_Shield = 0;
			
				iTemp = iDice(1,10000);
				if ((iTemp >= 1) && (iTemp < 5000))           iHitPoint = 1; // 50%´Â ¸öÅë¿¡ ¸íÁß
				else if ((iTemp >= 5000) && (iTemp < 7500))   iHitPoint = 2; // 25%´Â ´Ù¸®ºÎÀ§¿¡ ¸íÁß
				else if ((iTemp >= 7500) && (iTemp < 9000))   iHitPoint = 3; // 15%´Â ÆÈºÎÀ§¿¡ ¸íÁß
				else if ((iTemp >= 9000) && (iTemp <= 10000)) iHitPoint = 4; // 10%´Â ¸Ó¸®ºÎÀ§¿¡ ¸íÁß 

				switch (iHitPoint) {
				case 1:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] > 0) {
						// °©¿Ê¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö·üÀ» °è»ê: ÃÖ´ë 80%±îÁö ´ë¹ÌÁö¸¦ ¸·´Â´Ù.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 2:
					if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
						 m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) > 0) {
						// °©¿Ê¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö·üÀ» °è»ê: ÃÖ´ë 80%±îÁö ´ë¹ÌÁö¸¦ ¸·´Â´Ù.
						if ((m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] +
							m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]) >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)(m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_PANTS] + m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_LEGGINGS]);
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 3: 
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] > 0) {
						// °©¿Ê¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö·üÀ» °è»ê: ÃÖ´ë 80%±îÁö ´ë¹ÌÁö¸¦ ¸·´Â´Ù.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_ARMS];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;

				case 4:
					if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] > 0) {
						// °©¿Ê¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö·üÀ» °è»ê: ÃÖ´ë 80%±îÁö ´ë¹ÌÁö¸¦ ¸·´Â´Ù.
						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD] >= 80)
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_HEAD];
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Armor = (int)dTmp3;
					}
					break;
				}

				if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield > 0) {
					if (iDice(1,100) <= (m_pClientList[sTargetH]->m_cSkillMastery[11])) {
						// ParryingÀÌ ¼º°øÇß´Ù.	¹æÆÐ¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö·üÀ» °è»ê: ÃÖ´ë ´ë¹ÌÁö¸¦ 80%±îÁö ¸·´Â´Ù.
						CalculateSSN_SkillIndex(sTargetH, 11, 1);

						if (m_pClientList[sTargetH]->m_iDamageAbsorption_Shield >= 80) 
							 dTmp1 = 80.0f;
						else dTmp1 = (double)m_pClientList[sTargetH]->m_iDamageAbsorption_Shield;
						dTmp2 = (double)iAP_SM;
						dTmp3 = (dTmp1 / 100.0f) * dTmp2;

						iAP_Abs_Shield = (int)dTmp3;

						// v1.3 ¹æÆÐÀÇ ¼ö¸íÀ» ÁÙÀÎ´Ù.
						iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LHAND];
						if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
							// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀ» °¨¼Ò½ÃÅ°Áö ¾Ê´Â´Ù.
							if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
								m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
							if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
								// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
								// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
								SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
								// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
								ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
							}
						}
					}
				}

				iAP_SM = iAP_SM - (iAP_Abs_Armor + iAP_Abs_Shield);
				if (iAP_SM <= 0) iAP_SM = 1;

				//v1.432 Æ¯¼ö ´É·Â 1ÀÌ È°¼ºÈ­ µÇ¾î ÀÖÀ¸¸é ´ëÀÎ °ø°Ý½Ã¿¡ ´ë¹ÌÁö 
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sAttackerH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sAttackerH]->m_iSpecialAbilityType) {
					case 0: break;
					case 1: // HP 50%¾¿ ´ë¹ÌÁö¸¦ ÀÔÈù´Ù. ¸¸¾à 50%ÀÇ ´ë¹ÌÁö°¡ ¿ø·¡ ´ë¹ÌÁöº¸´Ù Àû´Ù¸é ´ë¹ÌÁö´Â ±×´ë·ÎÀÌ´Ù.
						iTemp = (m_pClientList[sTargetH]->m_iHP / 2);
						if (iTemp > iAP_SM) iAP_SM = iTemp;
						if (iAP_SM <= 0) iAP_SM = 1;
						break;

					case 2: // 10ÃÊ°£ ³Ãµ¿ È¿°ú 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
							SetIceFlag(sTargetH, DEF_OWNERTYPE_PLAYER, TRUE);
							// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (10*1000), 
								                sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 1, NULL, NULL);
							
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
						}
						break;

					case 3: // 10ÃÊ°£ ¸¶ºñ È¿°ú 
						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 0) {
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = 2;
							// º¸È£ È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (10*1000), 
												sTargetH, DEF_OWNERTYPE_PLAYER, NULL, NULL, NULL, 10, NULL, NULL);
	
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, 10, NULL, NULL);
						}
						break;

					case 4: // ¿ø¼¦ ¿øÅ³
						iAP_SM = (m_pClientList[sTargetH]->m_iHP);
						break;

					case 5: // ÀÔÈù ´ë¹ÌÁö ¸¸Å­ °ø°ÝÀÚ°¡ HP¸¦ ¾ò´Â´Ù.
						m_pClientList[sAttackerH]->m_iHP += iAP_SM;
						if (iGetMaxHP(sAttackerH) < m_pClientList[sAttackerH]->m_iHP) m_pClientList[sAttackerH]->m_iHP = iGetMaxHP(sAttackerH);
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						break;
					}
				}

				// °ø°Ý´ë»óÀÌ ´É·ÂÀ» »ç¿ëÁßÀÌ¶ó¸é ¹æ¾îÈ¿°ú°¡ ÀÖ´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
					switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
					case 50: // °ø°Ý ¹«±âÀÇ ¼ö¸íÀ» 0À¸·Î ¸¸µç´Ù.
						if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
							 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
						else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
						if (sWeaponIndex != -1)	m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						break;

					case 51: // ÇØ´ç ºÎÀ§ ´ë¹ÌÁö ¹«È¿È­
						if (iHitPoint == m_pClientList[sTargetH]->m_iSpecialAbilityEquipPos)
							iAP_SM = 0;
						break;

					case 52: // ¸ðµç ´ë¹ÌÁö ¹«È¿È­
						iAP_SM = 0;
						break;
					}
				}

				if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
					(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iAP_SM)) {
					// Çà¿îÈ¿°ú·Î Á×À½À» ¸ð¸éÇÑ´Ù.
					iAP_SM = m_pClientList[sTargetH]->m_iHP - 1;
				}

				// v1.3 ÇÇ°Ý´çÇßÀ¸¹Ç·Î ÀåÂøÇÏ°í ÀÖ´Â ¸öÅë ¹æ¾î±¸ÀÇ ¼ö¸íÀ» ÁÙÀÎ´Ù. 
				switch (iHitPoint) {
				case 1:
					// ¸öÅë °©¿Ê 
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_BODY];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸í ÁÙÁö ¾Ê´Â´Ù.
						if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
							// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
							// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
						}
					}
					break;

				case 2:
					// ¹ÙÁö È¤Àº ½Å¹ß·ù ¹æ¾î±¸
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_PANTS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
						if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
							// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
							// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
						}
					}

					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_LEGGINGS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
						
						// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
						if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
							// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
							// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
						}
					}
					break;

				case 3:
					// ÆÈ°©¿Ê 
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_ARMS];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
						if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
							// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
							// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
						}
					}
					break;

				case 4:
					iTemp = m_pClientList[sTargetH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_HEAD];
					if ((iTemp != -1) && (m_pClientList[sTargetH]->m_pItemList[iTemp] != NULL)) {
							
						// v1.432 Áß¸³ÀÎ °æ¿ì ¼ö¸íÀÌ ÁÙÁö ¾ÊÀ½
						if ((m_pClientList[sTargetH]->m_cSide != 0) && (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan > 0))	
							m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan--;
							
						if (m_pClientList[sTargetH]->m_pItemList[iTemp]->m_wCurLifeSpan == 0) {
							// ¼ö¸íÀÌ ´Ù µÇ¾úÀ¸¹Ç·Î ÀåÂøÀ» ÇØÁ¦ÇÑ´Ù.
							// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sTargetH]->m_pItemList[iTemp]->m_cEquipPos, iTemp, NULL, NULL);
							// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
							ReleaseItemHandler(sTargetH, iTemp, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
						}
					}
					break;
				}

				// v1.411 ¸ñÇ¥¹°ÀÌ ¸¶¹ý º¸È£ÁßÀÌ¾ú°í °ø°ÝÀÚ°¡ ¸¶¹ý ¹æ¾î¸¦ ¹«È¿È­ ½ÃÅ°´Â °ø°Ý ´É·ÂÀÌ ÀÖ´Ù¸é 
				if ((cAttackerSA == 2) && (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_PROTECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_PROTECT);					  
				}

				// v1.411 ¸ñÇ¥¹°ÀÌ Áßµ¶µÇÁö ¾Ê¾Ò°í °ø°ÝÀÚ°¡ Áßµ¶ ´É·ÂÀÌ ÀÖ´Ù¸é 
				if ( (m_pClientList[sTargetH]->m_bIsPoisoned == FALSE) && 
					 ((cAttackerSA == 5) || (cAttackerSA == 6) || (cAttackerSA == 61)) ) {
					// µ¶¼ºÀúÇ×À» °è»êÇÑ´Ù.
					if (bCheckResistingPoisonSuccess(sTargetH, DEF_OWNERTYPE_PLAYER) == FALSE) {
						// Áßµ¶µÇ¾ú´Ù.
						m_pClientList[sTargetH]->m_bIsPoisoned  = TRUE;
						if (cAttackerSA == 5)		m_pClientList[sTargetH]->m_iPoisonLevel = 15;
						else if (cAttackerSA == 6)  m_pClientList[sTargetH]->m_iPoisonLevel = 40;
						else if (cAttackerSA == 61) m_pClientList[sTargetH]->m_iPoisonLevel = iAttackerSAvalue; // cAttackerSA°¡ 61ÀÌ¸é Áßµ¶ Á¤µµ°¡ ÁöÁ¤µÈ °ÍÀ» ÀÇ¹Ì 
						
						m_pClientList[sTargetH]->m_dwPoisonTime = dwTime;
						// Áßµ¶µÇ¾úÀ½À» ¾Ë¸°´Ù. 
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sTargetH]->m_iPoisonLevel, NULL, NULL);
					}
				}

				m_pClientList[sTargetH]->m_iHP -= iAP_SM;
				if (m_pClientList[sTargetH]->m_iHP <= 0) {
					// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
					
					// ¸¶À»³»¿¡¼­ ÇÇÄÉÀÌ¸¦ Çß´Ù¸é °æºñ°¡ ¼ÒÈ¯µÈ´Ù.
					if (cAttackerType == DEF_OWNERTYPE_PLAYER)
						bAnalyzeCriminalAction(sAttackerH, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					
					ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iAP_SM);	
					bKilled     = TRUE;
					iKilledDice = m_pClientList[sTargetH]->m_iLevel;
					// »ì»óÇÑ ÇÃ·¹ÀÌ¾îÀÇ ·¹º§ ¸¸Å­ÀÇ ÁÖ»çÀ§°ª¸¸Å­ÀÇ ½ºÅ³ Ä«¿îÆ®¸¦ º¸³Ê½º·Î ¿Ã¸± ¼ö ÀÖ´Ù.
				}
				else {
					if (iAP_SM > 0) {
						// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
						SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
												
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
							 sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
						else sAttackerWeapon = 1;
						
						// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 60ÀÌ»óÀÏ¶§ ¹Ð¸°´Ù.
						if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
							 iMoveDamage = 60;
						else iMoveDamage = 40;

						if (iAP_SM >= iMoveDamage) {
							//´ë¹ÌÁö°¡ 40ÀÌ»óÀÌ¸é ¸ÂÀº Å¸°ÝÀ¸·Î ¹°·¯³­´Ù.
							//¹æÇâÀ» °è»êÇÑ´Ù.
							
							if (sTgtX == sAtkX) {
								if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE;
								else if (sTgtY > sAtkY) cDamageMoveDir = 5;
								else if (sTgtY < sAtkY) cDamageMoveDir = 1;
							}
							else if (sTgtX > sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 3;
								else if (sTgtY > sAtkY) cDamageMoveDir = 4;
								else if (sTgtY < sAtkY) cDamageMoveDir = 2;
							}
							else if (sTgtX < sAtkX) {
								if (sTgtY == sAtkY)     cDamageMoveDir = 7;
								else if (sTgtY > sAtkY) cDamageMoveDir = 6;
								else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
							}

							// v1.44 ¹Ð·Á³¯¶§ ´ë¹ÌÁö¸¦ ÀÔ·ÂÇÑ´Ù.
							m_pClientList[sTargetH]->m_iLastDamage = iAP_SM;
						
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iAP_SM, sAttackerWeapon, NULL);
						}
						else {
CAE_SKIPDAMAGEMOVE:;
							int iProb;
							// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û: ´Ü ¹«±âº°·Î Ãæ°Ý µ¿ÀÛ È¸ÇÇ°¡ µÈ´Ù.
							if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
								switch (m_pClientList[sAttackerH]->m_sUsingWeaponSkill) {
								case 6 : iProb = 3500; break;		// È°½î±â
								case 8 : iProb = 2500; break;		// ±äÄ® °ø°Ý 
								case 10: iProb = 1200; break;		// µµ³¢ °ø°Ý
								default: iProb = 1; break;			// ±âÅ¸ °ø°Ý
								}
							}
							else iProb = 1;
												
							if (iDice(1,10000) >= iProb) 
								SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iAP_SM, sAttackerWeapon, NULL);		
						}

						if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
							// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ´Ü ÆÐ·²¶óÀÌÁî µÈ°ÍÀº Ç®¸®Áö ¾Ê´Â´Ù. 	
							// 1: Hold-Person 
							// 2: Paralize
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
							m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
						}

						// ¸Â¾ÒÀ¸¹Ç·Î ÇÊ»ì±â Ä«¿îÆ® Áõ°¡ 
						m_pClientList[sTargetH]->m_iSuperAttackCount++;
						if (m_pClientList[sTargetH]->m_iSuperAttackCount > 14) { 
							
							m_pClientList[sTargetH]->m_iSuperAttackCount = 0;
							// ÇÊ»ì±â´Â ÃÖ´ë Level/10 °³ ±îÁö ÃàÀûµÈ´Ù.
							iMaxSuperAttack = (m_pClientList[sTargetH]->m_iLevel / 10);
							if (m_pClientList[sTargetH]->m_iSuperAttackLeft < iMaxSuperAttack) m_pClientList[sTargetH]->m_iSuperAttackLeft++;
							
							// v1.12 ¼­¹ö¿Í Å¬¶óÀÌ¾ðÆ® °£¿¡ Ä«¿îÆ®°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â °æ¿ì°¡ ÀÖÀ» ¼ö ÀÖÀ¸¹Ç·Î °¡°¨¿¡ »ó°ü¾øÀÌ º¸³½´Ù.
							SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SUPERATTACKLEFT, NULL, NULL, NULL, NULL);
						}
					}
				}
			}
			break;				   

		case DEF_OWNERTYPE_NPC:
			// Á×Àº NPC¿¡ ´ëÇÑ °ø°ÝÀº ¹«ÀÇ¹Ì.
			if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return 0;
			if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return 0;
			
			if (m_bIsCrusadeMode == TRUE) {
				// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­ °°ÀºÆíÀÌ °ø°ÝÇÒ ¼ö ¾ø´Â À¯´ÏÆ®µé 
				if (cAttackerSide == m_pNpcList[sTargetH]->m_cSide) {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 40:
					case 41:
					case 43:
					case 44:
					case 45:
					case 46:
					case 47: return 0;
					default: break;
					}
				}
				else {
					switch (m_pNpcList[sTargetH]->m_sType) {
					case 41:
						if (cAttackerSide != 0) {
							// ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ°¡ ÀûÀÇ °ø°ÝÀ» ¹ÞÀ¸¸é ¹ß»ç ¼Óµµ°¡ Áö¿¬µÈ´Ù.
							m_pNpcList[sTargetH]->m_iV1 += iAP_L;
							if (m_pNpcList[sTargetH]->m_iV1 > 500) {
								// ´ë¹ÌÁö¸¦ 1000 ¹ÞÀ¸¸é ¸¶³ª½ºÅå ¾çÀÌ 1 ³»·Á°£´Ù.
								m_pNpcList[sTargetH]->m_iV1 = 0;
								m_pNpcList[sTargetH]->m_iManaStock--;
								if (m_pNpcList[sTargetH]->m_iManaStock <= 0) m_pNpcList[sTargetH]->m_iManaStock = 0;
							}
						}
						break;
					}
				}
			}
					
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 1:
			case 2:
				return 0;
			}

			// NPCÀÇ Ã¼·ÂÀ» °¨¼Ò½ÃÅ²´Ù. 
			// NPCÀÇ ±Þ¿¡ µû¶ó (SM:small-medium(0) L:large(1)) °ø°ÝÄ¡¸¦ ´Þ¸® °è»êÇÑ´Ù.
			if (m_pNpcList[sTargetH]->m_cSize == 0)	
				 iDamage = iAP_SM;
			else iDamage = iAP_L;
			
			// ¸ó½ºÅÍ°¡ ¹°¸® ´ë¹ÌÁö Èí¼ö·üÀÌ ÀÖ´Ù¸é(AbsDamage°¡ 0º¸´Ù ÀÛ´Ù) ¿ø·¡ ´ë¹ÌÁö¸¦ °¨¼Ò½ÃÅ²´Ù.
			if (m_pNpcList[sTargetH]->m_iAbsDamage < 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)(abs(m_pNpcList[sTargetH]->m_iAbsDamage))/100.0f;
				dTmp3 = dTmp1 * dTmp2;
				dTmp2 = dTmp1 - dTmp3;
				iDamage = (int)dTmp2;
				if (iDamage < 0) iDamage = 1;
			}

			// v1.411 ¸ñÇ¥¹°ÀÌ ¸¶¹ý º¸È£ÁßÀÌ¾ú°í °ø°ÝÀÚ°¡ ¸¶¹ý ¹æ¾î¸¦ ¹«È¿È­ ½ÃÅ°´Â °ø°Ý ´É·ÂÀÌ ÀÖ´Ù¸é 
			if ((cAttackerSA == 2) && (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0)) {
							
				m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = NULL;
				bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_PROTECT);					  
			}

			// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
			switch (m_pNpcList[sTargetH]->m_cActionLimit) {
			case 0: // ÀÏ¹Ý
			case 3: // ´õ¹Ì·ù
			case 5: // °ÇÃà¹° 
				m_pNpcList[sTargetH]->m_iHP -= iDamage;
				break;
			}
			
			if (m_pNpcList[sTargetH]->m_iHP <= 0) {
				// NPC°¡ »ç¸ÁÇß´Ù.
				NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
				
				bKilled = TRUE;
				iKilledDice = m_pNpcList[sTargetH]->m_iHitDice;
				// »ì»óÇÑ ¸ó½ºÅÍÀÇ HitDice ÁÖ»çÀ§°ª ¸¸Å­ÀÇ º¸³Ê½º ½ºÅ³ Ä«¿îÆ®¸¦ ¾ò´Â´Ù.
			}
			else {
				// °ø°Ý´çÇßÁö¸¸ »ì¾ÆÀÖ´Ù. ±âÈ¸°¡ µÈ´Ù¸é ¹Ý°ÝÇÑ´Ù.
				
				// ActionLimit°¡ 1ÀÌ¸é ¹Ý°ÝÀ» ÇÏÁö ¾Ê´Â´Ù. ¿ÀÁ÷ ¿òÁ÷ÀÏ¼ö¸¸ ÀÖÀ¸´Ï.
				// PermAttackMode°¡ ¼³Á¤µÇ¾î ÀÖ´Ù¸é °ø°Ý ¹Þ¾Æµµ ¸ñÇ¥¸¦ ¹Ù²ÙÁö ¾Ê´Â´Ù.
				
				// ÆíÀÌ °°À¸¸é ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
				if (m_pNpcList[sTargetH]->m_cSide == cAttackerSide) goto CAE_SKIPCOUNTERATTACK;

				if (m_pNpcList[sTargetH]->m_cActionLimit != 0) goto CAE_SKIPCOUNTERATTACK;
				if (m_pNpcList[sTargetH]->m_bIsPermAttackMode == TRUE) goto CAE_SKIPCOUNTERATTACK;
				// ¼ÒÈ¯¸÷ÀÌ°í Á¦¾î ¸ðµå°¡ Hold¶ó¸é ¸Â¾Æµµ ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
				if ((m_pNpcList[sTargetH]->m_bIsSummoned == TRUE) && 
					(m_pNpcList[sTargetH]->m_iSummonControlMode == 1)) goto CAE_SKIPCOUNTERATTACK;
				
				// ¹Ý°ÝÇÒ °ÍÀÎÁöÀÇ ¿©ºÎ¸¦ °áÁ¤ÇÑ´Ù. 
				if (iDice(1,3) == 2) {
					// °ø°ÝÇÑ ´ë»óÀÌ ÇöÀç ¸ñÇ¥¹°º¸´Ù °Å¸®°¡ °¡±õ´Ù¸é ¸ñÇ¥¹° ¹Ù²Û´Ù.
					if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_ATTACK) {
						tX = tY = 0;
						switch (m_pNpcList[sTargetH]->m_cTargetType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pClientList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex] != NULL) {
								tX = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sX;
								tY = m_pNpcList[m_pNpcList[sTargetH]->m_iTargetIndex]->m_sY;
							}
							break;
						}
						// ÇöÀç ¸ñÇ¥¹°°úÀÇ °Å¸® 
						iDst1 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						tX = tY = 0;
						switch (cAttackerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sAttackerH] != NULL) {
								tX = m_pClientList[sAttackerH]->m_sX;
								tY = m_pClientList[sAttackerH]->m_sY;
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sAttackerH] != NULL) {
								tX = m_pNpcList[sAttackerH]->m_sX;
								tY = m_pNpcList[sAttackerH]->m_sY;
							}
							break;
						}

						// °ø°Ý¹ÞÀº ¸ñÇ¥¹°°úÀÇ °Å¸® 
						iDst2 = (m_pNpcList[sTargetH]->m_sX - tX)*(m_pNpcList[sTargetH]->m_sX - tX) + (m_pNpcList[sTargetH]->m_sY - tY)*(m_pNpcList[sTargetH]->m_sY - tY);
				
						if (iDst2 <= iDst1) {
							// °ø°ÝÇÑ ´ë»óÀÌ ÇöÀç ¸ñÇ¥·Î ÇÏ°í ÀÖ´Â ´ë»óº¸´Ù °¡±îÀÌ¿¡ ÀÖ´Ù. ¸ñÇ¥¹° º¯°æ 
							m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
							m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
							m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
							m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
						}
					}
					else {
						m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
						m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
						m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
						m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
					}
				}
			
CAE_SKIPCOUNTERATTACK:;
				
				// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú. ÀÏ¹Ý À¯´ÏÆ®ÀÇ °æ¿ì¿¡¸¸ Àû¿ëµÊ.
				if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0))
					m_pNpcList[sTargetH]->m_dwTime = dwTime;
				
				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û
				if (cAttackerType == DEF_OWNERTYPE_PLAYER) 
					sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);
				else sAttackerWeapon = 1;
				
				if ((wWeaponType < 40) && (m_pNpcList[sTargetH]->m_cActionLimit == 4)) {
					// ActionLimit°¡ 4¸é ¸Â¾ÒÀ»¶§ ¹Ý´ë¹æÇâÀ¸·Î ÀÌµ¿ÇÏ´Â ¿ÀºêÁ§Æ®ÀÌ´Ù.
					// ÀÌµ¿ÇÒ ¹æÇâÀ» °è»êÇÑ´Ù.
					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto CAE_SKIPDAMAGEMOVE2;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// ´Ù½Ã ÇÑ¹ø ¹æÇâÀ» ·£´ýÇÏ°Ô ±¸ÇÑ´Ù.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// ÀÌº¥Æ® ¾Ë¸°´Ù.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
										
					// ÇÑ¹ø ´õ °£´Ù.
					dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
					dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
					
					if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) {
						// ´Ù½Ã ÇÑ¹ø ¹æÇâÀ» ·£´ýÇÏ°Ô ±¸ÇÑ´Ù.
						cDamageMoveDir = iDice(1,8);
						dX = m_pNpcList[sTargetH]->m_sX + _tmp_cTmpDirX[cDamageMoveDir];
						dY = m_pNpcList[sTargetH]->m_sY + _tmp_cTmpDirY[cDamageMoveDir];
						
						if (m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->bGetMoveable(dX, dY, NULL) == FALSE) goto CAE_SKIPDAMAGEMOVE2;
					}
						
					// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->ClearOwner(5, sTargetH, DEF_OWNERTYPE_NPC, m_pNpcList[sTargetH]->m_sX, m_pNpcList[sTargetH]->m_sY);
					// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
					m_pMapList[m_pNpcList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_NPC, dX, dY);
					m_pNpcList[sTargetH]->m_sX   = dX;
					m_pNpcList[sTargetH]->m_sY   = dY;
					m_pNpcList[sTargetH]->m_cDir = cDamageMoveDir;
					
					// ÀÌº¥Æ® ¾Ë¸°´Ù.
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
					
					// ¸ñÀûÁö¿¡ µµÂøÇß´ÂÁö °Ë»çÇÑ´Ù.
					if (bCheckEnergySphereDestination(sTargetH, sAttackerH, cAttackerType) == TRUE) {
						if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
							iExp = (m_pNpcList[sTargetH]->m_iExp/3);
							if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0)
							iExp += m_pNpcList[sTargetH]->m_iNoDieRemainExp;

							//v1.42 °æÇèÄ¡ Áõ°¡ 
							if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
								dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
								dTmp2 = (double)iExp;
								dTmp3 = (dTmp1/100.0f)*dTmp2;
								iExp += (int)dTmp3;
							}

							// Crusade
							if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

							m_pClientList[sAttackerH]->m_iExpStock += iExp;

							// NPC ¿ÀºêÁ§Æ® »èÁ¦
							DeleteNpc(sTargetH);
							return FALSE;
						}
					}

CAE_SKIPDAMAGEMOVE2:;
				}
				else {
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, sAttackerWeapon, NULL);
				}
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û.
				
				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é ±×´ë·Î Ç®¸°´Ù. 
					// 1: Hold-Person 
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}
				else if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 2) {
					// ¸¶ºñµÈ ¸ó½ºÅÍÀÇ HPdice°¡ ³ô´Ù¸é ÆÐ·²ÀÌ Ç®¸± °¡´É¼ºÀÌ ÀÖ´Ù. 
					// 2: Paralize
					if ((m_pNpcList[sTargetH]->m_iHitDice > 50) && (iDice(1, 10) == 5)) {
						m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
						bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
					}
				}
			
				// NPC¿¡ ´ëÇÑ °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°ÝÀÚ¿¡°Ô ÁØ´Ù. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// NPC°¡ ÇÃ·¹ÀÌ¾îÀÇ °ø°Ý¿¡ Á×¾ú´Ù¸é Exp¸¦ ¿Ã¸°´Ù. 
					// ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						iExp = iDamage;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}

					//v1.42 °æÇèÄ¡ Áõ°¡ 
					if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
						dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
						dTmp2 = (double)iExp;
						dTmp3 = (dTmp1/100.0f)*dTmp2;
						iExp += (int)dTmp3;
					}

					if (m_bIsCrusadeMode == TRUE) iExp = iExp/3;
				}
			}
			break;
		}

//CAE_SKIPCOUNTERATTACK:;

		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ¼ÒÁöÇÑ °ø°Ý¹«±âÀÇ ¼ö¸íÀ» °¨¼Ò½ÃÅ²´Ù. 
			if (m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1)
				 sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND];
			else sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
			
			if (sWeaponIndex != -1) {
				// ¸ÕÀú ¹«±â¸¦ »ç¿ëÇÔÀ¸·Î½á Áõ°¡ÇÏ´Â SSNÀ» °è»êÇÑ´Ù.
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) &&
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_sIDnum != 231) ) {
					// ÇÈ¾×½º¸¦ µé°í ÀÖ´Ù¸é ±¤¹°¿¡ ´ëÇÑ °ø°ÝÀÌ ¾Æ´Ï¸é ½ºÅ³ÀÌ ¿Ã¶ó¼­´Â ¾ÈµÈ´Ù.
					if (bKilled == FALSE)
						 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, 1);
					else {
						if (m_pClientList[sAttackerH]->m_iHP <= 3) // Ã¼·ÂÀÌ °ÅÀÇ ¾ø¾ú´Ù¸é 2¹è º¸³Ê½º 
							 CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice)*2);
						else CalculateSSN_ItemIndex(sAttackerH, sWeaponIndex, iDice(1, iKilledDice));
					}
				}
				
				if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
					 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
					// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
					// °Ë·ù ¹«±âÀÇ °æ¿ì ³¯¾¾¿¡ ÀÇÇÑ ¼ö¸íÁõ°¡°¡ »¡¶óÁø´Ù.
					iWepLifeOff = 1;
					if ((wWeaponType >= 1) && (wWeaponType < 40)) {
						switch (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cWhetherStatus) {
						case 0:	break;
						case 1:	if (iDice(1,3) == 1) iWepLifeOff++; break;
						case 2:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,2); break;
						case 3:	if (iDice(1,2) == 1) iWepLifeOff += iDice(1,3); break;
						}
					}

					// ¼ö¸íÀ» °¨¼Ò½ÃÅ²´Ù. ´Ü Áß¸³ÀÌ¸é °¨¼ÒÇÏÁö ¾Ê´Â´Ù.
					if (m_pClientList[sAttackerH]->m_cSide != 0) {
						if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan < iWepLifeOff) 
							m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan = 0;
						else m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan -= iWepLifeOff;
					}

					if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan == 0) {
						// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
						// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
						SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_cEquipPos, sWeaponIndex, NULL, NULL);
						// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
						ReleaseItemHandler(sAttackerH, sWeaponIndex, TRUE);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
					}
				}
			}
			else {
				if (wWeaponType == 0) {
					// ¸Ç¼Õ°ø°ÝÀÌ ¸íÁßÇß´Ù. Wrestling SSN Áõ°¡ 
					CalculateSSN_SkillIndex(sAttackerH, 5, 1);
				}
			}
		}
	}
	else {
		// °ø°ÝÀº ½ÇÆÐ. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			// °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é Ã³¸®ÇØ¾ß ÇÒ °ÍÀÌ ÀÖ´Ù.
			// 1. ¿¬Å¸ Ä«¿îÆ® Å¬¸®¾î
			m_pClientList[sAttackerH]->m_iComboAttackCount = 0;
		}
	}

	return iExp;
}


/*
void CGame::CalculateAttackEffect(short sTargetH, char cTargetType, short sAttackerH, char cAttackerType)
{
 register int iAP_SM, iAP_L, i, iAttackerTACH0, iTargetAC, iResult;
 char  cAttackerName[21];
 short sWeaponIndex;
 DWORD dwTime = timeGetTime();
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	// °ø°ÝÇÑ ÀÚÀÇ Attack Point¿Í TACH0¸¦ ¾ò´Â´Ù.
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		
		if (m_pClientList[sAttackerH] == NULL) return;
		// ÀüÅõ¸ðµå°¡ ¾Æ´Ñ »óÅÂ¶ó¸é °ø°ÝÀÇ ÀÇ¹Ì°¡ ¾ø´Ù.
		if ((m_pClientList[sAttackerH]->m_sAppr2 & 0xF000) == 0) return;

		iAP_SM = 0;
		iAP_L  = 0;
		// °ø°Ý±¼¸²
		
		iAP_SM = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_SM, m_pClientList[sAttackerH]->m_cAttackDiceRange_SM);
		iAP_L  = iDice(m_pClientList[sAttackerH]->m_cAttackDiceThrow_L, m_pClientList[sAttackerH]->m_cAttackDiceRange_L);

		// º¸³Ê½º °¡»ê 
		iAP_SM += m_pClientList[sAttackerH]->m_cAttackBonus_SM;
		iAP_L  += m_pClientList[sAttackerH]->m_cAttackBonus_L;
		
		iAttackerTACH0 = m_pClientList[sAttackerH]->m_iCurTHAC0;
		
		//°ø°Ý´ë»ó¿¡ µû¶ó ¸íÁß·ü µ¡¼À°ªÀÌ ´Þ¶óÁø´Ù.
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			// SM 
			iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM;
		}
		else {
			if (m_pNpcList[sTargetH]->m_cSize == 0)	{
				// SM
				iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM;
			}
			else {
				// L
				iAttackerTACH0 += m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_L;
			}
		}

		strcpy(cAttackerName, m_pClientList[sAttackerH]->m_cCharName);
		break;

	case DEF_OWNERTYPE_NPC:
		iAP_SM = 0;
		
		iAP_SM = iDice(m_pNpcList[sAttackerH]->m_cAttackDiceThrow, m_pNpcList[sAttackerH]->m_cAttackDiceRange);
		
		iAttackerTACH0 = m_pNpcList[sAttackerH]->m_iTHAC0;
		
		memcpy(cAttackerName, m_pNpcList[sAttackerH]->m_cNpcName, 20);
		break;
	}

	// TestCode
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		wsprintf(G_cTxt, "THAC0:%d THAC0_SM:%d THAC0_L:%d", iAttackerTACH0, m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_SM, m_pClientList[sAttackerH]->m_iCurTHAC0_ItemEffect_L);
		PutLogList(G_cTxt);
	}

	// °ø°Ý´çÇÑ ´ë»óÀÇ AC¸¦ ¾ò´Â´Ù. 
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// Á¸ÀçÇÏÁö ¾Ê´Â Ä³¸¯ÅÍ´Â °ø°ÝÇÒ ¼ö ¾ø´Ù. 
		if (m_pClientList[sTargetH] == NULL) return;

		iTargetAC = m_pClientList[sTargetH]->m_iCurAC;
		break;

	case DEF_OWNERTYPE_NPC:
		iTargetAC = m_pNpcList[sTargetH]->m_iAC;
		break;
	}

	// °ø°ÝÀÌ ¼º°øÇß´ÂÁöÀÇ ¿©ºÎ¸¦ °áÁ¤ÇÑ´Ù °ø°ÝÀÌ ½ÇÆÐÇÏ¸é ±×³É ¸®ÅÏ. 
	iResult = (iAttackerTACH0 - iTargetAC);

	// ¸¸¾à 0 È¤Àº À½¼öÄ¡°¡ ³ª¿À¸é °ø°ÝÀº ¹«Á¶°Ç ¼º°øÇÑ´Ù.
	if (iResult <= 0) goto ATTACK_SUCCESS;
	// ¸íÁß±¼¸²
	if ((iResult < 64) && (iResult >= 1)) {
		if (iResult > iDice(1,64)) return;
	}
	else if (iResult >= 64) {
		// ÁÖ»çÀ§ ´«º¸´Ù ´õ Å« ¼ö°¡ ¿ä±¸µÉ¶§ 64°¡  ³ª¿Í¾ß¸¸ ¼º°ø 
		if (iDice(1, 64) == 64) goto ATTACK_SUCCESS;
		return;
	}

ATTACK_SUCCESS:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// ¸¸¾à °ø°Ý¹ÞÀº Å¬¶óÀÌ¾ðÆ®°¡ 3ÃÊµ¿¾È ÀÀ´äÀÌ ¾ø¾ú´Ù¸é Ç¥ÁØ ÀÀ´ä½Ã°£ 7ÃÊÁß 4ÃÊµ¿¾ÈÀº ³×Æ®¿öÅ© »óÈ²¿¡ µû¸¥ º¸È£¸¦ ¹Þ´Â´Ù.
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > 3000) return;
		
		m_pClientList[sTargetH]->m_iHP -= iAP_SM;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType);	
		}
		else {
			if (iAP_SM > 0) {
				// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL);
			}
		}
		break;				   

	case DEF_OWNERTYPE_NPC:
		// Á×Àº NPC¿¡ ´ëÇÑ °ø°ÝÀº ¹«ÀÇ¹Ì.
		if (m_pNpcList[sTargetH]->m_cBehavior == DEF_BEHAVIOR_DEAD) return;
		// Action Limit°¡ 1ÀÌ¸é °ø°Ý¹Þ¾Æµµ ¾Æ¹« ÀÇ¹Ì°¡ ¾ø´Ù. (»óÁ¡ ÁÖÀÎ µîµî)
		if (m_pNpcList[sTargetH]->m_cActionLimit == 1) return;
		// NPCÀÇ Ã¼·ÂÀ» °¨¼Ò½ÃÅ²´Ù. 
		// NPCÀÇ ±Þ¿¡ µû¶ó (SM:small-medium(0) L:large(1)) °ø°ÝÄ¡¸¦ ´Þ¸® °è»êÇÑ´Ù.
		if (m_pNpcList[sTargetH]->m_cSize == 0)	{
			 m_pNpcList[sTargetH]->m_iHP -= iAP_SM;
			 
		}
		else {
			m_pNpcList[sTargetH]->m_iHP -= iAP_L;
			
		}

		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC°¡ »ç¸ÁÇß´Ù.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH);
		}
		else {
			// °ø°Ý´çÇßÁö¸¸ »ì¾ÆÀÖ´Ù. ¹Ý°ÝÇÑ´Ù.
			if (m_pNpcList[sTargetH]->m_cActionLimit != 1) {
				// ActionLimit°¡ 1ÀÌ¸é ¹Ý°ÝÀ» ÇÏÁö ¾Ê´Â´Ù. ¿ÀÁ÷ ¿òÁ÷ÀÏ¼ö¸¸ ÀÖÀ¸´Ï.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;
			
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û.
			}
		}
		break;
	}

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ¼ÒÁöÇÑ °ø°Ý¹«±âÀÇ ¼ö¸íÀ» °¨¼Ò½ÃÅ²´Ù. 
		sWeaponIndex = m_pClientList[sAttackerH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND];
		if (sWeaponIndex != -1) {
			if ( (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex] != NULL) && 
				 (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wMaxLifeSpan != 0) ) {
				// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
				m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan--;
				if (m_pClientList[sAttackerH]->m_pItemList[sWeaponIndex]->m_wCurLifeSpan <= 0) {
					// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
					// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
					SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_RHAND, sWeaponIndex, NULL);
					// ¾ÆÀÌÅÛÀ» ÀåÂø ÇØÁ¦ ½ÃÅ²´Ù.
					ReleaseItemHandler(sAttackerH, sWeaponIndex);  // <- ÀÌ ÇÔ¼ö´Â ¼­¹ö¿¡¼­ÀÇ È¿°ú¸¸ Ã³¸® 
				}
			}
		}
	}
}
*/

void CGame::NpcKilledHandler(short sAttackerH, char cAttackerType, int iNpcH, short sDamage)
{
 short  sAttackerWeapon;
 int    * ip, i, iQuestIndex, iExp, iConstructionPoint, iGuildGUID, iWarContribution;
 double dTmp1, dTmp2, dTmp3;
 char   * cp, cData[120];

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	m_pNpcList[iNpcH]->m_bIsKilled = TRUE;
	m_pNpcList[iNpcH]->m_iHP = 0;
	m_pNpcList[iNpcH]->m_iLastDamage = sDamage;

	// ¸ÊÀÇ »ì¾ÆÀÖ´Â °´Ã¼¼ö¸¦ ÁÙÀÎ´Ù. 
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalAliveObject--;

	// ÇöÀç ÀÌ NPC¸¦ °ø°Ý´ë»óÀ¸·Î »ï°íÀÖ´Â °´Ã¼µéÀ» ÇØÁ¦ÇÑ´Ù.
	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);

	// ÇöÀç ÀÌ NPC¸¦ µû¸£°í ÀÖ´ø NPCµéÀÇ ÀÌµ¿¹æ½ÄÀ» º¯°æÇÑ´Ù. 
	ReleaseFollowMode(iNpcH, DEF_OWNERTYPE_NPC); 

	// ÇöÀç ¸ñÇ¥·Î »ï°í ÀÖ´ø °´Ã¼¸¦ ÇØÁ¦ÇÑ´Ù.
	m_pNpcList[iNpcH]->m_iTargetIndex = NULL;
	m_pNpcList[iNpcH]->m_cTargetType  = NULL;
	// Á×´Â µ¿ÀÛ Àü¼Û.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[sAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(10, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetDeadOwner(iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
	// Á×Àº NPC´Â ÀÌµ¿ÇÒ ¼ö ¾ø´Ù. 
	m_pNpcList[iNpcH]->m_cBehavior = DEF_BEHAVIOR_DEAD;
	
	// ÅÏ Ä«¿îÆ® ÃÊ±âÈ­.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
	// Á×Àº ½Ã°£ ±â·Ï 
	m_pNpcList[iNpcH]->m_dwDeadTime = timeGetTime();

	// Æ÷»óÀÌ ¾ø´Â ¸ÊÀÌ¶ó¸é ¾ÆÀÌÅÛÀ» »ý¼º½ÃÅ°Áö ¾Ê´Â´Ù.
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;
	
	// v1.42 ¾ÆÀÌÅÛ µå·ÓÀ» °üÀåÇÑ´Ù.
	NpcDeadItemGenerator(iNpcH, sAttackerH, cAttackerType);

	// »õ·Î¿î °æÇèÄ¡ ¹èºÐ °ø½Ä.
	// NPC¿¡ ´ëÇÑ °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°ÝÀÚ¿¡°Ô ÁØ´Ù. 
	if ( (m_pNpcList[iNpcH]->m_bIsSummoned != TRUE) && (cAttackerType == DEF_OWNERTYPE_PLAYER) && 
		 (m_pClientList[sAttackerH] != NULL) ) {
		// NPC°¡ ÇÃ·¹ÀÌ¾îÀÇ °ø°Ý¿¡ Á×¾ú´Ù¸é ExpStockÀ» ¿Ã¸°´Ù. 
		// ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.	 ³ª¸ÓÁö °æÇèÄ¡¸¦ ¿Ã¸°´Ù.
		iExp = (m_pNpcList[iNpcH]->m_iExp/3);
		if (m_pNpcList[iNpcH]->m_iNoDieRemainExp > 0)
			iExp += m_pNpcList[iNpcH]->m_iNoDieRemainExp;

		//v1.42 °æÇèÄ¡ Áõ°¡ 
		if (m_pClientList[sAttackerH]->m_iAddExp != NULL) {
			dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddExp;
			dTmp2 = (double)iExp;
			dTmp3 = (dTmp1/100.0f)*dTmp2;
			iExp += (int)dTmp3;
		}

		// Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§ ¸ó½ºÅÍ¸¦ Á×¿©¼­ ¾òÀ» ¼ö ÀÖ´Â °æÇèÄ¡´Â 1/3
		if (m_bIsCrusadeMode == TRUE) {
			if (iExp > 10) iExp = iExp/3;
		}

		m_pClientList[sAttackerH]->m_iExpStock += iExp;

		// Quest ¿©ºÎ¸¦ ÆÇ´ÜÇÑ´Ù.
		iQuestIndex = m_pClientList[sAttackerH]->m_iQuest;
		if (iQuestIndex != NULL) {
			if (m_pQuestConfigList[iQuestIndex] != NULL) {
				switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
				case DEF_QUESTTYPE_MONSTERHUNT:
					if ( (m_pClientList[sAttackerH]->m_bQuestMatchFlag_Loc == TRUE) &&
						 (m_pQuestConfigList[iQuestIndex]->m_iTargetType == m_pNpcList[iNpcH]->m_sType) ) {
						// Á¶°Ç¿¡ ÇÕ´çÇÏ´Ù. Ä«¿îÆ® Áõ°¡ÈÄ ÆÇ´Ü.
						m_pClientList[sAttackerH]->m_iCurQuestCount++;
						_bCheckIsQuestCompleted(sAttackerH);
					}
					break;
				}
			}
		}
	}

	// v1.41 Æ¯¼ö¸ó½ºÅÍ°¡ Á×¾úÀ» °æ¿ìÀÇ Ã³¸® 
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 32:
			// À¯´ÏÄÜÀÌ Á×¾ú´Ù. Á×ÀÎ ÀÚ¿¡°Ô Æä³ÎÆ¼¸¦ ¹°¸°´Ù. 
			m_pClientList[sAttackerH]->m_iRating -= 5;
			if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = 0;
			if (m_pClientList[sAttackerH]->m_iRating >  10000) m_pClientList[sAttackerH]->m_iRating = 0;
			break;

		case 33:
			break;
		}
	}

	// Crusade
	iConstructionPoint = 0;
	switch (m_pNpcList[iNpcH]->m_sType) {
	// Å©·ç¼¼ÀÌµå¿ë À¯´ÏÆ®µéÀÌ´Ù. °Ç¼³ Æ÷ÀÎÆ®, º¸³Ê½º °æÇèÄ¡ °è»ê
	case 1:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 2:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 3:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 4:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 5:  iConstructionPoint = 50; iWarContribution = 100; break;
	case 6:  iConstructionPoint = 50; iWarContribution = 100; break;	// ¸Ó¼­³Ê¸®
	case 36: iConstructionPoint = 700; iWarContribution = 4000; break;	// ¾Ö·Î¿ì °¡µå Å¸¿ö 
	case 37: iConstructionPoint = 700; iWarContribution = 4000; break;	// Ä³³í °¡µå Å¸¿ö
	case 38: iConstructionPoint = 500; iWarContribution = 2000; break;	// ¸¶³ª ÄÝ·ºÅÍ
	case 39: iConstructionPoint = 500; iWarContribution = 2000; break;	// µðÅØÅÍ
	case 40: iConstructionPoint = 1500; iWarContribution = 5000; break;	// ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ
	case 41: iConstructionPoint = 5000; iWarContribution = 10000; break;	// ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ
	case 43: iConstructionPoint =  500; iWarContribution = 1000; break;	// ¶óÀÌÆ® ¿ö ºñÆ²
	case 44: iConstructionPoint = 1000; iWarContribution = 2000; break;	// °íÁî ÇÚµå ³ªÀÌÆ®
	case 45: iConstructionPoint = 1500; iWarContribution = 3000; break;	// °íÁî ÇÚµå ±âº´
	case 46: iConstructionPoint = 1000; iWarContribution = 2000; break;	// ÅÛÇÃ ³ªÀÌÆ®
	case 47: iConstructionPoint = 1500; iWarContribution = 3000; break;	// ¹èÆ² °ñ·½
	}
	
	// Crusade
	if (iConstructionPoint != NULL) {
		switch (cAttackerType) {
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
				// »çÀÌµå°¡ ´Þ¶ó¾ß¸¸ °Ç¼³ Æ÷ÀÎÆ®°¡ °è»êµÈ´Ù.
				m_pClientList[sAttackerH]->m_iConstructionPoint += iConstructionPoint;

				if (m_pClientList[sAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[sAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				m_pClientList[sAttackerH]->m_iWarContribution   += iWarContribution;
				if (m_pClientList[sAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[sAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				//testcode
				wsprintf(G_cTxt, "Enemy Npc Killed by player! Construction: +%d WarContribution: +%d", iConstructionPoint, iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			else {
				// °°ÀºÆí NPC¸¦ Á×ÀÌ¸é ÀüÀï °øÇåµµ°¡ 2¹è·Î ¶³¾îÁø´Ù.
				m_pClientList[sAttackerH]->m_iWarContribution   -= (iWarContribution*2);
				if (m_pClientList[sAttackerH]->m_iWarContribution < 0)
					m_pClientList[sAttackerH]->m_iWarContribution = 0;

				//testcode
				wsprintf(G_cTxt, "Friendly Npc Killed by player! WarContribution: -%d", iWarContribution);
				PutLogList(G_cTxt);

				SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[sAttackerH]->m_iConstructionPoint, m_pClientList[sAttackerH]->m_iWarContribution, NULL, NULL);
			}
			break;

		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sAttackerH]->m_iGuildGUID != NULL) {
				if (m_pNpcList[sAttackerH]->m_cSide != m_pNpcList[iNpcH]->m_cSide) {
					// ÀüÀï¿ë ±¸Á¶¹° È¤Àº À¯´ÏÆ®°¡ Àû NPC¸¦ Á×¿´´Ù. ¹Ù·Î Åëº¸ÇÑ´Ù.
					// ÇöÀç ¼­¹ö¿¡ ÁöÈÖ°üÀÌ ÀÖ´Ù¸é °ð¹Ù·Î Åëº¸. ¾øÀ¸¸é ´Ù¸¥ ¼­¹ö·Î ¾Ë·ÁÁÜ.
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[sAttackerH]->m_iGuildGUID) &&
						(m_pClientList[i]->m_iCrusadeDuty == 3)) {
						
						m_pClientList[i]->m_iConstructionPoint += iConstructionPoint;
						if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
							m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

						//testcode
						wsprintf(G_cTxt, "Enemy Npc Killed by Npc! Construct point +%d", iConstructionPoint);
						PutLogList(G_cTxt);
						// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
						SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
						goto NKH_GOTOPOINT1;
					}
				
					// ÇöÀç ¼­¹ö¿¡ ¾ø´Ù. ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
					ZeroMemory(cData, sizeof(cData));
					cp = (char *)cData;
					*cp = GSM_CONSTRUCTIONPOINT;
					cp++;
					ip = (int*)cp;
					*ip = m_pNpcList[sAttackerH]->m_iGuildGUID;
					cp += 4;
					ip = (int*)cp;
					*ip = iConstructionPoint;
					cp += 4;
					bStockMsgToGateServer(cData, 9);
				}
			}
			break;
		}
	}

NKH_GOTOPOINT1:;

	// v1.411 ¸¸¾à ExplosiveÇÑ ¸ó½ºÅÍ°¡ Á×Àº °Å¶ó¸é Explosive
	if (m_pNpcList[iNpcH]->m_cSpecialAbility == 7) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 30); 
	}
	else if (m_pNpcList[iNpcH]->m_cSpecialAbility == 8) {
		m_pNpcList[iNpcH]->m_iMana = 100;
		m_pNpcList[iNpcH]->m_iMagicHitRatio = 100;
		NpcMagicHandler(iNpcH, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 61); 
	}
}


void CGame::NpcBehavior_Dead(int iNpcH)			   
{
 DWORD dwTime;

	if (m_pNpcList[iNpcH] == NULL) return; 

	dwTime = timeGetTime();
	// ÅÏ Ä«¿îÆ® Áõ°¡.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;
	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 5) {
		// ¸ÕÀú ÅÏ Ä«¿îÆ® Å¬¸®¾î.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
	}
	// 
	if ((dwTime - m_pNpcList[iNpcH]->m_dwDeadTime) > m_pNpcList[iNpcH]->m_dwRegenTime)
		DeleteNpc(iNpcH);
}

int CGame::iGetDangerValue(int iNpcH, short dX, short dY)
{
 register int ix, iy, iDangerValue;
 short sOwner, sDOType;
 char  cOwnerType;
 DWORD dwRegisterTime;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;

	iDangerValue = 0;

	for (ix = dX - 2; ix <= dX + 2; ix++)
	for (iy = dY - 2; iy <= dY + 2; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwner, &cOwnerType, ix, iy);	
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bGetDynamicObject( ix, iy, &sDOType, &dwRegisterTime );
		
		if (sDOType == 1) iDangerValue++;

		switch (cOwnerType) {
		case NULL:
			break;
		case DEF_OWNERTYPE_PLAYER:
			if (m_pClientList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		case DEF_OWNERTYPE_NPC:
			if (m_pNpcList[sOwner] == NULL) break;
			if (m_pNpcList[iNpcH]->m_cSide != m_pNpcList[sOwner]->m_cSide) 
				 iDangerValue++;
			else iDangerValue--;
			break;
		}
	}

	return iDangerValue;
}

void CGame::NpcBehavior_Flee(int iNpcH)
{
 char cDir;
 short sX, sY, dX, dY;
 short sTarget;
 char  cTargetType;

	if (m_pNpcList[iNpcH] == NULL) return;
	if (m_pNpcList[iNpcH]->m_bIsKilled == TRUE) return;

	// ÅÏ Ä«¿îÆ® Áõ°¡. 
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	// °ø°Ý ÀÎ°øÁö´É¿¡ ´ëÇÑ È¿°ú°è»ê.
	switch (m_pNpcList[iNpcH]->m_iAttackStrategy) {
	case DEF_ATTACKAI_EXCHANGEATTACK: // °ø°Ý -> ÈÄÅð -> ... 
	case DEF_ATTACKAI_TWOBYONEATTACK: // °ø°Ý -> °ø°Ý -> ÈÄÅð -> ...
		if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 2) {
			// ´Ù½Ã °ø°Ý ¸ðµå·Î ÀüÈ¯.
			m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
			return;
		}
		break;
	
	default:
		if (iDice(1,2) == 1) NpcRequestAssistance(iNpcH);
		break;
	}

	if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount > 10) {
		// 10¹øÀÇ ÅÏ¸¸ µµ¸ÁÇÑ ÈÄ ´Ù½Ã ÀÌµ¿¸ðµå·Î º¯È¯.
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;	
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
		m_pNpcList[iNpcH]->m_tmp_iError         = 0;
		if (m_pNpcList[iNpcH]->m_iHP <= 3) {
			m_pNpcList[iNpcH]->m_iHP += iDice(1, m_pNpcList[iNpcH]->m_iHitDice); // ! ¿¡³ÊÁö ºÎÁ·À¸·Î µµ¸ÁÃÆÀ»¶§ ¼º°øÀûÀ¸·Î µµ¸ÁÃÆÀ¸¹Ç·Î ¿¡³ÊÁö Áõ°¡.
			if (m_pNpcList[iNpcH]->m_iHP <= 0) m_pNpcList[iNpcH]->m_iHP = 1;
		}
		return;
	}

	// µµ¸ÁÄ¡´Âµ¥ À§ÇùÀÌ µÇ´Â °¡±î¿î ¸ñÇ¥¹°À» °Ë»öÇÑ´Ù.
	TargetSearch(iNpcH, &sTarget, &cTargetType);				
	if (sTarget != NULL) {
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
	}

	// ¸ñÇ¥¹°°ú ÀÚ½ÅÀÇ À§Ä¡¸¦ ±¸ÇÑ´Ù. ¹Ý´ë¹æÇâÀ¸·Î µµ¸ÁÄ¡±â À§ÇÔ.
	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;
	switch (m_pNpcList[iNpcH]->m_cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		dX = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pClientList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	case DEF_OWNERTYPE_NPC:
		dX = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sX;
		dY = m_pNpcList[m_pNpcList[iNpcH]->m_iTargetIndex]->m_sY;
		break;
	}
	dX = sX - (dX - sX);
	dY = sY - (dY - sY);

	cDir = cGetNextMoveDir(sX, sY, dX, dY, m_pNpcList[iNpcH]->m_cMapIndex, m_pNpcList[iNpcH]->m_cTurn, &m_pNpcList[iNpcH]->m_tmp_iError);
	if (cDir == 0) {
		// ÀÌµ¿ÇÒ ¼ö ¾ø´Ù. 
	}
	else {
		dX = m_pNpcList[iNpcH]->m_sX + _tmp_cTmpDirX[cDir];
		dY = m_pNpcList[iNpcH]->m_sY + _tmp_cTmpDirY[cDir];
		// ¿¹Àü À§Ä¡¿¡¼­ Áö¿î´Ù. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetOwner(iNpcH, DEF_OWNERTYPE_NPC, dX, dY);
		m_pNpcList[iNpcH]->m_sX   = dX;
		m_pNpcList[iNpcH]->m_sY   = dY;
		m_pNpcList[iNpcH]->m_cDir = cDir;
		SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTMOVE, NULL, NULL, NULL);
	}
}


void CGame::MsgProcess()
{
 char   * pData, cFrom, cKey;
 DWORD    dwMsgSize, * dwpMsgID;
 WORD   * wpMsgType, * wp;
 int      i, iClientH;
 char   m_msgBuff[1000];

	if ((m_bF1pressed == TRUE) && (m_bF4pressed == TRUE) && (m_bOnExitProcess == FALSE)) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®ÀÇ µ¥ÀÌÅÍ¸¦ ÀúÀåÇÑ ÈÄ ÇÁ·Î±×·¥À» Á¾·áÇØ¾ß ÇÑ´Ù. 
		m_cShutDownCode      = 2;
		m_bOnExitProcess     = TRUE;
		m_dwExitProcessTime  = timeGetTime();
		// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
		PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Local command)!!!");
		// ·Î±× ¼­¹ö¿¡°Ô ÇöÀç ¼­¹ö°¡ ¼Ë´Ù¿î ÁßÀÓÀ» ¾Ë¸°´Ù. 
		bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
		// OccupyFlag µ¥ÀÌÅÍ ÀúÀå 
		if (m_iMiddlelandMapIndex > 0) {
			// Crusade
			SaveOccupyFlagData();
			//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
			//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
		}
		
		return;
	}
		
	ZeroMemory(m_pMsgBuffer, DEF_MSGBUFFERSIZE+1);
	pData = (char *)m_pMsgBuffer;

	m_iCurMsgs = 0;
	while (bGetMsgQuene(&cFrom, pData, &dwMsgSize, &iClientH, &cKey) == TRUE) {
		
		//v1.31 Ã³¸®ÇÏ°í ÀÖ´Â ¸Þ½ÃÁö °¹¼ö¸¦ Ä«¿îÆ®ÇÑ´Ù.
		m_iCurMsgs++;
		if (m_iCurMsgs > m_iMaxMsgs) m_iMaxMsgs = m_iCurMsgs;

		switch (cFrom) {
		case DEF_MSGFROM_GATESERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_SERVERSTOCKMSG:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SERVERSTOCKMSG");
				ServerStockMsgHandler(pData);
				break;
									
			case MSGID_SENDSERVERSHUTDOWNMSG:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_SENDSERVERSHUTDOWNMSG");
				// °ÔÀÓ¼­¹ö ¼Ë´Ù¿îÇÑ´Ù´Â ¸Þ½ÃÁö ¼ö½ÅµÇ¾ú´Ù. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				switch (*wp) {
				case 1:
					PutLogList("(!) Send server shutdown announcement - 1.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
					}
					break;
				
				case 2:
					PutLogList("(!) Send server shutdown announcement - 2.");
					for (i = 1; i < DEF_MAXCLIENTS; i++)
					if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
						SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
					}
					break;
				}

				// WLS·Î ¼Ë´Ù¿îÇÑ´Ù´Â ¸Þ½ÃÁö. ÀÌ ¸Þ½ÃÁö°¡ Àü´ÞµÇ¸é ÇØ´ç WLS ÀüÃ¼ÀÇ »õ »ç¿ëÀÚ¿¡ ´ëÇÑ Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. ÀÌ °ÔÀÓ¼­¹ö¸¸ ¹ÞÁö ¾Ê´Â°ÍÀÌ ¾Æ´Ï´Ù.
				bSendMsgToLS(MSGID_SENDSERVERSHUTDOWNMSG, NULL, NULL); 
				break;
			
			case MSGID_GAMESERVERSHUTDOWNED:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_GAMESERVERSHUTDOWNED");
				// °ÔÀÓ¼­¹ö¸¦ ¼Ë´Ù¿î½ÃÅ°¶ó´Â ±Û·Î¹ú ¸í·ÉÀÌ ¼ö½ÅµÇ¾ú´Ù. 
				m_cShutDownCode      = 1;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Global command)!!!");
				// ·Î±× ¼­¹ö¿¡°Ô ÇöÀç ¼­¹ö°¡ ¼Ë´Ù¿î ÁßÀÓÀ» ¾Ë¸°´Ù. 
				bSendMsgToLS(MSGID_GAMESERVERSHUTDOWNED, NULL);
				// OccupyFlag µ¥ÀÌÅÍ ÀúÀå 
				if (m_iMiddlelandMapIndex > 0) {
					// Crusade
					SaveOccupyFlagData();
					//bSendMsgToLS(MSGID_REQUEST_SAVEARESDENOCCUPYFLAGDATA, NULL, NULL);
					//bSendMsgToLS(MSGID_REQUEST_SAVEELVINEOCCUPYFLAGDATA, NULL, NULL);
				}
				break;
			
			case MSGID_TOTALGAMESERVERCLIENTS:
				// ÇöÀç ºÐ»ê °ÔÀÓ¼­¹öÀÇ ÃÑ »ç¿ëÀÚ ¼öÀÌ´Ù. 
				wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE + 2);
				m_iTotalGameServerClients = (int)*wp;
				if (m_iTotalGameServerClients > m_iTotalGameServerMaxClients) 
					m_iTotalGameServerMaxClients = m_iTotalGameServerClients;
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER");
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
					PutLogList("(!) Game Server registration to Gate Server - Success!");
					m_bIsGateSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_GATESERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
					PutLogList("(!) Game Server registration to Gate Server - Fail!");
					PutLogList(" ");
					PutLogList("(!!!) STOPPED!");
					break;
				}
				
				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);

				/*
				if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					// °ÔÀÓÀ» ½ÃÀÛÇÒ ÁØºñ°¡ µÇ¾ú´Ù. ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				}
				*/
				break;
			}
			break;
		
		case DEF_MSGFROM_CLIENT:
			dwpMsgID = (DWORD *)(pData + DEF_INDEX4_MSGID);
			switch (*dwpMsgID) {
						
			case MSGID_REQUEST_SELLITEMLIST:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_SELLITEMLIST");
				RequestSellItemListHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RESTART:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_RESTART");
				RequestRestartHandler(iClientH);
				break;

			case MSGID_REQUEST_PANNING:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_PANNING");
				iRequestPanningMapDataRequest(iClientH, pData);
				break;

			case MSGID_REQUEST_NOTICEMENT:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_NOTICEMENT");
				RequestNoticementHandler(iClientH, pData);
				break;
			
			case MSGID_BWM_COMMAND_SHUTUP:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_BWM_COMMAND_SHUTUP");
				_BWM_Command_Shutup(pData);
				break;
			
			case MSGID_BWM_INIT:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_BWM_INIT");
				_BWM_Init(iClientH, pData);
				break;
			
			case MSGID_REQUEST_SETITEMPOS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_SETITEMPOS");
				// ¾ÆÀÌÅÛÀÇ À§Ä¡¸¦ ±â¾ïÇÑ´Ù.
				_SetItemPos(iClientH, pData);
				break;
			
			case MSGID_ADMINUSER:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_ADMINUSER");
				// ¿î¿µÀÚ ¸ðµå·Î ÀüÈ¯À» ¿äÃ» 
				RequestAdminUserMode(iClientH, pData);
				break;
			
			case MSGID_REQUEST_FULLOBJECTDATA:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_FULLOBJECTDATA");
				// ¼Õ½ÇµÈ µ¥ÀÌÅÍ¸¦ ¿äÃ»Çß´Ù. 
				RequestFullObjectData(iClientH, pData);
				break;
			
			case MSGID_REQUEST_RETRIEVEITEM:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_RETRIEVEITEM");
				RequestRetrieveItemHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_CIVILRIGHT:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_CIVILRIGHT");
				// ½Ã¹Î±ÇÀ» ¿äÃ»Çß´Ù.
				RequestCivilRightHandler(iClientH, pData);
				break;

			case MSGID_REQUEST_TELEPORT:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_TELEPORT");
				// Å¬¶óÀÌ¾ðÆ®°¡ ÅÚ·¹Æ÷Æ® Å¸ÀÏ¿¡ µµÂøÇÏ¿© ¸ÊÀ» ¹Ù²Ù°í ´Ù¸¥ ¸ÊÀÇ ÃÊ±â µ¥ÀÌÅÍ¸¦ ¿äÃ»Çß´Ù.
				RequestTeleportHandler(iClientH, pData);
				break;
			
			case MSGID_REQUEST_INITPLAYER:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_INITPLAYER");
				// Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍ ÃÖÃÊ ¸Þ½ÃÁö. 
				RequestInitPlayerHandler(iClientH, pData, cKey);
				break;
			case MSGID_REQUEST_INITDATA:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_INITDATA");
				// ÃÊ±â ¸Ê µ¥ÀÌÅÍ ¿äÃ» 
				RequestInitDataHandler(iClientH, pData, cKey);
				break;
			case MSGID_COMMAND_COMMON:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON");
				ClientCommonHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_MOTION:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_MOTION");
				ClientMotionHandler(iClientH, pData);
				break;
			case MSGID_COMMAND_CHECKCONNECTION:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_CHECKCONNECTION");
				CheckConnectionHandler(iClientH, pData);
				// Á¢¼ÓÀ¯Áö¸¦ À§ÇØ Å¬¶óÀÌ¾ðÆ®°¡ 7ÃÊ¸¶´Ù ÇÑ¹ø¾¿ º¸³»¿À´Â ¸Þ½ÃÁö. ´Ù¸¥ ÀÇ¹Ì´Â ¾ø´Ù.
				break;
			case MSGID_COMMAND_CHATMSG:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_CHATMSG");
				// Ã¤ÆÃ ¸Þ½ÃÁöÀÌ´Ù. 
				ChatMsgHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_CREATENEWGUILD:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_CREATENEWGUILD");
				// Å¬¶óÀÌ¾ðÆ®°¡ »õ ±æµå »ý¼ºÀ» ¿ä±¸Çß´Ù.
				RequestCreateNewGuildHandler(iClientH, pData, dwMsgSize);
				break;
			case MSGID_REQUEST_DISBANDGUILD:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_DISBANDGUILD");
				// ±æµåÀÇ ÇØ»êÀ» ¿ä±¸Çß´Ù.
				RequestDisbandGuildHandler(iClientH, pData, dwMsgSize);
				break;
			// v1.4311-3 Ãß°¡ Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍ¿Â »çÅõÀå ¿¹¾à¿¡ °üÇÑ ¸Þ¼¼Áö  case MSGID_REQUEST_FIGHTZONE_RESERVE:
			case MSGID_REQUEST_FIGHTZONE_RESERVE:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_REQUEST_FIGHTZONE_RESERVE");
				// »çÅõÀå ¿¹¾àÀ» ¿äÃ»Çß´Ù. 
				FightzoneReserveHandler(iClientH, pData, dwMsgSize);
				break;

			case MSGID_LEVELUPSETTINGS:
				// ·¹º§¾÷ ¼ÂÆÃÀÌ´Ù.
				LevelUpSettingsHandler(iClientH, pData, dwMsgSize);
				break;

				// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤ Ãß°¡.....
			case MSGID_STATECHANGEPOINT:
				StateChangeHandler(iClientH, pData, dwMsgSize);
				break;

			default:
				wsprintf(m_msgBuff,"Unknown message received! (0x%.8X) Delete Client",*dwpMsgID);
				PutLogList(m_msgBuff);
				DeleteClient(iClientH, TRUE, TRUE); // v1.4
				break;
			}	
			break;

		case DEF_MSGFROM_LOGSERVER:
			dwpMsgID   = (DWORD *)(pData + DEF_INDEX4_MSGID);
			wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);

			switch (*dwpMsgID) {
			case MSGID_REQUEST_CHECKACCOUNTPASSWORD:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_CHECKACCOUNTPASSWORD");
				// °èÁ¤ÀÇ ÆÐ½º¿öµå¸¦ ºñ±³ 
				RequestCheckAccountPasswordHandler(pData, dwMsgSize);
				break;
			
			case MSGID_REQUEST_FORCEDISCONECTACCOUNT:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_REQUEST_FORCEDISCONECTACCOUNT");
				// °­Á¦ °èÁ¤ Á¢¼Ó Á¾·á. µ¥ÀÌÅÍ¸¦ ÀúÀåÇÏ°í Á¢¼ÓÀ» Á¾·á½ÃÅ²´Ù. 
				wpMsgType  = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
				ForceDisconnectAccount((char *)(pData + DEF_INDEX2_MSGTYPE + 2), *wpMsgType);
				break;
			
			case MSGID_RESPONSE_SAVEPLAYERDATA_REPLY:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_SAVEPLAYERDATA_REPLY");
				// Ä³¸¯ÅÍÀÇ µ¥ÀÌÅÍ°¡ ÀúÀåµÇ¾úÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö 
				ResponseSavePlayerDataReplyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_GUILDNOTIFY:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_GUILDNOTIFY");
				// ´Ù¸¥ °ÔÀÓ¼­¹ö¿¡¼­ ¹ß»ýÇÑ ±æµå ÀÌº¥Æ®¿¡ ´ëÇÑ Åëº¸(±æµå¿ø °¡ÀÔ, ±æµå¿ø Å»Åð, ±æµå ÇØ»ê µî)
				GuildNotifyHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_DISBANDGUILD:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_DISBANDGUILD");
				// ±æµå ÇØ»ê¿ä±¸¿¡ ´ëÇÑ ÀÀ´ä 
				ResponseDisbandGuildHandler(pData, dwMsgSize);
				break;

			case MSGID_RESPONSE_CREATENEWGUILD:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_CREATENEWGUILD");
				// Ä³¸¯ÅÍÀÇ ±æµå»ý¼º ¿ä±¸¿¡ ´ëÇÑ ÀÀ´ä. 
				ResponseCreateNewGuildHandler(pData, dwMsgSize);
				break;
			
			case MSGID_RESPONSE_REGISTERGAMESERVER:
				switch (*wpMsgType) {
				case DEF_MSGTYPE_CONFIRM:
					DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_CONFIRM");
					PutLogList("(!) Game Server registration to Log Server - Success!");
					m_bIsLogSockAvailable = TRUE;
					break;

				case DEF_MSGTYPE_REJECT:
					DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_REGISTERGAMESERVER -> DEF_MSGTYPE_REJECT");
					PutLogList("(!) Game Server registration to Log Server - Fail!");
					break;
				}
		
				if (m_bIsBuildItemAvailable == FALSE) {
					// ¸¸¾à ºôµå¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Build-Item configuration error.");
				}

				if (m_bIsItemAvailable == FALSE) {
					// ¸¸¾à ¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Item configuration error.");
				}
				
				if (m_bIsNpcAvailable == FALSE) {
					// ¸¸¾à ¾ÆÀÌÅÛ Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! Npc configuration error.");
				}

				if (m_bIsMagicAvailable == FALSE) {
					// ¸¸¾à MAGIC Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! MAGIC configuration error.");
				}

				if (m_bIsSkillAvailable == FALSE) {
					// ¸¸¾à SKILL Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! SKILL configuration error.");
				}

				if (m_bIsQuestAvailable == FALSE) {
					// ¸¸¾à SKILL Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! QUEST configuration error.");
				}

				if (m_bIsPortionAvailable == FALSE) {
					// ¸¸¾à Portion Á¤ÀÇ È­ÀÏ¿¡¼­ ¿¡·¯°¡ ÀÖ¾ú´Ù¸é °ÔÀÓ¼­¹ö µî·Ï¿¡ »ó°ü¾øÀÌ µ¿ÀÛ ºÒ°¡´É.
					PutLogList(" ");
					PutLogList("(!!!) STOPPED! PORTION configuration error.");
				}

				//wsprintf(G_cTxt, "%d %d %d %d %d %d %d", (int)m_bIsGameStarted, (int)m_bIsItemAvailable, m_bIsNpcAvailable, (int)m_bIsGateSockAvailable, (int)m_bIsLogSockAvailable, (int)m_bIsMagicAvailable, (int)m_bIsSkillAvailable);
				//PutLogList(G_cTxt);

				/*
				if ((m_bIsGameStarted == FALSE) && (m_bIsItemAvailable == TRUE) && 
					(m_bIsNpcAvailable == TRUE) && (m_bIsGateSockAvailable == TRUE) &&
					(m_bIsLogSockAvailable == TRUE) && (m_bIsMagicAvailable == TRUE) &&
					(m_bIsSkillAvailable == TRUE) && (m_bIsPortionAvailable == TRUE) &&
					(m_bIsQuestAvailable == TRUE) ) {
					// °ÔÀÓÀ» ½ÃÀÛÇÒ ÁØºñ°¡ µÇ¾ú´Ù. ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					SendMessage(m_hWnd, WM_USER_STARTGAMESIGNAL, NULL, NULL); 
					m_bIsGameStarted = TRUE;
				}
				*/
				break;

			case MSGID_RESPONSE_PLAYERDATA:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_RESPONSE_PLAYERDATA");
				// ÇÃ·¹ÀÌ¾î µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
				ResponsePlayerDataHandler(pData, dwMsgSize);
				break;

			case MSGID_BUILDITEMCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_BUILDITEMCONFIGURATIONCONTENTS");
				// Build Item contents
				PutLogList("(!) BUILD-ITEM configuration contents received. Now decoding...");
				m_bIsBuildItemAvailable = _bDecodeBuildItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_ITEMCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_ITEMCONFIGURATIONCONTENTS");
				// ·Î±×¼­¹ö·ÎºÎÅÍ ¾ÆÀÌÅÛ ÄÁÇÇ±Ô·¹ÀÌ¼Ç µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù.
				PutLogList("(!) ITEM configuration contents received. Now decoding...");
				m_bIsItemAvailable = _bDecodeItemConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NPCCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NPCCONFIGURATIONCONTENTS");
				// NPC ÄÁÇÇ±Ô·¹ÀÌ¼Ç µ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
				PutLogList("(!) NPC configuration contents received. Now decoding...");
				m_bIsNpcAvailable = _bDecodeNpcConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			
			case MSGID_MAGICCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_MAGICCONFIGURATIONCONTENTS");
				PutLogList("(!) MAGIC configuration contents received. Now decoding...");
				m_bIsMagicAvailable = _bDecodeMagicConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_SKILLCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_SKILLCONFIGURATIONCONTENTS");
				PutLogList("(!) SKILL configuration contents received. Now decoding...");
				m_bIsSkillAvailable = _bDecodeSkillConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_QUESTCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_QUESTCONFIGURATIONCONTENTS");
				PutLogList("(!) QUEST configuration contents received. Now decoding...");
				m_bIsQuestAvailable = _bDecodeQuestConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_PORTIONCONFIGURATIONCONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_PORTIONCONFIGURATIONCONTENTS");
				PutLogList("(!) PORTION configuration contents received. Now decoding...");
				m_bIsPortionAvailable = _bDecodePortionConfigFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			// Crusade
			//case MSGID_ARESDENOCCUPYFLAGSAVEFILECONTENTS:
				//PutLogList("(!) Aresden OccupyFlag save file contents received. Now decoding...");
				//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 1);
				//break;

			// Crusade
			//case MSGID_ELVINEOCCUPYFLAGSAVEFILECONTENTS:
				//PutLogList("(!) Elvine OccupyFlag save file contents received. Now decoding...");
				//_bDecodeOccupyFlagSaveFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize, 2);
				//break;

			case MSGID_DUPITEMIDFILECONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_DUPITEMIDFILECONTENTS");
				PutLogList("(!) DupItemID file contents received. Now decoding...");
				_bDecodeDupItemIDFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;

			case MSGID_NOTICEMENTFILECONTENTS:
				DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_LOGSERVER -> MSGID_NOTICEMENTFILECONTENTS");
				PutLogList("(!) Noticement file contents received. Now decoding...");
				_bDecodeNoticementFileContents((char *)(pData + DEF_INDEX2_MSGTYPE + 2), dwMsgSize);
				break;
			}
			break;
		}
	}

}


BOOL CGame::bPutMsgQuene(char cFrom, char * pData, DWORD dwMsgSize, int iIndex, char cKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// ¸Þ½ÃÁö Å¥°¡ ´Ù Ã¡´Ù¸é ¿¡·¯ 
	if (m_pMsgQuene[m_iQueneTail] != NULL) return FALSE;

	// ¸Þ¸ð¸® ÇÒ´çÀÌ Àß¸øµÇ¾îµµ ¿¡·¯ 
	m_pMsgQuene[m_iQueneTail] = new class CMsg;
	if (m_pMsgQuene[m_iQueneTail] == NULL) return FALSE;

	if (m_pMsgQuene[m_iQueneTail]->bPut(cFrom, pData, dwMsgSize, iIndex, cKey) == FALSE) return FALSE;

	m_iQueneTail++;
	if (m_iQueneTail >= DEF_MSGQUENESIZE) m_iQueneTail = 0;

	// ¹ÂÅØ½º ¹ÝÈ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}


BOOL CGame::bGetMsgQuene(char * pFrom, char * pData, DWORD * pMsgSize, int * pIndex, char * pKey)
{
	/*
	HANDLE hMutex;
	
	hMutex = OpenMutex(MUTEX_ALL_ACCESS, FALSE, m_cServerName);
	if (hMutex != NULL) return FALSE; // ¹ÂÅØ½º°¡ »ý¼ºµÇ¾î ÀÖ´Ù. ¾îµð¼±°¡ Å¥¸¦ Á¶ÀÛÁßÀÌ´Ù. ±×³É ¸®ÅÏ 

	hMutex = CreateMutex(NULL, FALSE, m_cServerName);
	*/
	// °¡Á®°¥ ¸Þ½ÃÁö°¡ ¾øÀ¸¸é ¿¡·¯  
	if (m_pMsgQuene[m_iQueneHead] == NULL) return FALSE;

	m_pMsgQuene[m_iQueneHead]->Get(pFrom, pData, pMsgSize, pIndex, pKey);

	delete m_pMsgQuene[m_iQueneHead];
	m_pMsgQuene[m_iQueneHead] = NULL;

	m_iQueneHead++;
	if (m_iQueneHead >= DEF_MSGQUENESIZE) m_iQueneHead = 0;

	// ¹ÂÅØ½º ¹ÝÈ¯
	//ReleaseMutex(hMutex);

	return TRUE;
}


void CGame::ClientCommonHandler(int iClientH, char * pData)
{
 WORD * wp, wCommand;
 short * sp, sX, sY; 
 int   * ip, iV1, iV2, iV3, iV4;
 char  * cp, cDir, * pString;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wCommand = *wp;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	cDir = *cp;
	cp++;
 
	ip = (int *)cp;
	iV1 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV2 = *ip;
	cp += 4;

	ip = (int *)cp;
	iV3 = *ip;
	cp += 4;

	pString = cp;
	cp += 30;
	
	ip = (int *)cp;
	iV4 = *ip;
	cp += 4;
	
	
	switch (wCommand) {
	case DEF_COMMONTYPE_SETGUILDTELEPORTLOC:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDTELEPORTLOC");
		RequestSetGuildTeleportLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;

	case DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETGUILDCONSTRUCTLOC");
		RequestSetGuildConstructLocHandler(iClientH, iV1, iV2, m_pClientList[iClientH]->m_iGuildGUID, pString);
		break;
	
	case DEF_COMMONTYPE_GUILDTELEPORT:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GUILDTELEPORT");
		RequestGuildTeleportHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_SUMMONWARUNIT:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SUMMONWARUNIT");
		RequestSummonWarUnitHandler(iClientH, sX, sY, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQUEST_HELP:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_HELP");
		RequestHelpHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_MAPSTATUS:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_MAPSTATUS");
		MapStatusHandler(iClientH, iV1, pString);
		break;

	case DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_SELECTCRUSADEDUTY");
		SelectCrusadeDutyHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CANCELQUEST:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CANCELQUEST");
		CancelQuestHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_ACTIVATESPECABLTY");
		ActivateSpecialAbilityHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQUEST_JOINPARTY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_JOINPARTY");
		JoinPartyHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_REQUEST_CREATENEWPARTY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQUEST_CREATENEWPARTY");
		CreateNewPartyHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_GETMAGICABILITY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GETMAGICABILITY");
		GetMagicAbilityHandler(iClientH);
		break;

	case DEF_COMMONTYPE_BUILDITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_BUILDITEM");
		BuildItemHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_QUESTACCEPTED:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_QUESTACCEPTED");
		QuestAcceptedHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_CANCELEXCHANGEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CANCELEXCHANGEITEM");
		CancelExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_CONFIRMEXCHANGEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_CONFIRMEXCHANGEITEM");
		ConfirmExchangeItem(iClientH);
		break;
	
	case DEF_COMMONTYPE_SETEXCHANGEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_SETEXCHANGEITEM");
		SetExchangeItem(iClientH, iV1, iV2);
		break;
	
	case DEF_COMMONTYPE_REQ_GETHEROMANTLE:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETHEROMANTLE");
		GetHeroMantleHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_GETOCCUPYFLAG:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFLAG");
		GetOccupyFlagHandler(iClientH);
		break;

	case DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SETDOWNSKILLINDEX");
		SetDownSkillIndexHandler(iClientH, iV1);
		break;

	case DEF_COMMONTYPE_TALKTONPC:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TALKTONPC");
		NpcTalkHandler(iClientH, iV1);
		break;
	
	case DEF_COMMONTYPE_REQ_CREATEPORTION:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_CREATEPORTION");
		ReqCreatePortionHandler(iClientH, pData);
		break;
	
	case DEF_COMMONTYPE_REQ_GETFISHTHISTIME:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETFISHTHISTIME");
		ReqGetFishThisTimeHandler(iClientH);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEMCONFIRM");
		ReqRepairItemCofirmHandler(iClientH, iV1, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_REPAIRITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_REPAIRITEM");
		ReqRepairItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEMCONFIRM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEMCONFIRM");
		ReqSellItemConfirmHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_SELLITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_SELLITEM");
		ReqSellItemHandler(iClientH, iV1, iV2, iV3, pString);
		break;
	
	case DEF_COMMONTYPE_REQ_USESKILL:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USESKILL");
		UseSkillHandler(iClientH, iV1, iV2, iV3);
		break;
	
	case DEF_COMMONTYPE_REQ_USEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_USEITEM");
		UseItemHandler(iClientH, iV1, iV2, iV3, iV4);
		break;
	
	case DEF_COMMONTYPE_REQ_GETREWARDMONEY:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETREWARDMONEY");
		GetRewardMoneyHandler(iClientH);
		break;

	case DEF_COMMONTYPE_ITEMDROP:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_ITEMDROP");
		DropItemHandler(iClientH, iV1, iV2, pString);
		break;
	
	case DEF_COMMONTYPE_EQUIPITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EQUIPITEM");
		// ¿©±â¼­´Â Æ¯¼ºÄ¡ º¯È­¸¸À» ´Ù·é´Ù.
		bEquipItemHandler(iClientH, iV1);
		// ¹Ù²ï ¿ÜÇü¿¡ ´ëÇÑ Á¤º¸¸¦ ¿©±â¼­ Àü¼ÛÇÑ´Ù.
		// .....
		break;

	case DEF_COMMONTYPE_REQ_PURCHASEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_PURCHASEITEM");
		// ¾ÆÀÌÅÛ ±¸ÀÔ ¿ä±¸. »ç½Ç ¾ÆÀÌÅÛÀº Àå¼Ò¿¡ »ó°ü¾øÀÌ ¾îµð¼­¶óµµ ±¸ÀÔÇÒ ¼ö ÀÖ´Ù.
		RequestPurchaseItemHandler(iClientH, pString, iV1);
		break;

	case DEF_COMMONTYPE_REQ_STUDYMAGIC:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_STUDYMAGIC");
		// ¸¶¹ýÀ» ¹è¿î´Ù 
		RequestStudyMagicHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_REQ_TRAINSKILL:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_TRAINSKILL");
		//RequestTrainSkillHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_GIVEITEMTOCHAR:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_GIVEITEMTOCHAR");
		// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô Àü´ÞÇÑ´Ù.
		GiveItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_EXCHANGEITEMTOCHAR:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_EXCHANGEITEMTOCHAR");
		ExchangeItemHandler(iClientH, cDir, iV1, iV2, iV3, iV4, pString);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDAPPROVE");
		JoinGuildApproveHandler(iClientH, pString);
		break;
	
	case DEF_COMMONTYPE_JOINGUILDREJECT:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_JOINGUILDREJECT");
		JoinGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDAPPROVE");
		DismissGuildApproveHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_DISMISSGUILDREJECT");
		DismissGuildRejectHandler(iClientH, pString);
		break;

	case DEF_COMMONTYPE_RELEASEITEM:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_RELEASEITEM");
		// Å¬¶óÀÌ¾ðÆ®°¡ ÀåÂøµÈ ¾ÆÀÌÅÛÀ» ÇØÁ¦Çß´Ù.
		ReleaseItemHandler(iClientH, iV1, TRUE);
		break;

	case DEF_COMMONTYPE_TOGGLECOMBATMODE:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLECOMBATMODE");
		ToggleCombatModeHandler(iClientH);
		break;

	case DEF_COMMONTYPE_MAGIC:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_MAGIC");
		PlayerMagicHandler(iClientH, iV1, iV2, (iV3 - 100));
		break;

	case DEF_COMMONTYPE_TOGGLESAFEATTACKMODE:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_TOGGLESAFEATTACKMODE");
		ToggleSafeAttackModeHandler(iClientH);
		break;

	// v1.4311-3 Ãß°¡ ÀÔÀå±Ç ¹Þ±â  case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
	case DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET:
		DbgWnd->AddEventMsg("RECV -> DEF_MSGFROM_CLIENT -> MSGID_COMMAND_COMMON -> DEF_COMMONTYPE_REQ_GETOCCUPYFIGHTZONETICKET");
		GetFightzoneTicketHandler(iClientH);
		break;

	}
}

void CGame::DropItemHandler(int iClientH, short sItemIndex, int iAmount, char * pItemName)
{
 class CItem * pItem;
	
	// 
	// Amount°¡ -1ÀÌ¸é ¼Ò¸ðÇ°ÀÏ°æ¿ì ÀüºÎ¸¦, ÀÏ¹Ý ¾ÆÀÌÅÛÀº ±×³É ¶³¾î¶ß¸°´Ù´Â ÀÇ¹Ì 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((iAmount != -1) && (iAmount < 0)) return;

	// Amount°¡ -1ÀÌ°í ¼Ò¸ðÇ°ÀÌ¸é ¼ö·®ÀÇ ÀüºÎ¸¦ ¶³¾î¶ß¸°´Ù.
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (iAmount == -1) ) 
		 iAmount = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount;

	
	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½Ã 
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) return;
	
	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		   (((int)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount - iAmount) > 0) ) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é 
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸ 
			delete pItem;
			return;
		}
		else {
			if (iAmount <= 0) {
				// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ 0º¸´Ù ÀÛÀ¸¸é ¿¡·¯»óÈ². ¸®ÅÏ 
				delete pItem;
				return;
			}
			pItem->m_dwCount = (DWORD)iAmount;
		}

		// ¼ö·® °¨¼Ò 
		
		// ¿¡·¯. °¨¼Ò½ÃÅ°°íÀÚ ÇÏ´Â ¾çÀÌ ´õ ¸¹´Ù. 
		if ((DWORD)iAmount > m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount) {
			delete pItem;
			return;
		}

		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;
		
		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!!
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);

		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
		                                                         m_pClientList[iClientH]->m_sY, pItem);

		// v1.411 Èñ±Í ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀÎÁö Ã¼Å©  
		_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, NULL);
	}
	else {
		// ÀÏ¹Ý ¾ÆÀÌÅÛÀÌ³ª ¼Òºñ¼º ¾ÆÀÌÅÛÀ» ¸ðµÎ ¹ö·È´Ù.

		// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// v1.432
		if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ALTERITEMDROP) && 
			(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0)) {
			// Èñ»ýÀÇ µ¹ÀÎ °æ¿ì ¼ö¸íÀÌ 0ÀÎ »óÅÂ·Î ¶³¾îÁö¸é »ç¶óÁø´Ù.
			delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
			m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		}
		else {
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
 																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

			// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
		
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); //v1.4 color
		}

		// ¾ÆÀÌÅÛÀ» deleteÇÏÁö ¾Ê°í NULL·Î ÇÒ´çÇÑ´Ù. delete ÇÏÁö ¾Ê´Â ÀÌÀ¯´Â ¹Ù´Ú¿¡ ¶³¾îÁ® ÀÖ±â ¶§¹® 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

		// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		
		// ÀÎµ¦½º°¡ ¹Ù²î¾úÀ¸¹Ç·Î ÀçÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

int CGame::iClientMotion_GetItem_Handler(int iClientH, short sX, short sY, char cDir)
{
 DWORD * dwp, dwTime;
 WORD  * wp;
 char  * cp;
 short * sp, sRemainItemSprite, sRemainItemSpriteFrame;
 char  cRemainItemColor, cData[100];
 int   iRet, iEraseReq;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// ÁËÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â ¸í·ÉÀº ¹«½ÃÇÑ´Ù. Reject¸Þ½ÃÁö¸¦ ¹Þ±â ÀÌÀü¿¡ Àü¼ÛµÈ ¸Þ½ÃÁöµéÀÌ´Ù.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
	ClearSkillUsingStatus(iClientH);

	// Á×Àº À§Ä¡¿¡ ÀÖ¾ú´Ù¸é Áö¿î´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// ´Ù½Ã À§Ä¡ ½ÃÅ²´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(sX, sY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor); // v1.4
	if (pItem != NULL) {
		// ÇÃ·¹ÀÌ¾î°¡ ¾ÆÀÌÅÛÀ» È¹µæÇÏ¿´´Ù. 
		
		if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
			// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.

			// v1.41 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
			_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_ITEMOBTAINED;
			
			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

			// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
			*cp = 1;
			cp++;

			memcpy(cp, pItem->m_cName, 20);
			cp += 20;

			dwp  = (DWORD *)cp;
			*dwp = pItem->m_dwCount;
			cp += 4;

			*cp = pItem->m_cItemType;
			cp++;

			*cp = pItem->m_cEquipPos;
			cp++;

			*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
			cp++;

			sp  = (short *)cp;
			*sp = pItem->m_sLevelLimit;
			cp += 2;

			*cp = pItem->m_cGenderLimit;
			cp++;

			wp = (WORD *)cp;
			*wp = pItem->m_wCurLifeSpan;
			cp += 2;
			 
			wp = (WORD *)cp;
			*wp = pItem->m_wWeight;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSprite;
			cp += 2;

			sp  = (short *)cp;
			*sp = pItem->m_sSpriteFrame;
			cp += 2;

			*cp = pItem->m_cItemColor; // v1.4
			cp++;

			*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
			cp++;
			
			dwp = (DWORD *)cp;
			*dwp = pItem->m_dwAttribute;
			cp += 4;
			/*
			*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
			cp++;
			*/

			if (iEraseReq == 1) delete pItem;

			// ¾ÆÀÌÅÛÀ» ÁÝ°í³­ ÈÄ ³²Àº ¾ÆÀÌÅÛÀ» ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
				                        sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor);

			// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
		else 
		{
			// °ø°£ÀÌ ºÎÁ·ÇÏ°Å³ª ÇÑ°èÁß·®À» ÃÊ°úÇß´Ù. ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
			
			// °¡Á®¿Ô´ø ¾ÆÀÌÅÛÀ» ¿ø»óÈ¸º¹½ÃÅ²´Ù. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(sX, sY, pItem);
			
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return 0;
			}
		}
	}

	// Å¬¶óÀÌ¾ðÆ®°¡ MSGID_RESPONSE_MOTION¸Þ½ÃÁö¸¦ ¹Þ¾Æ¾ß¸¸ °è¼Ó ¸í·ÉÀ» Àü¼ÛÇÒ ¼ö ÀÖ´Ù. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

BOOL CGame::_bAddClientItemList(int iClientH, class CItem * pItem, int * pDelReq)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;
	
	// ÁýÀ» ¾ÆÀÌÅÛ Áß·®°è»ê  
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// ¼ö·®°³³äÀÌ ÀÖ´Â ¾ÆÀÌÅÛ 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// ¼ö·® °³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, 1)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	
	// ¼Òºñ¼º ¾ÆÀÌÅÛÀ» ÀÌ¹Ì ¼ÒÁöÇÏ°í ÀÖ´Ù¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù. 
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		for (i = 0; i < DEF_MAXITEMS; i++)
		if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
			 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, pItem->m_cName, 20) == 0) ) {
			// °°Àº ÀÌ¸§À» Ã£¾Ò´Ù. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount += pItem->m_dwCount;
			//delete pItem;
			*pDelReq = 1;
			
			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);
			
			return TRUE;
		}
	}
	
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		
		m_pClientList[iClientH]->m_pItemList[i] = pItem;
		// v1.3 ¾ÆÀÌÅÛÀÇ À§Ä¡´Â ¹«Á¶°Ç 100, 100
		m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
		m_pClientList[iClientH]->m_ItemPosList[i].y = 30;

		*pDelReq = 0;

		// ¸¸¾à È­»ì·ù ¾ÆÀÌÅÛÀÌ¶ó¸é È­»ìÀ» ÇÒ´çÇÑ´Ù. 
		if (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)
			m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);
		
		return TRUE;
	}

	// ´õÀÌ»ó ¾ÆÀÌÅÛÀ» ÁýÀ» °ø°£ÀÌ ¾ø´Ù.
	return FALSE;
}


BOOL CGame::bEquipItemHandler(int iClientH, short sItemIndex, BOOL bNotify)
{
 char  cEquipPos;
 short sTemp, sSpeed;
 int   iTemp;
	
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return FALSE;

	//¸¸¾à ÀåÂøÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ 0ÀÎ °æ¿ì´Â ÀåÂøÇÒ ¼ö ¾ø´Ù.
 	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan == 0) return FALSE;

	// ·¹º§ Á¦ÇÑ¿¡ °É·Áµµ ÀåÂøÇÒ ¼ö ¾ø´Ù. 
	//if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel) return FALSE;
	// v1.4334 Á¦ÀÛ ¾ÆÀÌÅÛÀÌ ¾Æ´Ñ °æ¿ì  ·¹º§ Á¦ÇÑ¿¡ °É·Áµµ ÀåÂøÇÒ ¼ö ¾ø´Ù. 
	if (((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) == NULL)  &&
	    (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sLevelLimit > m_pClientList[iClientH]->m_iLevel)) return FALSE;

	// ¼ºº° Á¦ÇÑ¿¡ °É·Áµµ ÀåÂøÇÒ ¼ö ¾ø´Ù. 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 0) {
		switch (m_pClientList[iClientH]->m_sType) {
		case 1:
		case 2:
		case 3:
			// ³²¼ºÀÌ´Ù.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 1) return FALSE;
			break;
		case 4:
		case 5:
		case 6:
			// ¿©¼ºÀÌ´Ù.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cGenderLimit != 2) return FALSE;
			break;
		}
	}

	// ¹«°Ô Á¦ÇÑ¿¡ °É·Áµµ »ç¿ëÇÒ ¼ö ¾ø´Ù.
	//if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wWeight > m_pClientList[iClientH]->m_iStr*100) return FALSE;
	// v1.432
	if (iGetItemWeight(m_pClientList[iClientH]->m_pItemList[sItemIndex], 1) > m_pClientList[iClientH]->m_iStr*100) return FALSE;
   
	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

	// ¿Ê¾ÆÀÌÅÛÀÇ °æ¿ì´Â Æ¯¼ºÄ¡ÀÇ Á¦ÇÑ¿¡ °É¸®¸é ÀåÂø ºÒ°¡´É. 
	if ((cEquipPos == DEF_EQUIPPOS_BODY) || (cEquipPos == DEF_EQUIPPOS_LEGGINGS) || (cEquipPos == DEF_EQUIPPOS_ARMS)) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4) {
		case 10: // Str Á¦ÇÑ 
			if (m_pClientList[iClientH]->m_iStr < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 11: // Dex
			if (m_pClientList[iClientH]->m_iDex < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 12: // Vit
			if (m_pClientList[iClientH]->m_iVit < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 13: // Int
			if (m_pClientList[iClientH]->m_iInt < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 14: // Mag
			if (m_pClientList[iClientH]->m_iMag < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		case 15: // Chr
			if (m_pClientList[iClientH]->m_iCharisma < m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5) {
				// Å¬¶óÀÌ¾ðÆ® »ó¿¡¼­´Â Âø¿ëµÈ »óÅÂÀÌ¹Ç·Î ¹þ°Ü¾ß ÇÑ´Ù. Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos, sItemIndex, NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], TRUE);
				return FALSE;
			}
			break;
		}
	}

	// ¸¸¾à ÀåÂøÇÑ ¾ÆÀÌÅÛÀÌ Æ¯¼ö ´É·ÂÀ» °¡Áö°í ÀÖ´Âµ¥ ÀÌ¹Ì Æ¯¼ö´É·ÂÀÌ ¼³Á¤µÇ¾î ÀÖÀ¸¸é ÀÌÀü¿¡ ÀåÂøÇÑ ¾ÆÀÌÅÛÀ» ÇØÁ¦.
	if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) || 
		(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) {
		
		if ((m_pClientList[iClientH]->m_iSpecialAbilityType != 0)) {
			// ÀÌ¹Ì Æ¯¼ö´É·ÂÀÌ ¼³Á¤µÇ¾î ÀÖ´Ù. ÀÌÀü¿¡ ÀåÂøµÇ¾î ÀÖ´Â ¾ÆÀÌÅÛ Âø¿ë ÇØÁ¦:
			// ´Ü, Âø¿ë ºÎÀ§°¡ °°´Ù¸é ÇØÁ¦ ¸Þ½ÃÁö º¸³»Áö ¾Ê´Â´Ù.
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos != m_pClientList[iClientH]->m_iSpecialAbilityEquipPos) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_iSpecialAbilityEquipPos, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], NULL, NULL);
				// ÇØ´ç Âø¿ë ºÎÀ§ÀÇ ¾ÆÀÌÅÛÈ¿°ú¸¦ Á¦°Å.
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ m_pClientList[iClientH]->m_iSpecialAbilityEquipPos ], TRUE);
			}
		}
	}
	
	// ÀåÂøÇÒ ¼ö ¾ø´Â ¾ÆÀÌÅÛÀ» ÀåÂø½ÃµµÇßÀ» °æ¿ì ¹«½Ã 
	if (cEquipPos == DEF_EQUIPPOS_NONE) return FALSE;

	if (cEquipPos == DEF_EQUIPPOS_TWOHAND) {
		// ¾ç¼ÕÀ» »ç¿ëÇÏ´Â ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ´Ù¸é  
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
		else {
			// ¿À¸¥¼Õ, ¿Þ¼Õ¿¡ ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ¸ðµÎ ÀåÂø ÇØÁ¦ 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ], FALSE);
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ], FALSE);
		}
	}
	else {
		// ¾ç¼Õ ¾ÆÀÌÅÛÀÌ ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
		if ((cEquipPos == DEF_EQUIPPOS_LHAND) || (cEquipPos == DEF_EQUIPPOS_RHAND)) {
			// ¹«±â³ª ¹æÆÐ·ù¶ó¸é ¾ç¼Õ¹«±â¸¦ ÇØÁ¦ 
			if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) 
				ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ], FALSE);
		}
		
		// ÀåÂøÀ§Ä¡¿¡ ¾ÆÀÌÅÛÀÌ ÀÌ¹Ì ÀÖÀ¸¸é »èÁ¦.
		if ( m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ] != -1) 
			ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_sItemEquipmentStatus[ cEquipPos ], FALSE);
	}

	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = sItemIndex;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = TRUE;
	
	// @@@@ ÀåÂø»óÅÂ°¡ º¯°æµÈ °Í°ú °ü·ÃÇÏ¿© Apprº¯¼ö¸¦ Á¶Á¤ÇÑ ÈÄ Åëº¸ÇÑ´Ù.
	// ¾ÆÀÌÅÛÀÇ ÀåÂøÀ§Ä¡¿¡ ¸Â°Ô Apprº¯¼ö¸¦ Á¶Á¤ÇÑ´Ù.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		
		// ¹«±â ¼Óµµ¸¦ ³ªÅ¸³»´Â StatusÀÇ ºñÆ®¸¦ ¼³Á¤ÇÑ´Ù.
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str¿¡ µû¶ó ¹«±â ¼Óµµ¸¦ ÁÙÀÎ´Ù. 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		if (sSpeed < 0) sSpeed = 0;
		sTemp = sTemp | sSpeed;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xF0FFFFFF; // ¹æÆÐ »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 24);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// ¾ç¼ÕÅ¸ÀÔÀÌÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡ ÀåÂøµÈ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr2 = sTemp;
		
		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 28);
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// ¹«±â ¼Óµµ¸¦ ³ªÅ¸³»´Â StatusÀÇ ºñÆ®¸¦ ¼³Á¤ÇÑ´Ù.
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		sSpeed = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cSpeed);
		// Str¿¡ µû¶ó ¹«±â ¼Óµµ¸¦ ÁÙÀÎ´Ù. 
		sSpeed -= (m_pClientList[iClientH]->m_iStr / 13);
		if (sSpeed < 0) sSpeed = 0;
		sTemp = sTemp | sSpeed;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.

		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue < 100) {
			// ¿ÜÇü°ªÀÌ 100 ÀÌÇÏ. Á¤»óÀûÀÎ °ª 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
		}
		else {
			// ¿ÜÇü°ªÀÌ 100 ÀÌ»óÀÌ¸é È®Àå ÇÃ·¡±×¸¦ »ç¿ëÇÑ´Ù. 
			sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue - 100) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
			m_pClientList[iClientH]->m_sAppr3 = sTemp;
			// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ ¼¼Æ®.
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp | 0x080;	
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
		}

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFF0FFFFF; // °Ñ¿Ê(°©¿Ê) »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 20);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // ¸ÁÅä »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 16);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// ¼Ó¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue)); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFF0FFF; // ¼Ó¿Ê »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 12);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// ¹ÙÁö Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 8); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFF0FF; // ¹ÙÁö »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 8);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// ºÎÃ÷ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 12); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFF0F; // ºÎÃ÷ »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor) << 4);
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = sTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cApprValue) << 4); // Appr °ªÀ» ¼¼ÆÃ. 
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFFF0; // Åõ±¸ »ö ºñÆ®¸¦ Å¬¸®¾î.
		iTemp = iTemp | ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor));
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
	}

	//v1.432 Æ¯¼ö ´É·ÂÀÌ ºÎ¿©µÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇÃ·¡±× ¼³Á¤ 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		case 1: // °ø°Ý½Ã 50% HP °¨¼Ò
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0004;	
			break;

		case 2: // ³Ãµ¿ È¿°ú 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x000C;	
			break;

		case 3: // ¸¶ºñ È¿°ú 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0008;	
			break;
		}
	}

	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// ¹æ¾î±¸ Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect) {
		case 0: break;
		default: // ³ì»ö 
			m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 | 0x0002;	
			break;
		}
	}

	// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» ¾Ë¸°´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// @@@@ ¶ÇÇÑ Ä³¸¯ÅÍÀÇ Æ¯¼ºÄ¡ º¯È­¸¦ °è»êÇÑ´Ù. 
	CalcTotalItemEffect(iClientH, sItemIndex, bNotify);

	return TRUE;
}


void CGame::SendEventToNearClient_TypeB(DWORD dwMsgID, WORD wMsgType, char cMapIndex, short sX, short sY, short sV1, short sV2, short sV3, short sV4)
{
 int i, iRet, iShortCutIndex;
 char  * cp, cData[100];
 DWORD * dwp, dwTime;
 WORD * wp;
 short * sp;
 BOOL bFlag;

	ZeroMemory(cData, sizeof(cData));
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = dwMsgID;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	sp  = (short *)cp;
	*sp = sX;
	cp += 2;

	sp  = (short *)cp;
	*sp = sY;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV1;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV2;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV3;
	cp += 2;

	sp  = (short *)cp;
	*sp = sV4;
	cp += 2;

	dwTime = timeGetTime();

	//for (i = 1; i < DEF_MAXCLIENTS; i++)
	bFlag = TRUE;
	iShortCutIndex = 0;
	while (bFlag == TRUE) {
		// DEF_MAXCLIENTS ±îÁö ·çÇÁ¸¦ µ¹Áö ¾Ê±â À§ÇÑ ¹æ¹ý. Å¬¶óÀÌ¾ðÆ® ¼ôÄÆ ¸®½ºÆ®¿¡¼­ 0ÀÌ ³ª¿À¸é ³¡ÀÌ´Ù.
		i = m_iClientShortCut[iShortCutIndex];
		iShortCutIndex++;
		if (i == 0) bFlag = FALSE;

		if ((bFlag == TRUE) && (m_pClientList[i] != NULL)) {
			if ( (m_pClientList[i]->m_cMapIndex == cMapIndex) &&
				 (m_pClientList[i]->m_sX >= sX - 10) &&
				 (m_pClientList[i]->m_sX <= sX + 10) &&
				 (m_pClientList[i]->m_sY >= sY - 8 ) &&
				 (m_pClientList[i]->m_sY <= sY + 8 ) ) {

				iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 18);
			}
		}
	}
}

int CGame::iClientMotion_Stop_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet;
 short   sOwnerH;
 char    cOwnerType;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if ((cDir <= 0) || (cDir > 8))       return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;
	
	// ÁËÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â ¸í·ÉÀº ¹«½ÃÇÑ´Ù. Reject¸Þ½ÃÁö¸¦ ¹Þ±â ÀÌÀü¿¡ Àü¼ÛµÈ ¸Þ½ÃÁöµéÀÌ´Ù.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// Á×ÀºÃ´ÇÏ±â Áß ÀÏ¾î³ª´Âµ¥ À§¿¡ ¹°Ã¼°¡ ÀÖÀ¸¸é Á¢¼ÓÀ» Á¾·á½ÃÅ²´Ù.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, sX, sY);		
		if (sOwnerH != NULL) {
			DeleteClient(iClientH, TRUE, TRUE);
			return 0;
		}
	}

	// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù. //!!!!
	ClearSkillUsingStatus(iClientH);

	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;

		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}

	// ¹æÇâÀ» ¹Ù²Û´Ù.
	m_pClientList[iClientH]->m_cDir = cDir;
	
	// Á×Àº À§Ä¡¿¡ ÀÖ¾ú´Ù¸é Áö¿î´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// ´Ù½Ã À§Ä¡ ½ÃÅ²´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	
	// Å¬¶óÀÌ¾ðÆ®°¡ MSGID_RESPONSE_MOTION¸Þ½ÃÁö¸¦ ¹Þ¾Æ¾ß¸¸ °è¼Ó ¸í·ÉÀ» Àü¼ÛÇÒ ¼ö ÀÖ´Ù. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::ResponseCreateNewGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå »ý¼º ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) &&
		(m_pClientList[i]->m_iLevel >= 20) && (m_pClientList[i]->m_iCharisma >= 20)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù. 
			wResult = DEF_MSGTYPE_CONFIRM;
			// ±æµå ÀÌ¸§Àº ÀÌ¹Ì ÀúÀåµÇ¾î ÀÖÀ¸¹Ç·Î ·©Å©¸¦ 0À¸·Î ¹Ù²ã À¯È¿È­ ÇÑ´Ù.
			m_pClientList[i]->m_iGuildRank = 0;	// ±æµå ·©Å©´Â 0. ±æµå¸¶½ºÅÍÀÓ 
			wsprintf(cTxt, "(!) New guild(%s) creation success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå »ý¼º ¿ä±¸°¡ ½ÇÆÐÇÏ¿´´Ù.
			// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµåÀÌ¸§À» ÃÊ±âÈ­ÇÑ´Ù "NONE".
			wResult = DEF_MSGTYPE_REJECT;
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;  
			m_pClientList[i]->m_iGuildGUID = -1;
			wsprintf(cTxt, "(!) New guild(%s) creation Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_CREATENEWGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, TRUE, TRUE);
			return;
		}

		return;
	}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestCreateNewGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100];
 DWORD * dwp;
 WORD  * wp;
 int     iRet;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	ZeroMemory(cGuildName, sizeof(cGuildName));
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if (m_pClientList[iClientH]->m_iGuildRank != -1) {
		// ÀÌ Ä³¸¯ÅÍ´Â ÀÌ¹Ì ±æµå¿¡ °¡ÀÔÇÏ¿© ÀÖÀ¸¹Ç·Î ±æµå¸¦ ¸¸µé ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot create guild! Already guild member.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		if ( (m_pClientList[iClientH]->m_iLevel < 20) || (m_pClientList[iClientH]->m_iCharisma < 20) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) ||
			 (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) != 0) ) { // v1.4
			// ÀÚ°Ý¿ä°ÇÀÌ ¸ÂÁö ¾Ê´Â´Ù. Æ¯¼ºÄ¡°¡ ³·°Å³ª ¸¶À»ÀÇ À§Ä¡°¡ ´Ù¸£°Å³ª ½Ã¹ÎÀÌ ¾Æ´Ñ °æ¿ì  
			ZeroMemory(cData, sizeof(cData));

			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_CREATENEWGUILD;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;

			// ±æµå »ý¼º ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
	   		// ±æµå ÀÌ¸§À» ÀÓ½Ã·Î ÀúÀåÇÑ´Ù. -> ¾îÂ÷ÇÇ ±æµå ÀÌ¸§Àº Rank°¡ -1ÀÏ¶§ ¹«ÀÇ¹ÌÇÏ¹Ç·Î .
			ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
			strcpy(m_pClientList[iClientH]->m_cGuildName, cGuildName);
			// ±æµåÀÇ ¼Ò¼Ó ¸¶À» ÀÌ¸§À» ÀúÀåÇÑ´Ù.
			ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
			strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
			// ±æµåÀÇ GUID¸¦ »ý¼ºÇÏ¿© ÀÔ·ÂÇÑ´Ù. 
			GetLocalTime(&SysTime);
			m_pClientList[iClientH]->m_iGuildGUID = (int)(SysTime.wYear + SysTime.wMonth + SysTime.wDay + SysTime.wHour + SysTime.wMinute + timeGetTime());
			
			// ±æµå »ý¼º¿äÃ» ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
			bSendMsgToLS(MSGID_REQUEST_CREATENEWGUILD, iClientH);
		}
	}
}


void CGame::RequestDisbandGuildHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120];

	if (m_bIsCrusadeMode == TRUE) return;

	cp = (char *)(pData	+ DEF_INDEX2_MSGTYPE + 2);
	ZeroMemory(cGuildName, sizeof(cGuildName));
	
	cp += 10;
	cp += 10;
	cp += 10;
	
	memcpy(cGuildName, cp, 20);
	cp += 20;

	if ((m_pClientList[iClientH]->m_iGuildRank != 0) || (memcmp(m_pClientList[iClientH]->m_cGuildName, cGuildName, 20) != 0)) {
		// ±æµå¸¶½ºÅÍ°¡ ¾Æ´Ï°Å³ª ±æµåÀÇ ÀÌ¸§ÀÌ ´Ù¸£¹Ç·Î ±æµåÇØ»êÀÇ ±ÇÇÑÀÌ ¾ø´Ù.
		wsprintf(cTxt, "(!)Cannot Disband guild! Not guildmaster.: CharName(%s)", m_pClientList[iClientH]->m_cCharName);
		PutLogList(cTxt);
	}
	else {
		// ±æµå ÇØ»ê ¸Þ½ÃÁö¸¦ ·Î±×¼­¹ö·Î Àü¼ÛÇÑ´Ù.
		bSendMsgToLS(MSGID_REQUEST_DISBANDGUILD, iClientH);
	}
}

void CGame::ResponseDisbandGuildHandler(char * pData, DWORD dwMsgSize)
{
 register int i;
 WORD  * wp, wResult;
 DWORD * dwp;
 char  * cp, cCharName[11], cData[100], cTxt[120];
 int iRet;
	
	// ·Î±× ¼­¹ö·ÎºÎÅÍ ±æµå ÇØ»ê ¿äÃ»¿¡ ´ëÇÑ ÀÀ´äµ¥ÀÌÅÍ°¡ µµÂøÇß´Ù. 
	ZeroMemory(cCharName, sizeof(cCharName));
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);
	cp += 10;
	
	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£´Â´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0)) {
		
		wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
		switch (*wp) {
		case DEF_LOGRESMSGTYPE_CONFIRM:
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå ÇØ»ê ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù. 
			wResult = DEF_MSGTYPE_CONFIRM;
			wsprintf(cTxt, "(!) Disband guild(%s) success! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			
			// Á¢¼ÓÁßÀÎ ±æµå¿øµé¿¡°Ô ±æµå°¡ ÇØ»êµÇ¾úÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù. 
			SendGuildMsg(i,	DEF_NOTIFY_GUILDDISBANDED, NULL, NULL, NULL);
			
			// ±æµåÀÌ¸§ Å¬¸®¾î
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			memcpy(m_pClientList[i]->m_cGuildName, "NONE", 4);
			m_pClientList[i]->m_iGuildRank = -1;		// ±æµå ·©Å©´Â -1. ±æµå¿øÀÌ ¾Æ´Ï´Ù. 
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_LOGRESMSGTYPE_REJECT:
			// Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå ÇØ»ê ¿ä±¸°¡ ½ÇÆÐÇÏ¿´´Ù.
			wResult = DEF_MSGTYPE_REJECT;
			wsprintf(cTxt, "(!) Disband guild(%s) Fail! : character(%s)", m_pClientList[i]->m_cGuildName, m_pClientList[i]->m_cCharName);
			PutLogList(cTxt);
			break;
		}				
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_DISBANDGUILD;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wResult;

		// ±æµå ÇØ»ê ¿ä±¸ ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
		iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
		return;
	}

	// ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À» ¼ö ¾ø´Ù.
	wsprintf(cTxt, "(!)Non-existing player data received from Log server(2): CharName(%s)", cCharName);
	PutLogList(cTxt);
}

void CGame::RequestPurchaseItemHandler(int iClientH, char * pItemName, int iNum)
{
 class CItem * pItem;
 char  * cp, cItemName[21], cData[100];
 short * sp;
 DWORD * dwp, dwGoldCount, dwItemCount;
 WORD  * wp, wTempPrice;
 int   i, iRet, iEraseReq, iGoldWeight;
 int   iCost, iDiscountRatio, iDiscountCost;
 double dTmp1, dTmp2, dTmp3;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	// ¸¸¾à ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é ±¸ÀÔÇÒ ¼ö ¾ø´Ù. 
	//if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
	//	 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, m_pClientList[iClientH]->m_cLocation, 10) != 0) ) return;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) {
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "arefarm", 7) == 0)) {

			}
			else return;
		}

		if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
			if ((memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ||
				(memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvfarm", 7) == 0)) {

			}
			else return;
		}
	}
	
	
	// ¾ÆÀÌÅÛÀ» ±¸ÀÔÇÑ´Ù. 
	ZeroMemory(cData, sizeof(cData));	
	ZeroMemory(cItemName, sizeof(cItemName));
	
	// ÀÓ½ÃÄÚµå´Ù. 
	if (memcmp(pItemName, "Arrows10", 8) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 10;
	}
	else if (memcmp(pItemName, "Arrows100", 9) == 0) {
		strcpy(cItemName, "Arrow");
		dwItemCount = 100;
	}
	else {
		memcpy(cItemName, pItemName, 20);
		dwItemCount = 1;
	}
	
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
			
			if (pItem->m_bIsForSale == FALSE) {
				// ÆÇ¸ÅµÇ´Â ¾ÆÀÌÅÛÀÌ ¾Æ´Ï´Ù. »ì ¼ö ¾ø´Ù.
				delete pItem;
				return;
			}

			pItem->m_dwCount = dwItemCount;
			
			// °¡°ÝÀ» °è»êÇÑ´Ù.
			iCost = pItem->m_wPrice * pItem->m_dwCount;
			
			/* v1.3 <- ÀÌ°Ç _bAddClientItemList¿¡¼­ Ã¼Å©ÇÏ´Â ±â´ÉÀÌ¹Ç·Î µÎ¹øÇÒ ÇÊ¿ä°¡ ¾ø´Ù.
			if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW))  
				iItemWeight = (pItem->m_wWeight * pItem->m_dwCount);
			else iItemWeight = pItem->m_wWeight;
			
			if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
				// Áß·® ÃÊ°ú. ±¸ÀÔÇÒ ¼ö ¾ø´Ù. 
				
				// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				delete pItem;
				return;
			}
			*/

			// ÇÃ·¹ÀÌ¾î°¡ ¼ÒÁöÇÑ Gold°¡ ¾ÆÀÌÅÛÀ» »ç±â¿¡ ÃæºÐÇÑÁö °Ë»çÇÑ´Ù.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			
			// Charisma¿¡ µû¸¥ ÇÒÀÎ·üÀ» °è»êÇÑ´Ù. 
			iDiscountRatio = (m_pClientList[iClientH]->m_iCharisma / 4) -1;
			if (iDiscountRatio == 0) iDiscountRatio = 1;
			
			dTmp1 = (double)(iDiscountRatio);
			dTmp2 = dTmp1 / 100.0f;
			dTmp1 = (double)iCost;
			dTmp3 = dTmp1 * dTmp2;
			iDiscountCost = (int)dTmp3;
				
			if (iDiscountCost >= (iCost/2)) iDiscountCost = (iCost/2)-1;

			if ( dwGoldCount < (DWORD)(iCost - iDiscountCost) ) {
				// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ¾ÆÀÌÅÛ °¡°Ý¿¡ ºñÇØ Àû´Ù. »ì¼ö ¾øÀ½.
				delete pItem;
				
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
				cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				*cp  = -1; // -1ÀÌ¸é ÀÇ¹Ì¾ø´Ù.
				cp++;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// ¾ÆÀÌÅÛ »ò´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMPURCHASED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;
				
				wp  = (WORD *)cp;
				*wp = (iCost - iDiscountCost);
				wTempPrice = (iCost - iDiscountCost);
				cp += 2;
				
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
				
				// GoldÀÇ ¼ö·®À» °¨¼Ò½ÃÅ²´Ù. ¹Ýµå½Ã ¿©±â¼­ ¼¼ÆÃÇØ¾ß ¼ø¼­°¡ ¹Ù²îÁö ¾Ê´Â´Ù.
				iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - wTempPrice);
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
				m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += wTempPrice;
					
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
			else 
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}

void CGame::GiveItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char * pItemName)
{
 register int iRet, iEraseReq;
 short * sp, sOwnerH;
 char  * cp, cOwnerType, cData[100], cCharName[21];
 DWORD * dwp;
 WORD  * wp;
 class CItem * pItem;
  
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (iAmount <= 0) return;

	// ¾ÆÀÌÅÛ ÀÌ¸§ÀÌ ÀÏÄ¡ÇÏÁö ¾Ê¾Æµµ ¹«½ÃµÈ´Ù.
	if (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, pItemName, 20) != 0) {
		PutLogList("GiveItemHandler - Not matching Item name");
		return;
	}

	ZeroMemory(cCharName, sizeof(cCharName));

	if ( ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
		   (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) &&
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount > (DWORD)iAmount) ) {
		// ¼Òºñ¼º ¾ÆÀÌÅÛÀÌ¾ú°í ¼ö·®¸¸Å­ °¨¼Ò½ÃÅ°°í ³²Àº °Ô ÀÖ´Ù¸é 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName) == FALSE) {
			// ºÐÇÒÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¸®½ºÆ®¿¡ ¾ø´Â °Å´Ù. ÀÌ·± ÀÏÀº ÀÏ¾î³¯ ¼ö°¡ ¾øÁö¸¸ 
			delete pItem;
			return;
		}
		else {
			pItem->m_dwCount = iAmount;
		}

		// ¼ö·® °¨¼Ò: 0º¸´Ù Å©´Ù.
		m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount -= iAmount;

		// º¯°æµÈ ¼ö·®À» ¼³Á¤ÇÏ°í ¾Ë¸°´Ù.
		// v1.41 !!! ¾ÆÀÌÅÛ ÀÌ¸§¿¡¼­ ÀÎµ¦½º·Î º¯°æµÇ¾ú´Ù. 
		SetItemCount(iClientH, sItemIndex, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount);
		
		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}

		if (sOwnerH == NULL) {
			// ÁÖ°íÀÚ ÇÏ´Â À§Ä¡¿¡ ¾Æ¹«µµ ¾ø´Ù.
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);
			
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		}
		else {
			// ¾ÆÀÌÅÛÀ» ÁØ´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// ÇÃ·¹ÀÌ¾î¿¡°Ô ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);

				if (sOwnerH == iClientH) {
					// ¸¸¾à ÀÚ±â ÀÚ½Å¿¡°Ô ÁÖ´Â °Å¶ó¸é ¹«½ÃÇÑ´Ù. ÇØÅ·ÀÇ ¼ÒÁö°¡ ÀÖ´Ù.
					delete pItem;
					return;
				}
				
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀ» ¾Ë·ÁÁØ´Ù. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED, sItemIndex, iAmount, NULL, cCharName);
				}
				else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 ¼ö·®´ÜÀ§ÀÇ ¾ÆÀÌÅÛÀ» Àü´Þ¿¡ ½ÇÆÐÇßÀ½À» ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTGIVEITEM, sItemIndex, iAmount, NULL, cCharName);
				}

			}
			else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù. 
					if (bSetItemToBankItem(iClientH, pItem) == FALSE) {
						// ¹°°ÇÀ» ¸Ã±â´Âµ¥ ½ÇÆÐÇÏ¿´´Ù.	
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);

						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

						// v1.411  
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
								                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
									                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
					}
		   		}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, pItem);

					// v1.411  
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
	
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
				}
			}
		}
	}
	else {
		// ¾ÆÀÌÅÛ ÀüºÎ¸¦ ÁÖ¾ú´Ù.
		
		// ÀåÂøÁßÀÎ ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù¸é ¾ÆÀÌÅÛ ÀåÂøÈ¿°ú¸¦ ÇØÁ¦ÇØ¾ß ÇÏ¹Ç·Î.
		ReleaseItemHandler(iClientH, sItemIndex, TRUE);

		// Ã³¸®µµÁß ¿¡·¯°¡ ¹ß»ýÇÒ¶§¸¦ ´ëºñÇØ¼­ -1·Î ÇÒ´çÇØ ³õ´Â´Ù.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) 
			m_pClientList[iClientH]->m_cArrowIndex = -1;
		
		//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY); // ¾ÆÀÌÅÛÀ» dX, dY¿¡ ÀÖ´Â Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. ¸¸¾à ¹ÞÀ» Ä³¸¯ÅÍ°¡ ¾ÆÀÌÅÛÀ» ¹ÞÁö ¸øÇÒ »óÈ²ÀÌ¶ó¸é ¶¥¿¡ ¶³¾îÁø´Ù.  
		
		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if ((wObjectID > 0) && (wObjectID < DEF_MAXCLIENTS)) {
					if (m_pClientList[wObjectID] != NULL) {
						if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
					}
				}
			}
			else {
				// NPC
				if ((wObjectID - 10000 > 0) && (wObjectID - 10000 < DEF_MAXNPCS)) {
					if (m_pNpcList[wObjectID - 10000] != NULL) {
						if ((WORD)sOwnerH != (wObjectID - 10000)) sOwnerH = NULL;
					}
				}
			}
		}
	
		if (sOwnerH == NULL) {
			// ¾ÆÀÌÅÛÀ» ÁÖ°íÀÚ ÇÏ´Â Àå¼Ò¿¡ Ä³¸¯ÅÍ°¡ ¾ø´Ù. 
			// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                             m_pClientList[iClientH]->m_sY, 
																	     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
			// v1.411  
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
	
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
				                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
								        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
										m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
		
			// ÀÌÁ¦ ¾ÆÀÌÅÛÀÌ ¶³¾îÁ³À¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DROPITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, NULL);
		}
		else {
			// ¾ÆÀÌÅÛÀ» ´Ù¸¥ Ä³¸¯ÅÍ¿¡°Ô ÁØ´Ù. @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
		
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				// Ä³¸¯ÅÍ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.	
				memcpy(cCharName, m_pClientList[sOwnerH]->m_cCharName, 10);
				pItem = m_pClientList[iClientH]->m_pItemList[sItemIndex];

				if ((m_bIsCrusadeMode == FALSE) && (strcmp(pItem->m_cName, "GuildAdmissionTicket") == 0)) {
					// ÇÃ·¹ÀÌ¾î iClientH °¡ sOwnerH¿¡°Ô ±æµå°¡ÀÔ ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù. ¸¸¾à 
					// sOwnerH°¡ ±æµå¸¶½ºÅÍ¶ó¸é ¾ÆÀÌÅÛÀ» ¹Þ´Â °ÍÀÌ ¾Æ´Ï¶ó È®ÀÎÀ» ÇØ ÁÖ¾î¾ß ÇÑ´Ù.
				
					if ((m_pClientList[iClientH]->m_iGuildRank == -1) && 
						(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) &&
						(memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[sOwnerH]->m_cLocation, 10) == 0) &&
						(m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// ±æµå ¸¶½ºÅÍÀÌ´Ù.	±æµå ¸¶½ºÅÍ¿¡°Ô´Â °¡ÀÔÈ®ÀÎ ¿äÃ» ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				if ((m_bIsCrusadeMode == FALSE) && (strcmp(pItem->m_cName, "GuildAdmissionTicket") == 0)) {
					// ÇÃ·¹ÀÌ¾î iClientH °¡ sOwnerH¿¡°Ô ±æµåÅ»Åð ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù. ¸¸¾à 
					// sOwnerH°¡ ±æµå¸¶½ºÅÍÀÌ°í iClientH¿Í ±æµå ÀÌ¸§ÀÌ °°°í iClientH°¡ ±æµå¿øÀÌ¶ó¸é 
					// ¾ÆÀÌÅÛÀ» ¹Þ´Â °ÍÀÌ ¾Æ´Ï¶ó È®ÀÎÀ» ÇØ ÁÖ¾î¾ß ÇÑ´Ù.
					if ( (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) && 
						 (m_pClientList[iClientH]->m_iGuildRank != -1) && 
						 (m_pClientList[sOwnerH]->m_iGuildRank == 0) ) {
						// ±æµå ¸¶½ºÅÍÀÌ´Ù.	±æµå ¸¶½ºÅÍ¿¡°Ô´Â Å»ÅðÈ®ÀÎ ¿äÃ» ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
						SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION, NULL, NULL, NULL, NULL);
						// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, 1, NULL, cCharName);
					
						goto REMOVE_ITEM_PROCEDURE;
					}
				}

				// ÀÏ¹ÝÀûÀÎ °æ¿ì ¾ÆÀÌÅÛÀ» ±×Àú ¹ÞÀ» »Ó...
				if (_bAddClientItemList(sOwnerH, pItem, &iEraseReq) == TRUE) {
					
					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» Àü´ÞÇÑ °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_GIVE, iClientH, sOwnerH, pItem);

					// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

					// 1°³ È¹µæÇß´Ù.
					*cp = 1;
					cp++;

					memcpy(cp, pItem->m_cName, 20);
					cp += 20;

					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;

					*cp = pItem->m_cItemType;
					cp++;

					*cp = pItem->m_cEquipPos;
					cp++;

					*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
					cp++;

					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
	
					*cp = pItem->m_cGenderLimit;
					cp++;

					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
		
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;

					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;

					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;

					// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 53);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}
				}
				else {
					// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
					// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
					iRet = m_pClientList[sOwnerH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
						DeleteClient(sOwnerH, TRUE, TRUE);
						break;
					}

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}
			else {
				// NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾ú´Ù.
				memcpy(cCharName, m_pNpcList[sOwnerH]->m_cNpcName, 20);

				if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Howard", 6) == 0) {
					// NPC°¡ Ã¢°í ÁÖÀÎÀÌ¾ú´Ù¸é ¹°°ÇÀ» º¸°üÇÏ°Ú´Ù´Â ÀÇ¹ÌÀÌ´Ù. 
					if (bSetItemToBankItem(iClientH, sItemIndex) == FALSE) {
						// ¾ÆÀÌÅÛÀ» º¸°üÇÏ´Âµ¥ ½ÇÆÐÇÏ¿© ¹Ù´Ú¿¡ ¶³¾îÁ³´Ù.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTITEMTOBANK, NULL, NULL, NULL, NULL);
						
						// ½ÇÆÐÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³±º´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                         	 m_pClientList[iClientH]->m_sY, 
							                                                         m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
						
						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
							                        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
													m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color
					}
				}
				else if (memcmp(m_pNpcList[sOwnerH]->m_cNpcName, "Kennedy", 7) == 0) {
					// ±æµå »ç¹«Àå¿¡°Ô ±æµå Å»Åð ½ÅÃ»¼­¸¦ ÁÖ¾ú´Ù¸é ±æµå¸¦ Å»ÅðÇÑ´Ù. 
					if ((m_bIsCrusadeMode == FALSE) && (memcmp(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, "GuildSucessionTicket", 14) == 0)) {
						
						if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (m_pClientList[iClientH]->m_iGuildRank != -1)) {
							// Å»Åð ½ÅÃ»ÀÚ¿¡°Ô Å»Åð ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
							SendNotifyMsg(iClientH, iClientH, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
						
							// ±æµå Å»Åð. 
							ZeroMemory(m_pClientList[iClientH]->m_cGuildName, sizeof(m_pClientList[iClientH]->m_cGuildName));
							memcpy(m_pClientList[iClientH]->m_cGuildName, "NONE", 4);
							m_pClientList[iClientH]->m_iGuildRank = -1;
							m_pClientList[iClientH]->m_iGuildGUID = -1;

							// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
							SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

							// ¾à°£ÀÇ °æÇèÄ¡°¡ ÇÏ¶ôÇÑ´Ù.
							m_pClientList[iClientH]->m_iExp -= 300;
							if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
							SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}

						// ÀÌ ¾ÆÀÌÅÛÀº »èÁ¦½ÃÄÑ¾ß ÇÑ´Ù. 
						delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
					} 
					else {
						// ±æµå Å»Åð ½ÅÃ»¼­°¡ ¾Æ´Ï¶ó¸é ¹Ù´Ú¿¡ ¶³±º´Ù. Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§µµ ±æµå °ü·Ã ¿¬»ê ºÒ°¡ 
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

						// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
						_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
						// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
						SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

						// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
						ZeroMemory(cCharName, sizeof(cCharName));

					}
				}
				else {
					// ÀÏ¹Ý NPC¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¸é ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö·Á¾ß ÇÑ´Ù. 

					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
							                                                     m_pClientList[iClientH]->m_sY, 
																			     m_pClientList[iClientH]->m_pItemList[sItemIndex]);

					// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
					_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);
					
					// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
							                    m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
								                m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
										        m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, 
												m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor); // v1.4 color

					// v1.4 ¾ÆÀÌÅÛ Àü´ÞÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¹æ¹ý 
					ZeroMemory(cCharName, sizeof(cCharName));
				}
			}

			// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ÁØ º»ÀÎ¿¡°Ô ¾ÆÀÌÅÛÀ» ÁÖ¾úÀ¸¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, sItemIndex, iAmount, NULL, cCharName);
		}

REMOVE_ITEM_PROCEDURE:;

		// ³×Æ®¿öÅ© ¿À·ù·Î Ã³¸®µµÁß Å¬¶óÀÌ¾ðÆ®°¡ Á¦°ÅµÇ¾ú´Ù¸é ´õÀÌ»ó ÁøÇàÇÒ ¼ö ¾ø´Ù. 
		if (m_pClientList[iClientH] == NULL) return;

		// ¾ÆÀÌÅÛÀ» ÁÖ°Å³ª ¹ö·ÈÀ¸¹Ç·Î Áö¿î´Ù. deleteÇØ¼­´Â ¾ÈµÈ´Ù! 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
		
		// È­»ì ÀÎµ¦½º¸¦ Àç ÇÒ´ç
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

void CGame::SendNotifyMsg(int iFromH, int iToH, WORD wMsgType, DWORD sV1, DWORD sV2, DWORD sV3, char * pString, DWORD sV4, DWORD sV5, DWORD sV6, DWORD sV7, DWORD sV8, DWORD sV9, char * pString2)
{
 char cData[1000];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 int   * ip, iRet, i;
	
	if (m_pClientList[iToH] == NULL) return;

	ZeroMemory(cData, sizeof(cData));

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);			   
	*wp  = wMsgType;

	cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

	// !!! sV1, sV2, sV3´Â DWORDÇüÀÓÀ» ¸í½ÉÇÏ¶ó.
	switch (wMsgType) {
	case DEF_NOTIFY_TCLOC:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV5;
		cp += 2;
		
		memcpy(cp, pString2, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
	
	case DEF_NOTIFY_GRANDMAGICRESULT:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 24);
		break;
	
	case DEF_NOTIFY_MAPSTATUSNEXT:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;

	case DEF_NOTIFY_MAPSTATUSLAST:
		memcpy(cp, pString, sV1);
		cp += sV1;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6+sV1);
		break;
	
	case DEF_NOTIFY_LOCKEDMAP:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 18);
		break;
	
	case DEF_NOTIFY_BUILDITEMSUCCESS:
	case DEF_NOTIFY_BUILDITEMFAIL:
		
		if (sV1 >= 0) {
			sp = (short *)cp;
			*sp = (short)sV1;
			cp += 2;
		}
		else {
			sp = (short *)cp;
			*sp = (short)sV1 + 10000;
			cp += 2;
		}

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
		
	case DEF_NOTIFY_HELP:
	case DEF_NOTIFY_QUESTREWARD:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
		
	case DEF_NOTIFY_CANNOTCONSTRUCT:
	case DEF_NOTIFY_METEORSTRIKECOMING:
	case DEF_NOTIFY_METEORSTRIKEHIT:
	case DEF_NOTIFY_HELPFAILED:
	case DEF_NOTIFY_SPECIALABILITYENABLED:
	case DEF_NOTIFY_FORCEDISCONN:
	case DEF_NOTIFY_OBSERVERMODE:
	case DEF_NOTIFY_QUESTCOMPLETED:
	case DEF_NOTIFY_QUESTABORTED:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_QUESTCONTENTS:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 44);
		break;
		
	case DEF_NOTIFY_ENERGYSPHERECREATED:
	case DEF_NOTIFY_ITEMCOLORCHANGE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_NOMORECRUSADESTRUCTURE:
	case DEF_NOTIFY_EXCHANGEITEMCOMPLETE:
	case DEF_NOTIFY_CANCELEXCHANGEITEM:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SETEXCHANGEITEM:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_OPENEXCHANGEWINDOW:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		*cp = (char)sV5;
		cp++;

		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;

		// v1.42
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)sV9;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 57);
		break;
	
	case DEF_NOTIFY_NOTFLAGSPOT:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_ITEMPOSLIST:
		for (i = 0; i < DEF_MAXITEMS; i++) {
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].x;
			cp += 2;
			sp = (short *)cp;
			*sp = m_pClientList[iToH]->m_ItemPosList[i].y;
			cp += 2;
		}
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXITEMS*4);
		break;
	
	case DEF_NOTIFY_ENEMYKILLS:
		ip  = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_CRUSADE:
		ip = (int *)cp;
		*ip = (int)sV1;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV2;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV3;
		cp += 4;

		ip = (int *)cp;
		*ip = (int)sV4;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_CONSTRUCTIONPOINT:
	case DEF_NOTIFY_SPECIALABILITYSTATUS:
	case DEF_NOTIFY_DAMAGEMOVE:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DOWNSKILLINDEXSET:
	case DEF_NOTIFY_RESPONSE_CREATENEWPARTY:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_ADMINIFO:
		switch (sV1) {
		case 1:
			// NPCÀÇ Á¤º¸¸¦ ¾ò¾î¿Â´Ù.
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHP;
			cp += 4;
			
			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iDefenseRatio;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_bIsSummoned;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_cActionLimit;
			cp += 4;

			ip  = (int *)cp;
			*ip	= m_pNpcList[sV2]->m_iHitDice;
			cp += 4;

			dwp  = (DWORD *)cp; // v1.4
			*dwp = m_pNpcList[sV2]->m_dwDeadTime;
			cp += 4;

			dwp  = (DWORD *)cp; 
			*dwp = m_pNpcList[sV2]->m_dwRegenTime;
			cp += 4;

			ip  = (int *)cp; 
			*ip	= (int)m_pNpcList[sV2]->m_bIsKilled;
			cp += 4;

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26 + 12);
			break;
		}
		break;

	case DEF_NOTIFY_NPCTALK:
		sp = (short *)cp;
		*sp = (short)sV1;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV2;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV3;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV4;
		cp += 2;

		sp = (short *)cp;
		*sp = (short)sV5;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV6;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV7;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV8;
		cp += 2;
		
		sp = (short *)cp;
		*sp = (short)sV9;
		cp += 2;

		if (pString != NULL) memcpy(cp, pString, 20);
		cp += 20;

		if (pString2 != NULL) memcpy(cp, pString2, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 64);
		break;

	case DEF_NOTIFY_PORTIONSUCCESS:
	case DEF_NOTIFY_LOWPORTIONSKILL:
	case DEF_NOTIFY_PORTIONFAIL:
	case DEF_NOTIFY_NOMATCHINGPORTION:
		// ÀÏÄ¡ÇÏ´Â Æ÷¼Ç Á¶ÇÕÀÌ ¾ø´Ù.
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SUPERATTACKLEFT:
		sp = (short *)cp;
		*sp = m_pClientList[iToH]->m_iSuperAttackLeft;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_SAFEATTACKMODE:
		*cp = m_pClientList[iToH]->m_bIsSafeAttackMode;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
	
	case DEF_NOTIFY_QUERY_JOINPARTY:
	case DEF_NOTIFY_IPACCOUNTINFO:
		strcpy(cp, pString);
		cp += strlen(pString);

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
		break;
	
	case DEF_NOTIFY_REWARDGOLD:
		dwp = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iRewardGold;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SERVERSHUTDOWN:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_GLOBALATTACKMODE:
	case DEF_NOTIFY_WHETHERCHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;
		
	case DEF_NOTIFY_FISHCANCELED:
	case DEF_NOTIFY_FISHSUCCESS:
	case DEF_NOTIFY_FISHFAIL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_DEBUGMSG:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_FISHCHANCE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
				
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_ENERGYSPHEREGOALIN:
	case DEF_NOTIFY_EVENTFISHMODE:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_NOTICEMSG:
		memcpy(cp, pString, strlen(pString));
		cp += strlen(pString);

		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, strlen(pString) + 7);
		break;

	case DEF_NOTIFY_CANNOTRATING:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;

	case DEF_NOTIFY_RATINGPLAYER:
		*cp = (char)sV1;
		cp++;

		memcpy(cp, pString, 10);
		cp += 10;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 22);
		break;

	case DEF_NOTIFY_ADMINUSERLEVELLOW:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_PLAYERSHUTUP:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 19);
		break;
	
	case DEF_NOTIFY_TIMECHANGE:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_TOBERECALLED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_HUNGER:
		*cp = (char)sV1;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7);
		break;

	case DEF_NOTIFY_PLAYERPROFILE:
		if (strlen(pString) > 100) {
			memcpy(cp, pString, 100);
			cp += 100;
		}
		else {
			memcpy(cp, pString, strlen(pString));
			cp += strlen(pString);
		}
		*cp = NULL;
		cp++;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 7 + strlen(pString));
		break;

	case DEF_NOTIFY_WHISPERMODEON:
	case DEF_NOTIFY_WHISPERMODEOFF:
	
	case DEF_NOTIFY_PLAYERONGAME:
	case DEF_NOTIFY_PLAYERNOTONGAME:
		memcpy(cp, pString, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 17);
		break;
	
	case DEF_NOTIFY_ITEMSOLD:
	case DEF_NOTIFY_ITEMREPAIRED:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_REPAIRITEMPRICE:
	case DEF_NOTIFY_SELLITEMPRICE:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)sV3;
		cp += 2;
		wp = (WORD *)cp;
		*wp = (WORD)sV4;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

	case DEF_NOTIFY_CANNOTREPAIRITEM:
	case DEF_NOTIFY_CANNOTSELLITEM:
		wp = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 30);

		break;
	
	case DEF_NOTIFY_SHOWMAP:
		wp  = (WORD *)cp;  // º¸¿©ÁÖ´Â Á¾·ù 
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;  // ¸Ê ¹øÈ£ (0 aresden, 1 elvine, 3 middleland...)
		*wp = (WORD)sV2;
		cp += 2;
	
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_SKILLUSINGEND:
		wp  = (WORD *)cp;  // ±â¼ú »ç¿ë °á°ú 
		*wp = (WORD)sV1;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_TOTALUSERS:
		wp  = (WORD *)cp;    
		*wp = (WORD)(m_iTotalGameServerClients) + (m_iTotalGameServerClients/10); //_iGetTotalClients();
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 8);
		break;
	
	case DEF_NOTIFY_MAGICEFFECTOFF:
	case DEF_NOTIFY_MAGICEFFECTON:
		wp  = (WORD *)cp;  // ¸¶¹ý È¿°ú Á¾·ù 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // ¸¶¹ý È¿°ú È¿·Â  
		*dwp = (DWORD)sV2;
		cp += 4;

		dwp  = (DWORD *)cp;  // ¸¶¹ý È¿°ú È¿·Â  
		*dwp = (DWORD)sV3;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;
	
	case DEF_NOTIFY_CANNOTITEMTOBANK:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	
	case DEF_NOTIFY_SERVERCHANGE:
		memcpy(cp, m_pClientList[iToH]->m_cMapName, 10);
		cp += 10;
	
		// World ServerÀÇ ÁÖ¼Ò¸¦ ¾Ë·ÁÁØ´Ù.
		memcpy(cp, m_cLogServerAddr, 15);
		cp += 15;

		ip = (int *)cp;
		*ip = m_iLogServerPort;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16 +19);
		break;

	case DEF_NOTIFY_SKILL:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SETITEMCOUNT:
		wp  = (WORD *)cp;  // ¾ÆÀÌÅÛ ÀÎµ¦½º ¹øÈ£ 
		*wp = (WORD)sV1;
		cp += 2;
		
		dwp  = (DWORD *)cp;  // ¾ÆÀÌÅÛÀÇ ÇöÀç ¼ö·® 
		*dwp = (DWORD)sV2;
		cp += 4;
				
		*cp = (char)sV3;
		cp++;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 13);
		break;

	case DEF_NOTIFY_ITEMDEPLETED_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_DROPITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;

	case DEF_NOTIFY_DROPITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 12);
		break;
		
	case DEF_NOTIFY_CANNOTGIVEITEM:
	case DEF_NOTIFY_GIVEITEMFIN_COUNTCHANGED:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_GIVEITEMFIN_ERASEITEM:
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;

		ip  = (int *)cp;
		*ip = (int)sV2;
		cp += 4;
		
		memcpy(cp, pString, 20);
		cp += 20;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 32);
		break;

	case DEF_NOTIFY_ENEMYKILLREWARD:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iEnemyKillCount;
		cp += 4;
		memcpy(cp, m_pClientList[sV1]->m_cCharName, 10);
		cp += 10;
		memcpy(cp, m_pClientList[sV1]->m_cGuildName, 20);
		cp += 20;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[sV1]->m_iGuildRank;
		cp += 2;
		sp  = (short *)cp;
		*sp = (short)m_pClientList[iToH]->m_iWarContribution;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_PKCAPTURED:
		// PK¸¦ Àâ¾Ò´Ù.
		// PKÀÇ PKcount
		wp  = (WORD *)cp;
		*wp = (WORD)sV1;
		cp += 2;
		wp  = (WORD *)cp;
		*wp = (WORD)sV2;
		cp += 2;
		memcpy(cp, pString, 10);
		cp += 10;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iRewardGold;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = m_pClientList[iToH]->m_iExp;
		cp += 4;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_NOTIFY_PKPENALTY:
		// PK Æä³ÎÆ¼¸¦ ¸Ô¾ú´Ù.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iStr;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iVit;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iDex;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iInt;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMag;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iPKCount;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;
	
	case DEF_NOTIFY_TRAVELERLIMITEDLEVEL:
	case DEF_NOTIFY_LIMITEDLEVEL:
		// Ã¼ÇèÆÇ »ç¿ëÀÚ´Â ´õÀÌ»ó ·¹º§À» ¿Ã¸± ¼ö ¾øÀ½À» ¾Ë¸°´Ù.
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_ITEMRELEASED:
	case DEF_NOTIFY_ITEMLIFESPANEND:
		// ÀüÅõÁß ¹«±â, È¤Àº ¹æ¾î±¸ ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´ÙÇØ ¸Á°¡Á³À½À» ¾Ë¸°´Ù. 
		sp  = (short *)cp;
		*sp = (short)sV1;	// ÀåÂø À§Ä¡ 
		cp += 2;
		sp = (short *)cp;
		*sp = (short)sV2;	// ¾ÆÀÌÅÛ ¹øÈ£  
		cp += 2;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;
	
	case DEF_NOTIFY_KILLED:
		// »ç¸Á Åëº¸ : Á×ÀÎ Ä³¸¯ÅÍ ÀÌ¸§µµ ÇÔ²² º¸³»ÁØ´Ù. 
		memcpy(cp, pString, 20);
		cp += 20;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 26);
		break;
	
	case DEF_NOTIFY_EXP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iExp;
		cp += 4;

		ip = (int *)cp;
		*ip = m_pClientList[iToH]->m_iRating;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 14);
		break;

	case DEF_NOTIFY_HP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iHP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_MP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iMP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_SP:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iSP;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

	case DEF_NOTIFY_CHARISMA:
		dwp  = (DWORD *)cp;
		*dwp = (DWORD)m_pClientList[iToH]->m_iCharisma;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break;

		//MOG Fixes
	case DEF_NOTIFY_STATECHANGE_FAILED:		// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ½ÇÆÐ..korean buttplugs
	case DEF_NOTIFY_SETTING_FAILED:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	case DEF_NOTIFY_STATECHANGE_SUCCESS:	// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¼º°ø.. wtf korean junk
		{
			int i;

			for (i = 0; i < DEF_MAXMAGICTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cMagicMastery[i];
				cp++;
			}

			for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
				*cp = m_pClientList[iToH]->m_cSkillMastery[i];
				cp++;
			}

			iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6 + DEF_MAXMAGICTYPE + DEF_MAXSKILLTYPE);
		}
		break;

	case DEF_NOTIFY_SETTING_SUCCESS:
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;

		/*
	case DEF_NOTIFY_LEVELUP:
		ip  = (int *)cp;
		*ip = m_pClientList[iToH]->m_iLevel;
		cp += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iStr;		
		cp  += 4;
		
		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iVit;								
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iDex;			
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iInt;					
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iMag;						
		cp  += 4;

		ip   = (int *)cp;
		*ip  = m_pClientList[iToH]->m_iCharisma;
		cp  += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 34);
		break;
*/
	case DEF_NOTIFY_QUERY_DISMISSGUILDREQPERMISSION:
	case DEF_NOTIFY_QUERY_JOINGUILDREQPERMISSION:
	case DEF_NOTIFY_CANNOTJOINMOREGUILDSMAN:
		
		memcpy(cp, m_pClientList[iFromH]->m_cCharName, 10);
		cp += 10;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 16);
		break;

	case DEF_COMMONTYPE_JOINGUILDAPPROVE:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;
		
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 28);
		break;

	case DEF_COMMONTYPE_JOINGUILDREJECT:			
    case DEF_COMMONTYPE_DISMISSGUILDAPPROVE:		
    case DEF_COMMONTYPE_DISMISSGUILDREJECT:
		if (m_pClientList[iFromH] != NULL)
			 memcpy(cp, m_pClientList[iFromH]->m_cGuildName, 20);
		else memcpy(cp, "?", 1);
		cp += 20;

		sp  = (short *)cp;
		*sp = DEF_GUILDSTARTRANK;
		cp += 2;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 38);
		break;

	case DEF_NOTIFY_GUILDDISBANDED:
		
		memcpy(cp, pString, 20);
		cp += 20;

		memcpy(cp, m_pClientList[iToH]->m_cLocation, 10);
		cp += 10;
	  
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 36);
		break;

	// v1.4311-3 Ãß°¡ Å¬¶óÀÌ¾ðÆ®¿¡°Ô »çÅõÀå ¿¹¾àÀÌ Ãë¼ÒµÇ¾ú´Ù°í ¾Ë¸² ..
	case DEF_NOTIFY_FIGHTZONERESERVE:
		ip = (int *)cp;
		*ip = (int )sV1;
		cp += 4;

		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 10);
		break; 

	// v1.4311-3 Ãß°¡ ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ñ°æ¿ì .
	case DEF_NOTIFY_NOGUILDMASTERLEVEL:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;

	// v1.4311-3 Ãß°¡ ÀÚ½ÅÀÇ ±æµå¿øÀÌ  ¾Æ´Ñ°æ¿ì 
	case DEF_NOTIFY_CANNOTBANGUILDMAN:
		iRet = m_pClientList[iToH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		// Ã³¸® µµÁß ¿À·ù°¡ ¹ß»ýÇÏ´Â °ÍÀ» ¸·±â À§ÇØ Áö¿ìÁö ¾Ê´Â´Ù. Time OutÀ¸·Î »èÁ¦µÉ °ÍÀÓ. 
		//DeleteClient(iToH, TRUE, TRUE);
		return;
	}
}

void CGame::JoinGuildApproveHandler(int iClientH, char * pName)
{
 register int i;
 BOOL bIsExist = FALSE;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.
	
	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		// v1.4 ¼Ò¼Ó ¸¶À»ÀÌ ´Þ¶óµµ ¹«½ÃµÈ´Ù.
		if (memcmp(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) != 0) return;
		
		// ±æµåÀÇ ÀÌ¸§À» º¹»çÇÏ°í ¼öÄ¡¸¦ ÃÊ±âÈ­ÇØ ÁØ´Ù.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName);
		
		// ±æµå GUIDº¹»çÇÑ´Ù.
		m_pClientList[i]->m_iGuildGUID = m_pClientList[iClientH]->m_iGuildGUID;

		// ±æµåÀÇ »ý¼ºÀ§Ä¡¸¦ ÃÊ±âÈ­ÇÑ´Ù.
		ZeroMemory(m_pClientList[i]->m_cLocation, sizeof(m_pClientList[i]->m_cLocation));
		strcpy(m_pClientList[i]->m_cLocation, m_pClientList[iClientH]->m_cLocation);

		m_pClientList[i]->m_iGuildRank = DEF_GUILDSTARTRANK; //@@@  GuildRankÀÇ ½ÃÀÛÀº DEF_GUILDSTARTRANK
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDAPPROVE, NULL, NULL, NULL, NULL);

		// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
		// ´Ù¸¥ ±æµå¿øµé¿¡°Ô »õ ±æµå¿øÀÌ ÀÖÀ½À» ¾Ë¸°´Ù.
		SendGuildMsg(i, DEF_NOTIFY_NEWGUILDSMAN, NULL, NULL, NULL);

		// ±æµåÁ¤º¸È­ÀÏ¿¡ »õ ±æµå¿øÀÇ ÀÌ¸§À» ±â·ÏÇÑ´Ù.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_NEWGUILDSMAN, i);
		return;
	}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::JoinGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ °¡ÀÔ ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô °¡ÀÔÀÌ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_JOINGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// °¡ÀÔÀ» ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::DismissGuildApproveHandler(int iClientH, char * pName)
{
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ Å»Åð¿ä±¸°¡ ¼º°øÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// ±æµå Á¤º¸ È­ÀÏ¿¡¼­ Å»ÅðÇÑ ±æµå¿øÀÇ ÀÌ¸§À» »èÁ¦ÇÑ´Ù.
		bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
		// ´Ù¸¥ ±æµå¿øµé¿¡°Ô ±æµå¿øÀÇ Å»Åð¸¦ ¾Ë¸°´Ù.
		SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
		// ±æµåÀÇ ÀÌ¸§À» ÃÊ±âÈ­ÇØ ÁØ´Ù.
		ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
		strcpy(m_pClientList[i]->m_cGuildName, "NONE");
		m_pClientList[i]->m_iGuildRank = -1; 
		m_pClientList[i]->m_iGuildGUID = -1;

		// Å»Åð ½ÅÃ»ÀÚ¿¡°Ô Å»Åð ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDAPPROVE, NULL, NULL, NULL, NULL);
		
		// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		return;
	}

	//  Å»Åð¸¦ ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}

void CGame::DismissGuildRejectHandler(int iClientH, char * pName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// pNameÀ» °®´Â Å¬¶óÀÌ¾ðÆ®ÀÇ iClientH ±æµå¿¡ ´ëÇÑ Å»Åð ¿ä±¸°¡ ½ÇÆÐ ÇÏ¿´´Ù.

	// pNameÀÇ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ® ±¸Á¶Ã¼¸¦ °Ë»öÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, pName, 10) == 0)) {
		
		// °¡ÀÔ ½ÅÃ»ÀÚ¿¡°Ô Å»Åð°¡ ½ÇÆÐÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_DISMISSGUILDREJECT, NULL, NULL, NULL, NULL);
		return;
	}

	// Å»Åð¸¦ ½ÅÃ»ÇÑ Å¬¶óÀÌ¾ðÆ®¸¦ Ã£À»¼ö ¾ø´Ù.(Á¢¼ÓÀÌ ±×»çÀÌ ²÷°å´Ù´øÁö) ¹«È¿ÀÓ 
}


DWORD CGame::dwGetItemCount(int iClientH, char * pName)
{
 register int i;
 char cTmpName[21];

	if (m_pClientList[iClientH] == NULL) return NULL;
	
	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		return m_pClientList[iClientH]->m_pItemList[i]->m_dwCount;
	}

	return 0;
}

int CGame::SetItemCount(int iClientH, char * pItemName, DWORD dwCount)
{
 register int i;
 char cTmpName[21];
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pItemName);

	for (i = 0; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i] != NULL) && (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, cTmpName, 20) == 0)) {
		
		wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], 1);// m_pClientList[iClientH]->m_pItemList[i]->m_wWeight;

		// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
		if (dwCount == 0) {
			ItemDepleteHandler(iClientH, i, FALSE);
		}
		else {
			// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
			m_pClientList[iClientH]->m_pItemList[i]->m_dwCount = dwCount;
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, i, dwCount, (char)TRUE, NULL);
		}
		
		return wWeight;
	}

	return -1;
}


int CGame::SetItemCount(int iClientH, int iItemIndex, DWORD dwCount)
{
 WORD wWeight;
	
	if (m_pClientList[iClientH] == NULL) return -1;
	if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return -1;
	
	wWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[iItemIndex], 1);//m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wWeight;

	// Ä«¿îÆ®°¡ 0ÀÌ¸é ¸ðµÎ ¼Ò¸ðµÈ °ÍÀÌ¹Ç·Î ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÑ´Ù.
	if (dwCount == 0) {
		ItemDepleteHandler(iClientH, iItemIndex, FALSE);
	}
	else {
		// ¾ÆÀÌÅÛÀÇ ¼ö·®ÀÌ º¯°æµÇ¾úÀ½À» ¾Ë¸°´Ù. 
		m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount = dwCount;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETITEMCOUNT, iItemIndex, dwCount, (char)TRUE, NULL);
	}
		
	return wWeight;	
}
   

void CGame::ClientKilledHandler(int iClientH, int iAttackerH, char cAttackerType, short sDamage)
{
 char  * cp, cAttackerName[21], cData[120];
 short sAttackerWeapon;
 int   * ip, i, iExH;
 BOOL  bIsSAattacked = FALSE;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	m_pClientList[iClientH]->m_bIsKilled = TRUE;
	// HP´Â 0ÀÌ´Ù.
	m_pClientList[iClientH]->m_iHP = 0;

	// ¸¸¾à ±³È¯ ¸ðµå¶ó¸é ±³È¯À» Ãë¼ÒÇÑ´Ù.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// ÇöÀç ÀÌ NPC¸¦ °ø°Ý´ë»óÀ¸·Î »ï°íÀÖ´Â °´Ã¼µéÀ» ÇØÁ¦ÇÑ´Ù.
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	ZeroMemory(cAttackerName, sizeof(cAttackerName));
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER_INDIRECT:
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pClientList[iAttackerH]->m_cCharName, 10);
		break;
	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iAttackerH] != NULL)
			memcpy(cAttackerName, m_pNpcList[iAttackerH]->m_cNpcName, 20);
		break;
	default:
		break;
	}

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_KILLED, NULL, NULL, NULL, cAttackerName);
	// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Á×´Â µ¿ÀÛ Àü¼Û.
	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		sAttackerWeapon = ((m_pClientList[iAttackerH]->m_sAppr2 & 0x0FF0) >> 4);	
	}
	else sAttackerWeapon = 1;
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
	// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(12, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
	// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);

	
	// Èñ»ýÀÚ°¡ Æ÷»óµµ ¾ø°í Æä³ÎÆ¼µµ ¾ø´Â ¸Ê¿¡¼­ Á×¾ú´Ù¸é Èñ»ýÀÚÀÇ ¾ÆÀÌÅÛÀ» ¶³¾î¶ß·Á¼­´Â ¾ÈµÈ´Ù. 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) return;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
		// v1.432
		// Æ¯¼ö ´É·ÂÀÌ ÀÖ´Â ¹«±â·Î °ø°ÝÀ» ´çÇß´Ù.
		switch (m_pClientList[iAttackerH]->m_iSpecialAbilityType) {
		case 1:
		case 2:
		case 3:
		case 4:
		case 5:
			bIsSAattacked = TRUE;
			break;
		}
		
		if (iAttackerH == iClientH) return; // ÀÚÆøÀÌ´Ù.
		// ÇÃ·¹ÀÌ¾î°¡ ÇÃ·¹ÀÌ¾î¸¦ Á×¿´´Ù¸é PKÀÎÁö ÀüÅõÁß ½Â¸®ÀÎÁö¸¦ ÆÇº°ÇÏ¿© °æÇèÄ¡¸¦ ¿Ã¸°´Ù. 
		if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
			// Èñ»ýÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù. 
			if (m_pClientList[iClientH]->m_iPKCount == 0) {
				// ¹«°íÇÑ ¿©ÇàÀÚ¿´´Ù. °ø°ÝÀÚ´Â PK ºÒÀÌÀÍÀ» ¹Þ´Â´Ù.
				ApplyPKpenalty(iAttackerH, m_pClientList[iClientH]->m_iLevel);
			}
			else {
				// ¹üÁË¸¦ ÀúÁö¸¥ ¿©ÇàÀÚ¿´´Ù. °ø°ÝÀÚ´Â PK¸¦ ÀâÀº°Í¿¡ ´ëÇÑ Æ÷»óÀ» ¹Þ´Â´Ù. 
				PK_KillRewardHandler(iAttackerH, iClientH);
			}
		} 
		else {
			// Èñ»ýÀÚ°¡ ¿©ÇàÀÚ°¡ ¾Æ´Ï¶ó ÇÑ ¸¶À» ¼Ò¼ÓÀÌ´Ù. 
			if (m_pClientList[iClientH]->m_iGuildRank == -1) {
				// Èñ»ýÀÚ´Â ½Ã¹ÎÀÌ´Ù.
				// °ø°ÝÀÚ°¡ ¿©ÇàÀÚ, °°Àº ¸¶À» ½Ã¹Î, °°Àº ¸¶À» ±æµå¿ø -> PK°¡ µÊ. ´Ù¸¥ ¸¶À» ½Ã¹Î, ±æµå¿ø -> Á¤´çÇÑ °ø°Ý
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// °ø°ÝÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù. 				
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ¹«°íÇÑ ½Ã¹ÎÀ» ¿©ÇàÀÚ°¡ Á×¿´´Ù. ¿©ÇàÀÚ´Â PK°¡ µÈ´Ù.
						ApplyPKpenalty(iAttackerH, m_pClientList[iClientH]->m_iLevel);
					}
					else {
						// ¿©ÇàÀÚ´Â PK¸¦ Àâ¾Æµµ º¸»óÀ» ¹ÞÁö ¸øÇÑ´Ù.

					}
				}
				else {
					// °ø°ÝÀÚ°¡ ½Ã¹Î, È¤Àº ±æµå¿ø -> ¸¶À»ÀÌ °°À¸¸é PK, ´Ù¸¥ ¸¶À»ÀÌ¶ó¸é Á¤´çÇÑ °ø°Ý 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// °°Àº ¸¶À» ½Ã¹ÎÀ» °°Àº¸¶À» ½Ã¹Î È¤Àº ±æµå¿øÀÌ °ø°ÝÇÑ °ÍÀÌ´Ù.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// Èñ»ýÀÚ°¡ ¹«°íÇÑ »óÅÂ. PKÀÌ´Ù.
							ApplyPKpenalty(iAttackerH, m_pClientList[iClientH]->m_iLevel);
						}
						else {
							// ¹üÁËÀÚ¸¦ Àâ¾Ò´Ù. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// °ø°ÝÀÚ°¡ ´Ù¸¥ ¸¶À» ¼Ò¼Ó. Á¤´çÇÑ °ø°ÝÇàÀ§
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
			else {
				// Èñ»ýÀÚ´Â ±æµå¿øÀÌ´Ù. 
				// °ø°ÝÇÑ ÀÚ°¡ ¿©ÇàÀÚ, ½Ã¹Î, ÀüÀï»óÅÂ°¡ ¾Æ´Ñ ±æµå¿ø-> PK / Àü»ý»óÅÂÁßÀÎ ±æµå¿ø -> Á¤´çÇÑ ÀüÅõÇàÀ§
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
					// °ø°ÝÀÚ°¡ ¿©ÇàÀÚÀÌ´Ù.
					if (m_pClientList[iClientH]->m_iPKCount == 0) {
						// ¹«°íÇÑ ±æµå¿øÀ» ¿©ÇàÀÚ°¡ Á×¿´´Ù. ¿©ÇàÀÚ´Â PK°¡ µÈ´Ù.
						ApplyPKpenalty(iAttackerH, m_pClientList[iClientH]->m_iLevel);
					}
					else {
						// ¿©ÇàÀÚ´Â PK¸¦ Àâ¾Æµµ º¸»óÀ» ¹ÞÁö ¸øÇÑ´Ù.

					}
				}
				else {
					// °ø°ÝÀÚ´Â ½Ã¹Î È¤Àº ±æµå¿ø -> ¸¶À»ÀÌ °°À¸¸é PK, ´Ù¸¥ ¸¶À»ÀÌ¶ó¸é Á¤´çÇÑ °ø°Ý 
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iAttackerH]->m_cLocation, 10) == 0) {
						// °°Àº ¸¶À» ±æµå¿øÀ» °°Àº¸¶À» ½Ã¹Î È¤Àº ±æµå¿øÀÌ °ø°ÝÇÑ °ÍÀÌ´Ù.  
						if (m_pClientList[iClientH]->m_iPKCount == 0) {
							// Èñ»ýÀÚ°¡ ¹«°íÇÑ »óÅÂ. PKÀÌ´Ù.
							ApplyPKpenalty(iAttackerH, m_pClientList[iClientH]->m_iLevel);
						}
						else {
							// ¹üÁËÀÚ¸¦ Àâ¾Ò´Ù. 
							PK_KillRewardHandler(iAttackerH, iClientH);
						}
					}
					else {
						// °ø°ÝÀÚ°¡ ´Ù¸¥ ¸¶À» ¼Ò¼Ó. Á¤´çÇÑ °ø°ÝÇàÀ§
						EnemyKillRewardHandler(iAttackerH, iClientH);
					}
				}
			}
		}

		// Èñ»ý´çÇÑ ÇÃ·¹ÀÌ¾îÀÇ µî±Þ¿¡ ¸Â´Â Æä³ÎÆ¼¸¦ ÃëÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			if (memcmp(m_pClientList[iAttackerH]->m_cLocation, "NONE", 4) == 0) {
				//¿©ÇàÀÚ¿¡°Ô °ø°Ý¹Þ¾Æ Á×¾ú´Ù. 
				//PK´çÇßÀ¸¹Ç·Î °æÇèÄ¡°¡ ÁÙÁö ¾Ê´Â´Ù.
				//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
				//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
				//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
			}
			else {
				if (memcmp(m_pClientList[iAttackerH]->m_cLocation, m_pClientList[iClientH]->m_cLocation, 10) == 0) {
					//°°Àº ¸¶À» ½Ã¹Î È¤Àº ±æµå¿ø¿¡°Ô Á×¾ú´Ù. 
					//PK´çÇßÀ¸¹Ç·Î °æÇèÁö°¡ ÁÙÁö ¾Ê´Â´Ù. 
					//m_pClientList[iClientH]->m_iExp -= iDice(1, 100);
					//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;
					//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
				}
				else {
					// ´Ù¸¥ ¸¶À» ½Ã¹Î È¤Àº ±æµå¿ø¿¡°Ô Á×¾ú´Ù. ÀüÀïÁß Á×¾úÀ¸¹Ç·Î °æÇèÄ¡¿Í ¾ÆÀÌÅÛÀÌ ¶³¾îÁø´Ù. 
					ApplyCombatKilledPenalty(iClientH, 2, bIsSAattacked);
				}
			}
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_NPC) {
		// ÇÃ·¹ÀÌ¾î°¡ ¸÷¿¡°Ô Á×¾ú´Ù. Èñ»ý´çÇÑ ÇÃ·¹ÀÌ¾îÀÇ µî±Þ¿¡ ¸Â´Â Æä³ÎÆ¼¸¦ ÃëÇÑ´Ù.
		if (m_pClientList[iClientH]->m_iPKCount == 0) {
			// Innocent
			ApplyCombatKilledPenalty(iClientH, 1, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 1) && (m_pClientList[iClientH]->m_iPKCount <= 3)) {
			// Criminal 
			ApplyCombatKilledPenalty(iClientH, 3, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 4) && (m_pClientList[iClientH]->m_iPKCount <= 11)) {
			// Murderer 
			ApplyCombatKilledPenalty(iClientH, 6, bIsSAattacked);
		}
		else if ((m_pClientList[iClientH]->m_iPKCount >= 12)) {
			// Slaughterer 
			ApplyCombatKilledPenalty(iClientH, 12, bIsSAattacked);
		}
		// ¸¸¾à °ø°ÝÇÑ NPC°¡ ÀüÀï¿ë À¯´ÏÆ®¶ó¸é ÁöÈÖ°ü¿¡°Ô °Ç¼³ Æ÷ÀÎÆ® ºÎ°¡
		if (m_pNpcList[iAttackerH]->m_iGuildGUID != NULL) {
						
			if (m_pNpcList[iAttackerH]->m_cSide != m_pClientList[iClientH]->m_cSide) {
				// ÀüÀï¿ë ±¸Á¶¹° È¤Àº À¯´ÏÆ®°¡ Àû ÇÃ·¹ÀÌ¾î¸¦ Á×¿´´Ù. ¹Ù·Î Åëº¸ÇÑ´Ù.
				// ÇöÀç ¼­¹ö¿¡ ÁöÈÖ°üÀÌ ÀÖ´Ù¸é °ð¹Ù·Î Åëº¸. ¾øÀ¸¸é ´Ù¸¥ ¼­¹ö·Î ¾Ë·ÁÁÜ.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildGUID == m_pNpcList[iAttackerH]->m_iGuildGUID) &&
					(m_pClientList[i]->m_iCrusadeDuty == 3)) {
					m_pClientList[i]->m_iConstructionPoint += (m_pClientList[iClientH]->m_iLevel / 2);

					if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
						m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

					//testcode
					wsprintf(G_cTxt, "Enemy Player Killed by Npc! Construction +%d", (m_pClientList[iClientH]->m_iLevel / 2));
					PutLogList(G_cTxt);
					// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
					return;
				}
				
				// ÇöÀç ¼­¹ö¿¡ ¾ø´Ù. ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
				ZeroMemory(cData, sizeof(cData));
				cp = (char *)cData;
				*cp = GSM_CONSTRUCTIONPOINT;
				cp++;
				ip = (int*)cp;
				*ip = m_pNpcList[iAttackerH]->m_iGuildGUID;
				cp += 4;
				ip = (int*)cp;
				*ip = (m_pClientList[iClientH]->m_iLevel / 2);
				cp += 4;
				bStockMsgToGateServer(cData, 9);
			}
		}
	}
	else if (cAttackerType == DEF_OWNERTYPE_PLAYER_INDIRECT) {
		// ÇÃ·¹ÀÌ¾î°¡ Á×¾úÁö¸¸ °ø°ÝÀÚ°¡ °£Á¢ÀûÀÌ´Ù. ¾Æ¹«·± ¿µÇâÀÌ ¾ø´Ù.
		//m_pClientList[iClientH]->m_iExp -= iDice(1, 50);
		//if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
}

void CGame::ReleaseItemHandler(int iClientH, short sItemIndex, BOOL bNotice)
{
 char cEquipPos;
 short sTemp;
 int   iTemp;

	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType != DEF_ITEMTYPE_EQUIP) return;
	
	// ÀåÂøµÇÁö ¾ÊÀº ¾ÆÀÌÅÛÀÌ¶ó¸é ¹«½ÃÇÑ´Ù. 
	if (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == FALSE) return;

	cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;
	// ¾ÆÀÌÅÛÀÇ ÇØÁ¦À§Ä¡¿¡ ¸Â°Ô Apprº¯¼ö¸¦ Á¶Á¤ÇÑ´Ù.
	switch (cEquipPos) {
	case DEF_EQUIPPOS_RHAND:
		// ¿À¸¥¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹«±â·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;

		// V1.3 ¹«±â¼Óµµ Àç°è»ê <- ¸Ç¼ÕÀÌ´Ï±ñ 0
		sTemp = m_pClientList[iClientH]->m_sStatus;
		sTemp = sTemp & 0xFFF0;
		m_pClientList[iClientH]->m_sStatus = sTemp;
		break;

	case DEF_EQUIPPOS_LHAND:
		// ¿Þ¼Õ¿¡ ÀåÂøÇÏ´Â ¾ÆÀÌÅÛ. ¹æÆÐ·ùÀÌ´Ù. 
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xFFF0;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xF0FFFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_TWOHAND:
		// ¾ç¼Õ¿¡ ÀåÂøÇÑ´ÙÁö¸¸ »ç½Ç ¿À¸¥¼Õ¿¡¸¸ µé°í ÀÖ´Ù. ¿Þ¼ÕÀº ºñ¾îÀÖ´Â »óÅÂ.
		sTemp = m_pClientList[iClientH]->m_sAppr2;
		sTemp = sTemp & 0xF00F;	// ¹«±â Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr2 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0x0FFFFFFF; // ¹«±â »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BODY:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		// °Ñ¿Ê È®Àå Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xFF7F;	
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFF0FFFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_BACK:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0xF0FF;	// ¸ÁÅä Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFF0FFFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_ARMS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFFF0;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFF0FFF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_PANTS:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xF0FF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFF0FF; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_LEGGINGS:
		sTemp = m_pClientList[iClientH]->m_sAppr4;
		sTemp = sTemp & 0x0FFF;	// °Ñ¿Ê Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr4 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFF0F; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;

	case DEF_EQUIPPOS_HEAD:
		sTemp = m_pClientList[iClientH]->m_sAppr3;
		sTemp = sTemp & 0xFF0F;	// Åõ±¸ Æ¯¼ºÄ¡ ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_sAppr3 = sTemp;

		iTemp = m_pClientList[iClientH]->m_iApprColor; // v1.4 ÄÃ·¯°ª ¼¼ÆÃ 
		iTemp = iTemp & 0xFFFFFFF0; // »ö ºñÆ®¸¦ Å¬¸®¾î.
		m_pClientList[iClientH]->m_iApprColor = iTemp;
		break;
 	}

	//v1.432 Æ¯¼ö ´É·ÂÀÌ ºÎ¿©µÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇÃ·¡±× ¼³Á¤ 
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) {
		// °ø°Ý Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFF3;	
	}
	
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY) {
		// ¹æ¾î±¸ Æ¯¼ö ´É·Â ºñÆ® Å¬¸®¾î
		m_pClientList[iClientH]->m_sAppr4 = m_pClientList[iClientH]->m_sAppr4 & 0xFFFC;
	}
	
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	m_pClientList[iClientH]->m_sItemEquipmentStatus[cEquipPos] = -1;
	
	// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» ¾Ë¸°´Ù.
	if (bNotice == TRUE)
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// ÀÌ ¾ÆÀÌÅÛÀ» ÇØÁ¦ÇÏ´Â °Í¿¡ µû¸£´Â Æ¯¼ºÄ¡ÀÇ º¯È­¸¦ °è»êÇÑ´Ù. 
	CalcTotalItemEffect(iClientH, sItemIndex, TRUE);
}


BOOL CGame::_bDecodeNpcConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iNpcConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// NPC ÀÌ¸§
					if (strlen(token) > 20)	{
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Too long Npc name.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					ZeroMemory(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, sizeof(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName));
					memcpy(m_pNpcConfigList[iNpcConfigListIndex]->m_cNpcName, token, strlen(token));
					cReadModeB = 2;
					break;
				case 2:
					// m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 3;
					break;
				case 3:
					// m_iHitDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitDice = atoi(token);
					cReadModeB = 4;
					break;
				case 4:
					// m_iDefenseRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iDefenseRatio = atoi(token);
					cReadModeB = 5;
					break;
				case 5:
					// m_iHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iHitRatio = atoi(token);
					cReadModeB = 6;
					break;
				case 6:
					// m_iMinBravery
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMinBravery = atoi(token);
					cReadModeB = 7;
					break;
				case 7:
					// m_iExpDice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iExpDice = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_cAttackDiceThrow
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceThrow = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_cAttackDiceRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttackDiceRange = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_cSize
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSize = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 12;
					break;
				
				case 12:
					// ActionLimit 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cActionLimit = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// Action Time
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwActionTime = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// ResistMagic
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cResistMagic = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// cMagicLevel
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cMagicLevel = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// cGenDayWeekLimit  // Æ¯Á¤ ¿äÀÏ¿¡¸¸ »ý¼ºµÇ´Â ¸ó½ºÅÍ¿©ºÎ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cDayOfWeekLimit = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// cChatMsgPresence
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence = atoi(token);
					
					if (m_pNpcConfigList[iNpcConfigListIndex]->m_cChatMsgPresence == 1) {
						// ¿¬°áµÈ Ã¤ÆÃ ¸Þ½ÃÁö°¡ Á¸ÀçÇÑ´Ù. ³»¿ëÀ» ÀÐ¾î ÀúÀåÇÑ´Ù. 


					}
					cReadModeB = 18;
					break;

				case 18:
					// m_cTargetSearchRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cTargetSearchRange = atoi(token);
										
					cReadModeB = 19;
					break;		

				case 19:
					// Npc Àç »ý¼º±îÁöÀÇ ½Ã°£
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_dwRegenTime = atoi(token);
										
					cReadModeB = 20;
					break;

				case 20:
					// Attribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_cAttribute = atoi(token);
										
					cReadModeB = 21;
					break;

				case 21:
					// Absorb Magic Damage
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAbsDamage = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// Maximum Mana Point
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMaxMana = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// MagicHitRatio
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iMagicHitRatio = atoi(token);
									
					cReadModeB = 24;
					break;

				case 24:
					// AttackRange
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! NPC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pNpcConfigList[iNpcConfigListIndex]->m_iAttackRange = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					iNpcConfigListIndex++;
					break;
				}
				break;

			case 2:
				m_iPlayerMaxLevel = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "Npc", 3) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pNpcConfigList[iNpcConfigListIndex] = new class CNpc(" ");
			}

			if (memcmp(token, "world-server-max-level", 22) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! NPC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) NPC(Total:%d) configuration - success!", iNpcConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

BOOL CGame::_bInitNpcAttr(class CNpc * pNpc, char * pNpcName, short sClass, char cSA)
{
 register int i, iTemp;
 char cTmpName[21];
 short sTemp;
 double dV1, dV2, dV3;

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pNpcName);

	for (i = 0; i < DEF_MAXNPCTYPES; i++) 
	if (m_pNpcConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pNpcConfigList[i]->m_cNpcName, 20) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø NPC ¼³Á¤À» Ã£¾Ò´Ù. ¼³Á¤°ªÀ¸·Î ÃÊ±âÈ­ÇÑ´Ù.
			ZeroMemory(pNpc->m_cNpcName, sizeof(pNpc->m_cNpcName));
			memcpy(pNpc->m_cNpcName, m_pNpcConfigList[i]->m_cNpcName, 20);
			
			pNpc->m_sType  = m_pNpcConfigList[i]->m_sType;
			
			// HitDice¿¡ µû¶ó °ø½ÄÀÌ ´Ù¸£´Ù. ¸÷°£ÀÇ Â÷º°À» µÎ±â À§ÇÔ.
			if (m_pNpcConfigList[i]->m_iHitDice <= 5)
				 pNpc->m_iHP  = abs(iDice(m_pNpcConfigList[i]->m_iHitDice, 4) + m_pNpcConfigList[i]->m_iHitDice);
			else pNpc->m_iHP  = abs((m_pNpcConfigList[i]->m_iHitDice * 4) + m_pNpcConfigList[i]->m_iHitDice + iDice(1, m_pNpcConfigList[i]->m_iHitDice));
			// v1.4 È®ÀÎÄÚµå
			if (pNpc->m_iHP == 0) pNpc->m_iHP = 1; 

			pNpc->m_iExp             = iDice(m_pNpcConfigList[i]->m_iExpDice, 4) + m_pNpcConfigList[i]->m_iExpDice;
			//
			pNpc->m_iHitDice         = m_pNpcConfigList[i]->m_iHitDice;   
			pNpc->m_iExpDice         = m_pNpcConfigList[i]->m_iExpDice;   
			pNpc->m_iDefenseRatio    = m_pNpcConfigList[i]->m_iDefenseRatio;
			pNpc->m_iHitRatio        = m_pNpcConfigList[i]->m_iHitRatio;
			pNpc->m_iMinBravery      = m_pNpcConfigList[i]->m_iMinBravery;
			pNpc->m_cAttackDiceThrow = m_pNpcConfigList[i]->m_cAttackDiceThrow;
			pNpc->m_cAttackDiceRange = m_pNpcConfigList[i]->m_cAttackDiceRange;
			pNpc->m_cSize            = m_pNpcConfigList[i]->m_cSize;
			pNpc->m_cSide            = m_pNpcConfigList[i]->m_cSide;
			pNpc->m_cActionLimit     = m_pNpcConfigList[i]->m_cActionLimit;
			pNpc->m_dwActionTime     = m_pNpcConfigList[i]->m_dwActionTime;
			pNpc->m_dwRegenTime      = m_pNpcConfigList[i]->m_dwRegenTime;
			pNpc->m_cResistMagic     = m_pNpcConfigList[i]->m_cResistMagic;
			pNpc->m_cMagicLevel      = m_pNpcConfigList[i]->m_cMagicLevel;
			pNpc->m_iMaxMana         = m_pNpcConfigList[i]->m_iMaxMana; // v1.4
			pNpc->m_iMana            = m_pNpcConfigList[i]->m_iMaxMana;
			pNpc->m_cChatMsgPresence = m_pNpcConfigList[i]->m_cChatMsgPresence;
			pNpc->m_cDayOfWeekLimit  = m_pNpcConfigList[i]->m_cDayOfWeekLimit;
			pNpc->m_cTargetSearchRange = m_pNpcConfigList[i]->m_cTargetSearchRange;
			
			switch (sClass) {
			case 43:
			case 44:
			case 45:
			case 46:
			case 47: // ÀüÀï¿ë À¯´ÖÀÇ °æ¿ì ¹«Á¶°Ç °ø°Ý¸¸ ÇÏ´Â Àü·«À» ±¸»ç.
				pNpc->m_iAttackStrategy = DEF_ATTACKAI_NORMAL;
				break;

			default: 
				pNpc->m_iAttackStrategy = iDice(1,10); 
				break;
			}
	
			pNpc->m_iAILevel		   = iDice(1,3);
			pNpc->m_iAbsDamage         = m_pNpcConfigList[i]->m_iAbsDamage;
			pNpc->m_iMagicHitRatio     = m_pNpcConfigList[i]->m_iMagicHitRatio;
			pNpc->m_iAttackRange       = m_pNpcConfigList[i]->m_iAttackRange;
			pNpc->m_cSpecialAbility    = cSA;
			pNpc->m_iBuildCount		   = m_pNpcConfigList[i]->m_iMinBravery;

			// v1.411 NPCÀÇ Æ¯¼ö È¿°ú °è»ê. °æÇèÄ¡ °¡Áß 
			switch (pNpc->m_cSpecialAbility) {
			case 1:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 2:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 30.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			
			case 3: // Absorbing Physical Damage
				if (pNpc->m_iAbsDamage > 0) {
					// ±âº»ÀûÀ¸·Î ¸¶¹ý ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¹°¸® ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage -= iTemp;
					if (pNpc->m_iAbsDamage < -90) pNpc->m_iAbsDamage = -90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)abs(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 4: // Absorbing Magical Damage
				if (pNpc->m_iAbsDamage < 0) {
					// ±âº»ÀûÀ¸·Î ¹°¸® ´ë¹ÌÁö Àý°¨ ´É·ÂÀÌ ÀÖ´Â °æ¿ì ¸¶¹ý ´ë¹ÌÁö Àý°¨Àº Àû¿ëµÇÁö ¾Ê´Â´Ù. 
					pNpc->m_cSpecialAbility = NULL;
					cSA = NULL;
				}
				else {
					iTemp = 20 + iDice(1, 60);
					pNpc->m_iAbsDamage += iTemp;
					if (pNpc->m_iAbsDamage > 90) pNpc->m_iAbsDamage = 90;
				}

				dV2 = (double)pNpc->m_iExp;
				dV3 = (double)(pNpc->m_iAbsDamage)/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 5:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 15.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 6:
			case 7:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 20.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;

			case 8:
				dV2 = (double)pNpc->m_iExp;
				dV3 = 25.0f/100.0f;
				dV1 = dV2 * dV3;
				pNpc->m_iExp += (int)dV1;
				break;
			}

			// v1.411 À§Ä¡ ¿Å±è 
			pNpc->m_iNoDieRemainExp  = (pNpc->m_iExp) - (pNpc->m_iExp/3);

			// v1.411 NPCÀÇ Æ¯¼ö ´É·Â »ðÀÔ 
			pNpc->m_sStatus	= pNpc->m_sStatus & 0xF0FF;
			sTemp           = cSA;
			sTemp           = sTemp << 8;
			pNpc->m_sStatus = pNpc->m_sStatus | sTemp;
	
			// v1.41 NPCÀÇ Class»ðÀÔ.
			pNpc->m_sStatus			   = pNpc->m_sStatus & 0xFFF0;
			pNpc->m_sStatus            = pNpc->m_sStatus | (sClass);
	
			return TRUE;
		}
	}

	// NPC¸®½ºÆ®¸¦ ¸ðµÎ °Ë»öÇßÀ½¿¡µµ ¹ß°ßµÇÁö ¾Ê¾Ò´Ù. 
	return FALSE;
}

int CGame::iDice(int iThrow, int iRange)
{
 register int i, iRet;

	if (iRange <= 0) return 0;

	iRet = 0;
	for (i = 1; i <= iThrow; i++) {
		
		iRet += (rand() % iRange) + 1;
	}

	return iRet;
}

void CGame::OnStartGameSignal()
{
 int i;
 char * cp;
 HANDLE hFile;
 FILE * pFile;
 DWORD  dwFileSize;
	
	// ¸Ê ÀÌº¥Æ® È­ÀÏÀ» ÀÐ¾î °¢°¢ÀÇ ¸Ê¿¡ ÇÒ´çµÈ NPCµéÀ» ¼¼ÆÃÇÑ´Ù.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) 
		_bReadMapInfoFiles(i);
	
	// Crusade
	
	// Á¡·É ±ê¹ß Á¤º¸ ÀÐ´Â´Ù.
	hFile = CreateFile("GameData\\OccupyFlag.txt", GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen("GameData\\OccupyFlag.txt", "rt");
	if (pFile == NULL) {
		// Á¡·É ±ê¹ß Á¤º¸¸¦ ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open file: GameData\\OccupyFlag.txt");
	}
	else {
		PutLogList("(!) Occupy Flag save file contents decoding...");
	
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);
		_bDecodeOccupyFlagSaveFileContents(cp, dwFileSize);
		delete cp;
	}

	// ÃÊ±â ¼³Ä¡ °Ç¹° Á¤º¸ ÀÐ´Â´Ù.
	bReadCrusadeStructureConfigFile("Crusade.cfg");
	// Æø°Ý Æ÷ÀÎÆ® Á¤º¸¸¦ ¹ÙÅÁÀ¸·Î ¸Ê ÀÎµ¦½º¸¦ ¸µÅ©½ÃÅ²´Ù.
	_LinkStrikePointMapIndex();

	bReadCrusadeGUIDFile("GameData\\CrusadeGUID.txt");
	
	PutLogList("");
	PutLogList("(!) Game Server Activated.");
}

void CGame::CalculateGuildEffect(int iVictimH, char cVictimType, short sAttackerH)
{
 register int ix, iy, iExp;
 short sOwnerH;
 char cOwnerType;

	// ### ERROR POINT! ÀÓ½Ã·Î ¸·¾Æ ³í´Ù.
	return;

	if (m_pClientList[sAttackerH] == NULL) return;

	switch (cVictimType) {

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iVictimH] == NULL) return;

		for (ix = m_pNpcList[iVictimH]->m_sX-2; ix <= m_pNpcList[iVictimH]->m_sX+2; ix++)
		for (iy = m_pNpcList[iVictimH]->m_sY-2; iy <= m_pNpcList[iVictimH]->m_sY+2; iy++) {
			
			m_pMapList[m_pNpcList[iVictimH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH != NULL) && (sOwnerH != sAttackerH) &&
			 	 (memcmp(m_pClientList[sAttackerH]->m_cGuildName, m_pClientList[sOwnerH]->m_cGuildName, 20) == 0) &&
				 (m_pClientList[sAttackerH]->m_iLevel >= m_pClientList[sOwnerH]->m_iLevel) ) {
				 // ±æµå¿ø°úÀÇ Çùµ¿ÀüÅõ¿¡¼­ °æÇèÄ¡¸¦ ¾ò±â À§ÇØ¼­´Â ¸ó½ºÅÍ¸¦ Á×ÀÎ ±æµå¿øÀÇ ·¹º§º¸´Ù ³·Àº ±æµå¿øÀÌ¾î¾ß ÇÑ´Ù.
				 // 1D3ÀÇ °ªÀÌ 2ÀÏ¶§ ¸ó½ºÅÍ °æÇèÄ¡ÀÇ 3ºÐÀÇ 1À» ¾ò´Â´Ù. 
				if (iDice(1,3) == 2) {
					iExp = (m_pNpcList[iVictimH]->m_iExp / 3);
					if (m_pClientList[sAttackerH]->m_iLevel >= m_iPlayerMaxLevel) iExp = 0;

					if (iExp > 0) {
						
						m_pClientList[sOwnerH]->m_iExp += iExp;
						if (bCheckLimitedUser(sOwnerH) == FALSE) {
							// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ °É¸®Áö ¾Ê¾Ò´Ù. °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
						}
						// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
						bCheckLevelUp(sOwnerH);
					}
				}
			}
		}												     
		break;
	}
}

void CGame::TimeHitPointsUp(int iClientH)
{
 register int iMaxHP, iTemp, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 Á×ÀºÃ´ÇÏ±â ±â¼ú »ç¿ëÁß¿¡´Â Ã¼·Â ¿À¸£Áö ¾ÊÀ½.

	//iMaxHP = (3*m_pClientList[iClientH]->m_iVit) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iStr/2); // V1.4
	iMaxHP = iGetMaxHP(iClientH);

	if (m_pClientList[iClientH]->m_iHP < iMaxHP) {
		
		// HP Â÷´Â ÃÖ¼Ò°ªÀ» º¸Àå.
		iTemp = iDice(1, (m_pClientList[iClientH]->m_iVit));
		if (iTemp < (m_pClientList[iClientH]->m_iVit/2)) iTemp = (m_pClientList[iClientH]->m_iVit/2);

		// v1.4 HPÂ÷´Â ¾çÀ» ÀçÁ¶Á¤ÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
			iTemp = iTemp - (iTemp/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

		iTotal = iTemp + m_pClientList[iClientH]->m_iHPstock;

		if (m_pClientList[iClientH]->m_iAddHP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddHP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iHP += iTotal; // Hit Point´Â 17ÃÊ¸¶´Ù 1D(Vit) + HPstock¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iHP > iMaxHP) m_pClientList[iClientH]->m_iHP = iMaxHP;
		if (m_pClientList[iClientH]->m_iHP <= 0)     m_pClientList[iClientH]->m_iHP = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
	}
	// HP°¡ ¿Ã¶ú´ø ¸»°Ç °£¿¡ 0À¸·Î Å¬¸®¾î.
	m_pClientList[iClientH]->m_iHPstock = 0;
}

void CGame::TimeManaPointsUp(int iClientH)
{
 register int iMaxMP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 Á×ÀºÃ´ÇÏ±â ±â¼ú »ç¿ëÁß¿¡´Â ¸¶³ª ¿À¸£Áö ¾ÊÀ½.

	iMaxMP = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2); // v1.4
	if (m_pClientList[iClientH]->m_iMP < iMaxMP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iMag)); // Mana Point´Â 20ÃÊ¸¶´Ù 1D(Magic)¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iAddMP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddMP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iMP += iTotal;
		
		if (m_pClientList[iClientH]->m_iMP > iMaxMP) 
			m_pClientList[iClientH]->m_iMP = iMaxMP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
	}
}


void CGame::TimeStaminarPointsUp(int iClientH)
{
 register int iMaxSP, iTotal;
 double dV1, dV2, dV3;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iHungerStatus <= 0) return;
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return; // v1.4 Á×ÀºÃ´ÇÏ±â ±â¼ú »ç¿ëÁß¿¡´Â ½ºÅ×¹Ì³Ê ¿À¸£Áö ¾ÊÀ½.

	iMaxSP = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
	if (m_pClientList[iClientH]->m_iSP < iMaxSP) {
		
		iTotal = iDice(1, (m_pClientList[iClientH]->m_iVit/3)); // Staminar Point´Â 10ÃÊ¸¶´Ù 1D(Vit/3)¾¿ ¿Ã¶ó°£´Ù.
		if (m_pClientList[iClientH]->m_iAddSP != 0) {
			dV2 = (double)iTotal;
			dV3 = (double)m_pClientList[iClientH]->m_iAddSP;
			dV1 = (dV3 / 100.0f)*dV2;
			iTotal += (int)dV1;
		}

		m_pClientList[iClientH]->m_iSP += iTotal;
		if (m_pClientList[iClientH]->m_iSP > iMaxSP) 
			m_pClientList[iClientH]->m_iSP = iMaxSP;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
	}
}

void CGame::DelayEventProcess()
{

}

void CGame::SendGuildMsg(int iClientH, WORD wNotifyMsgType, short sV1, short sV2, char * pString)
{
 char cData[500];
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 register int i, iRet;
	
	// °°Àº ±æµå¿øµé¿¡°Ô¸¸ º¸³»´Â ¸Þ½ÃÁöµé
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ( (m_pClientList[i] != NULL) && 
		 (memcmp(m_pClientList[i]->m_cGuildName, m_pClientList[iClientH]->m_cGuildName, 20) == 0) ) {

		// ### BUG POINT À§Ä¡°¡ Àß¸øµÇ¾î Æ÷ÀÎÅÍ ¿¬»êÀÌ Àß¸øµÇ¾ú´Ù. 
		ZeroMemory(cData, sizeof(cData));

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = wNotifyMsgType;
	
		cp = (char *)(cData	+ DEF_INDEX2_MSGTYPE + 2);

		// °°Àº ±æµå ÀÌ¸§À» °®°í ÀÖ´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Ò´Ù.
		switch (wNotifyMsgType) {
		case DEF_NOTIFY_GUILDDISBANDED:
			if (i == iClientH) break; // <-- ±æµå ¸¶½ºÅÍ ÀÚ½Å¿¡°Ô´Â ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê´Â´Ù.
			// ±æµå ÇØ»ê Åëº¸¿¡ ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå ·©Å©¸¦ Å¬¸®¾îÇÑ´Ù. 
			memcpy(cp, m_pClientList[iClientH]->m_cGuildName, 20);
			cp += 20;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 26);
			// ÇØ´ç Å¬¶óÀÌ¾ðÆ®ÀÇ ±æµå³»¿ëÀ» Å¬¸®¾îÇÑ´Ù. @@@@@@@
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1;
			m_pClientList[i]->m_iGuildGUID = -1;
			break;

		case DEF_NOTIFY_EVENTMSGSTRING:
			// ±æµå¿øµé¿¡°Ô Àü´ÞµÇ´Â ÀÌº¥Æ® ¸Þ½ÃÁö ½ºÆ®¸µ 
			strcpy(cp, pString);
			cp += strlen(pString);

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + strlen(pString) + 1);
			break;

		case DEF_NOTIFY_NEWGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;

		case DEF_NOTIFY_DISMISSGUILDSMAN:
			memcpy(cp, m_pClientList[iClientH]->m_cCharName, 10);
			cp += 10;

			iRet = m_pClientList[i]->m_pXSock->iSendMsg(cData, 6 + 10 + 1);
			break;
		}
	
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(i, TRUE, TRUE);
			return;
		}
	}

}

void CGame::GuildNotifyHandler(char * pData, DWORD dwMsgSize)
{
 // ´Ù¸¥ °ÔÀÓ¼­¹ö·ÎºÎÅÍ ±æµå ÀÌº¥Æ®°¡ µµÂøÇß´Ù. 
 char * cp, cCharName[11], cGuildName[21];

	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	memcpy(cCharName, cp, 10);
	cp += 10;

	memcpy(cGuildName, cp, 20);
	cp += 20;

	// ¾ÆÁ÷ ±¸ÇöµÇÁö ¾Ê¾Ò´Ù. 
}



void CGame::ToggleCombatModeHandler(int iClientH)
{
 short sAppr2;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	// Á×ÀºÃ´ÇÏ±â³ª Á×Àº »óÅÂ¿¡¼­´Â º¯È¯ÇÒ ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[19] == TRUE) return;

	sAppr2 = (short)((m_pClientList[iClientH]->m_sAppr2 & 0xF000) >> 12);
	
	if (sAppr2 == 0) {
		// ºñÀüÅõ ¸ðµå¿´´Ù. ÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0xF000 | m_pClientList[iClientH]->m_sAppr2);
	}
	else {
		// ÀüÅõ ¸ðµå¿´´Ù. ºñÀüÅõ¸ðµå·Î ¹Ù²Û´Ù.
		m_pClientList[iClientH]->m_sAppr2 = (0x0FFF & m_pClientList[iClientH]->m_sAppr2);
	}

	// Ä³¸¯ÅÍÀÇ ¿ÜÇüÀÌ ¹Ù²î¾úÀ¸¹Ç·Î ÀÌº¥Æ®¸¦ Àü´ÞÇÑ´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::OnGateSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 int   iRet;
	
	if (m_pGateSock == NULL) return;

	iRet = m_pGateSock->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// °ÔÀÌÆ®¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³À¸¹Ç·Î °ÔÀÓ¼­¹ö µî·Ï ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		PutLogList("(!!!) Gate-socket connected!");
		SendMsgToGateServer(MSGID_REQUEST_REGISTERGAMESERVER, NULL);
		// v1.41 gate-socketÀ» Àç¿¬°áÇÒ ¶§ Ä«¿îÆÃ ÇÏ´Â º¯¼ö. ¼­¹ö ÀÛµ¿ µµÁß gate-socketÀÌ ¼ÒÄÏ¿¡·¯·Î ²÷±â¸é °ð¹Ù·Î ÀçÁ¢¼ÓÀ» 
		// ½ÃµµÇÏ¸ç ÀÌ °ªÀÌ ÀÏÁ¤Ä¡ ÀÌ»óÀÌ µÇ¸é ¿¬°á ½ÇÆÐ·Î °£ÁÖµÇ¾î ÀÚµ¿ ¼­¹ö ¼Ë´Ù¿î ¸ðµå(4)·Î µé¾î°£´Ù. 
		m_iGateSockConnRetryTimes = 0;
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù.
		OnGateRead();
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
		// È®ÀÎÄÚµå°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â´Ù.
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
		// ¼ö½ÅÇØ¾ß ÇÒ ¸Þ½ÃÁö Å©±â°¡ ¹öÆÛº¸´Ù Å©´Ù.	Á¾·áÇØ¾ß¸¸ ÇÑ´Ù.
	case DEF_XSOCKEVENT_SOCKETERROR:
		// ¼ÒÄÏ¿¡ ¿¡·¯°¡ ³µ´Ù.
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
		delete m_pGateSock;
		m_pGateSock = NULL;
		PutLogList("(!!!) Gate-socket connection lost!");
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ 
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
		m_iGateSockConnRetryTimes = 1;

		wsprintf(G_cTxt, "(!!!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		/*
		// °ÔÀÌÆ® ¼­¹ö¿ÍÀÇ ¿¬°áÀÌ ²÷°åÀ¸¹Ç·Î º¹±¸ÇÒ ¼ö ¾ø´Ù. ÀÚµ¿À¸·Î ¼­¹ö¸¦ ¼Ë´Ù¿îÇÑ´Ù.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		break;
	}
}

void CGame::OnGateRead()
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pGateSock->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_GATESERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

void CGame::SendMsgToGateServer(DWORD dwMsg, int iClientH, char * pData)
{
 DWORD * dwp;
 WORD  * wp;
 int     iRet, i, * ip;
 char    cData[1000], cCharName[11], cAccountName[11], cAccountPassword[11], cAddress[16], cGuildName[21], cTxt[120], * cp;

	if (m_pGateSock == NULL) {
		PutLogList("(!) SendMsgToGateServer fail - Socket to Gate-Server not available.");
		return;
	}

	ZeroMemory(cData, sizeof(cData));
	ZeroMemory(cCharName, sizeof(cCharName));
	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));
	ZeroMemory(cAddress,  sizeof(cAddress));
	ZeroMemory(cGuildName, sizeof(cGuildName));

	switch (dwMsg) {
	case MSGID_SERVERSTOCKMSG:
		iRet = m_pGateSock->iSendMsg(pData, m_iIndexGSS+1);
		break;
	
	case MSGID_ITEMLOG:
		// ¾ÆÀÌÅÛ Àü´Þ ·Î±×´Ù. »ç¿ëÇÏÁö ¾ÊÀ½.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_ITEMLOG;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		memcpy(cp, pData, 47);
		cp += 47;

		iRet = m_pGateSock->iSendMsg(cData, 53);
		break;
	
	case MSGID_REQUEST_REGISTERGAMESERVER:
		// °ÔÀÌÆ® ¼­¹ö¿¡°Ô °ÔÀÓ¼­¹ö µî·ÏÀ» ¿äÃ»ÇÑ´Ù.
		wsprintf(cTxt, "(!) Try to register game server(%s) - GateServer", m_cServerName);
		PutLogList(cTxt);
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_REQUEST_REGISTERGAMESERVER;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		memcpy(cAccountName, m_cServerName, 10);
		memcpy(cAddress, m_cGameServerAddr, strlen(m_cGameServerAddr));

		memcpy(cp, cAccountName, 10);
		cp += 10;

		memcpy(cp, cAddress, 16);
		cp += 16;

		wp  = (WORD *)cp;
		*wp = m_iGameServerPort;
		cp += 2;

		*cp = m_iTotalMaps;
		cp++;

		for (i = 0; i < m_iTotalMaps; i++) {
			memcpy(cp, m_pMapList[i]->m_cName, 11);
			cp += 11;
		}
		
		dwp = (DWORD *)cp;
		*dwp = (DWORD)GetCurrentProcessId();	 // ÇÁ·Î¼¼½º ÇÚµéÀ» ±â·ÏÇÑ´Ù.

		cp += 4;
		dwp = (DWORD *)cp;
		*dwp = DEF_BUILDDATE;

		iRet = m_pGateSock->iSendMsg(cData, 43 + m_iTotalMaps*11);
		break;

	case MSGID_GAMESERVERALIVE:
		// Á¤±âÀûÀ¸·Î °ÔÀÓ ¼­¹öÀÇ Á¤º¸¸¦ Àü¼Û 
		// ¸¸¾à ·Î±× ¼­¹ö¿ÍÀÇ ¼ÒÄÏ ¿¬°áÀÌ ²÷¾îÁ³´Ù¸é ¸Þ½ÃÁö¸¦ º¸³»Áö ¾Ê¾Æ ¼­¹ö¿¡ ÀÌ»óÀÌ »ý°åÀ½À» ¾Ë¸®°Ô À¯µµÇÑ´Ù.
		if (m_bIsLogSockAvailable == FALSE) return;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_GAMESERVERALIVE;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;

		cp  = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		wp  = (WORD *)cp;
		*wp = m_iTotalClients;
		cp += 2;
		
		iRet = m_pGateSock->iSendMsg(cData, 8);
		break;
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// °ÔÀÌÆ® ¼­¹ö·Î ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù.
		PutLogList("(***) Socket to Gate-Server crashed! Critical error!");
		delete m_pGateSock;
		m_pGateSock = NULL;
		m_bIsGateSockAvailable = FALSE;

		// v1.41 Gate Server·ÎÀÇ Àç¿¬°á ½Ãµµ: ¼­¹ö¸¦ ¼Ë´Ù¿î ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù. 
		m_pGateSock = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pGateSock->bConnect(m_cGateServerAddr, m_iGateServerPort, WM_ONGATESOCKETEVENT);
		m_pGateSock->bInitBufferSize(DEF_MSGBUFFERSIZE);
		// v1.41 ¿¬°á ½Ã°£ Ã¼Å©¿ë 
		m_iGateSockConnRetryTimes = 1;	

		wsprintf(G_cTxt, "(!) Try to reconnect gate-socket... Addr:%s  Port:%d", m_cGateServerAddr, m_iGateServerPort);
		PutLogList(G_cTxt);

		/*
		// °ÔÀÌÆ® ¼­¹ö¿ÍÀÇ ¿¬°áÀÌ ²÷°åÀ¸¹Ç·Î º¹±¸ÇÒ ¼ö ¾ø´Ù. ÀÚµ¿À¸·Î ¼­¹ö¸¦ ¼Ë´Ù¿îÇÑ´Ù.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by gate-server connection Lost)!!!");
		}
		*/
		return;
	}
}

int CGame::iClientMotion_Magic_Handler(int iClientH, short sX, short sY, char cDir)
{
 char cData[100];
 DWORD * dwp, dwTime;
 WORD  * wp;
 int     iRet;
 	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	// ÁËÇ¥°¡ ÀÏÄ¡ÇÏÁö ¾Ê´Â ¸í·ÉÀº ¹«½ÃÇÑ´Ù. Reject¸Þ½ÃÁö¸¦ ¹Þ±â ÀÌÀü¿¡ Àü¼ÛµÈ ¸Þ½ÃÁöµéÀÌ´Ù.
	if ((sX != m_pClientList[iClientH]->m_sX) || (sY != m_pClientList[iClientH]->m_sY)) return 2;

	// v1.432-2 ¸Ê ¼½ÅÍ Á¤º¸¸¦ °»½ÅÇÑ´Ù. 
	int iStX, iStY;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) {
		iStX = m_pClientList[iClientH]->m_sX / 20;
		iStY = m_pClientList[iClientH]->m_sY / 20;
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iPlayerActivity++;
		
		switch (m_pClientList[iClientH]->m_cSide) {
		case 0: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iNeutralActivity++; break;
		case 1: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iAresdenActivity++; break;
		case 2: m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stTempSectorInfo[iStX][iStY].iElvineActivity++;  break;
		}
	}
		
	// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
	ClearSkillUsingStatus(iClientH);

	// Á×Àº À§Ä¡¿¡ ÀÖ¾ú´Ù¸é Áö¿î´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(0, iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);
	// ´Ù½Ã À§Ä¡ ½ÃÅ²´Ù.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, sX, sY);

	// Åõ¸í ¸ðµå¿´´Ù¸é ¸¶¹ý Casting½Ã¿¡ ÇØÁ¦µÈ´Ù.
	if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 )	{
		SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
		
		bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
		m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
	}

	m_pClientList[iClientH]->m_cDir = cDir;
	
	// Å¬¶óÀÌ¾ðÆ®°¡ MSGID_RESPONSE_MOTION¸Þ½ÃÁö¸¦ ¹Þ¾Æ¾ß¸¸ °è¼Ó ¸í·ÉÀ» Àü¼ÛÇÒ ¼ö ÀÖ´Ù. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_CONFIRM;

	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

int  _tmp_iMCProb[]        = {0, 300, 250, 200, 150, 100, 80, 70, 60, 50, 40};
int  _tmp_iMLevelPenalty[] = {0,   5,   5,   8,   8,  10, 14, 28, 32, 36, 40};
void CGame::PlayerMagicHandler(int iClientH, int dX, int dY, short sType, BOOL bItemEffect, int iV1)
{
 short  * sp, sX, sY, sOwnerH, sMagicCircle, rx, ry, sRemainItemSprite, sRemainItemSpriteFrame, sLevelMagic;
 char   * cp, cData[120], cDir, cOwnerType, cName[11], cItemName[21], cNpcWaypoint[11], cName_Master[11], cNpcName[21], cRemainItemColor;
 double dV1, dV2, dV3, dV4;
 int    i, iErr, iRet, ix, iy, iResult, iDiceRes, iNamingValue, iFollowersNum, iEraseReq, iWhetherBonus;
 int    tX, tY, iManaCost, iMagicAttr;
 class  CItem * pItem;
 DWORD * dwp, dwTime = timeGetTime();
 WORD  * wp, wWeaponType;
  
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((dX < 0) || (dX >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_sSizeY)) return;
	
	// ### BUG POINT!!!  	m_pClientList[iClientH]->m_cMapIndex == -1 ???
	if (m_pClientList[iClientH]->m_cMapIndex < 0) return;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex] == NULL) return;
	
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;

	// 마법 사용위치가 공격 불가능 맵이라면 캐스팅 불가능 
	if (m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// 오른손의 경우 지팡이라면 상관없이 마법을 사용할 수 있다.	
	if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);		
		if ((wWeaponType >= 30) && (wWeaponType < 39)) {
			// 지팡류는 들고 있어도 마법을 사용할 수 있다.
		}
		else return;
	}

	// 플레이어의 다른손에 아무것도 없는지 확인한다. 
	if ((m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_LHAND ]   != -1) ||
		(m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1)) return;

	// v1.42 비정상적으로 연속된 마법 메시지는 무시한다.
	if ((dwTime - m_pClientList[iClientH]->m_dwRecentAttackTime) < 100) return; 
	m_pClientList[iClientH]->m_dwRecentAttackTime = dwTime;

	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	// 마법의 성공여부를 계산한다. 
	// Magery가 100일때 써클별 마법 성공률 int _tmp_iMCProb[]. 
	//         1      2     3     4     5	 6     7	 8	  9    10
	// 성공률 300%	250%  200%  150%  100%  80%   70%   60%  50%   40%
	// 명중률 = Magery + (Mag 50 이상 보너스)
	sMagicCircle = (sType / 10) + 1;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] == 0)
		 dV1 = 1.0f;
	else dV1 = (double)m_pClientList[iClientH]->m_cSkillMastery[4];
	
	// 아이템으로 인한 마법효과라면 성공률 100%
	if (bItemEffect == TRUE) dV1 = (double)100.0f;

	dV2 = (double)(dV1 / 100.0f);
	dV3 = (double)_tmp_iMCProb[sMagicCircle];

	dV1 = dV2 * dV3;
	iResult = (int)dV1;
		
	// Int에 따른 추가 마법 성공률 계산 
	if (m_pClientList[iClientH]->m_iInt > 50)
		iResult += (m_pClientList[iClientH]->m_iInt - 50)/2;
		
	// v1.3 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 성공률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 성공률을 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 성공률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic); // v1.4
		}
	}

	// 날씨에 의한 마법 성공률 조정. 
	switch (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus) {
	case 0: break;
	case 1: iResult = iResult - (iResult / 24); break; // 비가 올 경우 성공률 4, 8, 20% 감소 
	case 2:	iResult = iResult - (iResult / 12); break;
	case 3: iResult = iResult - (iResult / 5);  break;
	}

	// 특수 아이템에 의한 마법 성공률 조정
	if (m_pClientList[iClientH]->m_iSpecialWeaponEffectType == 10) {
		dV1 = (double)iResult;
		dV2 = (double)(m_pClientList[iClientH]->m_iSpecialWeaponEffectValue * 3);
		dV3 = dV1*(dV2/100.0f);
		dV2 = dV1 + dV3;
		iResult = (int)dV2;
	}
		
	// 수치 조정.
	if (iResult <= 0) iResult = 1;

	// 날씨에 의한 마법 공격력 조정 
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
		
	// 마법의 소비 마나값 계산 
	iManaCost = m_pMagicConfigList[sType]->m_sValue1;
	if ((m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) && 
		(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)) {
		// 안전모드의 경우 마나 소비량 40%증가. 단 사투장에서는 해당없음
		iManaCost += (iManaCost / 2) - (iManaCost / 10);
	}

	if (m_pClientList[iClientH]->m_iManaSaveRatio > 0) {
		// 마나 절감 값이 양수면 그 만큼 마나소비가 줄어든다.
		dV1 = (double)m_pClientList[iClientH]->m_iManaSaveRatio;
		dV2 = (double)(dV1 / 100.0f);
		dV3 = (double)iManaCost;
		dV1 = dV2 * dV3; // 이 값이 절약되는 값 
		dV2 = dV3 - dV1; 
		iManaCost = (int)dV2;
		// 최소 1은 필요하다. 
		if (iManaCost <= 0) iManaCost = 1;
	}

	if (iResult < 100) {
		// 주사위를 굴린 값이 iResult보다 같거나 작으면 성공 
		iDiceRes = iDice(1,100);
		if (iResult < iDiceRes) {
			// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
			return;
		}
	}
	// iResult가 100보다 크면 무조건 성공, 그러나 배가 너무 고프다거나 SP가 낮으면 1/10 실패 가능성이 있다.
	if (((m_pClientList[iClientH]->m_iHungerStatus <= 10) || (m_pClientList[iClientH]->m_iSP <= 0)) && (iDice(1,1000) <= 100)) {
		// 마법 실패! Damage가 0이라면 마법 실패를 의미한다.
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, 0, -1, NULL);
		return;	
	}
	 
	// Mana가 부족해도 실패. 
	if (m_pClientList[iClientH]->m_iMP < iManaCost) {
		// 원래는 클라이언트에서 걸러지나 해킹을 대비하기 위함. 
		return;
	}

	// 명중률을 계산해서 iResult에다 넣어준다. 
	iResult = m_pClientList[iClientH]->m_cSkillMastery[4];
	// Mag이 50보다 크면 보너스 명중률
	if (m_pClientList[iClientH]->m_iMag > 50) iResult += (m_pClientList[iClientH]->m_iMag - 50); 	
	
	// 쓰고자 하는 마법의 써클과 플레이어의 레벨 관계에 따라 명중률이 가감된다. 
	sLevelMagic = (m_pClientList[iClientH]->m_iLevel / 10);
	if (sMagicCircle != sLevelMagic) {
		if (sMagicCircle > sLevelMagic) {
			// 자신의 레벨보다 큰 마법을 쓴다. 차이만큼 명중률을 감소시킨다. 비례하여 감소시킨다.
			dV1 = (double)(m_pClientList[iClientH]->m_iLevel - sLevelMagic*10);
			dV2 = (double)abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle];
			dV3 = (double)abs(sMagicCircle - sLevelMagic)*10;
			dV4 = (dV1 / dV3)*dV2;

			iResult -= abs(abs(sMagicCircle - sLevelMagic)*_tmp_iMLevelPenalty[sMagicCircle] - (int)dV4);
		}
		else {
			// 자신의 레벨보다 낮은 마법을 쓴다. 차이만큼 명중률을 증가시킨다.
			iResult += 5*abs(sMagicCircle - sLevelMagic);
		}
	}
	// 수치 조정.
	if (iResult <= 0) iResult = 1;
	// 만약 9써클 이상이면 마법 방어로 막을 수 없다.
	if (sType >= 80) iResult += 10000;

	// 공격 마법을 사용할 위치가 No-Attack-Area라고해도 실패 
	if (m_pMagicConfigList[sType]->m_cCategory == 1) {
		// 마법 보호 혹은 안전 영역이라면 공격 성공 못함 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetAttribute(sX, sY, 0x00000005) != 0) return;
	}
	
	// v1.41 마법 속성
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_POLYMORPH:
			// 변신 마법. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (1) { // bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pClientList[sOwnerH]->m_sOriginalType = m_pClientList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pClientList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_POLYMORPH ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					// 원래 타입을 저장해 놓는다.
					m_pNpcList[sOwnerH]->m_sOriginalType = m_pNpcList[sOwnerH]->m_sType;
					// 바뀐 외형을 통보해 준다.
					m_pNpcList[sOwnerH]->m_sType = 18;
					SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
					break;
				}

				// 변신 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_POLYMORPH, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POLYMORPH, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pClientList[iClientH]->m_sX;
			sY = m_pClientList[iClientH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr); // v1.41 FALSE
			}
			break;
		
		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_TREMOR: // v1.4 주변 공격 효과에 이어 잔류 효과가 있다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// 직격은 처리하지 않는다.
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_TELEPORT:
			// 텔레포트 마법. sValue 4에 따라서 텔레포트 목적지가 결정된다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 자신이 소속된 마을로 텔레포트. Recall이다. 
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (sOwnerH == iClientH) ) {
					// 자신외에는 Recall할 수 없다. 
					RequestTeleportHandler(iClientH, "1   ");
	 			}
			   	break;
	 		}
			break;

		case DEF_MAGICTYPE_SUMMON:
			// 소환마법 

			// 사투장 내에서는 소환마법이 불가능.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) return;

			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 지정된 Owner가 Master가 된다. 
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
				// Master로 지정된 대상을 따라다니고 있는 객체 수를 계산한다. 
				iFollowersNum = iGetFollowerNumber(sOwnerH, cOwnerType);

				// 소환마법을 Casting한 자의 Magery/20 만큼의 몬스터를 소환할 수 있다. 
				if (iFollowersNum >= (m_pClientList[iClientH]->m_cSkillMastery[4]/20)) break;
				
				iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
					// 더이상 이 맵에 NPC를 만들수 없다. 이름을 할당할 수 없기 때문.
				}
				else {
					// NPC를 생성한다.
					ZeroMemory(cName, sizeof(cName));
					wsprintf(cName, "XX%d", iNamingValue);
					cName[0] = '_';
					cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
					
					// Magery에 따라 소환되는 몬스터의 등급이 달라진다.
					ZeroMemory(cNpcName, sizeof(cNpcName));
					
					switch (iV1) {
					case NULL: // 일반적인 경우 
						iResult = iDice(1, m_pClientList[iClientH]->m_cSkillMastery[4] / 10);
						
						// v1.42 최저 몹 레벨을 입력 
						if (iResult < m_pClientList[iClientH]->m_cSkillMastery[4] / 20) 
							iResult = m_pClientList[iClientH]->m_cSkillMastery[4] / 20;

						switch (iResult) {
						case 1: strcpy(cNpcName, "Slime"); break;
						case 2: strcpy(cNpcName, "Giant-Ant"); break;
						case 3: strcpy(cNpcName, "Amphis"); break;
						case 4: strcpy(cNpcName, "Orc"); break;
						case 5: strcpy(cNpcName, "Skeleton"); break;
						case 6:	strcpy(cNpcName, "Clay-Golem"); break;
						case 7:	strcpy(cNpcName, "Stone-Golem"); break;
						case 8: strcpy(cNpcName, "Orc-Mage"); break;
						case 9:	strcpy(cNpcName, "Hellbound"); break;
						case 10:strcpy(cNpcName, "Cyclops"); break;
						}
						break;

					case 1:	strcpy(cNpcName, "Orc"); break;
					case 2: strcpy(cNpcName, "Skeleton"); break;
					case 3: strcpy(cNpcName, "Clay-Golem"); break;
					case 4: strcpy(cNpcName, "Stone-Golem"); break;
					case 5: strcpy(cNpcName, "Hellbound"); break;
					case 6: strcpy(cNpcName, "Cyclops"); break;
					case 7: strcpy(cNpcName, "Troll"); break;
					case 8: strcpy(cNpcName, "Orge"); break;
					}

					if (bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, &dX, &dY, cNpcWaypoint, NULL, NULL, m_pClientList[iClientH]->m_cSide, FALSE, TRUE) == FALSE) {
						// 실패했으므로 예약된 NameValue를 해제시킨다.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
					} 
					else {
						ZeroMemory(cName_Master, sizeof(cName_Master));
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							memcpy(cName_Master, m_pClientList[sOwnerH]->m_cCharName, 10);
							break;
						case DEF_OWNERTYPE_NPC:
							memcpy(cName_Master, m_pNpcList[sOwnerH]->m_cName, 5);
							break;
						}
						bSetNpcFollowMode(cName, cName_Master, cOwnerType);
				   	}
				}
			}
			break;

		case DEF_MAGICTYPE_CREATE:
			// 무언가를 생성시키는 마법 

			// 위치할 수 없는 곳에는 생기지 않는다. 
			if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetIsMoveAllowedTile(dX, dY) == FALSE )
				goto MAGIC_NOEFFECT;

			pItem = new class CItem;
			ZeroMemory(cItemName, sizeof(cItemName));

			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// Food를 생성해야 한다. 
				if (iDice(1,2) == 1)
					 wsprintf(cItemName, "Meat");
				else wsprintf(cItemName, "Baguette");
				break;
			}
		   		
			_bInitItemAttr(pItem, cItemName);
		   		
			// 아이템을 서있는 위치에 버린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);

			// v1.41 희귀 아이템을 떨어뜨린 것이라면 로그를 남긴다. 
			_bItemLog(DEF_ITEMLOG_DROP, iClientH, NULL, pItem);
					
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
				                  dX, dY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color
			break;

		case DEF_MAGICTYPE_PROTECT:
			// 보호 마법 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

			// 보호 상태라는 것을 설정하기 전에 이미 해당 보호가 걸려있는지 확인하고 걸려있다면 마법은 무시된다. 
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// v1.4334 중립은 플레이어에게 마방을 못하게 수정
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

			   	m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] != 0) goto MAGIC_NOEFFECT;
				// 정적 NPC들은 보호 마법 적용 안됨.				
				if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
			   	m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
				break;
			}

			// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_PROTECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
				                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

			// 효과가 생겼음을 알려준다.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER)
				SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_PROTECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 패럴을 못하게 수정
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto MAGIC_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}

				// 보호 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;

		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 보이지 않는 상태로 만든다. 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 인비를 못하게 수정
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 캐릭터를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto MAGIC_NOEFFECT;
										
					if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) {
						// 이동하지 않는 NPC는 투명 마법을 걸 수 없다.
						m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
						SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
						// 이 NPC를 추적하고 있던 몬스터를 해제시킨다.
						RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_INVISIBILITY);	
					}
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// v1.4334 중립은 플레이어에게 중독을 못하게 수정
				if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT;

				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_CREATE_DYNAMIC:
			// Dynamic Object를 생성하고 효력이 지속되는 타입.
			switch (m_pMagicConfigList[sType]->m_sValue10) {
			case DEF_DYNAMICOBJECT_PCLOUD_BEGIN: // 독구름

			case DEF_DYNAMICOBJECT_FIRE:   // Fire 이다.
			case DEF_DYNAMICOBJECT_SPIKE:  // Spike
				
				switch (m_pMagicConfigList[sType]->m_sValue11) {
				case 1: 
					// wall - type
					cDir = m_Misc.cGetNextMoveDir(m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY);
					switch (cDir) {
					case 1:	rx = 1; ry = 0;   break;
					case 2: rx = 1; ry = 1;   break;
					case 3: rx = 0; ry = 1;   break;
					case 4: rx = -1; ry = 1;  break;
					case 5: rx = 1; ry = 0;   break;
					case 6: rx = -1; ry = -1; break;
					case 7: rx = 0; ry = -1;  break;
					case 8: rx = 1; ry = -1;  break;
					}
					
					iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
						dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
					
					bAnalyzeCriminalAction(iClientH, dX, dY);
					
					for (i = 1; i <= m_pMagicConfigList[sType]->m_sValue12; i++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX + i*rx, dY + i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX + i*rx, dY + i*ry);

						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
							dX - i*rx, dY - i*ry, m_pMagicConfigList[sType]->m_dwLastTime*1000);	
						bAnalyzeCriminalAction(iClientH, dX - i*rx, dY - i*ry);
					}
					break;

				case 2:
					// Field - Type
					BOOL bFlag = FALSE;
					int cx, cy;
					for (ix = dX - m_pMagicConfigList[sType]->m_sValue12; ix <= dX + m_pMagicConfigList[sType]->m_sValue12; ix++)
					for (iy = dY - m_pMagicConfigList[sType]->m_sValue12; iy <= dY + m_pMagicConfigList[sType]->m_sValue12; iy++) {
						iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  ix, iy, m_pMagicConfigList[sType]->m_dwLastTime*1000, m_pMagicConfigList[sType]->m_sValue5);	

						// 만약 마을에서 필드를 깐 곳에 무고한 자가 있었다면 공격자는 가드의 공격을 받게 된다. 
						if (bAnalyzeCriminalAction(iClientH, ix, iy, TRUE) == TRUE) {
							bFlag = TRUE;
							cx = ix;
							cy = iy;
						}
					}
					// 필드인 경우 경비를 1명만 소환하기 위함.
					if (bFlag == TRUE) bAnalyzeCriminalAction(iClientH, cx, cy);
			  		break;
				}
				//
				break;

			case DEF_DYNAMICOBJECT_ICESTORM:
				// Ice-Storm Dynamic Object 
				iAddDynamicObjectList(iClientH, DEF_OWNERTYPE_PLAYER_INDIRECT, m_pMagicConfigList[sType]->m_sValue10, m_pClientList[iClientH]->m_cMapIndex, 
											  dX, dY, m_pMagicConfigList[sType]->m_dwLastTime*1000,
											  m_pClientList[iClientH]->m_cSkillMastery[4]);	
				break;

			default:
				break;
			}
			break;

		case DEF_MAGICTYPE_POSSESSION:
			// 원거리에 떨어져 있는 물건을 집어오는 마법이다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (sOwnerH != NULL) break; // v1.41 포제션 마법은 사람이 서 있는 위에는 효력이 없다. 
			
			pItem = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->pGetItem(dX, dY, &sRemainItemSprite, &sRemainItemSpriteFrame, &cRemainItemColor);
			if (pItem != NULL) {
				// 플레이어가 아이템을 획득하였다. 
				if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
					// 아이템을 획득했다.

					// v1.411 로그 남긴다.
					_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);

					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_ITEMOBTAINED;
					
					cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
					
					// 1개 획득했다. <- 여기서 1개란 카운트를 말하는 것이 아니다
					*cp = 1;
					cp++;
					
					memcpy(cp, pItem->m_cName, 20);
					cp += 20;
					
					dwp  = (DWORD *)cp;
					*dwp = pItem->m_dwCount;
					cp += 4;
					
					*cp = pItem->m_cItemType;
					cp++;
					
					*cp = pItem->m_cEquipPos;
					cp++;
					
					*cp = (char)0; // 얻은 아이템이므로 장착되지 않았다.
					cp++;
					
					sp  = (short *)cp;
					*sp = pItem->m_sLevelLimit;
					cp += 2;
					
					*cp = pItem->m_cGenderLimit;
					cp++;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wCurLifeSpan;
					cp += 2;
					
					wp = (WORD *)cp;
					*wp = pItem->m_wWeight;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSprite;
					cp += 2;
					
					sp  = (short *)cp;
					*sp = pItem->m_sSpriteFrame;
					cp += 2;
					
					*cp = pItem->m_cItemColor;
					cp++;

					*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
					cp++;
					
					dwp = (DWORD *)cp;
					*dwp = pItem->m_dwAttribute;
					cp += 4;
					/*
					*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
					cp++;
					*/

					if (iEraseReq == 1) delete pItem;
					
					// 아이템을 줍고난 후 남은 아이템을 다른 클라이언트에게 알린다. 
					SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, m_pClientList[iClientH]->m_cMapIndex,
						                        dX, dY,	sRemainItemSprite, sRemainItemSpriteFrame, cRemainItemColor); // v1.4
					
					// 아이템 정보 전송 
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
					
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
				else 
				{
					// 공간이 부족하거나 한계중량을 초과했다. 아이템을 얻을 수 없다.
					
					// 가져왔던 아이템을 원상회복시킨다. 
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(dX, dY, pItem);
					
					dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
					*dwp = MSGID_NOTIFY;
					wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
					*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
					
					iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
					switch (iRet) {
					case DEF_XSOCKEVENT_QUENEFULL:
					case DEF_XSOCKEVENT_SOCKETERROR:
					case DEF_XSOCKEVENT_CRITICALERROR:
					case DEF_XSOCKEVENT_SOCKETCLOSED:
						// 메시지를 보낼때 에러가 발생했다면 제거한다.
						DeleteClient(iClientH, TRUE, TRUE);
						return;
					}
				}
			}
			//
		   	break;

		case DEF_MAGICTYPE_CONFUSE:
			// 혼란 마법이다. 
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1: // confuse Language이다. 
			case 2: // Confusion, Mass Confusion 	
				for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// 자신도 피폭될 수 있으니 주의.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
						// 해당 위치에 캐릭터가 있다.
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// 상대방이 마법 저항에 실패했다.
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //이미 다른 Confuse효과가 있다면 무시된다.
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
										        sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							// 마법에 걸렸음을 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
						}
					}
				}	
				break;

			case 3: // Ilusion, Mass-Ilusion
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
				for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
					// 자신도 피폭될 수 있으니 주의.
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
						// 해당 위치에 캐릭터가 있다.
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
							// 상대방이 마법 저항에 실패했다.
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] != 0) break; //이미 다른 Confuse효과가 있다면 무시된다.
							m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_CONFUSE ] = (char)m_pMagicConfigList[sType]->m_sValue4;

							// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
							bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_CONFUSE, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
										        sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

							// 마법에 걸렸음을 알린다.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_CONFUSE, m_pMagicConfigList[sType]->m_sValue4, iClientH, NULL);
						}
					}
				}	
				break;
			}
		   	break;

		case DEF_MAGICTYPE_POISON:
			// 중독 마법. 먼저 마법 저항을 굴리고 다음으로 독성저항을 한번 더 굴린다. 
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			
			if (m_pMagicConfigList[sType]->m_sValue4 == 1) {
				// 중독을 거는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					// v1.4334 중립은 플레이어에게 중독을 못하게 수정
					if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) goto MAGIC_NOEFFECT ;

					// 범죄행위라면 
					bAnalyzeCriminalAction(iClientH, dX, dY);

					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.
							m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
							m_pClientList[sOwnerH]->m_iPoisonLevel = m_pMagicConfigList[sType]->m_sValue5;
							m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
							// 중독되었음을 알린다. 
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pMagicConfigList[sType]->m_sValue5, NULL, NULL);
						}
					}
					break;
			
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						// 마법 저항에 실패했다. 독성저항을 계산한다.
						if (bCheckResistingPoisonSuccess(sOwnerH, cOwnerType) == FALSE) {
							// 중독되었다.

						}
					}
					break;
				}
			}
			else if (m_pMagicConfigList[sType]->m_sValue4 == 0) {
				// 중독을 푸는 마법 
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					
					if (m_pClientList[sOwnerH]->m_bIsPoisoned == TRUE) {
						// 중독된 상태였다면 중독을 푼다.
						m_pClientList[sOwnerH]->m_bIsPoisoned = FALSE;
						// 중독이 풀렸음을 알린다. 
						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
					}
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					break;
				}
			}
			break;

		case DEF_MAGICTYPE_BERSERK:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 버서커 모드로 전환된다.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] != 0) goto MAGIC_NOEFFECT;
					// 정적 NPC들은 광분 안됨				
					if (m_pNpcList[sOwnerH]->m_cActionLimit != 0) goto MAGIC_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetBerserkFlag(sOwnerH, cOwnerType, TRUE);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_BERSERK, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_BERSERK, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;
			}
			break;

		
			// Resurrection Magic. 
			case DEF_MAGICTYPE_RESURRECTION: 
				// Get the ID of the dead Player/NPC on coords dX, dY. 
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY); 
				switch (cOwnerType) { 
				// For Player. 
				case DEF_OWNERTYPE_PLAYER: 
				// The Player has to exist. 
				if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT; 
					// Resurrection is not for alive Players. 
					if (m_pClientList[sOwnerH]->m_bIsKilled == FALSE) goto MAGIC_NOEFFECT; 
						// Set Deadflag to Alive. 
						m_pClientList[sOwnerH]->m_bIsKilled = FALSE; 
						// Player's HP becomes half of the Max HP. 
						m_pClientList[sOwnerH]->m_iHP = ((m_pClientList[sOwnerH]->m_iLevel * 2) + (m_pClientList[sOwnerH]->m_iVit * 3) + (m_pClientList[sOwnerH]->m_iStr / 2)) / 2; 
						// Send new HP to Player. 
						 SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL); 
						// Make Player stand up. (Currently, by a fake damage). 
						m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->ClearDeadOwner(dX, dY); 
						m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->SetOwner(sOwnerH, DEF_OWNERTYPE_PLAYER, dX, dY); 
						SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, NULL, NULL, NULL); 
						break; 
						// Resurrection is not for NPC's. 
			case DEF_OWNERTYPE_NPC: 
				goto MAGIC_NOEFFECT; 
			break; 
			} 
break;

case DEF_MAGICTYPE_ICE:

			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
					// 대미지와 함께
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
					// 얼어서 동작이 늦어지는 효과
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						// 타겟이 살아있고 얼음 저항에 실패했다면 얼어붙는다.
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
								// 대상이 플레이어인 경우 알려준다.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) goto MAGIC_NOEFFECT;
						if ((m_pNpcList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
						break;
					}
					
				}
			
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
						
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
						// 얼어서 동작이 늦어지는 효과. 죽지 않았으면 적용 
						if ((m_pClientList[sOwnerH]->m_iHP > 0) && (bCheckResistingIceSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)) {
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (m_pMagicConfigList[sType]->m_sValue10*1000), 
								                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
					}
				}
			}
			break;

		default:
			break;
		}
	}
	else {
		// Casting 후 딜레이가 걸리는 마법

	}

MAGIC_NOEFFECT:;

	if (m_pClientList[iClientH] == NULL) return;

	// Mana를 감소시키고 통보한다.
	m_pClientList[iClientH]->m_iMP -= iManaCost; // sValue1이 Mana Cost
	if (m_pClientList[iClientH]->m_iMP < 0) 
		m_pClientList[iClientH]->m_iMP = 0;

	CalculateSSN_SkillIndex(iClientH, 4, 1 );

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);

	// 마법 효과를 다른 클라이언트에게 전송한다. 마법번호 + 100이 에펙트 번호 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					            m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, dX, dY, (sType+100), m_pClientList[iClientH]->m_sType);

}


void CGame::NpcMagicHandler(int iNpcH, short dX, short dY, short sType)
{
 short  sOwnerH;
 char   cOwnerType;
 register int i, iErr, ix, iy, sX, sY, tX, tY, iResult, iWhetherBonus, iMagicAttr;
 DWORD  dwTime = timeGetTime();

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((dX < 0) || (dX >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX) ||
        (dY < 0) || (dY >= m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY)) return;
									   
	if ((sType < 0) || (sType >= 100))     return;
	if (m_pMagicConfigList[sType] == NULL) return;
	
	// 공격위치가 공격 불가능 맵이라면 공격 불가능 
	if (m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
	
	// 몬스터 별 마법 명중률 입력 
	iResult = m_pNpcList[iNpcH]->m_iMagicHitRatio;
	
	// 날씨에 의한 마법 공격력 조정  
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_cWhetherStatus);

	// v1.41 마법 속성 
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	if (m_pMagicConfigList[sType]->m_dwDelayTime == 0) {
		// 즉시 효과를 보는 마법 
		switch (m_pMagicConfigList[sType]->m_sType) {
		case DEF_MAGICTYPE_INVISIBILITY:
			switch (m_pMagicConfigList[sType]->m_sValue4) {
			case 1:
				// 보이지 않는 상태로 만든다. 
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 캐릭터를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_PLAYER);
					break;

				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					SetInvisibilityFlag(sOwnerH, cOwnerType, TRUE);
					// 이 NPC를 추적하고 있던 몬스터를 해제시킨다.
					RemoveFromTarget(sOwnerH, DEF_OWNERTYPE_NPC);
					break;
				}
			
				// 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_INVISIBILITY, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					                sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);

				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_INVISIBILITY, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				break;

			case 2:
				// dX, dY 반경 8 주변의 Invisibility 상태인 Object가 있으면 해제 시킨다.
				for (ix = dX - 8; ix <= dX + 8; ix++)
				for (iy = dY - 8; iy <= dY + 8; iy++) {
					m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if (sOwnerH != NULL) {
						switch (cOwnerType) {
						case DEF_OWNERTYPE_PLAYER:
							if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;

						case DEF_OWNERTYPE_NPC:
							if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
								SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);
								bRemoveFromDelayEventList(sOwnerH, cOwnerType, DEF_MAGICTYPE_INVISIBILITY);
							}
							break;
						}
					}
				}
				break;
			}
			break;

		case DEF_MAGICTYPE_HOLDOBJECT:
			// 오브젝트의 움직임을 봉쇄한다. 
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE) {
				
				switch (cOwnerType) {
				case DEF_OWNERTYPE_PLAYER:
					if (m_pClientList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					if (m_pClientList[sOwnerH]->m_iAddPR >= 500) goto NMH_NOEFFECT;
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
					
				case DEF_OWNERTYPE_NPC:
					if (m_pNpcList[sOwnerH] == NULL) goto NMH_NOEFFECT;
					if (m_pNpcList[sOwnerH]->m_cMagicLevel >= 6) goto NMH_NOEFFECT; // v1.4 마법 레벨 6이상인 리치급 이상의 마법 몬스터에게는 마비 마법 통하지 않는다.
					if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) goto NMH_NOEFFECT;
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = (char)m_pMagicConfigList[sType]->m_sValue4;
					break;
				}
				
				// 봉쇄 효과가 해제될 때 발생할 딜레이 이벤트를 등록한다.
				bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_HOLDOBJECT, dwTime + (m_pMagicConfigList[sType]->m_dwLastTime*1000), 
					sOwnerH, cOwnerType, NULL, NULL, NULL, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
				
				// 효과가 생겼음을 알려준다.
				if (cOwnerType == DEF_OWNERTYPE_PLAYER)
					SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_HOLDOBJECT, m_pMagicConfigList[sType]->m_sValue4, NULL, NULL);
			}
			break;
		
		
		case DEF_MAGICTYPE_DAMAGE_LINEAR:
			// 일직선 상에 있는 목표를 모두 공격한다.
			sX = m_pNpcList[iNpcH]->m_sX;
			sY = m_pNpcList[iNpcH]->m_sY;

			for (i = 2; i < 10; i++) {
				iErr = 0;
				m_Misc.GetPoint2(sX, sY, dX, dY, &tX, &tY, &iErr, i);
			
				// tx, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx-1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx+1, ty
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty-1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				// tx, ty+1
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 		 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}

				if ( (abs(tX - dX) <= 1) && (abs(tY - dY) <= 1)) break;
			}

			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
				}
			}

			// dX, dY
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
				 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
			}
			break;
		
		case DEF_MAGICTYPE_DAMAGE_SPOT:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			break;

		case DEF_MAGICTYPE_HPUP_SPOT:
			// 이 마법은 명중률과는 상관이 없다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			Effect_HpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA:
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, dX, dY);
			if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	 (m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// 죽은 척하고 있는 플레이어다.
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_Damage_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, TRUE, iMagicAttr);
			}
			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_DAMAGE_AREA_NOSPOT:
			// 직격은 계산하지 않는다.			
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// 죽은 척하고 있는 플레이어다.
					if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot_DamageMove(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, dX, dY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
			   	}
			}
			break;

		case DEF_MAGICTYPE_SPDOWN_AREA:
			// Sp가 줄어든다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
				Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (bCheckResistingMagicSuccess(m_pNpcList[iNpcH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_SpDown_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		case DEF_MAGICTYPE_SPUP_AREA:
			// Sp가 상승한다.
			m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
			// 마법 저항이 필요없다. 
			Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6);
			// 주변 공격 효과 
			for (iy = dY - m_pMagicConfigList[sType]->m_sValue3; iy <= dY + m_pMagicConfigList[sType]->m_sValue3; iy++)
			for (ix = dX - m_pMagicConfigList[sType]->m_sValue2; ix <= dX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
				// 자신도 피폭될 수 있으니 주의.
				m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				// 마법저항이 필요 없다.
				Effect_SpUp_Spot(iNpcH, DEF_OWNERTYPE_NPC, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9);
			}
			break;

		}
	}
	else {
		// Casting 후 딜레이가 걸리는 마법

	}

NMH_NOEFFECT:;

	// Mana를 감소시킨다.
	m_pNpcList[iNpcH]->m_iMana -= m_pMagicConfigList[sType]->m_sValue1; // sValue1이 Mana Cost
	if (m_pNpcList[iNpcH]->m_iMana < 0) 
		m_pNpcList[iNpcH]->m_iMana = 0;

	// 마법 효과를 다른 클라이언트에게 전송한다. 마법번호 + 100이 에펙트 번호 
	SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pNpcList[iNpcH]->m_cMapIndex,
					            m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, dX, dY, (sType+100), m_pNpcList[iNpcH]->m_sType);

}




void CGame::RequestTeleportHandler(int iClientH, char * pData, char * cMapName, int dX, int dY)
{
 char  * pBuffer, cTempMapName[21];
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cDestMapName[11], cDir, cMapIndex;
 short * sp, sX, sY;
 int   * ip, i, iRet, iSize, iDestX, iDestY, iExH, iMapSide;
 BOOL    bRet, bIsLockedMapNotify;
 SYSTEMTIME SysTime;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsOnWaitingProcess == TRUE) return;
	
	bIsLockedMapNotify = FALSE;

	// 만약 교환 모드라면 교환을 취소한다.
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		_ClearExchangeStatus(iExH);
		_ClearExchangeStatus(iClientH);
	}

	// 중립이 리콜 마법을 사용하면 투명하게 되는 버그 수정 
	// 중립이면 리콜 마법을 사용하지 못하게 된다. 
	if ((memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && (pData[0] == '1'))
		return;

	// 현재 이 플레이어를 목표로 삼고 있는 몹들의 공격행동을 멈추게 한다. 
	RemoveFromTarget(iClientH, DEF_OWNERTYPE_PLAYER);
	
	// 현재 맵 위치에서 지운다.
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(13, iClientH, DEF_OWNERTYPE_PLAYER, 
	                                                             m_pClientList[iClientH]->m_sX, 
	   														     m_pClientList[iClientH]->m_sY);

	// 다른 클라이언트들에게 플레이어가 현 위치에서 사라짐을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

	// 현재 텔레포트가 마법에 의한 것인지, 아니면 일반적인 텔레포트 타일에 의한 것인지를 체크한다. 
	// 만약 일반적인 텔레포트 타일에 의한 것이라면 텔레포트할 위치의 맵이름, 좌표를 구해와서 
	// 그 맵이 현재 서버에 존재하는지를 검색한다. 만약 현재 서버에 존재하지 않는다면 클라이언트에게 
	// 다른 서버로의 접속을 시도하라는 메시지를 보낸다. 

	// 먼저 플레이어가 서있는 위치가 텔레포트 타일인지 알아낸다. 
	sX = m_pClientList[iClientH]->m_sX;
	sY = m_pClientList[iClientH]->m_sY;

	ZeroMemory(cDestMapName, sizeof(cDestMapName));
	bRet = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSearchTeleportDest(sX, sY, cDestMapName, &iDestX, &iDestY, &cDir);

	// Crusade
	if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
		// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
		// 만약 갈 맵이 건물 내부라면  
		iMapSide = iGetMapLocationSide(cDestMapName);
		if ((iMapSide != 0) && (m_pClientList[iClientH]->m_cSide == iMapSide)) {
			// 들어가고자 하는 맵이 같은 편의 건물 내부라면 들어갈 수 있다.
		}
		else {
			iDestX = -1;
			iDestY = -1;
			bIsLockedMapNotify = TRUE;
			ZeroMemory(cDestMapName, sizeof(cDestMapName));
			strcpy(cDestMapName, m_pClientList[iClientH]->m_cLockedMapName);
		}
	}

	if ((bRet == TRUE) && (cMapName == NULL)) {
		// 플레이어가 텔레포트 타일 위에 서 있다. 텔레포트 할 맵이 현재 서버에 존재하는지 검색한다. 물론 목적지가 지정되지 않은 텔레포트여야한다.
	 	for (i = 0; i < DEF_MAXMAPS; i++)
		if (m_pMapList[i] != NULL) {
			if (memcmp(m_pMapList[i]->m_cName, cDestMapName, 10) == 0) {
				// 현재 서버에 텔레포트할 맵이 존재한다.
				m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = iDestY;
				m_pClientList[iClientH]->m_cDir = cDir;
				m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
				goto RTH_NEXTSTEP;
			}
		}

		// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
		m_pClientList[iClientH]->m_sX   = iDestX;	  // 텔레포트 좌표를 입력한다.
		m_pClientList[iClientH]->m_sY   = iDestY;
		m_pClientList[iClientH]->m_cDir = cDir;
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		memcpy(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10);  // 맵 이름을 바꾼다.
		
		// 플레이어의 데이터를 저장하고 저장했다는 응답이 오면 클라이언트에게 접속을 다시 할것을 알려준다.
		bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE);  // ! 카운팅 하지 않는다.
		// !!!!
		m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
		m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
		return;
	}
	else {
		// 마법에 의한 텔레포트이다. 
		switch (pData[0]) {
		case '0':
			// Forced Recall. 
			// 레벨 제한이 있는 맵에 들어갔을때 일어난다. 
			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);
			
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
					// 현재 서버에 텔레포트할 맵이 존재한다.
					GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
										
					m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
					goto RTH_NEXTSTEP;
				}
			}

			// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
			m_pClientList[iClientH]->m_sX   = -1;	  // 텔레포트 좌표를 입력한다.
			m_pClientList[iClientH]->m_sY   = -1;	  // -1은 InitialPoint를 말한다.
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
			// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
			
			m_pClientList[iClientH]->m_bIsOnServerChange = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
		
		case '1':
			// Recall.플레이어가 소속된 마을의 진입 포인트로 간다.
			// 만약 부활존이라면 리콜되지 않는다.
			//if (memcmp(m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, "resurr", 6) == 0) return;

			ZeroMemory(cTempMapName, sizeof(cTempMapName));
			if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
				strcpy(cTempMapName, "default");
			}
			else strcpy(cTempMapName, m_pClientList[iClientH]->m_cLocation);
			
			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}

			for (i = 0; i < DEF_MAXMAPS; i++)
			if (m_pMapList[i] != NULL) {
				if (memcmp(m_pMapList[i]->m_cName, cTempMapName, 10) == 0) {
					// 현재 서버에 텔레포트할 맵이 존재한다.
					
					GetMapInitialPoint(i, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cLocation);
					
					m_pClientList[iClientH]->m_cMapIndex = i; // 맵 인덱스를 바꾼다.
					ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
					memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[i]->m_cName, 10);  // 맵 이름을 바꾼다.
					goto RTH_NEXTSTEP;
				}
			}

			// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
			m_pClientList[iClientH]->m_sX   = -1;	  // 텔레포트 좌표를 입력한다.
			m_pClientList[iClientH]->m_sY   = -1;	  // -1은 InitialPoint를 말한다.
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
			// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
			bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
			// !!!
			m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
			m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
			return;
		
		case '2':
			// 목적지가 지정된 텔레포트.

			// Crusade
			if ((strcmp(m_pClientList[iClientH]->m_cLockedMapName, "NONE") != 0) && (m_pClientList[iClientH]->m_iLockedMapTime > 0)) {
				// 특정 맵에 갖힌 상태이다. 텔레포트 타일의 위치를 갖힌 맵으로 변형한다.
				dX = -1;
				dY = -1;
				bIsLockedMapNotify = TRUE;
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, m_pClientList[iClientH]->m_cLockedMapName);
			}
			else {
				ZeroMemory(cTempMapName, sizeof(cTempMapName));
				strcpy(cTempMapName, cMapName);
			}
			
			cMapIndex = iGetMapIndex(cTempMapName);
			if (cMapIndex == -1) {
				// 현재 서버에 목적지가 없다. 
				// 현재 서버에 텔레포트 할 맵이 없다. 클라이언트는 현재 접속을 종료하고 다른 서버로 접속을 시도해야 한다.
				m_pClientList[iClientH]->m_sX   = dX; //-1;	  // 텔레포트 좌표를 입력한다.
				m_pClientList[iClientH]->m_sY   = dY; //-1;	  // -1은 InitialPoint를 말한다.
			
				ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
				memcpy(m_pClientList[iClientH]->m_cMapName, cTempMapName, 10);  // 맵 이름을 바꾼다.
				// 플레이어의 데이터를 저장하고 응답을 받은 후 재접속을 알려야 한다.
								
				bSendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA_REPLY, iClientH, FALSE); // ! 카운팅 하지 않는다.
				// !!!
				m_pClientList[iClientH]->m_bIsOnServerChange   = TRUE;
				m_pClientList[iClientH]->m_bIsOnWaitingProcess = TRUE;
				return;
			}

			m_pClientList[iClientH]->m_sX   = dX;
			m_pClientList[iClientH]->m_sY   = dY;
			m_pClientList[iClientH]->m_cMapIndex = cMapIndex;
			
			ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
			memcpy(m_pClientList[iClientH]->m_cMapName, m_pMapList[cMapIndex]->m_cName, 10);  
			break;
		}
	}

RTH_NEXTSTEP:;

	// Crusade
	if (bIsLockedMapNotify == TRUE) SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);

	pBuffer = new char [DEF_MSGBUFFERSIZE+1];
	ZeroMemory(pBuffer, DEF_MSGBUFFERSIZE+1);
	
	// 맵데이터를 전송한다.
	dwp  = (DWORD *)(pBuffer + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_INITDATA;
	wp   = (WORD *)(pBuffer + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_MSGTYPE_CONFIRM;
	
	cp = (char *)(pBuffer + DEF_INDEX2_MSGTYPE + 2);

	// 플레이어의 위치를 확정한다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE)
		 bGetEmptyPosition(&m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_cMapIndex);
	else GetMapInitialPoint(m_pClientList[iClientH]->m_cMapIndex, &m_pClientList[iClientH]->m_sX, &m_pClientList[iClientH]->m_sY);

	// 전송할 맵 데이터의 기준위치. 플레이어는 기준위치 (x, y)로부터 (x+14, y+12)에 위치한다.
	sp  = (short *)cp;
	*sp = iClientH;		// Player ObjectID
	cp += 2;
	
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX - 14 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY - 12 - 5;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sType;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr1;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr2;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr3;
	cp += 2;

	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sAppr4;
	cp += 2;
	// v1.4 ApprColor
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iApprColor;
	cp += 4;
	
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sStatus;
	cp += 2;
	
	// (!) 플레이어가 위치하는 맵이름을 기록한다.
	memcpy(cp, m_pClientList[iClientH]->m_cMapName, 10);
	cp += 10;

	// 명칭상의 맵 이름을 입력한다. 
	memcpy(cp, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10);
	cp += 10;

	// 주야간 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = 1;
	else *cp = m_cDayOrNight;
	cp++;

	// 기상 상태 모드를 삽입 
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE) 
		 *cp = NULL;
	else *cp = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus;
	cp++;

	// v1.4 Contribution
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iContribution;
	cp += 4;
	
	// @@@ 플레이어를 맵상에 최초로 위치시킨다.
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) {
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, 
			                                                       DEF_OWNERTYPE_PLAYER, 
																   m_pClientList[iClientH]->m_sX, 
								  								   m_pClientList[iClientH]->m_sY);
	}

	// v1.41
	*cp = (char)m_pClientList[iClientH]->m_bIsObserverMode;
	cp++;

	// v1.41 
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iRating;
	cp += 4;

	// v1.44
	ip = (int *)cp;
	*ip = m_pClientList[iClientH]->m_iHP;
	cp += 4;
		  
	// 맵의 정보를 추가한다. 
	iSize = iComposeInitMapData(m_pClientList[iClientH]->m_sX - 10, m_pClientList[iClientH]->m_sY - 7, iClientH, cp );
	// 메시지 전송 
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4 + 3); //Zabuza fix
	//iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(pBuffer, 46 + iSize +4 +4 +1 +4 +4); // v1.41
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// 메시지를 보낼때 에러가 발생했다면 제거한다.
		DeleteClient(iClientH, TRUE, TRUE);
		if(pBuffer != NULL) delete pBuffer;
		return;
	}

	if(pBuffer != NULL) delete pBuffer;

	// 다른 클라이언트들에게 플레이어가 새로운 위치에 나타났음을 알린다. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
	
	int iTL_;

	// 플레이어가 다른 맵에 들어갔다. 만약 적국이라면 시간을 설정한다.
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "elvine", 6) == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v1.42
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			// 남아있을 수 있는 잔존 시간을 설정해 준다. 
			// 시간을 구한다음 iWarPeriod를 구한다.
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //월요일 30초
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //화요일 30초
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //수요일 30초
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //목요일 1분
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100;  break; //금요일 10분
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300;  break; //토요일 30분 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //일요일 60분
			}
		}
		else {
			// 잔존시간이 있다. 요일별 잔존시간보다 크면 1로 초기화 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //월요일 30초
			case 2:	iTL_ = 40; break;   //화요일 30초
			case 3:	iTL_ = 40; break;   //수요일 30초
			case 4:	iTL_ = 40; break;   //목요일 30초
			case 5:	iTL_ = 20*10 +100; break; //금요일 10분
			case 6:	iTL_ = 20*30 +300; break; //토요일 30분 
			case 0:	iTL_ = 20*60; break; //일요일 60분
			}
			
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;		
		}
	}
	else
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) && 
		 (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, "aresden", 7) == 0) ) {
		
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;

		// v1.42
		if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall == 0) {
			// 남아있을 수 있는 잔존 시간을 설정해 준다. 
			// 시간을 구한다음 iWarPeriod를 구한다.
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //월요일 30초
			case 2:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //화요일 30초
			case 3:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //수요일 30초
			case 4:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 40; break;   //목요일 1분
			case 5:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*10 +100;  break; //금요일 10분
			case 6:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*30 +300;  break; //토요일 30분 
			case 0:	m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 20*60; break; //일요일 60분
			}
		}
		else {
			// 잔존시간이 있다. 요일별 잔존시간보다 크면 1로 초기화 
			GetLocalTime(&SysTime);
			switch (SysTime.wDayOfWeek) {
			case 1:	iTL_ = 40; break;   //월요일 30초
			case 2:	iTL_ = 40; break;   //화요일 30초
			case 3:	iTL_ = 40; break;   //수요일 30초
			case 4:	iTL_ = 40; break;   //목요일 30초
			case 5:	iTL_ = 20*10 +100; break; //금요일 10분
			case 6:	iTL_ = 20*30 +300; break; //토요일 30분 
			case 0:	iTL_ = 20*60; break; //일요일 60분
			}
			
			if (m_pClientList[iClientH]->m_iTimeLeft_ForceRecall > iTL_) 
				m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 1;
		}
	}
	// 같은 서버에 사투장이 떠있는 경우 
	// v1.4311-3 변경 사투장에 입장하면 강콜타임을 시작한다.
	else if ( m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE ) {
		m_pClientList[iClientH]->m_dwWarBeginTime = timeGetTime();
		m_pClientList[iClientH]->m_bIsWarLocation = TRUE;
		// 남아있을 수 있는 잔존 시간을 설정해 준다. 
		// 시간을 구한다음 iWarPeriod를 구한다.
		GetLocalTime(&SysTime);
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 2*20;  

	} else {
		m_pClientList[iClientH]->m_bIsWarLocation = FALSE;	
		m_pClientList[iClientH]->m_iTimeLeft_ForceRecall = 0;
	}

	// 추가로 보내줘야 할 정보를 보낸다. v1.1
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
	// v1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
	// V1.3
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMPOSLIST, NULL, NULL, NULL, NULL);
	// v1.4 
	_SendQuestContents(iClientH);
	_CheckQuestEnvironment(iClientH);

	// v1.432
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime == 0)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYENABLED, NULL, NULL, NULL, NULL);

	// Crusade 현재 크루세이드 모드이고 플레이어의 CrusadeGUID가 0 혹은 현재와 다르다면 처음 할당되는 것이다. 크루세이드 역할 초기화.
	if (m_bIsCrusadeMode == TRUE) {
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == 0) {
			// 크루세이드모드이고 플레이어의 GUID가 0이란 것은 처음 크루세이드 모드에 들어왔다는 의미. 역할 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		}
		else if (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID) {
			// 크루세이드모드이고 플레이어의 GUID가 현재 크루세이드 아이디와 다르다는 것은 저번에 벌어졌던 크루세이드의 결과이다.
			// 이런 경우 전공에 따른 포상을 할 수 없다. 최소한 크루세이드 모드가 종료된 다음 다음 전면전이 시작되기 전에 접속을 해야 포상을 얻을 수 있다.
			// 이전에 할당되었던 역할, 건설 포인트, 전쟁 공헌도 초기화.
			m_pClientList[iClientH]->m_iCrusadeDuty       = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = m_dwCrusadeGUID;
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
	}
	else {
		// 크루세이드 모드가 아닌 경우 역할과 공헌 포인트만 초기화. 전쟁 공헌도는 잠시후에 계산되어서 포상된다.
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			m_pClientList[iClientH]->m_iCrusadeDuty = 0;
			m_pClientList[iClientH]->m_iConstructionPoint = 0;
		}
		else if ((m_pClientList[iClientH]->m_dwCrusadeGUID != NULL) && (m_pClientList[iClientH]->m_dwCrusadeGUID != m_dwCrusadeGUID)) {
			// 크루세이드 GUID가 다르다. 포상 불가.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
			m_pClientList[iClientH]->m_iWarContribution   = 0;
			m_pClientList[iClientH]->m_dwCrusadeGUID = 0;
		}
	}

	// v1.42
	if (memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) {
		wsprintf(G_cTxt, "Char(%s)-Enter(%s) Observer(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_cMapName, m_pClientList[iClientH]->m_bIsObserverMode);
		PutLogEventFileList(G_cTxt);
	}

	// Crusade
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, -1, NULL);
}

void CGame::ReleaseFollowMode(short sOwnerH, char cOwnerType)
{
 register int i;

	for (i = 0; i < DEF_MAXNPCS; i++)
	if ((i != sOwnerH) && (m_pNpcList[i] != NULL)) {
		if ((m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) &&
			(m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) &&
			(m_pNpcList[i]->m_cFollowOwnerType == cOwnerType)) {
			
			m_pNpcList[i]->m_cMoveType = DEF_MOVETYPE_RANDOMWAYPOINT;
		}
	}
}

BOOL CGame::_bDecodeMagicConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iMagicConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ¸¶¹ý ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pMagicConfigList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[atoi(token)] = new class CMagic;
					iMagicConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// ¸¶¹ý ÀÌ¸§ 
					ZeroMemory(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, sizeof(m_pMagicConfigList[iMagicConfigListIndex]->m_cName));
					memcpy(m_pMagicConfigList[iMagicConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// ¸¶¹ý Á¾·ù m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// ¸¶¹ý µô·¹ÀÌ ½Ã°£ m_dwDelayTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwDelayTime = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// ¸¶¹ý Áö¼Ó½Ã°£ m_dwLastTime
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_dwLastTime = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 7;
					break;
				
				case 7:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// m_sValue7
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue7 = atoi(token);
					cReadModeB = 13;
					break;
				
				case 13:
					// m_sValue8
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue8 = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// m_sValue9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue9 = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// m_sValue10
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue10 = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// m_sValue11
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue11 = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// m_sValue12
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sValue12 = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// m_sIntLimit
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_sIntLimit = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// m_iGoldCost
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iGoldCost = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					// m_cCategory
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_cCategory = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// m_iAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMagicConfigList[iMagicConfigListIndex]->m_iAttribute = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "magic", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) MAGIC(Total:%d) configuration - success!", iMagicConfigListIndex);
	PutLogList(cTxt);

	return TRUE;

}



BOOL CGame::_bDecodeSkillConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iSkillConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ½ºÅ³ ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pSkillConfigList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[atoi(token)] = new class CSkill;
					iSkillConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// ½ºÅ³ ÀÌ¸§ 
					ZeroMemory(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, sizeof(m_pSkillConfigList[iSkillConfigListIndex]->m_cName));
					memcpy(m_pSkillConfigList[iSkillConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				case 3:
					// ½ºÅ³ Á¾·ù m_sType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// m_sValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue1 = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// m_sValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue2 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_sValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue3 = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// m_sValue4
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue4 = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// m_sValue5
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue5 = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// m_sValue6
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pSkillConfigList[iSkillConfigListIndex]->m_sValue6 = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "skill", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
		//token = strtok(NULL, seps);
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! SKILL configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) SKILL(Total:%d) configuration - success!", iSkillConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


void CGame::RequestStudyMagicHandler(int iClientH, char * pName, BOOL bIsPurchase)
{
 char  * cp, cMagicName[31], cData[100];
 DWORD * dwp, dwGoldCount;
 WORD  * wp;
 int   * ip, iReqInt, iCost, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	// ¸¶¹ýÀ» ¹è¿î´Ù. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cMagicName, sizeof(cMagicName));
	memcpy(cMagicName, pName, 30);
	
	iRet = _iGetMagicNumber(cMagicName, &iReqInt, &iCost);
	if (iRet == -1) {
		// ÀÌ·± ÀÌ¸§ÀÇ ¸¶¹ýÀº Á¸ÀçÇÏÁö ¾Ê´Â´Ù. ¹«½ÃÇÑ´Ù. 

	}
	else {
		if (bIsPurchase == TRUE) {
			if (m_pMagicConfigList[iRet]->m_iGoldCost < 0) return; // ÀÏ¹ÝÀûÀ¸·Î ¹è¿ï¼ö ¾ø´Â ¸¶¹ýÀÌ¶ó¸é(°¡°ÝÀÌ À½¼ö) ¹è¿ï ¼ö ¾ø´Ù.
			dwGoldCount = dwGetItemCount(iClientH, "Gold");
			if ((DWORD)iCost > dwGoldCount) return; // µ·ÀÌ ºÎÁ·ÇØµµ ¹è¿ï ¼ö ¾ø´Ù.
		}
	
		// ÀÌ¹Ì ¹è¿î ¸¶¹ýÀ» ´Ù½Ã ¹è¿ì°Ú´Ù°í ¿äÃ»ÇÏ¸é ¹«½Ã 
		if (m_pClientList[iClientH]->m_cMagicMastery[iRet] != 0) return;
		if (iReqInt <= m_pClientList[iClientH]->m_iInt) {
			
			// µ·À» »ç¿ëÇßÀ½À» ¾Ë¸°´Ù.
			if (bIsPurchase == TRUE) SetItemCount(iClientH, "Gold", dwGoldCount - iCost);
			
			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);
		
			// ¸¶¹ý »ç¿ë ´É·Â Ç¥½Ã .
			m_pClientList[iClientH]->m_cMagicMastery[iRet] = 1;
	
			// ¸¶¹ýÀ» ¹è¿ü´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			
			// ¸¶¹ý ¹øÈ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 37);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// Á¶°ÇÀÌ ¸¸Á·µÇÁö ¾Ê¾Æ ¸¶¹ýÀ» ¹è¿ï ¼ö ¾ø´Ù.
			// ¸¶¹ýÀ» ¹è¿ï¼ö ¾ø¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_MAGICSTUDYFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ½ÇÆÐÀÌÀ¯.
			*cp = 1;
			cp++;

			// ¸¶¹ý ¹øÈ£ 
			*cp = iRet;
			cp++;

			memcpy(cp, cMagicName, 30);
			cp += 30;

			ip = (int *)cp;
			*ip = iCost;
			cp += 4;

			ip = (int *)cp;
			*ip = iReqInt;
			cp += 4;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 46);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
}

int CGame::_iGetMagicNumber(char * pMagicName, int * pReqInt, int * pCost)
{
 register int i;
 char cTmpName[31];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMagicName);

	for (i = 0; i < DEF_MAXMAGICTYPE; i++) 
	if (m_pMagicConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pMagicConfigList[i]->m_cName, 30) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø ¸¶¹ý ¼³Á¤À» Ã£¾Ò´Ù. ¸¶¹ý ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
			*pReqInt = (int)m_pMagicConfigList[i]->m_sIntLimit;
			*pCost   = (int)m_pMagicConfigList[i]->m_iGoldCost;
			
			return i;
		}
	}
	
	return -1;
}

void CGame::TrainSkillResponse(BOOL bSuccess, int iClientH, int iSkillNum, int iSkillLevel)
{
 char  * cp, cData[100];
 DWORD * dwp;
 WORD  * wp;
 int   iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((iSkillNum < 0)	|| (iSkillNum > 100)) return;
	if ((iSkillLevel < 0) || (iSkillLevel > 100)) return;
	
	if (bSuccess == TRUE) {
		// ÀÌ¹Ì ±â¼úÀ» ÀÍÈù »óÅÂ¶ó¸é ¼Ò¿ëÀÌ ¾ø´Ù.
		if (m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] != 0) return;
		
		m_pClientList[iClientH]->m_cSkillMastery[iSkillNum] = iSkillLevel;
		// ±â¼ú ÃÑ ÇÕÀ» Àç °è»êÇÑ´Ù.
		bCheckTotalSkillMasteryPoints(iClientH, iSkillNum);

		// ±â¼úÀ» ¹è¿ü´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// ±â¼ú¹øÈ£
		*cp = iSkillNum;
		cp++;
		
		// ±â¼ú ·¹º§ .
		*cp = iSkillLevel;
		cp++;
	 
		// Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 8);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
	else {


	}

	/*
	// ±â¼úÀ» ¹è¿î´Ù. 
	ZeroMemory(cData, sizeof(cData));	

	ZeroMemory(cSkillName, sizeof(cSkillName));
	memcpy(cSkillName, pName, 20);
	
	iRet = _iGetSkillNumber(cSkillName);
	if (iRet == 0) {
		// ÀÌ·± ÀÌ¸§ÀÇ ±â¼úÀº Á¸ÀçÇÏÁö ¾Ê´Â´Ù.

	}
	else {
		// Å¬¶óÀÌ¾ðÆ®°¡ iRet¹øÂ° ±â¼úÀÇ ¸î·¹º§À» ¹è¿ì´Â Áö, ¹è¿ì±â¿¡ ÃæºÐÇÑ ´É·ÂÄ¡¸¦ °®°í ÀÖ´ÂÁö °Ë»çÇÑ´Ù. 
		
		if (1) {
			// @@ Test¿ëÀ¸·Î ÀÏ´Ü ¹«Á¶°Ç »ç¿ëÀÌ °¡´ÉÇÏ°Ô ¸¸µç´Ù. 
			m_pClientList[iClientH]->m_cSkillMastery[iRet]++;
	
			// ±â¼úÀ» ¹è¿ü´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINSUCCESS;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ±â¼ú ·¹º§ .
			*cp = m_pClientList[iClientH]->m_cSkillMastery[iRet];
			cp++;

			// ±â¼ú¹øÈ£
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
		else {
			// Á¶°ÇÀÌ ¸¸Á·µÇÁö ¾Ê¾Æ ¸¶¹ýÀ» ¹è¿ï ¼ö ¾ø´Ù.
			// ¸¶¹ýÀ» ¹è¿ï¼ö ¾ø¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_SKILLTRAINFAIL;

			cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			// ½ÇÆÐÀÌÀ¯.
			*cp = 1;
			cp++;

			// ±â¼ú¹øÈ£
			*cp = iRet;
			cp++;

			memcpy(cp, cSkillName, 20);
			cp += 20;

			// Á¤º¸ Àü¼Û 
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 28);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
		}
	}
	*/
}


int CGame::_iGetSkillNumber(char * pSkillName)
{
 register int i;
 char cTmpName[21];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pSkillName);

	for (i = 1; i < DEF_MAXSKILLTYPE; i++) 
	if (m_pSkillConfigList[i] != NULL) {
		if (memcmp(cTmpName, m_pSkillConfigList[i]->m_cName, 20) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø ±â¼ú ¼³Á¤À» Ã£¾Ò´Ù. ±â¼ú ¹øÈ£¸¦ ¹ÝÈ¯ÇÑ´Ù.
			return i;
		}
	}
	
	return 0;
}

BOOL CGame::bPlayerItemToBank(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// ´õÀÌ»ó ÀúÀåÇÒ °ø°£ÀÌ ¾ø´Ù. 
	return FALSE;

NEXT_STEP_PLTB:;

	// ¾ÆÀÌÅÛÀ» ÀúÀåÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù. 
	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù.
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);

	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù. 
	m_pClientList[iClientH]->m_pItemInBankList[iIndex] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
	// ÇÃ·¹ÀÌ¾î ¾ÆÀÌÅÛ ¸®½ºÆ®¸¦ Å¬¸®¾îÇÏ°í 
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;

	// ¾ÆÀÌÅÛ ¸®½ºÆ®ÀÇ ºó °ø°£À» »èÁ¦ÇÑ´Ù.
	for (i = 1; i < DEF_MAXITEMS; i++)
	if ((m_pClientList[iClientH]->m_pItemList[i-1] == NULL) && (m_pClientList[iClientH]->m_pItemList[i] != NULL)) {
		m_pClientList[iClientH]->m_pItemList[i-1]       = m_pClientList[iClientH]->m_pItemList[i];	
		m_pClientList[iClientH]->m_bIsItemEquipped[i-1] = m_pClientList[iClientH]->m_bIsItemEquipped[i];	
		m_pClientList[iClientH]->m_pItemList[i]   = NULL;
		m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
	}

	return TRUE;
}



BOOL CGame::bBankItemToPlayer(int iClientH, short sItemIndex)
{
 register int i, iIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if (m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
		iIndex = i;
		goto NEXT_STEP_PLTB;
	}
	// ´õÀÌ»ó °®°íÀÖÀ» °ø°£ÀÌ ¾ø´Ù. 
	return FALSE;

NEXT_STEP_PLTB:;

	// ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÒ °ø°£ÀÌ ³²¾ÆÀÖ´Ù. 
	
	// ¾ÆÀÌÅÛ Å¬·¡½ºÀÇ ÁÖ¼Ò¸¦ ¹Ù²Û´Ù. 
	m_pClientList[iClientH]->m_pItemList[iIndex] = m_pClientList[iClientH]->m_pItemInBankList[sItemIndex]; 
	
	m_pClientList[iClientH]->m_pItemInBankList[sItemIndex] = NULL;

	return TRUE;
}



BOOL CGame::__bReadMapInfo(int iMapIndex)
{
 char * pContents, * token, cTxt[250], cFn[255];	 
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iTeleportLocIndex  = 0;
 int  iWayPointCfgIndex  = 0;
 int  iTotalNpcSetting   = 0;
 int  iMGARCfgIndex      = 0;
 int  iSMGRCfgIndex      = 0;
 int  iNMRCfgIndex       = 0;
 int  iFishPointIndex 	 = 0;
 int  iMineralPointIndex = 0;
 int  iStrategicPointIndex = 0;
 int  iIndex = 0;

 int  iNamingValue;
 class CStrTok * pStrTok;
 HANDLE hFile;
 DWORD  dwFileSize, dwReadSize;
 FILE * pFile;

 char cName[6], cNpcName[21], cNpcMoveType, cNpcWaypointIndex[10], cNamePrefix;
 short sIPindex;

	// »çÅõÀåÀÎÁö¸¦ ÆÇ´Ü.
	if (memcmp(m_pMapList[iMapIndex]->m_cName, "fightzone", 9) == 0) 
		m_pMapList[iMapIndex]->m_bIsFightZone = TRUE;

	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn, "mapdata\\");
	strcat(cFn, m_pMapList[iMapIndex]->m_cName);
	strcat(cFn, ".txt");
	
	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) return FALSE;
	dwFileSize = GetFileSize(hFile, NULL);
	CloseHandle(hFile);


	pContents = new char[dwFileSize+1];
	ZeroMemory(pContents, dwFileSize+1);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// ¸Ê Á¤º¸ÆÄÀÏÀ»  ÀÐÀ» ¼ö ¾ø´Ù.
		wsprintf(cTxt, "(!) Cannot open file : %s", cFn);
		PutLogList(cTxt);
		return FALSE;
	}
	else {
		wsprintf(cTxt, "(!) Reading Map info file : %s", cFn);
		PutLogList(cTxt);
		dwReadSize = fread(pContents, dwFileSize, 1, pFile);
		fclose(pFile);
	}

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	//token = strtok(pContents, seps);
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcX = atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// ÅÚ·¹Æ÷Æ® ¼Ò½º ÁÂÇ¥ Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 2 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sSrcY = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö ¸Ê ÀÌ¸§ 
					ZeroMemory(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, 
						       sizeof(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName));
					strcpy(m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDestMapName, token);
					cReadModeB = 4;
					break;

				case 4:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ X 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 3 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestX = atoi(token);
					cReadModeB = 5;
					break;
				
				case 5:
					// ÅÚ·¹Æ÷Æ® ¸ñÀûÁö À§Ä¡ Y 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 4 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_sDestY = atoi(token);
					cReadModeB = 6;
					break;
				
				case 6:
					// ÅÚ·¹Æ÷Æ® ÈÄ ¹æÇâ  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 5 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex]->m_cDir = atoi(token);
					iTeleportLocIndex++;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 2:
				switch (cReadModeB) {
				case 1:
					// waypoint ¹øÈ£   
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 6 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iWayPointCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 7 - Duplicated waypoint");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// waypoint ÁýÇÕ Á¤ÀÇ X  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 8 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// waypoint ÁýÇÕ Á¤ÀÇ Y  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 9 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_WaypointList[iWayPointCfgIndex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 3:
				// Npc¸¦ Æ¯Á¤À§Ä¡¿¡ À§Ä¡½ÃÅ²´Ù.
				switch (cReadModeB) {
				case 1:
					// NPCÀÇ ÀÌ¸§. 
					ZeroMemory(cNpcName, sizeof(cNpcName));
					strcpy(cNpcName, token);
					cReadModeB = 2;
					break;
				case 2:
					// NpcMoveType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 10 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcMoveType = atoi(token);
					cReadModeB = 3;
					break;
				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 11 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cNpcWaypointIndex[cReadModeB-3] = atoi(token);
					cReadModeB++;
					break;
				case 13:
					// cNamePrefix
					cNamePrefix = token[0];
					// ÀÌÁ¦ ÀÌ°÷¿¡¼­ NPC¸¦ »ý¼ºÇÑ´Ù. 
					
					iNamingValue = m_pMapList[iMapIndex]->iGetEmptyNamingValue();
					if (iNamingValue == -1) {
						// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
					}
					else {
						// NPC¸¦ »ý¼ºÇÑ´Ù.
						ZeroMemory(cName, sizeof(cName));
						wsprintf(cName, "XX%d", iNamingValue);
						cName[0] = cNamePrefix;
						cName[1] = iMapIndex+65;
											
						if (bCreateNewNpc(cNpcName, cName, m_pMapList[iMapIndex]->m_cName, 0, 0, cNpcMoveType, NULL, NULL, cNpcWaypointIndex, NULL, NULL, -1, FALSE) == FALSE) {
							// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
							m_pMapList[iMapIndex]->SetNamingValueEmpty(iNamingValue);
						} 
					}
					cReadModeA = 0;
					cReadModeB = 0;
					iTotalNpcSetting++;
					break;
				}
				break;

			case 4:
				switch (cReadModeB) {
				case 1:
					// Random-Mob-Generator »ç¿ë ¿©ºÎ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 12 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bRandomMobGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					// Mob- Level
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 13 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 5:
				// Maximum object
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 14 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}

				m_pMapList[iMapIndex]->m_iMaximumObject = atoi(token);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 6:
				// Ä³¸¯ÅÍ ·£´ý »ý¼º ±ÝÁö ±¸¿ª : ¸¶À» Áß½ÉºÎ °°Àºµ¥¼­ ¸÷ÀÌ ¹ß»ýµÇ¸é °ï¶õÇÏ¹Ç·Î 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 15 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMGARCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Waypoint ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 16 - Duplicated Mob Gen Rect Number!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					cReadModeB = 2;
					break;

				case 2:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 17 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 18 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 19 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 20 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[iMGARCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
			
			case 7:
				// Æ¯Á¤Áö¿ª ¸÷ »ý¼º 
				switch (cReadModeB) {
				case 1:
					// Rect ¹øÈ£ m_stSpotMobGenerator[]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 21 - Wrong Data format(MGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iSMGRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined == TRUE) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â ¸÷ Á¦³Ê·¹ÀÌÅÍ ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error - ");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].bDefined = TRUE;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 22 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 1)
						cReadModeB = 3;
					else if (m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cType == 2)
						cReadModeB = 9;  // RECT°¡ ¾Æ´Ï¶ó WaypointÁýÇÕÀ» ÀÐ¾î¾ß ÇÑ´Ù.
					break;

				case 3:
					// left
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 23 - Wrong Data format(SMGAR num).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.left = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// top
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 24 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.top = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// right
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 25 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.right = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// bottom
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 26 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].rcRect.bottom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 27 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// Max Mobs
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 28 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				default:
					// WayPoint0~waypoint9
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 29 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].cWaypoint[cReadModeB - 9] = atoi(token);
					cReadModeB++;
			   		break;

				case 19:
					// spot mob type
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 30 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMobType = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 31 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iMaxMobs = atoi(token);
					m_pMapList[iMapIndex]->m_stSpotMobGenerator[iSMGRCfgIndex].iCurMobs	= 0;
					cReadModeA = 0;
					cReadModeB = 0;
					break;
			  	}
				break;

			case 8:
				// ¸ÊÀÌ ¼ÓÇÑ Àå¼Ò ÀÌ¸§ 
				ZeroMemory(m_pMapList[iMapIndex]->m_cLocationName, sizeof(m_pMapList[iMapIndex]->m_cLocationName));
				memcpy(m_pMapList[iMapIndex]->m_cLocationName, token, 10);
				cReadModeA = 0;
				cReadModeB = 0;
				break;

			case 9:
				switch (cReadModeB) {
				case 1:
					// Initial-Point Index
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32:1 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					sIPindex = atoi(token);
					if (m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x != -1) {
						PutLogList("(!!!) CRITICAL ERROR! Duplicate Initial Point Index!");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;
				
				case 2:
					// Initial-Point X
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 32 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].x = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Initial-Point Y
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 33 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pInitialPoint[sIPindex].y = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;
		
			case 10:
				// °ø°Ý ¹«È¿È­ ¿µ¿ª RECT
				switch (cReadModeB) {
				case 1:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 34 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iNMRCfgIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â No-Magic-Rect ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 35 - Duplicate No-Magic-Rect number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 36 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].left = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 37 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].top = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 38 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].right = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 39 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_rcNoAttackRect[iNMRCfgIndex].bottom = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 11:
				m_pMapList[iMapIndex]->m_bIsFixedDayMode = (BOOL)atoi(token);
				cReadModeA = 0;
				break;

			case 12:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 40 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iFishPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Fish Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 41 - Duplicate FishPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalFishPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 42 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 43 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_FishPointList[iFishPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 13:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 44 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxFish = atoi(token);

				cReadModeA = 0;
				break;

			case 14:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 45 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_cType = atoi(token);

				cReadModeA = 0;
				break;

			case 15:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 46 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 16:
				// ±¤¹° Á¦³×·¹ÀÌÅÍÀÇ Á¸ÀçÀ¯¹«¿Í µî±Þ 
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 47 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_bMineralGenerator = (BOOL)atoi(token);
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 48 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_cMineralGeneratorLevel = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 17:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 49 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iMineralPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x != -1) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Mineral Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 50 - Duplicate MineralPoint number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalMineralPoint++;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 51 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].x = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 52 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_MineralPointList[iMineralPointIndex].y = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 18:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 53 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iMaxMineral = atoi(token);

				cReadModeA = 0;
				break;

			case 19:
				if (_bGetIsStringIsNumber(token) == FALSE) {
					PutLogList("(!!!) CRITICAL ERROR! Map Info file error 54 - Wrong Data format.");
					delete pContents;
					delete pStrTok;
					return FALSE;
				}
				m_pMapList[iMapIndex]->m_iUpperLevelLimit = atoi(token);

				cReadModeA = 0;
				break;

			case 20:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 55 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iStrategicPointIndex = atoi(token);

					if (m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Strategic Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 56 - Duplicate Strategic Point number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex] = new class CStrategicPoint;
					cReadModeB = 2;
					break;

				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 57 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iSide = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 58 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iValue = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 59 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iX = atoi(token);

					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 60 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_pStrategicPointList[iStrategicPointIndex]->m_iY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 21:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 61 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Creation Point ¹øÈ£ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 62 - Duplicate EnergySphereCreation number");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereCreationPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 63 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].cType = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 64 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 65 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereCreationList[iIndex].sY = atoi(token);

					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 22:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 66 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â Energy-Sphere-Goal Point ¹øÈ£ÀÌ´Ù.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 67 - Duplicate EnergySphereGoal number(%d:%d)", iIndex, m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pMapList[iMapIndex]->m_iTotalEnergySphereGoalPoint++;
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 68 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].cResult = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 69 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenX = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 70 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].aresdenY = atoi(token);
					
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 71 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineX = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 72 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stEnergySphereGoalList[iIndex].elvineY = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			case 23:
				switch (cReadModeB) {
				case 1:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 73 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					iIndex = atoi(token);
					
					if (strlen(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName) != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÇ¾îÀÖ´Â  Point ¹øÈ£ÀÌ´Ù.
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! Map Info file error 74 - Duplicate Strike Point number(%d)", iIndex);
						PutLogList(G_cTxt);
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					cReadModeB = 2;
					break;
				
				case 2:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 75 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dX = atoi(token);

					cReadModeB = 3;
					break;

				case 3:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 76 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].dY = atoi(token);

					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iHP = atoi(token);
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iInitHP = atoi(token);
					cReadModeB = 5;
					break;


				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[0] = atoi(token);
					
					cReadModeB = 6;
					break;

				case 6:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[0] = atoi(token);
					
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[1] = atoi(token);
					
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[1] = atoi(token);
					
					cReadModeB = 9;
					break;

				case 9:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[2] = atoi(token);
					
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[2] = atoi(token);
					
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[3] = atoi(token);
					
					cReadModeB = 12;
					break;

				case 12:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[3] = atoi(token);
					
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectX[4] = atoi(token);
					
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! Map Info file error 77 - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].iEffectY[4] = atoi(token);
					
					cReadModeB = 15;
					break;

				case 15:
					ZeroMemory(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, sizeof(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName));
					strcpy(m_pMapList[iMapIndex]->m_stStrikePoint[iIndex].cRelatedMapName, token);
					
					m_pMapList[iMapIndex]->m_iTotalStrikePoints++;

					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "teleport-loc", 12) == 0) {
				m_pMapList[iMapIndex]->m_pTeleportLoc[iTeleportLocIndex] = new class CTeleportLoc;
				cReadModeA = 1;
				cReadModeB = 1;
			}

			if (memcmp(token, "waypoint", 8) == 0) {
				cReadModeA = 2;
				cReadModeB = 1;
			}

			if (memcmp(token, "npc", 3) == 0) {
				cReadModeA = 3;
				cReadModeB = 1;
			}

			if (memcmp(token, "random-mob-generator", 20) == 0) {
				cReadModeA = 4;
				cReadModeB = 1;
			}
			
			if (memcmp(token, "maximum-object", 14) == 0) 
				cReadModeA = 5;

			if (memcmp(token, "npc-avoidrect", 13) == 0) {
				cReadModeA = 6;
				cReadModeB = 1;
			}

			if (memcmp(token, "spot-mob-generator", 18) == 0) {
				cReadModeA = 7;
				cReadModeB = 1;
			}

			if (memcmp(token, "map-location", 12) == 0)
				cReadModeA = 8;

			if (memcmp(token, "initial-point", 13) == 0) {
				cReadModeA = 9;
				cReadModeB = 1;
			}

			if (memcmp(token, "no-attack-area", 14) == 0) {
				cReadModeA = 10;
				cReadModeB = 1;
			}

			if (memcmp(token, "fixed-dayornight-mode", 21) == 0) cReadModeA = 11;

			if (memcmp(token, "fish-point", 10) == 0) {
				cReadModeA = 12;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-fish", 8) == 0)		cReadModeA = 13;	
			if (memcmp(token, "type", 4) == 0)			cReadModeA = 14;	
			if (memcmp(token, "level-limit", 11) == 0)	cReadModeA = 15;	

			if (memcmp(token, "mineral-generator", 17) == 0) {
				cReadModeA = 16;
				cReadModeB = 1;
			}

			if (memcmp(token, "mineral-point", 13) == 0) {
				cReadModeA = 17;
				cReadModeB = 1;
			}

			if (memcmp(token, "max-mineral", 11) == 0)			cReadModeA = 18;	
			if (memcmp(token, "upper-level-limit", 17) == 0)	cReadModeA = 19;	// v1.4
			if (memcmp(token, "strategic-point", 15) == 0) {	// v1.41
				cReadModeA = 20;	
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-creation-point", 28) == 0) {
				cReadModeA = 21;
				cReadModeB = 1;
			}

			if (memcmp(token, "energy-sphere-goal-point", 24) == 0) {
				cReadModeA = 22;
				cReadModeB = 1;
			}

			if (memcmp(token, "strike-point", 12) == 0) {
				cReadModeA = 23;
				cReadModeB = 1;
			}

			if (memcmp(token, "[END-MAP-INFO]", 14) == 0) {
				cReadModeA = 0;
				cReadModeB = 0;
				goto RMI_SKIPDECODING;
			}
		}
		token = pStrTok->pGet();
	}	

RMI_SKIPDECODING:;

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! map info file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) Map info file decoding(%s) - success! TL(%d) WP(%d) LNPC(%d) MXO(%d) RMG(%d / %d)", cFn, iTeleportLocIndex, iWayPointCfgIndex, iTotalNpcSetting, m_pMapList[iMapIndex]->m_iMaximumObject, m_pMapList[iMapIndex]->m_bRandomMobGenerator, m_pMapList[iMapIndex]->m_cRandomMobGeneratorLevel);
	PutLogList(cTxt);

	// Crusade °ø°Ý ºÒ°¡´É ¿µ¿ªÀ» Å¸ÀÏ¿¡ Ç¥½ÃÇÑ´Ù.
	m_pMapList[iMapIndex]->_SetupNoAttackArea();

	return TRUE;

}

void CGame::Quit()
{
 int i;	

	// ¾²·¹µå¸¦ Á×ÀÎ´Ù.
	G_bIsThread = FALSE;
	Sleep(300);
		
	if (m_pMainLogSock != NULL) delete m_pMainLogSock;
	if (m_pGateSock != NULL) delete m_pGateSock;

	for (i = 0; i < DEF_MAXSUBLOGSOCK; i++)
		if (m_pSubLogSock[i] != NULL) delete m_pSubLogSock[i];

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) delete m_pClientList[i];

	for (i = 0; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) delete m_pNpcList[i];

	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) delete m_pMapList[i];

	for (i = 0; i < DEF_MAXITEMTYPES; i++)
	if (m_pItemConfigList[i] != NULL) delete m_pItemConfigList[i];

	for (i = 0; i < DEF_MAXNPCTYPES; i++)
	if (m_pNpcConfigList[i] != NULL) delete m_pNpcConfigList[i];

	for (i = 0; i < DEF_MAXMAGICTYPE; i++)
	if (m_pMagicConfigList[i] != NULL) delete m_pMagicConfigList[i];

	for (i = 0; i < DEF_MAXSKILLTYPE; i++)
	if (m_pSkillConfigList[i] != NULL) delete m_pSkillConfigList[i];

	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
	if (m_pQuestConfigList[i] != NULL) delete m_pQuestConfigList[i];

	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++)
	if (m_pDynamicObjectList[i] != NULL) delete m_pDynamicObjectList[i];

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++)
	if (m_pDelayEventList[i] != NULL) delete m_pDelayEventList[i];

	for (i = 0; i < DEF_MAXNOTIFYMSGS; i++)
	if (m_pNoticeMsgList[i] != NULL) delete m_pNoticeMsgList[i];

	for (i = 0; i < DEF_MAXFISHS; i++)
	if (m_pFish[i] != NULL) delete m_pFish[i];

	for (i = 0; i < DEF_MAXMINERALS; i++)
	if (m_pMineral[i] != NULL) delete m_pMineral[i];

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++)
	if (m_pPortionConfigList[i] != NULL) delete m_pPortionConfigList[i];

	for (i = 0; i < DEF_MAXBUILDITEMS; i++) 
	if (m_pBuildItemList[i] != NULL) delete m_pBuildItemList[i];

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) delete m_pDupItemIDList[i];

	if (m_pNoticementData != NULL) delete m_pNoticementData;

}

int CGame::iGetLevelExp(int iLevel)
{
 int iRet;
	
	if (iLevel == 0) return 0;
	
	iRet = iGetLevelExp(iLevel - 1) + iLevel * ( 50 + (iLevel * (iLevel / 17) * (iLevel / 17) ) );

	return iRet;
}

int CGame::_iCalcSkillSSNpoint(int iLevel)
{
 int iRet;

	if (iLevel < 1) return 1;
	
	if (iLevel <= 50) 
		iRet = iLevel;
	else if (iLevel > 50) {
		iRet = ( iLevel * iLevel ) / 10;
	}

	return iRet;
}

BOOL CGame::bCheckLevelUp(int iClientH)
{
 BOOL bStr, bVit, bDex, bInt, bMag, bChr;
 char cLoopCnt;

	if (m_pClientList[iClientH] == NULL) return FALSE;
	// ÃÖ´ë ·¹º§ Á¦ÇÑ 
	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) return FALSE;
	if (m_pClientList[iClientH]->m_iExp < m_pClientList[iClientH]->m_iNextLevelExp) return FALSE;
	
	bStr = bVit = bDex = bInt = bMag = bChr = FALSE;
	// ¸¸¾à Ã¼ÇèÆÇ »ç¿ëÀÚ¶ó¸é ·¹º§ 10ÀÌ»óÀÇ °æÇèÄ¡¸¦ °¡Áú¼ö´Â ¾ø´Ù. Account Status: 1-Ã¼ÇèÆÇ »ç¿ëÀÚ  2-Á¤½Ä »ç¿ëÀÚ 3-Á¤½Ä »ç¿ëÀÚ »ç¿ëÁßÁö 
	cLoopCnt = 0;
	while (1) {
		if (cLoopCnt++ > 100) return FALSE; // ¹«¾ð°¡ ¿¡·¯°¡ ¹ß»ýÇÑ °Í °°´Ù. ÇØÅ·µî¿¡ ÀÇÇÑ ÆÄÀÏ Á¶ÀÛ 
		if (m_pClientList[iClientH]->m_iExp >= m_pClientList[iClientH]->m_iNextLevelExp) {
			// ·¹º§ÀÌ ¿Ã¶ú´Ù.
			m_pClientList[iClientH]->m_iLevel++;
			// ·¹º§ÀÌ ¿À¸¥°Í¿¡ ´ëÇÑ Æ¯¼ºÄ¡ Æ÷ÀÎÆ®¸¦ Áõ°¡½ÃÄÑ¾ß ÇÑ´Ù. 
//			if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
//	  		      m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) <= DEF_TOTALLEVELUPPOINT) {
				// ·¹º§ ¾÷ ¼¼ÆÃÀÌ 3º¸´Ù °°°Å³ª ÀÛ¾Æ¾ß À¯È¿ÇÏ´Ù. 

					  m_pClientList[iClientH]->m_iLU_Pool += 3;
/*
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr  += m_pClientList[iClientH]->m_cLU_Str;
					bStr = TRUE;
				}
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit  += m_pClientList[iClientH]->m_cLU_Vit;
					bVit = TRUE;
				}
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex  += m_pClientList[iClientH]->m_cLU_Dex;
					bDex = TRUE;
				}
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt  += m_pClientList[iClientH]->m_cLU_Int;
					bInt = TRUE;
				}
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag  += m_pClientList[iClientH]->m_cLU_Mag;
					bMag = TRUE;
				}
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma += m_pClientList[iClientH]->m_cLU_Char;
					bChr = TRUE;
				}
				*/
//			}

			// ¼³Á¤Ä¡¸¦ È®ÀÎÇÑ´Ù. 
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iStr = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iDex = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iVit = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iInt = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT)      m_pClientList[iClientH]->m_iMag = DEF_CHARPOINTLIMIT;
			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) m_pClientList[iClientH]->m_iCharisma = DEF_CHARPOINTLIMIT;

			// ·¹º§ÀÌ ¿À¸¥°ÍÀ» Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

			// ´ÙÀ½ ·¹º§·ÎÀÇ °æÇèÄ¡°ª °è»ê, ÇÒ´ç.
			m_pClientList[iClientH]->m_iNextLevelExp = m_iLevelExpTable[m_pClientList[iClientH]->m_iLevel + 1]; //iGetLevelExp(m_pClientList[iClientH]->m_iLevel + 1);
		
			// Æ¯¼ºÄ¡ Àç °è»ê. 
			CalcTotalItemEffect(iClientH, -1, FALSE);

			//v1.4 ´ÙÀ½ ·¹º§ 
			//wsprintf(G_cTxt, "(!) Level up: ·¹º§(%d) °æÇèÄ¡(%d) ´ÙÀ½·¹º§°æÇèÄ¡(%d)", m_pClientList[iClientH]->m_iLevel, m_pClientList[iClientH]->m_iExp, m_pClientList[iClientH]->m_iNextLevelExp);
			//PutLogFileList(G_cTxt);
		}
		else return TRUE;
	}

	return FALSE;
}
// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
//  desc		 :: ÁöÁ¸Æ÷ÀÎÆ®¸¦ ·¹º§¾÷ Æ÷ÀÎÆ®·Î µ¹¸°´Ù...
//	return value :: void
//  date		 :: [2003-04-14]    stupid koreans
/////////////////////////////////////////////////////////////////////////////////////
void CGame::StateChangeHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cStateChange1, cStateChange2, cStateChange3;
 char cStr, cVit, cDex, cInt, cMag, cChar;
 char cStateTxt[512];
 int iOldStr, iOldVit, iOldDex, iOldInt, iOldMag, iOldChar;
 int iTotalSetting = 0;
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iGizonItemUpgradeLeft <= 0) return;

	cStr = cVit = cDex = cInt = cMag = cChar = 0;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStateChange1 = *cp;
	cp++;

	cStateChange2 = *cp;
	cp++;

	cStateChange3 = *cp;
	cp++;

	iOldStr	= m_pClientList[iClientH]->m_iStr;
	iOldVit	= m_pClientList[iClientH]->m_iVit;
	iOldDex = m_pClientList[iClientH]->m_iDex;
	iOldInt = m_pClientList[iClientH]->m_iInt;
	iOldMag = m_pClientList[iClientH]->m_iMag;
	iOldChar = m_pClientList[iClientH]->m_iCharisma;
	
	
	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma);
	PutLogList(G_cTxt);
//	wsprintf(G_cTxt, "(*)   ");
//	PutLogList(G_cTxt);
//	wsprintf(G_cTxt, "(*) Char(%s) Str(%d) Vit(%d) Dex(%d) Int(%d) Mag(%d) Chr(%d) ", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iStr, m_pClientList[iClientH]->m_iVit, m_pClientList[iClientH]->m_iDex, m_pClientList[iClientH]->m_iInt, m_pClientList[iClientH]->m_iMag, m_pClientList[iClientH]->m_iCharisma,  );
//	PutLogList(G_cTxt);
	
	
	if(!bChangeState(cStateChange1,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange2,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}
	if(!bChangeState(cStateChange3,&cStr,&cVit,&cDex,&cInt,&cMag,&cChar))
	{
		//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	//±æµå ¸¶½ºÅÍ¸é cChar¸¦ ¸ø ³»¸°´Ù..
	if(m_pClientList[iClientH]->m_iGuildRank == 0 )
	{
		if(m_pClientList[iClientH]->m_iCharisma - cChar < 20)
		{
			//Å¬¶óÀÌ¾ðÆ®¿¡¼­ °ªÀ» Àß¸ø º¸³»¿Âµí...
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
			return;
		}
	}

	//Æ¯¼ºÄ¡ °ªÀÌ ·¹º§°ú ¸ÂÁö ¾Ê´Ù¸é ³»¸±¼ö ¾ø´Ù..
	if(iOldStr +iOldVit	+iOldDex +iOldInt +iOldMag +iOldChar != (179*3 + 70))
	{
		//ÇØÅ·ÀÌ´Ù... Å¬¶óÀÌ¾ðÆ®¿¡¼­ ¸øº¸³»°Ô µÇ¾î ÀÖ´Ù ±Ùµ¥ ¿Ô´Ù¸é ÇØÅ·...
		return;
	}


	if(cStr < 0 || cVit < 0 || cDex < 0 || cInt < 0 || cMag < 0 || cChar < 0
		|| cStr + cVit + cDex + cInt + cMag + cChar != 3)
	{
//		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	// Æ¯¼ºÄ¡°ªÀÌ 10ÀÌÇÏ·Î ¸ø³»·Á °£´Ù... Á¦ÇÑÀ» ³ÑÀ»¼öµµ ¾ø´Ù...
	if ((m_pClientList[iClientH]->m_iStr - cStr > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iStr - cStr < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iDex - cDex > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iDex - cDex < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iInt - cInt > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iInt - cInt < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iVit - cVit > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iVit - cVit < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iMag - cMag > DEF_CHARPOINTLIMIT) 
		 || (m_pClientList[iClientH]->m_iMag - cMag < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if ((m_pClientList[iClientH]->m_iCharisma - cChar > DEF_CHARPOINTLIMIT)
		 || (m_pClientList[iClientH]->m_iCharisma - cChar < 10)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	if (m_pClientList[iClientH]->m_iLU_Pool < 3) m_pClientList[iClientH]->m_iLU_Pool = 3;

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.
	m_pClientList[iClientH]->m_iLU_Pool += 3;
	
	m_pClientList[iClientH]->m_iGizonItemUpgradeLeft--;

	m_pClientList[iClientH]->m_iStr  -= cStr;
	m_pClientList[iClientH]->m_iVit  -= cVit;
	m_pClientList[iClientH]->m_iDex  -= cDex;
	m_pClientList[iClientH]->m_iInt  -= cInt;
	//2003-04-22ÀÏ ¸¶¹ýÀ» »èÁ¦ ½ÃÅ²´Ù.... ÀÎÆ®°¡ ³»·Á°¡°í ³ª¼­ µ¹¾Æ°¡¾ß ÇÑ´Ù...
	if(cInt > 0)
		bCheckMagicInt(iClientH);
	m_pClientList[iClientH]->m_iMag  -= cMag;
	m_pClientList[iClientH]->m_iCharisma -= cChar;

	ZeroMemory(cStateTxt,sizeof(cStateTxt));

	wsprintf(cStateTxt, "STR(%d->%d)VIT(%d->%d)DEX(%d->%d)INT(%d->%d)MAG(%d->%d)CHARISMA(%d->%d)",
		iOldStr, m_pClientList[iClientH]->m_iStr,
		iOldVit, m_pClientList[iClientH]->m_iVit,
		iOldDex, m_pClientList[iClientH]->m_iDex,
		iOldInt, m_pClientList[iClientH]->m_iInt,
		iOldMag, m_pClientList[iClientH]->m_iMag,
		iOldChar,m_pClientList[iClientH]->m_iCharisma				
		);

	//_bCustomLog(DEF_ITEMLOG_CUSTOM,iClientH,NULL,cStateTxt);

	//2003-04-22ÀÏ ½ºÅ³À» ³»·Á°¡°Ô ÇÑ´Ù... 
	//bCheckSkillState(iClientH);

	//¼º°ø..!!!
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_STATECHANGE_SUCCESS, NULL, NULL, NULL, NULL);
}

// 2003-04-21 ÀÎÆ®¿¡ µû¸¥ ¸¶¹ýÀ» »èÁ¦ ½ÃÄÑÁØ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  BOOL CGame::bCheckMagicInt(int iClientH)  //another retarded korean function
//  desc		 :: ÀÎÆ®°¡ ³»·Á°¬À»¶§ »èÁ¦ÇÒ ¸¶¹ýÀ» Ã³¸®ÇÑ´Ù... Ã¼Å©¸¸...
//	return value :: ¹«Á¶°Ç TRUE   // ....dumbass koreans
//  date		 :: 2003-04-21
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bCheckMagicInt(int iClientH)
{

	for(int i = 0;i < DEF_MAXMAGICTYPE ;i++)
	{
		if(m_pMagicConfigList[i] != NULL)
		if(m_pMagicConfigList[i]->m_sIntLimit > m_pClientList[iClientH]->m_iInt)
		{
			m_pClientList[iClientH]->m_cMagicMastery[i] = 0;
		}
	}

	return TRUE;
}

// 2003-04-14 ÁöÁ¸ Æ÷ÀÎÆ®¸¦ ·¹º§ ¼öÁ¤¿¡ ¾µ¼ö ÀÖ´Ù...
/////////////////////////////////////////////////////////////////////////////////////
//  bChangeState(char cStateChange 
//  		  ,char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
//  desc		 :: ÁöÁ¸ Æ÷ÀÎÆ®·Î Æ¯¼º°ª ¹Ù²Üƒ”À» ´õÇØ ÁØ´Ù...
//	return value :: BOOLÇü 0(FASLE) ¿¡·¯ ·¹º§ ¼öÁ¤ ºÒ°¡...
//  date		 :: [2003-04-14] 
/////////////////////////////////////////////////////////////////////////////////////
BOOL CGame::bChangeState(char cStateChange, char* cStr, char *cVit,char *cDex,char *cInt,char *cMag,char *cChar)
{
	if(cStateChange == DEF_STR)
	{
		*cStr += 1;
	}
	else if(cStateChange == DEF_VIT)
	{
		*cVit += 1;
//		if(m_pClientList[iClientH]->m_iStr - cVit < 10 || m_pClientList[iClientH]->cVit - cVit < DEF_CHARPOINTLIMIT )
//			return 0;
	}
	else if(cStateChange == DEF_DEX)
	{
		*cDex += 1;
	}
	else if(cStateChange == DEF_INT)
	{
		*cInt += 1;
	}
	else if(cStateChange == DEF_MAG)
	{
		*cMag += 1;
	}
	else if(cStateChange == DEF_CHR)
	{
		*cChar += 1;
	}
	else
	{
		//Å¬¶óÀÌ¾ðÆ®°¡ Àß¸øµÈ °ªÀ» º¸³» ¿Ô´Ù..
//		::MessageBox(NULL, "Å¬¶óÀÌ¾ðÆ® ¹ö±×?","debug", MB_ICONEXCLAMATION | MB_YESNO) ;
		return 0;
	}

	return cStateChange;
}

void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;
	int iTotalSetting = 0;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if(m_pClientList[iClientH]->m_iLU_Pool <= 3) 
	{
		//ÇØÄ¿ÀÎ°¡??
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

	if(m_pClientList[iClientH]->m_iLU_Pool < 3) {
		m_pClientList[iClientH]->m_iLU_Pool = 3;
	}


	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > m_pClientList[iClientH]->m_iLU_Pool - 3) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
	if ((m_pClientList[iClientH]->m_iStr + cStr > DEF_CHARPOINTLIMIT) || (cStr < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iDex + cDex > DEF_CHARPOINTLIMIT) || (cDex < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iInt + cInt > DEF_CHARPOINTLIMIT) || (cInt < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iVit + cVit > DEF_CHARPOINTLIMIT) || (cVit < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iMag + cMag > DEF_CHARPOINTLIMIT) || (cMag < 0)) 
		return;

	if ((m_pClientList[iClientH]->m_iCharisma + cChar > DEF_CHARPOINTLIMIT) || (cChar < 0)) 
		return;

	iTotalSetting = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iDex + m_pClientList[iClientH]->m_iVit + 
		m_pClientList[iClientH]->m_iInt + m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ Æ÷ÀÎÆ® > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)¸é ºñÁ¤»óÀÌ´Ù.. Ã³¸® ºÒ°¡.. ·¹º§¾÷ Æ÷ÀÎÆ®¸¦ Á¤»óÄ¡·Î ¸¶Ãß°í Ã³¸® ºÒ°¡..
	if (iTotalSetting + m_pClientList[iClientH]->m_iLU_Pool -3
	>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		m_pClientList[iClientH]->m_iLU_Pool = /*m_cLU_Str ÃÊ±â°ª*/3 + (m_pClientList[iClientH]->m_iLevel-1)*3 + 70 - iTotalSetting;

		//iTotalSetting°ªÀÌ Àß¸øµÈ °æ¿ì´Ù...
		if(m_pClientList[iClientH]->m_iLU_Pool < 3)
			m_pClientList[iClientH]->m_iLU_Pool = 3;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return ;
	}

	//(·¹º§ Æ¯¼º°ª + ·¹º§¾÷ ½ÃÅ³ Æ÷ÀÎÆ® ÁD > ·¹º§¾÷ Æ¯¼º°ª Á¤»óÄ¡)ÀÌ¸é Ã³¸® ºÒ°¡..
	if (iTotalSetting + (cStr + cVit + cDex + cInt + cMag + cChar)
		>	((m_pClientList[iClientH]->m_iLevel-1)*3 + 70)) 
	{
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_FAILED, NULL, NULL, NULL, NULL);
		return;
	}

	m_pClientList[iClientH]->m_iLU_Pool = m_pClientList[iClientH]->m_iLU_Pool - (cStr + cVit + cDex + cInt + cMag + cChar);

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.
	m_pClientList[iClientH]->m_iStr  += cStr;
	m_pClientList[iClientH]->m_iVit  += cVit;
	m_pClientList[iClientH]->m_iDex  += cDex;
	m_pClientList[iClientH]->m_iInt  += cInt;
	m_pClientList[iClientH]->m_iMag  += cMag;
	m_pClientList[iClientH]->m_iCharisma += cChar;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SETTING_SUCCESS, NULL, NULL, NULL, NULL);

}

/*
void CGame::LevelUpSettingsHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
	char * cp, cStr, cVit, cDex, cInt, cMag, cChar;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);

	m_pClientList[iClientH]->m_iLU_Pool += DEF_TOTALLEVELUPPOINT;
	wsprintf(G_cTxt, "(*) Level Up: Char(%s) Level (%d) DEF_TOTALLEVELUPPOINT (%d) m_pClientList[iClientH]->m_iLU_Pool (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel, DEF_TOTALLEVELUPPOINT, m_pClientList[iClientH]->m_iLU_Pool);		
	PutLogList(G_cTxt);

	cStr = *cp;
	cp++;

	cVit = *cp;
	cp++;

	cDex = *cp;
	cp++;

	cInt = *cp;
	cp++;

	cMag = *cp;
	cp++;

	cChar = *cp;
	cp++;

	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
	if ((cStr > DEF_TOTALLEVELUPPOINT) || (cStr < 0)) 
		return;

	if ((cDex > DEF_TOTALLEVELUPPOINT) || (cDex < 0)) 
		return;

	if ((cInt > DEF_TOTALLEVELUPPOINT) || (cInt < 0)) 
		return;

	if ((cVit > DEF_TOTALLEVELUPPOINT) || (cVit < 0)) 
		return;

	if ((cMag > DEF_TOTALLEVELUPPOINT) || (cMag < 0)) 
		return;

	if ((cChar > DEF_TOTALLEVELUPPOINT) || (cChar < 0)) 
		return;

	if ( (cStr + cVit + cDex + cInt + cMag + cChar) > DEF_TOTALLEVELUPPOINT) 
		return;

	// ¿À·ù°¡ ¾øÀ¸¸é °ªÀ» ÇÒ´çÇÑ´Ù.

	//m_pClientList[iClientH]->m_cLU_Str  = cStr;
	//m_pClientList[iClientH]->m_cLU_Vit  = cVit;
	//m_pClientList[iClientH]->m_cLU_Dex  = cDex;
	//m_pClientList[iClientH]->m_cLU_Int  = cInt;
	//m_pClientList[iClientH]->m_cLU_Mag  = cMag;
	//m_pClientList[iClientH]->m_cLU_Char = cChar;

	/*
	m_pClientList[iClientH]->m_cLU_Str = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Vit = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Dex = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Int = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Mag = *cp;
	cp++;

	m_pClientList[iClientH]->m_cLU_Char = *cp;
	cp++;

	if ((m_pClientList[iClientH]->m_cLU_Str > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Str < 0)) 
	m_pClientList[iClientH]->m_cLU_Str = 0;

	if ((m_pClientList[iClientH]->m_cLU_Vit > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Vit < 0)) 
	m_pClientList[iClientH]->m_cLU_Vit = 0;

	if ((m_pClientList[iClientH]->m_cLU_Dex > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Dex < 0)) 
	m_pClientList[iClientH]->m_cLU_Dex = 0;

	if ((m_pClientList[iClientH]->m_cLU_Int > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Int < 0)) 
	m_pClientList[iClientH]->m_cLU_Int = 0;

	if ((m_pClientList[iClientH]->m_cLU_Mag > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Mag < 0)) 
	m_pClientList[iClientH]->m_cLU_Mag = 0;

	if ((m_pClientList[iClientH]->m_cLU_Char > DEF_TOTALLEVELUPPOINT) || (m_pClientList[iClientH]->m_cLU_Char < 0)) 
	m_pClientList[iClientH]->m_cLU_Char = 0;

	if ( (m_pClientList[iClientH]->m_cLU_Str + m_pClientList[iClientH]->m_cLU_Vit + m_pClientList[iClientH]->m_cLU_Dex + 
	m_pClientList[iClientH]->m_cLU_Int + m_pClientList[iClientH]->m_cLU_Mag + m_pClientList[iClientH]->m_cLU_Char) > DEF_TOTALLEVELUPPOINT) {
	// Level-Up Setting°ª¿¡ ¿À·ù°¡ ÀÖ´Ù.
	m_pClientList[iClientH]->m_cLU_Str = m_pClientList[iClientH]->m_cLU_Vit = m_pClientList[iClientH]->m_cLU_Dex =  
	m_pClientList[iClientH]->m_cLU_Int = m_pClientList[iClientH]->m_cLU_Mag = m_pClientList[iClientH]->m_cLU_Char = 0;
	}
	*/
//}

// v1.4311-3 Ãß°¡ »çÅõÀå ¿¹¾à ÇÔ¼ö FightzoneReserveHandler
void CGame::FightzoneReserveHandler(int iClientH, char * pData, DWORD dwMsgSize)
{
 char * cp, cGuildName[21], cTxt[120], cData[100], cMsg[100];
 int iFightzoneNum ,* ip ,  iEnableReserveTime ;
 DWORD * dwp, dwGoldCount ;
 WORD  * wp, wResult;
 int     iRet, iResult=1, iCannotReserveDay;
 SYSTEMTIME SysTime;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
 
	GetLocalTime(&SysTime);
	
	// ¿¹¾à °¡´ÉÇÑ ½Ã°£ : µÎ½Ã°£ °£°ÝÀ¸·Î ¿¹¾àÀÌ °¡´ÉÇÏ¸ç »ç¿ë¿Ï·á 5ºÐÀü¿¡´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
	iEnableReserveTime  = 2*20*60 - ((SysTime.wHour%2)*20*60 + SysTime.wMinute*20) - 5*20;
	
	dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	// ¿¹¾àÀ» ¿øÇÏ´Â »çÅõÀå ¹øÈ£¸¦ ¹Þ´Â´Ù.
	iFightzoneNum = *ip;

	// Àß¸øµÈ fightzone ¹øÈ£¸¦ °É·¯³½´Ù.
	if ((iFightzoneNum < 1) || (iFightzoneNum > DEF_MAXFIGHTZONE)) return;

	// »çÅõÀåÀÌ Áßº¹µÇÁö ¾Ê°Ô ÇÏ±â À§ÇØ ¿äÀÏ¿¡ µû¶ó »ç¿ëÇÒ¼ö ÀÖ´Â »çÅõÀåÀÌ ´Ù¸£°Ô ÇÏ±â À§ÇÑ º¯¼ö´Ù.
	// È¦¼ö³¯¿¡´Â ¾Æ·¹½ºµ§ 2 4 6 8 ¿¤¹ÙÀÎÀÌ 1 3 5 7  »çÅõÀåÀÌ »ç¿ë°¡´ÉÇÏ´Ù 
    //             ex) 1ÀÏÀÎ°æ¿ì => {1 + 1 (¾Æ·¹½ºµ§) + 1 (»çÅõÀå ¹øÈ£ )} %2 == 1 ÀÌ¹Ç·Î 
	//                            ¾Æ·¹½ºµ§Àº È¦¼ö³¯ È¦¼ö »çÅõÀåÀ»  ¿¹¾à ÇÒ¼ö ¾ø´Ù. 

	iCannotReserveDay = (SysTime.wDay + m_pClientList[iClientH]->m_cSide + iFightzoneNum ) % 2 ;
	if (iEnableReserveTime <= 0 ){
		// ¿¹¾à¿¡ ½ÇÆÐÇß´Ù. 
		// ¸¸¾à ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ ¾Æ´Ï¸é 0 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³»°í 
		wResult = DEF_MSGTYPE_REJECT;
		iResult = 0 ;
	} else if (m_iFightZoneReserve[iFightzoneNum-1] != 0){
		// »çÅõÀåÀÌ ¿¹¾à µÇ¾î ÀÖÀ¸¸é  -1 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -1 ;
	} else if ( dwGoldCount < 1500 ) {
		// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ÀÔÀå±Ç °¡°Ý¿¡ ºñÇØ Àû´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -2 ;	           // µ·ÀÌ ÀûÀ¸¸é -2 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô º¸³½´Ù.
	} else if( iCannotReserveDay ) {
		// ¿À´ÃÀº ¿¹¾àÇÒ ¼ö ¾ø´Â ³¯ÀÌ´Ù. ÀÌ¶§´Â -3 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -3 ;
	} else if( m_pClientList[iClientH]-> m_iFightzoneNumber != 0 ) {
		// ÀÌ¹Ì ´Ù¸¥ »çÅõÀåÀ» ¿¹¾àÇß´Ù. ÀÌ¶§´Â -4 °ªÀ» Å¬¶óÀÌ¾ðÆ®¿¡ º¸³½´Ù.
		wResult = DEF_MSGTYPE_REJECT;
		iResult = -4 ;
	} else {
		// »ç¿ëÀÚ°¡ °í¸¥ »çÅõÀåÀÌ ¿¹¾àÀÌ µÇ¾î ÀÖÁö ¾Ê°í 
		// ¿¹¾à¿¡ ÇÊ¿äÇÑ ±Ý¾×µµ °¡Áö°í ÀÖ°í
		// ¿¹¾à °¡´ÉÇÑ ½Ã°£ÀÌ¸é  ¿¹¾àÇÑ´Ù.
	
		// ¿¹¾à¿¡ ¼º°ø Çß´Ù. 
		wResult = DEF_MSGTYPE_CONFIRM;

		// »çÅõÀå ¿¹¾àÀ» À§ÇÑ ±Ý¾×À» °¨¼Ò ½ÃÅ²´Ù.
		SetItemCount(iClientH, "Gold", dwGoldCount - 1500);
		iCalcTotalWeight(iClientH);
		
		// »çÅõÀåÀ» ¿¹¾àÇÑ Å¬¶óÀÌ¾ðÆ®ÀÇ ID¸¦ ³Ö´Â´Ù.
		m_iFightZoneReserve[iFightzoneNum-1] = iClientH;
		
		m_pClientList[iClientH]->m_iFightzoneNumber  = iFightzoneNum ;
		m_pClientList[iClientH]->m_iReserveTime	 =  SysTime.wMonth*10000 + SysTime.wDay*100 + SysTime.wHour ;  

		if (SysTime.wHour%2 )	m_pClientList[iClientH]->m_iReserveTime  += 1  ;	// È¦¼ö ½Ã°£´ëÀÌ¸é ÇÑ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		else					m_pClientList[iClientH]->m_iReserveTime  += 2  ;    // Â¦¼ö ½Ã°£´ëÀÌ¸é µÎ ½Ã°£ ÈÄ±îÁö ¿¹¾àµÈ´Ù.
		wsprintf(G_cTxt, "(*) Reserve FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iReserveTime);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		m_pClientList[iClientH]->m_iFightZoneTicketNumber  = 50 ;  
		iResult = 1 ;
	}  

	ZeroMemory(cData, sizeof(cData));

	dwp = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_FIGHTZONE_RESERVE;

	wp = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp =  wResult ;

	ip  = (int *)(cData + DEF_INDEX2_MSGTYPE+2) ; 
	*ip =  iResult ;
	ip+= 4;
	
	// »çÅõÀå ¿¹¾à ÀÀ´ä ¸Þ¼¼Áö  Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
		
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
 
	switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}



BOOL CGame::bCheckLimitedUser(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	
	if ( (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) && 
		 (m_pClientList[iClientH]->m_iExp >= m_iLevelExp20 ) ) {
		// ¿©ÇàÀÚ°¡ ·¹º§ 20 °æÇèÄ¡¸¦ ¾ò¾ú´Ù¸é 19¼öÁØÀ¸·Î È¯¿ø. 

		m_pClientList[iClientH]->m_iExp = m_iLevelExp20 - 1;	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TRAVELERLIMITEDLEVEL, NULL, NULL, NULL, NULL);
		return TRUE;
	}


	return FALSE;
}

void CGame::RequestCivilRightHandler(int iClientH, char *pData)
{
 char * cp, cData[100];
 DWORD * dwp;
 WORD * wp, wResult;
 int  iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// ÀÌ¹Ì ÇÑ ¸¶À»ÀÇ ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ½Ã¹Î±ÇÀ» °¡Áú ¼ö ¾ø´Ù. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) wResult = 0;
	else wResult = 1;

	// ·¹º§ÀÌ 5 ÀÌÇÏ¶óµµ ½Ã¹Î±ÇÀ» ¾òÀ» ¼ö ¾ø´Ù. 
	if (m_pClientList[iClientH]->m_iLevel < 5) wResult = 0;
	
	if (wResult == 1) {
		// ÇöÀç ¸ÊÀÇ ÀÌ¸§À» ÇÒ´çÇÑ´Ù.
		ZeroMemory(m_pClientList[iClientH]->m_cLocation, sizeof(m_pClientList[iClientH]->m_cLocation));
		strcpy(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName);
	}

	// Side ÇÒ´ç
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) 
		m_pClientList[iClientH]->m_cSide = 1;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) 
		m_pClientList[iClientH]->m_cSide = 2;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_CIVILRIGHT;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wResult;

	// v1.41 ¸Ê ÀÌ¸§ ¾Ë·ÁÁÜ 
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cp, m_pClientList[iClientH]->m_cLocation, 10);
	cp += 10;

	// ÀÀ´ä ¸Þ½ÃÁö¸¦ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¼Û
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 16);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}

	// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}


void CGame::RequestRetrieveItemHandler(int iClientH, char *pData)
{
 char * cp, cBankItemIndex, cMsg[100];
 register int i, j, iRet, iItemWeight;
 DWORD * dwp;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cBankItemIndex = *cp;

	if ((cBankItemIndex < 0) || (cBankItemIndex >= DEF_MAXBANKITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] == NULL) {
		// ¿À·ù´Ù. 
		ZeroMemory(cMsg, sizeof(cMsg));
			
		dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_RETRIEVEITEM;
		wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
	}
	else {
		// Áß·®°è»ê 
		/*
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			//iItemWeight = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight * m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount;
			iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		}
		else iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], 1); //m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_wWeight;
		*/
		// v1.432
		iItemWeight = iGetItemWeight(m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex], m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
		
		if ( (iItemWeight + m_pClientList[iClientH]->m_iCurWeightLoad) > _iCalcMaxLoad(iClientH)) {
			// ÇÑ°èÁß·® ÃÊ°ú, ¾ÆÀÌÅÛÀ» Ã£À» ¼ö ¾ø´Ù. 
			// ½ÇÆÐ ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			ZeroMemory(cMsg, sizeof(cMsg));
			
			// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 6);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				break;
			}
			return;
		}
		
		//!!!
		if ( (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) || 
			 (m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
			// Áßº¹ÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ¶ó¸é ¼ö·®¸¸ Áõ°¡½ÃÅ²´Ù.	
			for (i = 0; i < DEF_MAXITEMS; i++)
			if ( (m_pClientList[iClientH]->m_pItemList[i] != NULL) && 
				 (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cItemType) && 
			 	 (memcmp(m_pClientList[iClientH]->m_pItemList[i]->m_cName, m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_cName, 20) == 0) ) {
				// °°Àº Çü½ÄÀÇ ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ¼ö·®À» Áõ°¡½ÃÅ²´Ù.
				// v1.41 !!! 
				SetItemCount(iClientH, i, m_pClientList[iClientH]->m_pItemList[i]->m_dwCount + m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex]->m_dwCount);
				
				// ¹ðÅ© ¾ÆÀÌÅÛ »èÁ¦ 
				delete m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;

				// ºó °ø°£À» ¾ø¾Ø´Ù. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
				
				// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
			
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
				// È­»ì ÇÒ´ç
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
								
				// ¸Þ½ÃÁö Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}

			// °°Àº ÀÌ¸§À» °®°í ÀÖ´Â ¾ÆÀÌÅÛÀÌ ¾ø´Ù. »õ·Î Ãß°¡ÇØ¾ß ÇÑ´Ù. 
			goto RRIH_NOQUANTITY;
		} 
		else {
RRIH_NOQUANTITY:;
			// ¼ö·®°³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ 
			for (i = 0; i < DEF_MAXITEMS; i++)
			if (m_pClientList[iClientH]->m_pItemList[i] == NULL) {
				// ºó °ø°£À» Ã£¾Ò´Ù. 
				// ¸ÕÀú ÁÖ¼Ò¸¦ ¿Å±ä´Ù. 
				m_pClientList[iClientH]->m_pItemList[i] = m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex];
				// v1.3 1-27 12:22
				m_pClientList[iClientH]->m_ItemPosList[i].x = 40;
				m_pClientList[iClientH]->m_ItemPosList[i].y = 30;
			
				m_pClientList[iClientH]->m_bIsItemEquipped[i] = FALSE;
				
				m_pClientList[iClientH]->m_pItemInBankList[cBankItemIndex] = NULL;
				
				// ºó °ø°£À» ¾ø¾Ø´Ù. 
				for ( j = 0; j <= DEF_MAXBANKITEMS - 2; j++) {
					if ((m_pClientList[iClientH]->m_pItemInBankList[j+1] != NULL) && (m_pClientList[iClientH]->m_pItemInBankList[j] == NULL)) {
						m_pClientList[iClientH]->m_pItemInBankList[j] = m_pClientList[iClientH]->m_pItemInBankList[j+1];	
						
						m_pClientList[iClientH]->m_pItemInBankList[j+1] = NULL;
					}
				}
								
				// ¼º°ø ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				ZeroMemory(cMsg, sizeof(cMsg));
					
				dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
				*dwp = MSGID_RESPONSE_RETRIEVEITEM;
				wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_MSGTYPE_CONFIRM;
					
				cp = (char *)(cMsg + DEF_INDEX2_MSGTYPE + 2);
				*cp = cBankItemIndex;
				cp++;
				*cp = i;
				cp++;
					
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
		
				// È­»ì ÇÒ´ç
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
					
				// ¸Þ½ÃÁö Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
				return;
			}
			// ¾ÆÀÌÅÛÀ» µÇÃ£À» °ø°£ÀÌ ¾ø´Ù. ¿À·ù
			ZeroMemory(cMsg, sizeof(cMsg));
			
			dwp  = (DWORD *)(cMsg + DEF_INDEX4_MSGID);
			*dwp = MSGID_RESPONSE_RETRIEVEITEM;
			wp   = (WORD *)(cMsg + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_MSGTYPE_REJECT;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cMsg, 8);
		}
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

BOOL CGame::bSetItemToBankItem(int iClientH, short sItemIndex)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];
 class CItem * pItem;
	
	// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀ» º¸°üÇÑ´Ù.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// ºñ¾îÀÖ´Â À§Ä¡¸¦ Ã£¾Ò´Ù.
				
		m_pClientList[iClientH]->m_pItemInBankList[i] = m_pClientList[iClientH]->m_pItemList[sItemIndex];
		pItem = m_pClientList[iClientH]->m_pItemInBankList[i];
		// !!! ¾ÆÀÌÅÛÀÇ Æ÷ÀÎÅÍ¸¦ ÀÌµ¿ÇßÀ¸´Ï ±âÁ¸ÀÇ Æ÷ÀÎÅÍ´Â NULL°ªÀ¸·Î ÇÒ´ç. 
		m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;
		
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);			   
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);		       
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // À§Ä¡ ÀúÀå 
		cp++;

		// 1°³.
		*cp = 1;
		cp++;						    

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
		}

		return TRUE;
	}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return FALSE;
}


void CGame::ApplyPKpenalty(short sAttackerH, short sVictumLevel)
{
 int iV1, iV2;

	if (m_pClientList[sAttackerH] == NULL) return;
	// ¾ÈÀü °ø°Ý ¸ðµå°¡ ÄÑÁø »óÅÂ¿¡¼­ °ø°ÝÀ¸·Î ÀÎÇØ °°Àº ÆíÀÌ Á×À»¼ö´Â ¾øÁö¸¸ ¸¸¾à ÀÖÀ»°æ¿ì ¹«½Ã 
	// ´Ü °ø°ÝÀÚ°¡ ¹üÁËÀÚ°¡ ¾Æ´Ï¾î¾ß¸¸ ÇØ´çµÈ´Ù.
	if ((m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) && (m_pClientList[sAttackerH]->m_iPKCount == 0)) return; 
	
	// PK Count Áõ°¡  
	m_pClientList[sAttackerH]->m_iPKCount++;

	// °æÇèÄ¡ °¨¼Ò 
	iV1 = iDice((sVictumLevel/2)+1, 50); 
	iV2 = iDice((m_pClientList[sAttackerH]->m_iLevel/2)+1, 50);

	m_pClientList[sAttackerH]->m_iExp -= iV1; 
	m_pClientList[sAttackerH]->m_iExp -= iV2;
	if (m_pClientList[sAttackerH]->m_iExp < 0) m_pClientList[sAttackerH]->m_iExp = 0;

	// Æä³ÎÆ¼¸¦ ¸Ô¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKPENALTY, NULL, NULL, NULL, NULL);	

	// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
	SendEventToNearClient_TypeA(sAttackerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);

	// v1.4 ·Î±× ÆÄÀÏ¿¡ ±â·Ï 
	//wsprintf(G_cTxt, "(!) PK-penalty: °ø°ÝÀÚ(%s) ¼Õ½Ç °æÇèÄ¡(%d) °æÇèÄ¡(%d) ", m_pClientList[sAttackerH]->m_cCharName, iV1+iV2, m_pClientList[sAttackerH]->m_iExp);
	//PutLogFileList(G_cTxt);

	// v1.4 Å©¶óÀÓ È½¼ö Áõ°¡ 
	m_stCityStatus[m_pClientList[sAttackerH]->m_cSide].iCrimes++;

	// v1.41 Rating ÇÏ¶ô 
	m_pClientList[sAttackerH]->m_iRating -= 10;
	if (m_pClientList[sAttackerH]->m_iRating > 10000)  m_pClientList[sAttackerH]->m_iRating =  10000;
	if (m_pClientList[sAttackerH]->m_iRating < -10000) m_pClientList[sAttackerH]->m_iRating = -10000;
	
	// v2.03 PK½Ã °­ÄÝ¸ðµå »èÁ¦ 
/*	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "aresden") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk11") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk12") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk21") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arebrk22") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "aresden") == 0)   ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone2") == 0) ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "areuni") == 0)    ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "arefarm") == 0)) {
			
			// ¾Æ·¹½ºµ§ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "bisle");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
			RequestTeleportHandler(sAttackerH, "2   ", "bisle", -1, -1);
			return;		
		}
	}

	if (strcmp(m_pClientList[sAttackerH]->m_cLocation, "elvine") == 0) {
		if ( (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk11") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk12") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk21") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvbrk22") == 0)  ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvine") == 0)    ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "huntzone1") == 0) ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvuni") == 0)    ||
			 (strcmp(m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_cName, "elvfarm") == 0)) {
			
			// ¾Æ·¹½ºµ§ ±Ù±³¿¡¼­ PK¸¦ Çß´Ù. ºí¸®µù ÅÚ·¹Æ÷Æ® 5ºÐ
			ZeroMemory(m_pClientList[sAttackerH]->m_cLockedMapName, sizeof(m_pClientList[sAttackerH]->m_cLockedMapName));
			strcpy(m_pClientList[sAttackerH]->m_cLockedMapName, "bisle");
			m_pClientList[sAttackerH]->m_iLockedMapTime = 60*3;
			RequestTeleportHandler(sAttackerH, "2   ", "bisle", -1, -1);
			return;		
		}
	} */
}


void CGame::PK_KillRewardHandler(short sAttackerH, short sVictumH)
{
	if (m_pClientList[sAttackerH] == NULL) return;
	if (m_pClientList[sVictumH] == NULL)   return;

	if (m_pClientList[sAttackerH]->m_iPKCount != 0) {
		// PK¸¦ ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.

	}
	else {
		// Æ÷»ó±Ý¸¸ ´©Àû. °æÇèÄ¡´Â ¿À¸£Áö ¾Ê´Â´Ù. 
		m_pClientList[sAttackerH]->m_iRewardGold += iGetExpLevel(m_pClientList[sVictumH]->m_iExp) * 3;
		
		
		if (m_pClientList[sAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
			m_pClientList[sAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
		if (m_pClientList[sAttackerH]->m_iRewardGold < 0) 
			m_pClientList[sAttackerH]->m_iRewardGold = 0;
		
		SendNotifyMsg(NULL, sAttackerH, DEF_NOTIFY_PKCAPTURED, m_pClientList[sVictumH]->m_iPKCount, m_pClientList[sVictumH]->m_iLevel, NULL, m_pClientList[sVictumH]->m_cCharName);
	}
}

void CGame::EnemyKillRewardHandler(int iAttackerH, int iClientH)
{
 int iRewardExp;

	if (m_pClientList[iAttackerH] == NULL) return;
	if (m_pClientList[iClientH] == NULL)   return;
	if (m_pClientList[iAttackerH]->m_iLevel >= m_iPlayerMaxLevel) return;

	
	if (m_pClientList[iAttackerH]->m_iPKCount != 0) {
		// ÀûÀ» ÀâÀº »ç¶÷ÀÌ PK¸é ¾Æ¹«·± µæÀÌ ¾ø´Ù.
	}
	else {
		// Èñ»ýÀÚÀÇ ½Ã¹Î, ±æµå¿ø ¿©ºÎ¿¡ µû¶ó Æ÷»óÀÌ ´Þ¶óÁø´Ù. 
		if (m_pClientList[iClientH]->m_iGuildRank == -1) {
			// ±æµå¿øÀÌ ¾Æ´Ï¹Ç·Î ½Ã¹Î. (¿©ÇàÀÚÀÇ °æ¿ì¿¡´Â ÀÌ ÇÔ¼ö°¡ È£ÃâµÇÁö ¾ÊÀ¸¹Ç·Î)
			iRewardExp = iDice(1, (2*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp);
			
			if (m_bIsCrusadeMode == TRUE) {
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ (1/3)*3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 6¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;

				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);

				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= 30) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= 30) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		else {
			iRewardExp = iDice(1, (3*iGetExpLevel(m_pClientList[iClientH]->m_iExp))) + iGetExpLevel(m_pClientList[iClientH]->m_iExp);

			// ±æµå¿øÀÌ´Ù.
			if (m_bIsCrusadeMode == TRUE) {
				// Å©·ç¼¼ÀÌµå ¸ðµå.
				// Å©·ç¼¼ÀÌµå ¸ðµå¶ó¸é °æÇèÄ¡ÀÇ 1/3À» ¸ÕÀú ÁÖ°í ³ª¸ÓÁö´Â 2¹è·Î ÀüÀï °øÇåµµ¿¡ ´©Àû 
				m_pClientList[iAttackerH]->m_iExp += (iRewardExp/3)*4;
				m_pClientList[iAttackerH]->m_iWarContribution += (iRewardExp - (iRewardExp/3))*12;

				if (m_pClientList[iAttackerH]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
					m_pClientList[iAttackerH]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

				m_pClientList[iAttackerH]->m_iConstructionPoint += m_pClientList[iClientH]->m_iLevel / 2;
				
				if (m_pClientList[iAttackerH]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
					m_pClientList[iAttackerH]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;

				//testcode
				wsprintf(G_cTxt, "Enemy Player Killed by Player! Construction: +%d WarContribution +%d", m_pClientList[iClientH]->m_iLevel / 2, (iRewardExp - (iRewardExp/3))*6);
				PutLogList(G_cTxt);

				// ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iAttackerH]->m_iConstructionPoint, m_pClientList[iAttackerH]->m_iWarContribution, NULL, NULL);
				
				// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30 ÀÌ»óÀÎ °æ¿ì Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= 30) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
			else {
				// ÀÏ¹Ý ¸ðµå.
				m_pClientList[iAttackerH]->m_iExp += iRewardExp;
				// Enemy Kill count¸¦ ¿Ã¸°´Ù.
				if (iGetExpLevel(m_pClientList[iClientH]->m_iExp) >= 30) {
					// Èñ»ýÀÚÀÇ ·¹º§ÀÌ 30ÀÌ»óÀÌ°í
					if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iClientH]->m_cMapName, 10) != 0) {
						// Èñ»ýÀÚ°¡ Á×Àº °÷ÀÌ ÀÚ½ÅÀÇ ¸¶À»ÀÌ ¾Æ´Ï¶ó¸é EK·Î ÀÎÁ¤ 
						m_pClientList[iAttackerH]->m_iEnemyKillCount++;
					}
				}	
				// Æ÷»ó±Ý ´©Àû 
				m_pClientList[iAttackerH]->m_iRewardGold += iDice(1, (iGetExpLevel(m_pClientList[iClientH]->m_iExp)));
				if (m_pClientList[iAttackerH]->m_iRewardGold > DEF_MAXREWARDGOLD) 
					m_pClientList[iAttackerH]->m_iRewardGold = DEF_MAXREWARDGOLD;
				if (m_pClientList[iAttackerH]->m_iRewardGold < 0) 
					m_pClientList[iAttackerH]->m_iRewardGold = 0;
			}
		}
		
		// ÀûÀ» Àâ¾Ò´Ù´Â ¸Þ½ÃÁö º¸³¿ 
		SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_ENEMYKILLREWARD, iClientH, NULL, NULL, NULL);
		
		if (bCheckLimitedUser(iAttackerH) == FALSE) {
			// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
			SendNotifyMsg(NULL, iAttackerH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
		}
		// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
		bCheckLevelUp(iAttackerH);
		
		//v1.4 ±³Àü¿¡¼­ ÀÌ±ä Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
		m_stCityStatus[m_pClientList[iAttackerH]->m_cSide].iWins++;
	}
}

void CGame::ApplyCombatKilledPenalty(int iClientH, char cPenaltyLevel, BOOL bIsSAattacked)
{  
 int iExp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	// Crusade
	if (m_bIsCrusadeMode == TRUE) {
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÎ °æ¿ì ÀüÀïÁß¿¡ Á×¾îµµ ¾Æ¹«·± Æä³ÎÆ¼°¡ ¾ø´Ù.
		// PKcount¸¸ °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) 
			m_pClientList[iClientH]->m_iPKCount--;
		return;
	}
	else {
		// PKcount °¨¼Ò 
		if (m_pClientList[iClientH]->m_iPKCount > 0) 
			m_pClientList[iClientH]->m_iPKCount--;

		// ÇÃ·¹ÀÌ¾î·ÎºÎÅÍÀÇ °ø°ÝÀ» ¹Þ°í ÀüÀïÁß »ç¸ÁÇß´Ù.
		iExp = iDice(1, (5*cPenaltyLevel*m_pClientList[iClientH]->m_iLevel));

		// Áß¸³ÀÎ °æ¿ì Á×¾úÀ» ¶§ ¶³¾îÁö´Â °æÇèÄ¡´Â 1/3
		if (m_pClientList[iClientH]->m_bIsNeutral == TRUE) iExp = iExp / 3;

		m_pClientList[iClientH]->m_iExp -= iExp;
		if (m_pClientList[iClientH]->m_iExp < 0) m_pClientList[iClientH]->m_iExp = 0;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	
		// v1.41 Áß¸³Àº ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_bIsNeutral != TRUE) {
			if (m_pClientList[iClientH]->m_iLevel < 50) {
				// ·¹º§ 50 ¹Ì¸¸Àº ¾ÆÀÌÅÛÀÌ ÇÏ³ª Àû°Ô ¶³¾îÁø´Ù.
				cPenaltyLevel--;
				if (cPenaltyLevel <= 0) cPenaltyLevel = 1;
				_PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
			}
			else _PenaltyItemDrop(iClientH, cPenaltyLevel, bIsSAattacked);
		}
	}
}


void CGame::_PenaltyItemDrop(int iClientH, int iTotal, BOOL bIsSAattacked)
{
 register int i, j, iRemainItem;
 char cItemIndexList[DEF_MAXITEMS], cItemIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((m_pClientList[iClientH]->m_iAlterItemDropIndex != -1) && (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex] != NULL)) {
		// ´ëÃ¼ÀûÀ¸·Î ¶³¾îÁö´Â ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é ´Ù¸¥ ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê°í ÀÌ ¾ÆÀÌÅÛ¸¸ ¶³¾îÁø´Ù. 
		if (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan > 0)
			m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_wCurLifeSpan--;

		DropItemHandler(iClientH, m_pClientList[iClientH]->m_iAlterItemDropIndex, -1, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_iAlterItemDropIndex]->m_cName);
		return;
	}

	for (i = 1; i <= iTotal; i++) {
		iRemainItem = 0;
		ZeroMemory(cItemIndexList, sizeof(cItemIndexList));
		
		for (j = 0; j < DEF_MAXITEMS; j++) 
		if (m_pClientList[iClientH]->m_pItemList[j] != NULL) {
			cItemIndexList[iRemainItem] = j;
			iRemainItem++;
		}
		
		if (iRemainItem == 0) return;
		cItemIndex = cItemIndexList[ iDice(1, iRemainItem) - 1 ];
		
		if ((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectType != 0) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
			(m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3)) {
			// °³ÀÎ¿¡°Ô ¼ÓÇÑ ¾ÆÀÌÅÛÀ¸·Î ¶³¾îÁöÁö ¾Ê´Â´Ù. ¸ÁÅä°°Àº °³ÀÎ¿ë ¾ÆÀÌÅÛ 
		}
		else if (((m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY) ||
			     (m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY)) &&
			     (bIsSAattacked == FALSE)) {
			// Æ¯¼ö ´É·ÂÀ» °¡Áø ¾ÆÀÌÅÛÀÌ Æ¯¼ö °ø°ÝÀ» ¹ÞÀº°Ô ¾Æ´Ï¶ó¸é ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}
		else if ((m_pClientList[iClientH]->m_bIsLuckyEffect == TRUE) && (iDice(1,10) == 5)) {
			// Ä³¸¯ÅÍ¿¡°Ô Çà¿îÈ¿°ú°¡ ÀÖÀ¸¸é 10% È®·ü·Î ¾ÆÀÌÅÛÀÌ ¶³¾îÁöÁö ¾Ê´Â´Ù.
		}
		else DropItemHandler(iClientH, cItemIndex, -1, m_pClientList[iClientH]->m_pItemList[cItemIndex]->m_cName);
	}
}

void CGame::GetRewardMoneyHandler(int iClientH)		    
{
 int iRet, iEraseReq, iWeightLeft, iRewardGoldLeft;
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cData[100], cItemName[21];
 class CItem * pItem;
 short * sp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	
	// ³²Àº Áß·®À» °è»êÇÑ´Ù. 
	iWeightLeft = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
		
	if (iWeightLeft <= 0) return;
	// Áß·®À» ¹ÝÀ¸·Î ³ª´«´Ù. <- Ã£Àº µ·À¸·Î ¾ÆÀÌÅÛÀ» »ì °ø°£Àº ¸¶·ÃÇØ µÖ¾ß ÇÏ¹Ç·Î.
	iWeightLeft = iWeightLeft / 2;
	if (iWeightLeft <= 0) return;

	pItem = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItem, cItemName);
	//pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
	
	// (iWeightLeft / pItem->m_wWeight)°¡ ÃÖ´ë ¹ÞÀ» ¼ö ÀÖ´Â Gold°¹¼ö. °®°íÀÖ´Â Æ÷»ó±Ý°ú ºñ±³ÇÑ´Ù. 
	if ((iWeightLeft / iGetItemWeight(pItem, 1)) >= m_pClientList[iClientH]->m_iRewardGold) {
		// Æ÷»ó±ÝÀ» ¸ðµÎ ¹ÞÀ» ¼ö ÀÖ´Ù. 
		pItem->m_dwCount = m_pClientList[iClientH]->m_iRewardGold;
		iRewardGoldLeft = 0;
	}
	else {
		// (iWeightLeft / pItem->m_wWeight)¸¸ ¹Þ´Â´Ù.
		pItem->m_dwCount = (iWeightLeft / iGetItemWeight(pItem, 1));
		iRewardGoldLeft = m_pClientList[iClientH]->m_iRewardGold - (iWeightLeft / iGetItemWeight(pItem, 1));
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		
		// ³²Àº Æ÷»ó±Ý ³»¿ª °è»ê.
		m_pClientList[iClientH]->m_iRewardGold = iRewardGoldLeft;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;

		*cp = pItem->m_cGenderLimit;
		cp++;

		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/

		if (iEraseReq == 1) delete pItem;
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
						
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}

		// ±× ´ÙÀ½ ³²Àº Æ÷»ó±ÝÀ» ¾Ë·ÁÁØ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REWARDGOLD, NULL, NULL, NULL, NULL);
	}
	else {
		// ¹ÞÀ» ¼ö ¾ø´Â °æ¿ì´Â ¾Æ¹«·± Ã³¸®¸¦ ÇÏÁö ¾Ê´Â´Ù. 

	}
}


int CGame::_iCalcMaxLoad(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return 0;

	return (m_pClientList[iClientH]->m_iStr * 500 + m_pClientList[iClientH]->m_iLevel*500);
}

int CGame::iAddDynamicObjectList(short sOwner, char cOwnerType, short sType, char cMapIndex, short sX, short sY, DWORD dwLastTime, int iV1)
{
 register int i;
 short sPreType;
 DWORD dwTime, dwRegisterTime;

	// ¸¸¾à ÀÌ¹Ì À§Ä¡¿¡ °´Ã¼°¡ Á¸ÀçÇÏ¸é »ý¼ºÇÒ ¼ö ¾ø´Ù.
	m_pMapList[cMapIndex]->bGetDynamicObject(sX, sY, &sPreType, &dwRegisterTime);
	if (sPreType != NULL) return NULL;

	// ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®ÀÇ Á¾·ù¿¡ µû¶ó ³õÀ» ¼ö ÀÖ´Â ¿©ºÎ¸¦ ÆÇº°ÇÑ´Ù. 
	switch (sType) {	
	case DEF_DYNAMICOBJECT_FIRE:
		if (m_pMapList[cMapIndex]->bGetIsMoveAllowedTile(sX, sY) == FALSE)
			return NULL;
		// ºñ°¡ ¿Â´Ù°Å³ª ÇÏ´Â ÀÏÀÌ ÀÖÀ¸¸é Áö¼Ó ½Ã°£ÀÌ ÁÙ¾îµç´Ù.
		if (dwLastTime != NULL)  {
			switch (m_pMapList[cMapIndex]->m_cWhetherStatus) {
			case 1:	dwLastTime = dwLastTime - (dwLastTime / 2);       break;
			case 2:	dwLastTime = (dwLastTime / 2) - (dwLastTime / 3); break;
			case 3:	dwLastTime = (dwLastTime / 3) - (dwLastTime / 4); break;
			}

			// °á°ú°¡ 0ÀÌ¶ó¸é ÃÖ¼ÒÇÑÀÇ °ªÀ» ³Ö¾îÁØ´Ù.
			if (dwLastTime == NULL) dwLastTime = 1000;
		}
		break;
	
	case DEF_DYNAMICOBJECT_FISHOBJECT:
	case DEF_DYNAMICOBJECT_FISH:
		if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE)
			return NULL;
		break;

	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		if (m_pMapList[cMapIndex]->bGetMoveable(sX, sY) == FALSE)
			return NULL;
		// ±¤¹°ÀÌ ÀÖ´Â °÷Àº ÀÓ½Ã·Î °¥ ¼ö ¾ø´Ù. ±¤¹°ÀÌ »ç¶óÁö¸é ÇØÁ¦½ÃÄÑÁà¾ß ÇÑ´Ù. 
		m_pMapList[cMapIndex]->SetTempMoveAllowedFlag(sX, sY, FALSE);
		break;
	}
   	
	// »õ·Î µî·ÏÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] == NULL) {
		// ºó°ø°£À» Ã£¾Ò´Ù.
		dwTime = timeGetTime();
		
		if (dwLastTime != NULL) 
			dwLastTime += (iDice(1,4)*1000);

		m_pDynamicObjectList[i] = new class CDynamicObject(sOwner, cOwnerType, sType, cMapIndex, sX, sY, dwTime, dwLastTime, iV1);
		// ¸®½ºÆ®¿¡ µî·ÏÇßÀ¸¹Ç·Î ÀÌÁ¦ ¸Ê¿¡ µî·ÏÇÏ°í ÀÎÁ¢ÇÑ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô µ¿Àû°´Ã¼ ¹ß»ýÀ» ¾Ë¸°´Ù.
		m_pMapList[cMapIndex]->SetDynamicObject(i, sType, sX, sY, dwTime);
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_CONFIRM, cMapIndex, sX, sY, sType, i, NULL);

		return i;	// Dynamic Object handleÀ» ¹ÝÈ¯ÇÑ´Ù.
	}

	return NULL;
}

void CGame::CheckDynamicObjectList()
{
 register int i;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
 short sType;

	// ³¯¾¾ È¿°ú¿¡ µû¸¥ µ¿Àû °´Ã¼ÀÇ Áö¼Ó½Ã°£ ´ÜÃàÀ» °è»êÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) ) {
		
			switch (m_pDynamicObjectList[i]->m_sType) {
			case DEF_DYNAMICOBJECT_FIRE:
				// ºÒÀÇ °æ¿ì ºñ°¡ ¿ÈÀ¸·Î ÀÎÇØ ¼ö¸íÀÌ ±Þ°ÝÈ÷ ´ÜÃàµÈ´Ù.
				switch (m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus) {
				case 0: break;
				case 1: 
				case 2:
				case 3:
					// (³²Àº ½Ã°£/10)*ºñ¿À´Â »óÅÂ ¸¸Å­ ½Ã°£À» »«´Ù.
					m_pDynamicObjectList[i]->m_dwLastTime = m_pDynamicObjectList[i]->m_dwLastTime - 
						                                    (m_pDynamicObjectList[i]->m_dwLastTime/10) * m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->m_cWhetherStatus;
					break;
				}
				break;
			}
		}
	}

	// ½Ã°£ÀÌ ¸¸·áµÈ °´Ã¼¸¦ Á¾·á½ÃÅ²´Ù. Áö¼Ó½Ã°£ÀÌ NULLÀÌ¸é ¿µ¿øÈ÷ ³²¾ÆÀÖ´Â µ¿Àû °´Ã¼ÀÌ´Ù.
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) { 
		if ( (m_pDynamicObjectList[i] != NULL) && (m_pDynamicObjectList[i]->m_dwLastTime != NULL) && 
			 ((dwTime - m_pDynamicObjectList[i]->m_dwRegisterTime) >= m_pDynamicObjectList[i]->m_dwLastTime) ) {
		
			// Áö¼Ó½Ã°£ÀÌ °æ°úÇÑ µ¿Àû °´Ã¼¸¦ Ã£¾Ò´Ù.
			m_pMapList[ m_pDynamicObjectList[i]->m_cMapIndex ]->bGetDynamicObject( m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, &sType, &dwRegisterTime );
			// µî·Ï½Ã°£ÀÌ ÀÏÄ¡ÇÑ´Ù¸é °´Ã¼°¡ »ç¶óÁø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³»Áà¾ß ÇÑ´Ù.
			
			if (dwRegisterTime == m_pDynamicObjectList[i]->m_dwRegisterTime) {
				SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, m_pDynamicObjectList[i]->m_sType, i, NULL);
				// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY, dwTime);
			}

			switch (sType) {
			case DEF_DYNAMICOBJECT_FISHOBJECT:
			case DEF_DYNAMICOBJECT_FISH:
				// ¹°°í±â ¿ÀºêÁ§Æ®°¡ »ç¶óÁ³À¸¹Ç·Î Ã³¸®ÇÑ´Ù.
				bDeleteFish(m_pDynamicObjectList[i]->m_sOwner, 2); // ½Ã°£ÀÌ Áö³ª¼­ ¹°°í±â°¡ »ç¶óÁø´Ù.
				break;
			}
	
			// ¸®½ºÆ®¸¦ »èÁ¦ÇÑ´Ù.
			delete m_pDynamicObjectList[i];
			m_pDynamicObjectList[i] = NULL;
		}
	}
}

void CGame::CalculateSSN_ItemIndex(int iClientH, short sWeaponIndex, int iValue)
{
 short sSkillIndex;
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_pItemList[sWeaponIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	
	sSkillIndex = m_pClientList[iClientH]->m_pItemList[sWeaponIndex]->m_sRelatedSkill;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	// ½ºÅ³ ¼öÁØÀÌ 0ÀÌ¶ó¸é Ä«¿îÆ®°¡ ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue * 100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		 (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.
		
		switch (sSkillIndex) {
		case 0:
		case 2:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// ¸¶¹ý ÀúÇ×ÀÇ ÃÖ´ëÄ¡´Â Level*2
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21: // ÁöÆÎÀÌ °ø°Ý 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // µ¶¼º ÀúÇ× 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
	 		
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 600À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}


void CGame::CalculateSSN_SkillIndex(int iClientH, short sSkillIndex, int iValue)
{
 int   iOldSSN, iSSNpoint, iWeaponIndex;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sSkillIndex < 0) || (sSkillIndex >= DEF_MAXSKILLTYPE)) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// ±â¼ú ¼öÁØÀÌ 0ÀÌ¶ó¸é ½ºÅ³Àº ¿À¸£Áö ¾Ê´Â´Ù.
	if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] == 0) return;

#ifdef DEF_TESTSERVER
	iValue = iValue *100;
#endif

	iOldSSN = m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex];
	m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] += iValue;
	
	iSSNpoint = m_iSkillSSNpoint[ m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]+1 ];

	// ¸¸¾à SkillSSNÀÌ Á¦ÇÑÄ¡¸¦ ³Ñ¾î¼¹´Ù¸é Skill°ªÀÌ Áõ°¡ÇÑ´Ù. 
	if ( (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] < 100) &&
		(m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] > iSSNpoint) ) {
		
		// ½ºÅ³ÀÌ ¿Ã¶ú´Ù.
		m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]++; 
		// Æ¯¼ºÄ¡ Á¦ÇÑÀÌ ÀÖ´Â SkillÀ» Ã³¸®ÇÑ´Ù.
		switch (sSkillIndex) {
		case 0:
		case 2:
		case 5:
		case 13:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iStr * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 3:
			// ¸¶¹ý ÀúÇ×Àº ÃÖ´ë Level*2¸¸Å­ ¿À¸¥´Ù.
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iLevel * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 4:
		case 21:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iMag * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 1:
		case 6:
		case 7:
		case 8:
		case 9:
		case 10:
		case 11:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iDex * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 12:
		case 14:
		case 15:
		case 19:
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iInt * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		case 23: // µ¶¼º ÀúÇ× 
			if (m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex] > (m_pClientList[iClientH]->m_iVit * 2)) {
				// Á¦ÇÑÄ¡º¸´Ù Ä¿Á³´Ù. ¹«È¿ÀÌ¹Ç·Î ÀÌÀü»óÅÂ·Î µÇµ¹¸°´Ù.
				m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = iOldSSN;
			}
			else m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;

		default:
			m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] = 0;
			break;
		}
		
		// ¸¸¾à ¹«±â¿Í °ü·ÃÀÖ´Â ½ºÅ³ÀÌ ¿Ã¶ú°í ÇöÀç ±× ¹«±â¸¦ »ç¿ë ÁßÀÌ¶ó¸é ÇöÀç ¸íÁß·ü¿¡ 1À» ´õÇÑ´Ù. 
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// Ä«¿îÆ®°¡ 0ÀÌ¸é ½ºÅ³ÀÌ Á¤»óÀûÀ¸·Î ¿Ã¶ú´Ù´Â ÀÇ¹Ì. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ »ó½ÂÀÌ¾ú´Ù. ¸íÁß·üÀ» 1 ¿Ã¸°´Ù. 
					m_pClientList[iClientH]->m_iHitRatio++;
				}
			}
		}
			
		if (m_pClientList[iClientH]->m_iSkillSSN[sSkillIndex] == 0) {
			// SKillÀÇ ÃÑÇÕÀÌ 700À» ³ÑÀ¸¸é ´Ù¸¥ ½ºÅ³Áß ÇÏ³ª¸¦ 1 ³»¸°´Ù. 
			bCheckTotalSkillMasteryPoints(iClientH, sSkillIndex);
		
			// SkillÀÌ ¿Ã¶ú´Ù´Â °ÍÀ» Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sSkillIndex], NULL, NULL);
		}
	}
}

void CGame::MobGenerator()
{
 register int i, j, iNamingValue, iResult, iTotalMob;
 char cNpcName[21], cName_Master[11], cName_Slave[11], cWaypoint[11];
 char cSA;
 int  pX, pY, iMapLevel, iProbSA, iKindSA, iResultNum, iMin;
 BOOL bMaster, bFirmBerserk, bIsSpecialEvent;
 double dV1, dV2, dV3;
 
	if (m_bOnExitProcess == TRUE) return;
	
	for (i = 0; i < DEF_MAXMAPS; i++) {
		// Random Mob Generator
		
		/*
		iResultNum = 0;
		// v1.432 월드 서버의 총 사용자 수에 비례하여 최대 오브젝트 수를 결정한다. 1000명 이상이면 100%  최소 50%
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE)) {
			// 사용자 수에 비례하여 랜덤 몹 갯수 보정.
			if (m_iTotalGameServerClients >= 1000) {
				iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			}
			else {
				dV2 = (double)m_iTotalGameServerClients;
				dV3 = (m_pMapList[i]->m_iMaximumObject - 30);

				dV1 = (dV2 / 1000.0f)*dV3;
				iResultNum = (int)dV1;
			}

			// v1.432 숫자 보정
			iMin = (m_pMapList[i]->m_iMaximumObject - 30) - ((m_pMapList[i]->m_iMaximumObject - 30)/3);
			if (iResultNum > (m_pMapList[i]->m_iMaximumObject - 30)) iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			if (iResultNum < iMin) iResultNum = iMin;
		}
		*/

		//if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && 
		//	 ((m_pMapList[i]->m_iMaximumObject - 30) > m_pMapList[i]->m_iTotalActiveObject) ) {

		// 크루세이드 모드일때는 평소의 30% 수준으로 몬스터가 생성된다.
		if (m_pMapList[i] != NULL) {
			//if (m_bIsCrusadeMode == TRUE) 
			//	 iResultNum = (m_pMapList[i]->m_iMaximumObject - 30) / 3;
			//else iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
			iResultNum = (m_pMapList[i]->m_iMaximumObject - 30);
		}
				
		if ( (m_pMapList[i] != NULL) && (m_pMapList[i]->m_bRandomMobGenerator == TRUE) && (iResultNum > m_pMapList[i]->m_iTotalActiveObject) ) {
			// i번째 맵에 몹을 생성할 조건이 만족되었다.
			
			// Crusade : 전면전 모드일때 미들랜드 몹 생산 중단.
			if ((m_iMiddlelandMapIndex != -1) && (m_iMiddlelandMapIndex == i) && (m_bIsCrusadeMode == TRUE)) break;
			
			iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
			if (iNamingValue != -1) {
				// Master Mob을 생성한다.
				ZeroMemory(cName_Master, sizeof(cName_Master));
				wsprintf(cName_Master, "XX%d", iNamingValue);
				cName_Master[0] = '_';
				cName_Master[1] = i + 65;
			
				ZeroMemory(cNpcName, sizeof(cNpcName));
			
				bFirmBerserk = FALSE;
				iResult = iDice(1,100);
				// 몹 제네레이터의 레벨 
				switch (m_pMapList[i]->m_cRandomMobGeneratorLevel) {
				case 1:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 3;
					iMapLevel = 1;
					break;

				case 2:
					if ((iResult >= 1) && (iResult < 40)) {
						iResult = 1;
					}
					else if ((iResult >= 40) && (iResult < 80)) {
						iResult = 2;
					}
					else iResult = 10;
					iMapLevel = 1;
					break;

				case 3:     // v1.4334 몹제너레이터 변경
					if ((iResult >= 1) && (iResult < 25)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 25) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 75)) {
						switch ( iDice(1,5) ) {	
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						case 5: iResult = 18; break;
						}
						
					}
					else if ((iResult >= 75) && (iResult <= 100)) {
						switch ( iDice(1,4) ) {
						case 1:
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						}
					}
					iMapLevel = 4;
					break;

				case 4:
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 2; break;
						case 2: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 14; break;
						case 2:	iResult = 9; break;
						}
					}
					iMapLevel = 2;
					break;

				case 5:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 14; break;
						case 3: iResult = 9; break;
						}
					}
					iMapLevel = 3;
					break;

				case 6:
					if ((iResult >= 1) && (iResult < 60)) {
						switch ( iDice(1,4) ) {
						case 1: iResult = 5; break;
						case 2:	iResult = 6; break;
						case 3: iResult = 7; break;
						case 4: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 95)) {
						switch ( iDice(1,4) ) {
						case 1:
						case 2: iResult = 8;  break;
						case 3:	iResult = 11; break;
						case 4:	iResult = 12; break;
						}
						
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2:	iResult = 9;  break;
						case 3:	iResult = 13; break;
						case 4: iResult = 14; break;
						case 5: iResult = 18; break;
						}
					}
					iMapLevel = 4;
					break;

				case 7:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,4) ) {
						case 1:	iResult = 1;  break;
						case 2: iResult = 2;  break;
						case 3: iResult = 10; break;
						case 4: iResult = 3;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch ( iDice(1,4) ) {
						case 1:
						case 2:
						case 3: iResult = 6;  break;
						case 4: iResult = 12; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 12; break;
						case 2: iResult = 2;  break;
						case 3: 
							if (iDice(1,100) == 13) 
								 iResult = 17;
							else iResult = 12;
							break;
						}
					}
					iMapLevel = 4;
					break;

				case 8:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 90)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 11; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 90) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 9;  break;
						case 2: iResult = 14; break;
						}
					}
					iMapLevel = 4;
					break;

				case 9:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4;  break;
						case 2: iResult = 5;  break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 8;  break;
						case 2: iResult = 9;  break;
						case 3: iResult = 13; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch ( iDice(1,6) ) {
						case 1:
						case 2:
						case 3: iResult = 9;  break;
						case 4:
						case 5: iResult = 14; break;
						case 6: iResult = 15; break;
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;
					
					iMapLevel = 4;
					break;

				case 10:
					if ((iResult >= 1) && (iResult < 70)) {
						switch ( iDice(1,2) ) {
						case 1:	iResult = 4; break;
						case 2: iResult = 5; break;
						}
					}
					else if ((iResult >= 70) && (iResult < 95)) {
						// 
						switch ( iDice(1,3) ) {
						case 1:
						case 2:	iResult = 13; break;
						case 3: iResult = 14; break;
						}
					}
					else if ((iResult >= 95) && (iResult < 100)) {
						switch (iDice(1,3)) {
						case 1:
						case 2: iResult = 14; break;
						case 3: iResult = 15; break;
						}
					}

					// Demon은 Berserk 상태가 되지 않는다.
					if ((iDice(1,3) == 1) && (iResult != 16)) bFirmBerserk = TRUE;

					iMapLevel = 5;
					break;

				case 11:
					if ((iResult >= 1) && (iResult < 30)) {
						switch ( iDice(1,5) ) {
						case 1:
						case 2: 
						case 3:
						case 4: 
						case 5: iResult = 2; break;
						}
					}
					else if ((iResult >= 30) && (iResult < 60)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 3; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 60) && (iResult < 80)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 7; break;
						}
					}
					else if ((iResult >= 80) && (iResult < 95)) {
						switch ( iDice(1,3) ) {
						case 1:
						case 2: iResult = 10;  break;
						case 3:	iResult = 11; break;
						}
					}
					else if ((iResult >= 95) && (iResult <= 100)) {
						switch ( iDice(1,3) ) {
						case 1: iResult = 11; break;
						case 2: iResult = 7; break;
						case 3: iResult = 8; break;
						}
					}
					iMapLevel = 3;
					break;

				case 12:
					if ((iResult >= 1) && (iResult < 50)) {
						switch ( iDice(1,3) ) {
						case 1:	iResult = 1 ; break;
						case 2: iResult = 2 ; break;
						case 3: iResult = 10; break;
						}
					}
					else if ((iResult >= 50) && (iResult < 85)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 5; break;
						case 2: iResult = 4; break;
						}
					}
					else if ((iResult >= 85) && (iResult < 100)) {
						switch ( iDice(1,2) ) {
						case 1: iResult = 8; break;
						case 2: iResult = 11; break;
						}
					}
					iMapLevel = 2;
					break;
				}

				pX = NULL;
				pY = NULL;
				
				// Special Event. 여러 맵중 랜덤한 맵이 걸리도록 주사위를 굴려야만 한다.
				bIsSpecialEvent = FALSE;
				if ((m_bIsSpecialEventTime == TRUE) && (iDice(1,10) == 3)) bIsSpecialEvent = TRUE;

				if (bIsSpecialEvent == TRUE) {
					switch (m_cSpecialEventType) {
					case 1:
						// 몹 이벤트. 현재 맵에서 가장 플레이어가 많은 곳에 뿌린다.
						if (m_pMapList[i]->m_iMaxPx != 0) {
							pX = m_pMapList[i]->m_iMaxPx*20 +10;
							pY = m_pMapList[i]->m_iMaxPy*20 +10;

							if (pX < 0) pX = 0;
							if (pY < 0) pY = 0;

							if (m_bIsCrusadeMode == TRUE) {
								// 크루세이드 모드인 경우 적국에 용병을 소환 
								if (strcmp(m_pMapList[i]->m_cName, "aresden") == 0)
									iResult = 20;
								else if (strcmp(m_pMapList[i]->m_cName, "elvine") == 0)
									iResult = 19;
							}
							
							wsprintf(G_cTxt, "(!) Mob-Event Map(%s) Loc(%d,%d)", m_pMapList[i]->m_cName, pX, pY);
							PutLogList(G_cTxt);
						}
						break;
					
					case 2:
						// 데몬 혹은 유니콘을 생성 
						if (iDice(1,3) == 2) {
							// 셋중 한번은 데몬이 생성된다.
							if ((memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7)   == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "middled1n", 9) == 0) ||
								(memcmp(m_pMapList[i]->m_cLocationName, "elvine", 6)    == 0)) {
									// 마을 내에서는 데몬의 출현 가능성을 더 낮춘다. 
								if (iDice(1,20) == 5) 
									 iResult = 16;
								else iResult = 5;
							}
							else iResult = 16;
						}
						else iResult = 17;
						
						// 특별 이벤트 활성화 프래그 비활성화 
						m_bIsSpecialEventTime = FALSE;
						break;
					}
				}
				
				ZeroMemory(cNpcName, sizeof(cNpcName));
				//Random Monster Spawns
				switch (iResult) {
				case 1:  strcpy(cNpcName, "Slime");				iProbSA = 5;  iKindSA = 1; break;
				case 2:  strcpy(cNpcName, "Giant-Ant");			iProbSA = 10; iKindSA = 2; break;
				case 3:  strcpy(cNpcName, "Orc");				iProbSA = 15; iKindSA = 1; break;
				case 4:  strcpy(cNpcName, "Zombie");			iProbSA = 15; iKindSA = 3; break;
				case 5:  strcpy(cNpcName, "Skeleton");			iProbSA = 35; iKindSA = 8; break;
				case 6:  strcpy(cNpcName, "Orc-Mage");			iProbSA = 30; iKindSA = 7; break;
				case 7:  strcpy(cNpcName, "Scorpion");			iProbSA = 15; iKindSA = 3; break;
				case 8:  strcpy(cNpcName, "Stone-Golem");		iProbSA = 25; iKindSA = 5; break;
				case 9:  strcpy(cNpcName, "Cyclops");			iProbSA = 35; iKindSA = 8; break;
				case 10: strcpy(cNpcName, "Amphis");			iProbSA = 20; iKindSA = 3; break;
				case 11: strcpy(cNpcName, "Clay-Golem");		iProbSA = 20; iKindSA = 5; break;
				case 12: strcpy(cNpcName, "Orge");				iProbSA = 25; iKindSA = 1; break;
				case 13: strcpy(cNpcName, "Hellbound");			iProbSA = 25; iKindSA = 8; break;
				case 14: strcpy(cNpcName, "Liche");				iProbSA = 30; iKindSA = 8; break;
				case 15: strcpy(cNpcName, "Demon");				iProbSA = 20; iKindSA = 8; break;
				case 16: strcpy(cNpcName, "Unicorn");			iProbSA = 35; iKindSA = 7; break;
				case 17: strcpy(cNpcName, "WereWolf");			iProbSA = 25; iKindSA = 1; break;
				case 18: strcpy(cNpcName, "YB-Aresden");		iProbSA = 15; iKindSA = 1; break;
				case 19: strcpy(cNpcName, "YB-Elvine");			iProbSA = 15; iKindSA = 1; break;
				case 20: strcpy(cNpcName, "Troll");				iProbSA = 25; iKindSA = 3; break; 
				case 21: strcpy(cNpcName, "Stalker");           iProbSA = 15; iKindSA = 1;  break;
				case 22: strcpy(cNpcName, "Mountain-Giant");	iProbSA = 15; iKindSA = 1;  break;
				case 23: strcpy(cNpcName, "Giant-Frog");		iProbSA = 15; iKindSA = 6;  break;
				case 24: strcpy(cNpcName, "Cannibal-Plant");	iProbSA = 15; iKindSA = 5;  break;
				case 25: strcpy(cNpcName, "Beholder");			iProbSA = 15; iKindSA = 7;  break;
				case 26: strcpy(cNpcName, "Dark-Elf");			iProbSA = 20; iKindSA = 2;  break;
				case 27: strcpy(cNpcName, "Rabbit");			iProbSA = 15; iKindSA = 1;  break;
				case 28: strcpy(cNpcName, "Cat");				iProbSA = 15; iKindSA = 6;  break;
				case 29: strcpy(cNpcName, "Ettin");				iProbSA = 15; iKindSA = 6;  break;
				case 30: strcpy(cNpcName, "Gagoyle");			iProbSA = 15; iKindSA = 9;  break;
				case 31: strcpy(cNpcName, "Rudolph");			iProbSA = 15; iKindSA = 1;  break;
				case 32: strcpy(cNpcName, "Frost");				iProbSA = 0;  iKindSA = 1;  break;
				case 33: strcpy(cNpcName, "DireBoar");			iProbSA = 15; iKindSA = 1;  break;
				case 34: strcpy(cNpcName, "Ice");				iProbSA = 15; iKindSA = 1;  break;
				case 35: strcpy(cNpcName, "Wyvern");			iProbSA = 15; iKindSA = 9;  break;
				case 36: strcpy(cNpcName, "Barlog");			iProbSA = 10; iKindSA = 1;  break;
				case 37: strcpy(cNpcName, "Centaurus");			iProbSA = 15; iKindSA = 10; break;
				case 38: strcpy(cNpcName, "Claw-Turtle");		iProbSA = 15; iKindSA = 1;  break;
				case 39: strcpy(cNpcName, "Fire-Wyvern");		iProbSA = 10; iKindSA = 10; break;
				case 40: strcpy(cNpcName, "Giant-Cray-Fish");	iProbSA = 5;  iKindSA = 1;  break;
				case 41: strcpy(cNpcName, "Lizard");			iProbSA = 5;  iKindSA = 1;  break;
				case 42: strcpy(cNpcName, "Giant-Plant");		iProbSA = 100; iKindSA = 1;  break;
				case 43: strcpy(cNpcName, "Master-Mage-Orc");	iProbSA = 10; iKindSA = 9;  break;
				case 44: strcpy(cNpcName, "Minotaurus");		iProbSA = 10; iKindSA = 5;  break;
				case 45: strcpy(cNpcName, "Nizie");				iProbSA = 10; iKindSA = 10; break;
				case 46: strcpy(cNpcName, "Tentocle");			iProbSA = 10; iKindSA = 10; break;
				case 47: strcpy(cNpcName, "Abaddon");			iProbSA = 10; iKindSA = 9;  break;
				default: strcpy(cNpcName, "Orc");				iProbSA = 15; iKindSA = 1; break;
				}

				// v1.411 몬스터의 특수 특성치를 입력한다. 
				cSA = 0;
				if (iDice(1,100) <= iProbSA) {
					cSA = _cGetSpecialAbility(iKindSA);
				}
								
				if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk, TRUE)) == FALSE) {
					// 실패했으므로 예약된 NameValue를 해제시킨다.
					m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
				}
				else {
					
				}
			}	
			
			// 처음 생성된 몹의 종류에 따른 생성 갯수를 계산한다.
			switch (iResult) {
			case 1:	 iTotalMob = iDice(1,5)-1; break;
			case 2:	 iTotalMob = iDice(1,5)-1; break;
			case 3:	 iTotalMob = iDice(1,5)-1; break;
			case 4:	 iTotalMob = iDice(1,3)-1; break;
			case 5:	 iTotalMob = iDice(1,3)-1; break;
			case 6:  iTotalMob = iDice(1,3)-1; break;
			case 7:  iTotalMob = iDice(1,3)-1; break;
			case 8:  iTotalMob = iDice(1,2)-1; break;
			case 9:  iTotalMob = iDice(1,2)-1; break;
			case 10: iTotalMob = iDice(1,5)-1; break;
			case 11: iTotalMob = iDice(1,3)-1; break;
			case 12: iTotalMob = iDice(1,5)-1; break;
			case 13: iTotalMob = iDice(1,3)-1; break;
			case 14: iTotalMob = iDice(1,3)-1; break;
			case 15: iTotalMob = iDice(1,3)-1; break;
			case 16: iTotalMob = iDice(1,2)-1; break;
			case 17: iTotalMob = iDice(1,2)-1; break;
			case 18: iTotalMob = iDice(1,5)-1; break;
			case 19: iTotalMob = iDice(1,5)-1; break;
			case 20: iTotalMob = iDice(1,5)-1; break;
			case 21: iTotalMob = iDice(1,5)-1; break;
			case 22: iTotalMob = iDice(1,5)-1; break;
			case 23: iTotalMob = iDice(1,5)-1; break;
			case 24: iTotalMob = iDice(1,5)-1; break;
			case 25: iTotalMob = iDice(1,5)-1; break;
			case 26: iTotalMob = iDice(1,5)-1; break;
			case 27: iTotalMob = iDice(1,5)-1; break;
			case 28: iTotalMob = iDice(1,5)-1; break;
			case 29: iTotalMob = iDice(1,5)-1; break;
			case 30: iTotalMob = iDice(1,5)-1; break;
			case 31: iTotalMob = iDice(1,5)-1; break;
			case 32: iTotalMob = iDice(1,5)-1; break;
			case 33: iTotalMob = iDice(1,5)-1; break;
			case 34: iTotalMob = iDice(1,5)-1; break;
			case 35: iTotalMob = iDice(1,5)-1; break;
			case 36: iTotalMob = iDice(1,5)-1; break;
			case 37: iTotalMob = iDice(1,5)-1; break;
			case 38: iTotalMob = iDice(1,5)-1; break;
			case 39: iTotalMob = iDice(1,5)-1; break;
			case 40: iTotalMob = iDice(1,5)-1; break;
			case 41: iTotalMob = iDice(1,5)-1; break;
			case 42: iTotalMob = iDice(1,5)-1; break;
			case 43: iTotalMob = iDice(1,5)-1; break;
			case 44: iTotalMob = iDice(1,5)-1; break; 
			case 45: iTotalMob = iDice(1,5)-1; break;
			case 46: iTotalMob = iDice(1,5)-1; break;
			case 47: iTotalMob = iDice(1,5)-1; break;
			default: iTotalMob = 0; break;
			}
			// 마스터를 생성할 수 없었다면 슬레이브도 만들지 않는다. 
			if (bMaster == FALSE) iTotalMob = 0;

			// 1.4 몹이 뭉쳐 나오는 것을 막기 위해서 30% 확률로 마스터만 생성한다.
			//if ((iTotalMob >= 2) && (iDice(1,2) == 1)) iTotalMob = 0;
			
			// v1.432 몬스터의 종류에 따라 무리를 지을 확률이 다르다.
			if (iTotalMob >= 2) {
				switch (iResult) {
				case 1:  // Slime 
				case 2:  // Giant-Ant
				case 3:  // Orc
				case 4:  // Zombie
				case 5:  // Skeleton
				case 7:  // Scorpion
				case 8:  // Stone-Golem
				case 10: // Amphis
				case 11: // Clay-Golem
				case 12: // Troll
				case 13: // Orge
					if (iDice(1,5) != 1) iTotalMob = 0;  // 75% 확률로 혼자 발생.
					break;

				case 9:  // Cyclops
				case 6:  // Orc-Mage
				case 14: // Hellbound
				case 15: // Liche
				case 16: // Demon
				case 17: // Unicorn
				case 18: // WereWolf
				case 19:
				case 20:
				case 21:
				case 22:
				case 23:
				case 24:
				case 25:
				case 26:
				case 27:
				case 28:
				case 29:
				case 30:
				case 31:
				case 32:
				case 33:
				case 34:
				case 35:
				case 36:
				case 37:
				case 38:
				case 39:
				case 40:
				case 41:
				case 42:
				case 43:
				case 44:
				case 45:
				case 46:
				case 47:
					if (iDice(1,5) == 1) iTotalMob = 0;  // 75% 확률로 무리를 짓는다.
					break;
				}
			}
			
			// 만약 정기정으로 몹을 대량 추가해야 할 시점이라면 슬레이브 갯수를 늘린다. Special Event 1번 
			if (bIsSpecialEvent == TRUE) {
				switch (m_cSpecialEventType) {
				case 1:
					// 몹 이벤트
					if ((iResult != 15) && (iResult != 16)) iTotalMob = 30;
					break;
				
				case 2:
					// 데몬 출몰 
					if ( (memcmp(m_pMapList[i]->m_cLocationName, "aresden", 7) == 0) ||
						 (memcmp(m_pMapList[i]->m_cLocationName, "elvine",  6) == 0) ) {
						// 만약 마을이라면 슬래이브 데몬은 없다.
						iTotalMob = 0;
					}
					break;
				}
				m_bIsSpecialEventTime = FALSE;
			}

			for (j = 0; j < iTotalMob; j++) {
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// Slave Mob들을 생성한다.
					ZeroMemory(cName_Slave, sizeof(cName_Slave));
					wsprintf(cName_Slave, "XX%d", iNamingValue);
					cName_Slave[0] = '_';
					cName_Slave[1] = i + 65;
			
					// v1.411 몬스터의 특수 특성치를 입력한다. 
					cSA = 0;
					if (iDice(1,100) <= iProbSA) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
						// 실패했으므로 예약된 NameValue를 해제시킨다.
						m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
					}
					else {
						// Slave모드로 전환.
						bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
					}
				}
			}
		}
		// random mob generator	^
 
		// spot mob generator 
		if ( (m_pMapList[i] != NULL) && ((m_pMapList[i]->m_iMaximumObject) > m_pMapList[i]->m_iTotalActiveObject) ) {
			for (j = 1; j < DEF_MAXSPOTMOBGENERATOR; j++)
			if ( (iDice(1,3) == 2) && (m_pMapList[i]->m_stSpotMobGenerator[j].bDefined == TRUE) &&
				 (m_pMapList[i]->m_stSpotMobGenerator[j].iMaxMobs > m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs) ) {
				// 데이터가 정의되어 있고 몹을 만들 기회가 됐다.
				iNamingValue = m_pMapList[i]->iGetEmptyNamingValue();
				if (iNamingValue != -1) {
					// 몹을 생성한다.
					
					ZeroMemory(cNpcName, sizeof(cNpcName));
					switch (m_pMapList[i]->m_stSpotMobGenerator[j].iMobType) {
					// 3.51 et al Monster Spawns
					case 6:   strcpy(cNpcName,"Orc-Mage");			iProbSA = 30; iKindSA = 7;  break;
					case 10:  strcpy(cNpcName,"Slime");				iProbSA = 5;  iKindSA = 1;  break;
					case 11:  strcpy(cNpcName,"Skeleton");			iProbSA = 35; iKindSA = 8;  break;
					case 12:  strcpy(cNpcName,"Stone-Golem");		iProbSA = 25; iKindSA = 5;  break;
					case 13:  strcpy(cNpcName,"Cyclops");			iProbSA = 35; iKindSA = 8;  break;
					case 14:  strcpy(cNpcName,"Orc");				iProbSA = 15; iKindSA = 1;  break;
					// 15 ShopKeeper-W
					case 16:  strcpy(cNpcName,"Giant-Ant");			iProbSA = 10; iKindSA = 2;  break;
					case 17:  strcpy(cNpcName,"Scorpion");			iProbSA = 15; iKindSA = 3;  break;
					case 18:  strcpy(cNpcName,"Zombie");			iProbSA = 15; iKindSA = 3;  break;
					// 19 Gandlf          
					// 20 Howard
					// 21 Guard - Aresden, Elvine, and Neutral
					case 22:  strcpy(cNpcName,"Amphis");			iProbSA = 20; iKindSA = 3;  break;
					case 23:  strcpy(cNpcName,"Clay-Golem");		iProbSA = 20; iKindSA = 5;  break;
					case 24:  strcpy(cNpcName,"Guard-Aresden");		iProbSA = 20; iKindSA = 1;  break;
					case 25:  strcpy(cNpcName,"Guard-Elvine");		iProbSA = 20; iKindSA = 1;  break;
					case 26:  strcpy(cNpcName,"Guard-Neutral");		iProbSA = 20; iKindSA = 1;  break;
					case 27:  strcpy(cNpcName,"Hellbound");			iProbSA = 20; iKindSA = 1;  break;
					case 28:  strcpy(cNpcName, "Troll");			iProbSA = 25; iKindSA = 3; break; 
					case 29:  strcpy(cNpcName,"Orge");              iProbSA = 15; iKindSA = 1;  break;
					case 30:  strcpy(cNpcName,"Liche");				iProbSA = 30; iKindSA = 8;  break;
					case 31:  strcpy(cNpcName,"Demon");				iProbSA = 20; iKindSA = 8;  break;
					case 32:  strcpy(cNpcName,"Unicorn");			iProbSA = 35; iKindSA = 7;  break;
					case 33:  strcpy(cNpcName,"WereWolf");			iProbSA = 25; iKindSA = 1;  break;
					case 34:  strcpy(cNpcName,"Dummy");				iProbSA = 5;  iKindSA = 1;  break;
					case 35:  strcpy(cNpcName,"Attack-Dummy");		iProbSA = 5;  iKindSA = 1;  break;
					// 36 Arrow Gaurd Tower Kit - Aresden, Elvine
					// 37 Cannon Gaurd Tower Kit - Aresden, Elvine
					// 38 Mana Collector Kit - Aresden, Elvine
					// 39 Detector Constructor Kit - Aresden, Elvine
					// 40 Energy Shield Generator - Aresden, Elvine
					// 41 Grand Master Generator - Aresden Elvine
					// 42 Mana Stone
					// 43 Light War Beetle - Aresden, Elvine
					// 44 God's Hand Knight
					// 45 Mounted God's Hand Knight
					// 46 Temple Knight
					// 47 Battle Golem
					case 48:  strcpy(cNpcName,"Stalker");			iProbSA = 20; iKindSA = 3;  break;
					case 49:  
						if (iDice(1, 7200) == 135) {
							strcpy(cNpcName,"Hellclaw");
							iProbSA = 20;
							iKindSA = 8;
						}
						else {
							strcpy(cNpcName, "Orc");
							iProbSA = 15;
							iKindSA = 1;
						}
						break;
					
					case 50:  
						if (iDice(1, 7200) == 135) {
							strcpy(cNpcName,"Tigerworm");
							iProbSA = 20;
							iKindSA = 8;
						}
						else {
							strcpy(cNpcName, "Orc");
							iProbSA = 15;
							iKindSA = 1;
						}
						break;
					//51 Catapult
					case 52:  strcpy(cNpcName,"Gagoyle");			iProbSA = 15; iKindSA = 9;  break;
					case 53:  strcpy(cNpcName,"Beholder");			iProbSA = 15; iKindSA = 7;  break;
					case 54:  strcpy(cNpcName,"Dark-Elf");			iProbSA = 20; iKindSA = 2;  break;
					case 55:  strcpy(cNpcName,"Rabbit");			iProbSA = 15; iKindSA = 1;  break;
					case 56:  strcpy(cNpcName,"Cat");				iProbSA = 15; iKindSA = 6;  break;
					case 57:  strcpy(cNpcName,"Giant-Frog");		iProbSA = 15; iKindSA = 6;  break;
					case 58:  strcpy(cNpcName,"Mountain-Giant");	iProbSA = 15; iKindSA = 1;  break;
					case 59:  strcpy(cNpcName,"Ettin");				iProbSA = 15; iKindSA = 6;  break;
					case 60:  strcpy(cNpcName,"Cannibal-Plant");	iProbSA = 15; iKindSA = 5;  break;
					case 61:  strcpy(cNpcName,"Rudolph");			iProbSA = 15; iKindSA = 1;  break;
					case 62:  strcpy(cNpcName,"DireBoar");			iProbSA = 15; iKindSA = 1;  break;
					case 63:  strcpy(cNpcName,"Frost");				iProbSA = 0;  iKindSA = 1;  break;
					// 64 Crops
					case 65:  strcpy(cNpcName,"Ice");				iProbSA = 15; iKindSA = 1;  break;
					case 66:  strcpy(cNpcName,"Wyvern");			iProbSA = 15; iKindSA = 9;  break;
					case 70:  strcpy(cNpcName,"Barlog");			iProbSA = 15; iKindSA = 1;  break;
					case 71:  strcpy(cNpcName,"Centaurus");			iProbSA = 15; iKindSA = 10; break;
					case 72:  strcpy(cNpcName,"Claw-Turtle");		iProbSA = 15; iKindSA = 1;  break;
					case 73:  strcpy(cNpcName,"Fire-Wyvern");		iProbSA = 15; iKindSA = 10; break;
					case 74:  strcpy(cNpcName,"Giant-Cray-Fish");	iProbSA = 15;  iKindSA = 1;  break;
					case 75:  strcpy(cNpcName,"Lizard");			iProbSA = 15;  iKindSA = 1;  break;
					case 76:  strcpy(cNpcName,"Giant-Plant");		iProbSA = 100; iKindSA = 1;  break;
					case 77:  strcpy(cNpcName,"Master-Mage-Orc");	iProbSA = 15; iKindSA = 9;  break;
					case 78:  strcpy(cNpcName,"Minotaurus");		iProbSA = 15; iKindSA = 5;  break;
					case 79:  strcpy(cNpcName,"Nizie");				iProbSA = 15; iKindSA = 10; break;
					case 80:  strcpy(cNpcName,"Tentocle");			iProbSA = 15; iKindSA = 10; break;
					case 81:  						
						if (iDice(1, 7200) == 135) {
							strcpy(cNpcName,"Abaddon");
							iProbSA = 20;
							iKindSA = 8;
						}
						else {
							strcpy(cNpcName, "Orc");
							iProbSA = 15;
							iKindSA = 1;
						}
						break;
					default: 
						strcpy(cNpcName, "Orc");
						iProbSA = 15; 
						iKindSA = 1; 
						break;
					}

					// Spot Mob Generator도 FirmBersek된 몬스터를 생성한다.
					bFirmBerserk = FALSE;
					if ((m_pMapList[i]->m_cRandomMobGeneratorLevel >= 9) && (iDice(1,3) == 1)) bFirmBerserk = TRUE;
					
					ZeroMemory(cName_Master, sizeof(cName_Master));
					wsprintf(cName_Master, "XX%d", iNamingValue);
					cName_Master[0] = '_';
					cName_Master[1] = i + 65;
			
					// v1.411 몬스터의 특수 특성치를 입력한다. 더미인 경우는 특수 특성치 입력 안함.
					cSA = 0;
					if ((m_pMapList[i]->m_stSpotMobGenerator[j].iMobType != 34) && (iDice(1,100) <= iProbSA)) {
						cSA = _cGetSpecialAbility(iKindSA);
					}

					switch (m_pMapList[i]->m_stSpotMobGenerator[j].cType) {
					case 1:
						// RANDOMAREA
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMAREA, &pX, &pY, cWaypoint, &m_pMapList[i]->m_stSpotMobGenerator[j].rcRect, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							//PutLogList("SpotMobGenerator(RANDOMAREA) Fail! Cannot locate mob.");	
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);
						}
						else {
							//wsprintf(G_cTxt, "SpotMobGenerator(RANDOMAREA) - Map:%d TotalActiveObject:%d Mob:%s ", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName );
							//PutLogList(G_cTxt);
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
						}
						break;

					case 2:
						// RANDOMWAYPOINT
						if (bCreateNewNpc(cNpcName, cName_Master, m_pMapList[i]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOMWAYPOINT, NULL, NULL, m_pMapList[i]->m_stSpotMobGenerator[j].cWaypoint, NULL, j, -1, FALSE, FALSE, bFirmBerserk) == FALSE) {
							//PutLogList("SpotMobGenerator(RANDOMWAYPOINT) Fail! Cannot locate mob.");	
							// 실패했으므로 예약된 NameValue를 해제시킨다.
							m_pMapList[i]->SetNamingValueEmpty(iNamingValue);	
						}
						else {
							//wsprintf(G_cTxt, "SpotMobGenerator(RANDOMWAYPOINT) - Map:%d TotalActiveObject:%d Mob:%s (%d %d)", i, m_pMapList[i]->m_iTotalActiveObject, cNpcName, pX, pY);
							//PutLogList(G_cTxt);
							m_pMapList[i]->m_stSpotMobGenerator[j].iCurMobs++;
					  	}
						break;
					}
				}
			}
		}
		// spot mob generator ^
 	}
}






void CGame::CalcNextWayPointDestination(int iNpcH)
{
 short sRange, sX, sY;
 register int i, j, iMapIndex;
 BOOL bFlag;

	switch (m_pNpcList[iNpcH]->m_cMoveType) {
	case DEF_MOVETYPE_GUARD:
		// ÁöÁ¤µÈ À§Ä¡¸¦ ¹þ¾î³ªÁö ¾ÊÀ¸¸ç Ãß°ÝÀÌ ³¡³­ ÈÄ¿¡ µ¹¾Æ¿Â´Ù.
		break;
	
	case DEF_MOVETYPE_SEQWAYPOINT: 

		m_pNpcList[iNpcH]->m_cCurWaypoint++;
		if (m_pNpcList[iNpcH]->m_cCurWaypoint >= m_pNpcList[iNpcH]->m_cTotalWaypoint)
			m_pNpcList[iNpcH]->m_cCurWaypoint = 1;
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMWAYPOINT:
	
		m_pNpcList[iNpcH]->m_cCurWaypoint = (short)((rand() % (m_pNpcList[iNpcH]->m_cTotalWaypoint - 1)) + 1);
		m_pNpcList[iNpcH]->m_dX  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].x);
		m_pNpcList[iNpcH]->m_dY  = (short)(m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_WaypointList[ m_pNpcList[iNpcH]->m_iWayPointIndex[ m_pNpcList[iNpcH]->m_cCurWaypoint ] ].y);
		break;

	case DEF_MOVETYPE_RANDOMAREA:
				
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.right - m_pNpcList[iNpcH]->m_rcRandomArea.left);
		m_pNpcList[iNpcH]->m_dX = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.left);
		sRange = (short)(m_pNpcList[iNpcH]->m_rcRandomArea.bottom - m_pNpcList[iNpcH]->m_rcRandomArea.top);
		m_pNpcList[iNpcH]->m_dY = (short)((rand() % sRange) + m_pNpcList[iNpcH]->m_rcRandomArea.top);
		break;

	case DEF_MOVETYPE_RANDOM:
		// ¿ÏÀü ·£´ý 
		//m_pNpcList[iNpcH]->m_dX = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeX - 50)) + 15;
		//m_pNpcList[iNpcH]->m_dY = (rand() % (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_sSizeY - 50)) + 15;
		iMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;

		for ( i = 0; i <= 30; i++) {
		// °¥ ¼ö ÀÖ´Â ÁÂÇ¥°¡ ³ª¿Ã¶§ ±îÁö 30¹ø ¹Ýº¹ 
			sX = (rand() % (m_pMapList[iMapIndex]->m_sSizeX - 50)) + 15;
			sY = (rand() % (m_pMapList[iMapIndex]->m_sSizeY - 50)) + 15;

			bFlag = TRUE;
			for (j = 0; j < DEF_MAXMGAR; j++)
			if (m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left != -1) {
				// ÇÇÇØ¾ß ÇÒ ÁÂÇ¥°¡ ÀÖ´Ù. 
				if ((sX >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].left) &&
					(sX <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].right) &&
					(sY >= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].top) &&
					(sY <= m_pMapList[iMapIndex]->m_rcMobGenAvoidRect[j].bottom)) {
					// Avoid Rect¾ÈÀÌ¹Ç·Î ÀÌ À§Ä¡¿¡´Â »ý¼º½ÃÅ³ ¼ö ¾ø´Ù.	
					bFlag = FALSE;
				}
			}
			if (bFlag == TRUE) goto CNW_GET_VALIDLOC_SUCCESS;
		}
		// Fail! 
		m_pNpcList[iNpcH]->m_tmp_iError  = 0; 
		return;

CNW_GET_VALIDLOC_SUCCESS:;
		m_pNpcList[iNpcH]->m_dX = sX;
		m_pNpcList[iNpcH]->m_dY = sY;
		break;
	}

	m_pNpcList[iNpcH]->m_tmp_iError  = 0; // @@@ !!! @@@
}
void CGame::DeleteNpc(int iNpcH)
{
 int  i, iNamingValue;
 char cTmp[21], cItemName[21];
 class CItem * pItem;
 DWORD dwCount, dwTime;
 
	if (m_pNpcList[iNpcH] == NULL) return;

	dwTime = timeGetTime();

	//죽어있던 위치에서 삭제 
	SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->ClearOwner(11, iNpcH, DEF_OWNERTYPE_NPC, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);

	ZeroMemory(cTmp, sizeof(cTmp));
	strcpy(cTmp, (char *)(m_pNpcList[iNpcH]->m_cName + 2));
	// NPC의 NamigValue를 얻어와 사용중인 표시를 해지한다.
	iNamingValue = atoi(cTmp);

	// NamingValue를 비우고 동작중인 개체 수를 감소시킨다.
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
	m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iTotalActiveObject--;

	// Spot-mob-generator정보 
	if ( m_pNpcList[iNpcH]->m_iSpotMobIndex != NULL )
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_stSpotMobGenerator[m_pNpcList[iNpcH]->m_iSpotMobIndex].iCurMobs--;

	RemoveFromTarget(iNpcH, DEF_OWNERTYPE_NPC);
	
	// 크루세이드용 건축물이라면 지휘관 통보용 건축물 리스트를 해제
	switch (m_pNpcList[iNpcH]->m_sType) {
	case 36:
	case 37:
	case 38:
	case 39:
	case 42:
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->bRemoveCrusadeStructureInfo(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY);
		
		// 길드 건축물 개수도 감소시킴 
		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if (m_pGuildTeleportLoc[i].m_iV1 == m_pNpcList[iNpcH]->m_iGuildGUID) {
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			m_pGuildTeleportLoc[i].m_iV2--;
			if (m_pGuildTeleportLoc[i].m_iV2 < 0) m_pGuildTeleportLoc[i].m_iV2 = 0;
			break;	
		}
		break;
	}

	// DelayEvent를 삭제 
	bRemoveFromDelayEventList(iNpcH, DEF_OWNERTYPE_NPC, NULL);
	if (m_pNpcList[iNpcH]->m_bIsSummoned == FALSE) {
		// 소환몹이 아니라면 연금 재료가 나온다.
		pItem = new class CItem;
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pNpcList[iNpcH]->m_sType) {
		
		case 10: // Slime
			switch (iDice(1,2)) {
			case 1: if (iDice(1,16) == 1) strcpy(cItemName, "SlimeJelly"); // 1/16
			case 2: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			default: break;
			}
			break;

		case 16: // Giant-Ant
			switch (iDice(1,4)) {
			case 1: if (iDice(1,9) == 1)  strcpy(cItemName, "AntLeg"); break;	// 1/18
			case 2: if (iDice(1,10) == 1) strcpy(cItemName, "AntFeeler"); break;	// 1/20
			case 3: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
		case 4: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 22: // Amphis
			switch (iDice(1,6)) {
			case 1: if (iDice(1,5) == 1) strcpy(cItemName, "SnakeMeat"); break;	// 1/20
			case 2: if (iDice(1,6) == 1) strcpy(cItemName, "SnakeSkin"); break;	// 1/24
			case 3: if (iDice(1,6) == 1) strcpy(cItemName, "SnakeTeeth"); break;	// 1/24
			case 4: if (iDice(1,7) == 1) strcpy(cItemName, "SnakeTongue"); break;	// 1/28
			case 5: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 6: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;	
			default: break;
			}
			break;

		case 14: // Orc
			switch (iDice(1,5)) {
			case 1: if (iDice(1,7) == 1) strcpy(cItemName, "OrcMeat"); break;	// 1/21
			case 2: if (iDice(1,10) == 1) strcpy(cItemName,"OrcLeather"); break;	// 1/30
			case 3: if (iDice(1,11) == 1) strcpy(cItemName,"OrcTeeth"); break;	// 1/33
			case 4: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 5: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 17: // Scorpion
			switch (iDice(1,6)) {
			case 1: if (iDice(1,7) == 1) strcpy(cItemName, "ScorpionPincer"); break;	// 1/28
			case 2: if (iDice(1,7) == 1) strcpy(cItemName, "ScorpionMeat"); break;	// 1/28
			case 3: if (iDice(1,9) == 1) strcpy(cItemName, "ScorpionSting"); break;	// 1/36
			case 4: if (iDice(1,8) == 1) strcpy(cItemName, "ScorpionSkin"); break;	// 1/32
			case 5: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 6: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 18: // Zombie
			switch (iDice(1,2)) {
			case 1: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 2: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
		 	}
			break;

		case 11: // Skeleton
			switch (iDice(1,3)) {
			case 1: if (iDice(1,30) == 1) strcpy(cItemName, "SkeletonBones"); break;	// 1/30
			case 2: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 3: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 23: // Clay-Golem
			switch (iDice(1,3)) {
			case 1: if (iDice(1,30) == 1) strcpy(cItemName, "LumpofClay"); break;		// 1/30
			case 2: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 3: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 12: // Stone-Golem
			switch (iDice(1,3)) {
			case 1: if (iDice(1,30) == 1) strcpy(cItemName, "StoneGolemPiece"); break;	// 1/30  
			case 2: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 3: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 27: // Helbound
			switch (iDice(1,8)) {
			case 1: if (iDice(1,10) == 1) strcpy(cItemName,"HelboundHeart"); break;	// 1/60
			case 2: if (iDice(1,8) == 1) strcpy(cItemName, "HelboundLeather"); break;	// 1/48
			case 3: if (iDice(1,8) == 1) strcpy(cItemName, "HelboundTail"); break;	// 1/48
			case 4: if (iDice(1,6) == 1)  strcpy(cItemName,"HelboundTeeth"); break;	// 1/36
			case 5: if (iDice(1,6) == 1)  strcpy(cItemName,"HelboundClaw"); break;	// 1/36
			case 6: if (iDice(1,10) == 1) strcpy(cItemName,"HelboundTongue"); break;	// 1/60
			case 7: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 8: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 13: // Cyclops
			switch (iDice(1,7)) {
			case 1: if (iDice(1,16) == 1) strcpy(cItemName, "CyclopsEye"); break;	// 1/80
			case 2: if (iDice(1,20) == 1) strcpy(cItemName, "CyclopsHandEdge"); break;	// 1/100
			case 3: if (iDice(1,20) == 1)  strcpy(cItemName,"CyclopsHeart"); break;	// 1/100
			case 4: if (iDice(1,12) == 1)  strcpy(cItemName,"CyclopsMeat"); break;	// 1/60
			case 5: if (iDice(1,18) == 1)  strcpy(cItemName,"CyclopsLeather"); break;	// 1/90
			case 6: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 7: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 28: // Troll
			switch (iDice(1,6)) {
			case 1: if (iDice(1,15) == 1) strcpy(cItemName, "TrollHeart"); break;	// 1/60
			case 2: if (iDice(1,13) == 1) strcpy(cItemName, "TrollMeat"); break;	// 1/52
			case 3: if (iDice(1,15) == 1) strcpy(cItemName, "TrollLeather"); break;	// 1/60
			case 4: if (iDice(1,17) == 1) strcpy(cItemName, "TrollClaw"); break;	// 1/68
			case 5: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 6: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 29: // Orge
			switch (iDice(1,8)) {
			case 1: if (iDice(1,20) == 1) strcpy(cItemName, "OgreHair"); break;	// 1/120
			case 2: if (iDice(1,22) == 1) strcpy(cItemName, "OgreHeart"); break;		// 1/132
			case 3: if (iDice(1,15) == 1) strcpy(cItemName, "OgreMeat"); break;		// 1/90
			case 4: if (iDice(1,15) == 1) strcpy(cItemName, "OgreLeather"); break;		// 1/90
			case 5: if (iDice(1,18) == 1) strcpy(cItemName, "OgreTeeth"); break;		// 1/108
			case 6: if (iDice(1,18) == 1) strcpy(cItemName, "OgreClaw"); break;		// 1/108
			case 7: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 8: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 30: // Liche
			switch (iDice(1,2)) {
			case 1: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 2: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 31: // Demon 
			switch (iDice(1,6)) {
			case 1: if (iDice(1,400) == 123) strcpy(cItemName, "DemonHeart"); break;	
			case 2:	if (iDice(1,100) == 123) strcpy(cItemName, "DemonMeat"); break;	
			case 3:	if (iDice(1,200) == 123) strcpy(cItemName, "DemonLeather"); break;	
			case 4:	if (iDice(1,300) == 123) strcpy(cItemName, "DemonEye"); break;	
			case 5: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 6: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 32: // Unicorn
			switch (iDice(1,6)) {
			case 1: if (iDice(1,2000) == 396) strcpy(cItemName, "UnicornHorn");   break;	  
			case 2: if (iDice(1,500) == 3)    strcpy(cItemName, "UnicornHeart"); break;	
			case 3: if (iDice(1,100) == 3)    strcpy(cItemName, "UnicornMeat"); break;	
			case 4: if (iDice(1,200) == 3)    strcpy(cItemName, "UnicornLeather"); break;	
			case 5: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
					break;
			case 6: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

		case 33: // Werewolf
			switch (iDice(1,8)) {
			case 1: if (iDice(1,20) == 3) strcpy(cItemName, "WerewolfTail"); break;	    // 1/120
			case 2: if (iDice(1,22) == 3) strcpy(cItemName, "WerewolfHeart"); break;		// 1/132
			case 3: if (iDice(1,15) == 3) strcpy(cItemName, "WerewolfMeat"); break;		// 1/90
			case 4: if (iDice(1,15) == 3) strcpy(cItemName, "WerewolfLeather"); break;		// 1/90
			case 5: if (iDice(1,18) == 3) strcpy(cItemName, "WerewolfTeeth"); break;		// 1/108
			case 6: if (iDice(1,18) == 3) strcpy(cItemName, "WerewolfClaw"); break;		// 1/108
			case 7: if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
			case 8: bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			default: break;
			}
			break;

			case 80:
			case 79:
			case 78:
			case 77:
			case 76:
			case 75:
			case 74:
			case 72:
			case 71:
			case 70:
			case 65:
			case 62:
			case 63:
			case 61:
			case 60:
			case 59:
			case 58:
			case 57:
			case 56:
			case 55:
			case 54:
			case 53:
			case 52:
				if (iDice(1,50) == 25) 
						switch (iDice(1,4)) {
						case 1: strcpy(cItemName, "AncientTablet(LU)"); break;
						case 2: strcpy(cItemName, "AncientTablet(LD)"); break;
						case 3: strcpy(cItemName, "AncientTablet(RU)"); break;
						case 4: strcpy(cItemName, "AncientTablet(RD)"); break;
					}
				else bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
				break;


		case 48:
		case 49:
		case 50:
		case 66:
		case 73:
		case 81:
			bGetItemNameWhenDeleteNpc(cItemName, m_pNpcList[iNpcH]->m_sType); break;
			break;
		}

		// 특수 아이템이 안나온 경우 리치나 데몬, 유니콘은 Gold가 대체된다.
		dwCount = 1;
		if (strlen(cItemName) == 0) {
			switch (m_pNpcList[iNpcH]->m_sType) {
			case 30:
			case 31:
			case 32:
				strcpy(cItemName, "Gold");
				dwCount = (DWORD)(iDice(1, m_pNpcList[iNpcH]->m_iExpDice * 4) + m_pNpcList[iNpcH]->m_iExpDice);
				dwCount = dwCount - (dwCount/3);
				break;
			}
		}
		
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			delete pItem;
			pItem = NULL;
		}
		else {
			// 아이템 수량 입력 
			pItem->m_dwCount = dwCount;
			
			// 아이템에 고유 코드 입력 
			pItem->m_sTouchEffectType   = DEF_ITET_ID;
			pItem->m_sTouchEffectValue1 = iDice(1,100000);
			pItem->m_sTouchEffectValue2 = iDice(1,100000);
			//pItem->m_sTouchEffectValue3 = timeGetTime();
			// 마지막 숫자는 아이템 생성 월, 일	
			SYSTEMTIME SysTime;
			char cTemp[256];
			GetLocalTime(&SysTime);
			ZeroMemory(cTemp, sizeof(cTemp));
			wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
			pItem->m_sTouchEffectValue3 = atoi(cTemp);
			
			// 아이템을 서있는 위치에 떨어뜨린다. 
			m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, pItem);
						
			// 다른 클라이언트에게 아이템이 떨어진 것을 알린다. 
			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
				    	                m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
						                pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

			// 로그 남긴다.
			_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, NULL, pItem);
		}
	}

	delete m_pNpcList[iNpcH];
	m_pNpcList[iNpcH] = NULL;
}


void CGame::RequestFullObjectData(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp, wObjectID;
 char  * cp, cData[100];
 short * sp, sX, sY, sTemp, sTemp2;
 int   * ip, iRet;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	wp = (WORD *)(pData + DEF_INDEX2_MSGTYPE);
	wObjectID = *wp;
	
	ZeroMemory(cData, sizeof(cData));
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_EVENT_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTSTOP;
	
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	if (wObjectID < 10000) {
		// Ä³¸¯ÅÍÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù. 
		// Àß¸øµÈ ÀÎµ¦½º°ªÀÌ°Å³ª Á¸ÀçÇÏÁö ¾Ê´Â ÇÃ·¹ÀÌ¾î¶ó¸é ¹«½Ã.
		if ( (wObjectID == 0) || (wObjectID >= DEF_MAXCLIENTS) ) return;
		if (m_pClientList[wObjectID] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			// ObjectID
		cp += 2;
		sp  = (short *)cp;
		sX  = m_pClientList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pClientList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pClientList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pClientList[wObjectID]->m_cCharName, 10);
		cp += 10;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr1;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr2;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr3;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pClientList[wObjectID]->m_sAppr4;
		cp += 2;
		//v1.4 ApprColor
		ip = (int *)cp;
		*ip = m_pClientList[wObjectID]->m_iApprColor;
		cp += 4;
		
		sp  = (short *)cp;
		
		// m_pClientList[i]¿Í m_pClientList[sOwnerH]ÀÇ °ü°è¸¦ ÀÔ·ÂÇÑ´Ù.
		// sStatusÀÇ »óÀ§ 4ºñÆ®°¡ FOE °ü°è¸¦ ³ªÅ¸³½´Ù. 
		sTemp = m_pClientList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		sTemp2 = (short)iGetPlayerABSStatus(wObjectID, iClientH); //(short)iGetPlayerRelationship(iClientH, wObjectID);
		sTemp  = (sTemp | (sTemp2 << 12));
		
		*sp = sTemp;
		cp += 2;
		
		if (m_pClientList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 41); // v1.4
	}
	else {
		// NPCÀÇ Á¤º¸¸¦ ¿øÇÑ´Ù.
		// Àß¸øµÈ ÀÎµ¦½º °ªÀÌ°Å³ª »ý¼ºµÇÁö ¾ÊÀº NPC¶ó¸é ¹«½Ã 
		if ( ((wObjectID - 10000) == 0) || ((wObjectID - 10000) >= DEF_MAXNPCS) ) return;
		if (m_pNpcList[wObjectID - 10000] == NULL) return;
		
		wp  = (WORD *)cp;
		*wp = wObjectID;			
		cp += 2;

		wObjectID -= 10000;

		sp  = (short *)cp;
		sX  = m_pNpcList[wObjectID]->m_sX;
		*sp = sX;
		cp += 2;
		sp  = (short *)cp;
		sY  = m_pNpcList[wObjectID]->m_sY;
		*sp = sY;
		cp += 2;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sType;
		cp += 2;
		*cp = m_pNpcList[wObjectID]->m_cDir;
		cp++;
		memcpy(cp, m_pNpcList[wObjectID]->m_cName, 5);
		cp += 5;
		sp  = (short *)cp;
		*sp = m_pNpcList[wObjectID]->m_sAppr2;
		cp += 2;
		
		sp  = (short *)cp;
	
		sTemp = m_pNpcList[wObjectID]->m_sStatus;
		sTemp = 0x0FFF & sTemp; // »óÀ§ 4ºñÆ® Å¬¸®¾î
		
		sTemp2 = iGetNpcRelationship(wObjectID, iClientH);
		sTemp  = (sTemp | (sTemp2 << 12));	
		*sp = sTemp;
		cp += 2;

		if (m_pNpcList[wObjectID]->m_bIsKilled == TRUE) // v1.4
			 *cp = 1;
		else *cp = 0;
		cp++;

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 25); // v1.4
	}

	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
}

int CGame::_iGetArrowItemIndex(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return -1;

	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {

		// Arrow ¾ÆÀÌÅÛÀÌ 1°³ ÀÌ»ó ÀÖÀ¸¸é ÀÎµ¦½º °ªÀ» ¹ÝÈ¯ÇÑ´Ù.
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_cItemType == DEF_ITEMTYPE_ARROW) &&
			 (m_pClientList[iClientH]->m_pItemList[i]->m_dwCount > 0) )
			return i;	
	}

	return -1;
}

void CGame::ItemDepleteHandler(int iClientH, short sItemIndex, BOOL bIsUseItemResult)
{
	// ¼Ò¸ð¼º ¾ÆÀÌÅÛÀÇ Ä«¿îÆ®°¡ 0ÀÌ¸é »èÁ¦ÇÑ´Ù. È¤Àº Áß°í ¾ÆÀÌÅÛÀ» ÆÈ¾Æ¹ö¸° °Ï¿ì  
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	
	// v1.411 ·Î±×¸¦ ³²±ä´Ù. 
	_bItemLog(DEF_ITEMLOG_DEPLETE, iClientH, NULL, m_pClientList[iClientH]->m_pItemList[sItemIndex]);

	// ¸ÕÀú ÀåÂøµÇ¾î ÀÖ´Ù¸é ÇØÁ¦½ÃÅ²´Ù. ÀÌ·± °æ¿ì´Â °ÅÀÇ ¾øÀ» µí 
	ReleaseItemHandler(iClientH, sItemIndex, TRUE);
	
	// ÀÌÁ¦ ¾ÆÀÌÅÛÀ» ¸®½ºÆ®¿¡¼­ »èÁ¦ÇÒ°ÍÀ» Åëº¸ÇÑ´Ù.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMDEPLETED_ERASEITEM, sItemIndex, (int)bIsUseItemResult, NULL, NULL);

	// ¾ÆÀÌÅÛÀ» ¸Þ¸ð¸®¿¡¼­ »èÁ¦ 
	delete m_pClientList[iClientH]->m_pItemList[sItemIndex];
	m_pClientList[iClientH]->m_pItemList[sItemIndex] = NULL;

	m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] = FALSE;
	
	// !!! BUG POINT
	// ¾ÆÀÌÅÛÀÇ ÀÎµ¦½º°¡ ¹Ù²ï »óÈ²ÀÌ´Ù. ArrowIndex¿Í °°Àº °ÍÀº ´Ù½Ã ÇÒ´çÇØ¾ß ÇÑ´Ù. 
	m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);

	// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
	iCalcTotalWeight(iClientH);
}

void CGame::NpcBehavior_Stop(int iNpcH)
{
 char  cTargetType;
 short sTarget = NULL;
 BOOL  bFlag;

	// STOPÇÑ NPC´Â ´ëÀåÀåÀÌ°°ÀÌ ÀüÇô ¿òÁ÷ÀÌÁö ¾ÊÀ¸¸ç °¡²û Á¦ÀÚ¸®¿¡¼­ ´Ù¸¥ µ¿ÀÛÀ» ÇÏ´Â °ÍµéÀÌ´Ù. 
	// m_cActionLimit °¡ 2, 3, 5ÀÎ NPCµéÀÌ ÀÌ·± ¼Ó¼ºÀ» °®´Â´Ù. 
	if (m_pNpcList[iNpcH] == NULL) return; 

	// ÅÏ Ä«¿îÆ® Áõ°¡.
	m_pNpcList[iNpcH]->m_sBehaviorTurnCount++;

	switch (m_pNpcList[iNpcH]->m_cActionLimit) {
	case 5:
		
		switch (m_pNpcList[iNpcH]->m_sType) {
		case 38: // Mana Collector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_ManaCollector(iNpcH);

				if (bFlag == TRUE) {
					// ¸¶³ª Ã¤Áý. °ø°Ý µ¿ÀÛÀ¸·Î ¾Ë·Á¾ß ÇÑ´Ù.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 39: // Detector
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				bFlag = _bNpcBehavior_Detector(iNpcH);
				
				if (bFlag == TRUE) {
					// ÀûÀ» ¹ß°ßÇß´Ù. °ø°Ý µ¿ÀÛÀ¸·Î ¾Ë·Á¾ß ÇÑ´Ù.	
					SendEventToNearClient_TypeA(iNpcH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTATTACK, m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY, 1); 
				}
			}
			break;

		case 40: // Energy Shield Generator
			break;

		case 41: // Grand Magic Generator
			if (m_pNpcList[iNpcH]->m_sBehaviorTurnCount >= 3) {
				m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;
				_NpcBehavior_GrandMagicGenerator(iNpcH);
			}
			break;

		case 42: // ManaStone
			break;

		default: 
			TargetSearch(iNpcH, &sTarget, &cTargetType);				
			break;
		}
		break;
	}
	
	if ((sTarget != NULL)) {

		// °ø°Ý¸ñÇ¥ ¹ß°ß. 
		m_pNpcList[iNpcH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
		m_pNpcList[iNpcH]->m_sBehaviorTurnCount = 0;		
		m_pNpcList[iNpcH]->m_iTargetIndex = sTarget;
		m_pNpcList[iNpcH]->m_cTargetType  = cTargetType;
		// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û. 
		return;
	}
}

void CGame::UseItemHandler(int iClientH, short sItemIndex, short dX, short dY, short sDestItemID)
{
 int iTemp, iMax, iV1, iV2, iV3, iSEV1, iEffectResult = 0;
 DWORD dwTime;
 short sTemp, sTmpType, sTmpAppr1;

	dwTime = timeGetTime();

	//testcode
	//wsprintf(G_cTxt, "%d", sDestItemID);
	//PutLogList(G_cTxt);

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;

	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) || 
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) ) {
	}
	else return;
 	
	if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE) ||
		 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_EAT) ) {
				
		// ¾ÆÀÌÅÛÀÇ È¿°ú¿¡ ¸Â´Â Ã³¸®¸¦ ÇÑ´Ù. 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_LOTTERY:
			// º¹±Ç ¾ÆÀÌÅÛ EV1(È®·ü: ÃÖÀú 100) EV2(»óÇ° Á¾·ù) EV3(»óÇ° ¼ö·®)
			iTemp = iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1);
			if (iTemp == iDice(1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1)) {
				// ´çÃ·!

			}
			else {
				// ²Î!
				
			}
			break;
		
		case DEF_ITEMEFFECTTYPE_HP:
			iMax = iGetMaxHP(iClientH);
			if (m_pClientList[iClientH]->m_iHP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iHP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iHP > iMax) m_pClientList[iClientH]->m_iHP = iMax;
				if (m_pClientList[iClientH]->m_iHP <= 0)   m_pClientList[iClientH]->m_iHP = 1;

				iEffectResult = 1;
			}
			break;

		case DEF_ITEMEFFECTTYPE_MP:
			iMax = (2*m_pClientList[iClientH]->m_iMag) + (2*m_pClientList[iClientH]->m_iLevel) + (m_pClientList[iClientH]->m_iInt/2);
		
			if (m_pClientList[iClientH]->m_iMP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else 
				{
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iMP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iMP > iMax) 
					m_pClientList[iClientH]->m_iMP = iMax;

				iEffectResult = 2;
			}
			break;

		case DEF_ITEMEFFECTTYPE_SP:
			iMax = (2*m_pClientList[iClientH]->m_iStr) + (2*m_pClientList[iClientH]->m_iLevel);
		
			if (m_pClientList[iClientH]->m_iSP < iMax) {
				
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 == 0) {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
				}
				else {
					iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
					iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
					iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue3;
				}

				m_pClientList[iClientH]->m_iSP += (iDice(iV1, iV2) + iV3); 
				if (m_pClientList[iClientH]->m_iSP > iMax) 
					m_pClientList[iClientH]->m_iSP = iMax;

				iEffectResult = 3;
			}

			if (m_pClientList[iClientH]->m_bIsPoisoned == TRUE) {
				// Áßµ¶µÈ »óÅÂ¿´´Ù¸é Áßµ¶À» Ç¬´Ù.
				m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
				// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
			}
			break;

		case DEF_ITEMEFFECTTYPE_HPSTOCK:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iV3 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
		
			m_pClientList[iClientH]->m_iHPstock += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHPstock < 0)   m_pClientList[iClientH]->m_iHPstock = 0;
			if (m_pClientList[iClientH]->m_iHPstock > 500) m_pClientList[iClientH]->m_iHPstock = 500;

			// ¹è°íÇÄÀ» ÇØ°áÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHungerStatus += iDice(iV1, iV2) + iV3;
			if (m_pClientList[iClientH]->m_iHungerStatus > 100) m_pClientList[iClientH]->m_iHungerStatus = 100;
			if (m_pClientList[iClientH]->m_iHungerStatus < 0)   m_pClientList[iClientH]->m_iHungerStatus = 0;
			break;

		case DEF_ITEMEFFECTTYPE_STUDYSKILL:
			// ±â¼úÀ» ¹è¿î´Ù.	
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			iV2 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			iSEV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1;
			// iV1Àº ¹è¿ï Skill ¹øÈ£. iV2´Â ±â¼ú ¼öÁØ, iSEV1Àº »ç¿ëÀÚ Á¤ÀÇ ±â¼ú ¼öÁØ(¿ì¼±¼øÀ§) 
			if (iSEV1 == 0) {
				// »ç¿ëÀÚ Á¤ÀÇ ±â¼ú¼öÁØÀÌ 0ÀÌ¶ó¸é Ç¥ÁØ ±â¼ú¼öÁØ¿¡ µû¶ó ±â¼úÀ» ¹è¿ì°Ô µÈ´Ù. 
				TrainSkillResponse(TRUE, iClientH, iV1, iV2);
			}
			else {
		   		TrainSkillResponse(TRUE, iClientH, iV1, iSEV1);
			}
			break;

		case DEF_ITEMEFFECTTYPE_STUDYMAGIC:
			// iV1Àº ¹è¿ï ¸¶¹ý ¹øÈ£.
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pMagicConfigList[iV1] != NULL) 
				RequestStudyMagicHandler(iClientH, m_pMagicConfigList[iV1]->m_cName, FALSE);
			break;

		case DEF_ITEMEFFECTTYPE_MAGIC:
			// Åõ¸í ¸ðµå¿´´Ù¸é ¸¶¹ý È¿°ú ¾ÆÀÌÅÛ »ç¿ë½Ã¿¡ ÇØÁ¦µÈ´Ù.
			if ( (m_pClientList[iClientH]->m_sStatus & 0x10) != 0 ) {
				SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
			
				bRemoveFromDelayEventList(iClientH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_INVISIBILITY);
				m_pClientList[ iClientH ]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
			}

			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Recall ¸¶¹ý È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				// testcode
				PutLogList("Recall!");
				RequestTeleportHandler(iClientH, "1   ");
				break;

			case 2:
				// Åõ¸í ¸¶¹ýÈ¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ. 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 32, TRUE);
				break;

			case 3:
				// Åõ¸í ¸¶¹ý Ã£±â. »çÅõÀå ³»ºÎ¸é ¼Ò¿ë¾ø´Ù. 
				if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == FALSE)
					PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 34, TRUE);
				break;

			case 4:
				// fixed location teleportation: ÀÔÀå±Ç µîµî
				switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2) {
				case 1:
					// ºí¸®µù ¾ÆÀÏ·Î °£´Ù 
					if (memcmp(m_pClientList[iClientH]->m_cMapName, "bisle", 5) != 0) {
						//v1.42
						ItemDepleteHandler(iClientH, sItemIndex, TRUE);
						RequestTeleportHandler(iClientH, "2   ", "bisle", -1, -1);
					}
					break;
				
				case 11:	
				case 12:
				case 13:
				case 14:
				case 15:
				case 16:
				case 17:
				case 18:
				case 19:
					// °áÅõÀåÀ¸·Î °£´Ù. 
					SYSTEMTIME SysTime;

					GetLocalTime(&SysTime);
					// v1.4311-3 º¯°æ ÀÔÀå±Ç Ã¼Å© ´Þ/³¯Â¥/½Ã°£À¸·Î Ã¼Å©ÇÑ´Ù. 
					// ÀÔÀå °¡´ÉÇÑ ½Ã°£º¸´Ù ÀÛ°Å³ª °°À¸¸é ÀÔÀå±ÇÀÌ »ç¶óÁø´Ù.
					if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue1 != SysTime.wMonth) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue2 != SysTime.wDay) ||
						(m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sTouchEffectValue3 <= SysTime.wHour) ) {
						// ³¯Â¥°¡ Á¤È®ÇÏÁö ¾Ê´Ù. ¾Æ¹«·± È¿°ú°¡ ¾ø°í ÀÔÀå±ÇÀº »ç¶óÁø´Ù.
					}
					else {
						char cDestMapName[11];
						ZeroMemory(cDestMapName, sizeof(cDestMapName));
						wsprintf(cDestMapName, "fightzone%d", m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 - 10);
						if (memcmp(m_pClientList[iClientH]->m_cMapName, cDestMapName, 10) != 0) {
							//v1.42
							ItemDepleteHandler(iClientH, sItemIndex, TRUE);
							RequestTeleportHandler(iClientH, "2   ", cDestMapName, -1, -1);
						}
					}
					break;
				}
				break;

			case 5:
				// ¼ÒÈ¯È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ 
				PlayerMagicHandler(iClientH, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, 31, TRUE,
					               m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2); 	         
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_FIRMSTAMINAR:
			m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			if (m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar > 20*30) m_pClientList[iClientH]->m_iTimeLeft_FirmStaminar = 20*30; // ÃÖ´ë 30ºÐ°£ 
			break;

		case DEF_ITEMEFFECTTYPE_CHANGEATTR:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// ¸Ó¸® »öÀ» ¹Ù²Û´Ù. 
				m_pClientList[iClientH]->m_cHairColor++;
				if (m_pClientList[iClientH]->m_cHairColor > 15) m_pClientList[iClientH]->m_cHairColor = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 2:
				// ¸Ó¸® ½ºÅ¸ÀÏÀ» ¹Ù²Û´Ù.
				m_pClientList[iClientH]->m_cHairStyle++;
				if (m_pClientList[iClientH]->m_cHairStyle > 7) m_pClientList[iClientH]->m_cHairStyle = 0;

				sTemp = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
				m_pClientList[iClientH]->m_sAppr1 = sTemp;
				break;

			case 3:
				// ÇÇºÎ»öÀ» ¹Ù²Û´Ù.
				// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
				m_pClientList[iClientH]->m_cSkin++;
				if (m_pClientList[iClientH]->m_cSkin > 3)
					m_pClientList[iClientH]->m_cSkin = 1;
				
				if (m_pClientList[iClientH]->m_cSex == 1)      sTemp = 1;
				else if (m_pClientList[iClientH]->m_cSex == 2) sTemp = 4; 
				
				switch (m_pClientList[iClientH]->m_cSkin) {
				case 2:	sTemp += 1; break;
				case 3:	sTemp += 2; break;
				}
				m_pClientList[iClientH]->m_sType  = sTemp;
				break;

			case 4:
				// ¼ºÀüÈ¯ - ¸¸¾à ¿ÊÀ» ÀÔ°í ÀÖ´Ù¸é ½ÇÆÐÇÑ´Ù. 
				sTemp = m_pClientList[iClientH]->m_sAppr3 & 0xFF0F;
				if (sTemp == 0) {
					// sTemp°¡ 0ÀÌ ¾Æ´Ï¶ó¸é °Ñ¿Ê, ¼Ó¿Ê, ¹ÙÁöÁß ÇÑ°¡Áö¸¦ ÀÔ°í ÀÖ´Â °ÍÀÌ´Ù. ¼ºÀüÈ¯À» ÇÒ ¼ö ¾ø´Ù. 
					if (m_pClientList[iClientH]->m_cSex == 1) 
						 m_pClientList[iClientH]->m_cSex = 2;
					else m_pClientList[iClientH]->m_cSex = 1;

					// ³»¿ëÀ» ¹ÙÅÁÀ¸·Î Appearance¸¦ °è»ê, ÇÒ´çÇÑ´Ù.
					if (m_pClientList[iClientH]->m_cSex == 1) {
						// ³²ÀÚÀÌ´Ù. 
						sTmpType = 1;
					}
					else if (m_pClientList[iClientH]->m_cSex == 2) {
						// ¿©ÀÚÀÌ´Ù.
						sTmpType = 4; 
					}

					switch (m_pClientList[iClientH]->m_cSkin) {
					case 1:
						// ¹éÀÎÀÌ¸é ±×´ë·Î.
						break;
					case 2:
						sTmpType += 1;
						break;
					case 3:
						sTmpType += 2;
						break;
					}

					sTmpAppr1 = (m_pClientList[iClientH]->m_cHairStyle << 8) | (m_pClientList[iClientH]->m_cHairColor << 4) | (m_pClientList[iClientH]->m_cUnderwear);
					m_pClientList[iClientH]->m_sType  = sTmpType;
					m_pClientList[iClientH]->m_sAppr1 = sTmpAppr1; 
					//
				}
				break;
			}

			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
			break;
		}
		// *** Request Teleport Handler°¡ ÀÛµ¿µÇ¸é ÀÌ¹Ì µ¥ÀÌÅÍ ÀúÀåÀÌ ¿äÃ»µÈ »óÅÂÀÌ¹Ç·Î ÀÌÈÄ¿¡ ¾ÆÀÌÅÛÀ» ¾ø¾ÖºÁ¾ß ¼Ò¿ëÀÌ ¾ø´Ù. 
		// ¾ÆÀÌÅÛÀ» ¸ÕÀú ¾ø¾Ø´Ù.
		ItemDepleteHandler(iClientH, sItemIndex, TRUE);
		
		switch (iEffectResult) {
		case 1:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
			break;
		case 2:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
			break;
		case 3:
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			break;
		default:
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_DEPLETE_DEST) {
		// »ç¿ëÇÏ¸é¼­ ¸ñÇ¥ÁöÁ¡À» ÁöÁ¤ÇÏ´Â ¾ÆÀÌÅÛ.
		// dX, dYÀÇ ÁÂÇ¥°¡ À¯È¿ ¹üÀ§ ³»¿¡ ÀÖ´ÂÁö È®ÀÎÇØ¾ß ÇÑ´Ù.
		if (_bDepleteDestTypeItemUseEffect(iClientH, dX, dY, sItemIndex, sDestItemID) == TRUE) 
			ItemDepleteHandler(iClientH, sItemIndex, TRUE); 
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) {
		// È­»ìÀ» ÇÒ´çÇÑ´Ù. 
		m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_PERM) {
		// ¿µ±¸È÷ ¾µ ¼ö ÀÖ´Â ¾ÆÀÌÅÛ. Áï ¾²°í³ªµµ ¾ø¾îÁöÁö ¾Ê´Â ¾ÆÀÌÅÛ. (ex: Áöµµ) 
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_SHOWLOCATION:
			iV1 = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			switch (iV1) {
			case 1:
				// ÇöÀç ÀÚ½ÅÀÇ À§Ä¡¸¦ º¸¿©ÁØ´Ù. 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 1, NULL, NULL);
				else 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0)
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 2, NULL, NULL);
				else 
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "middleland") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 3, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 4, NULL, NULL);	
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone2") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 5, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone1") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 6, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone4") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 7, NULL, NULL);
				else
				if (strcmp(m_pClientList[iClientH]->m_cMapName, "huntzone3") == 0)
					 SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 8, NULL, NULL);
				else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SHOWMAP, iV1, 0, NULL, NULL);
				break;
			}
			break;
		}
	}
	else if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemType == DEF_ITEMTYPE_USE_SKILL) {
		// ±â¼ú°ú °ü·ÃµÈ ¾ÆÀÌÅÛÀ» »ç¿ëÇÑ´Ù. ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ³·Ãß°í µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·ÏÇÑ´Ù. 
		
		if ( (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) || 
			 (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) ||
			 (m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] == TRUE) ) {
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù Çß°Å³ª ¾ø°Å³ª °ü·Ã ½ºÅ³À» »ç¿ëÁßÀÌ¶ó¸é ¹«½Ã 
			return;
		}
		else {
			if ( m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan != 0 ) {
				// ÃÖ´ë ¼ö¸íÀÌ 0ÀÌ¸é »ç¿ëÇØµµ ¼ö¸íÀÌ ÁÙÁö ¾Ê´Â´Ù.
				m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan--;
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan <= 0) {
					// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀÌ ´Ù µÇ¾ú´Ù.
					// ¾ÆÀÌÅÛÀÌ ¸Á°¡Á³´Ù´Â ¸Þ½ÃÁö <- ÀÌ°É ¹ÞÀ¸¸é ÀåÂøÈ­¸é¿¡¼­ ÇØÁ¦½ÃÄÑ¾ß ÇÑ´Ù.
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMLIFESPANEND, DEF_EQUIPPOS_NONE, sItemIndex, NULL, NULL);
				}
				else {
					// ±â¼ú »ç¿ë ½Ã°£ ID°ªÀ» ±¸ÇÑ´Ù. v1.12
					int iSkillUsingTimeID = (int)timeGetTime();
					
					bRegisterDelayEvent(DEF_DELAYEVENTTYPE_USEITEM_SKILL, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill, 
			                     dwTime + m_pSkillConfigList[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]->m_sValue2*1000, 
								 iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_cMapIndex, dX, dY, 
								 m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ], iSkillUsingTimeID, NULL);
					
					// ±â¼ú »ç¿ëÁß 
					m_pClientList[iClientH]->m_bSkillUsingStatus[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = TRUE;
					m_pClientList[iClientH]->m_iSkillUsingTimeID[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ] = iSkillUsingTimeID; //v1.12
		 		}
			}
		}
	}
}

  
void CGame::Effect_Damage_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife;
 char cAttackerSide;
 DWORD dwTime;
 register double dTmp1, dTmp2, dTmp3;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	
	// ÇØ´ç Å¸ÄÏ¿¡°Ô ´ë¹ÌÁö¸¦ ¸ÔÀÎ´Ù. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	// °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é Mag¿¡ µû¸¥ º¸³Ê½º ´ë¹ÌÁö¸¦ °¡»ê 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		if (iDamage <= 0) iDamage = 0;

		// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 1.33¹è 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade : Àü¸éÀü ¸ðµåÀÏ¶§ ±ºÀÎ ´ëÀÎ °ø°Ý·Â 1.33¹è 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
			iDamage += iDamage/3;
		 
		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// °ø°Ý ´ë»óÀÌ Á¸ÀçÇÏÁö ¾ÊÀ¸¸é ¸®ÅÏ 
		if (m_pClientList[sTargetH] == NULL) return;
		// ÀÌ¹Ì Á×¾î ÀÖ´Ù¸é Ã³¸® ¾ÈÇÔ.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		// ·¢À¸·Î ÀÎÇØ º¸È£¸¦ ¹Þ¾Æ¾ß ÇÑ´Ù¸é 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// °ø°ÝÀÚ°¡ À§Ä¡ÇÑ ¸ÊÀÌ °ø°Ý ºÒ°¡´É ¸ÊÀÌ¶ó¸é 
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 °ø°ÝÀÚ°¡ Áß¸³ÀÌ¸é ´ëÀÎ °ø°ÝÀÌ ºÒ°¡´ÉÇÏ´Ù. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		
		// ¸¸¾à °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			// °ø°ÝÀÚ°¡ ¾ÈÀü °ø°Ý ¸ðµå¶ó¸é °ø°ÝÀÇ ÀÇ¹Ì°¡ ¾ø´Ù. 
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// ¾Æ¹« È¿°ú ¾øÀ½. ¸¶³ª ¼Òºñ·®ÀÌ ÁÙ¾úÀ¸¹Ç·Î 
				}
				else {
					// °°Àº ÆíÀÌÁö¸¸ ¸¸¾à »çÅõÀå ³»¿¡¼­ ÆíÀÌ °°´Ù¸é °ø°Ý Ã³¸®¸¦ ÇØ¾ßÇÑ´Ù.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// »çÅõÀå ³»¿¡¼­ ´Ù¸¥ ±æµå´Ù. °ø°ÝÀÌ °¡´ÉÇÏ´Ù. 
						}
						else return;
					}
					else return;
				}
			}

			// ¸¶¹ý º¸È£ È¤Àº ¾ÈÀü ¿µ¿ªÀÌ¶ó¸é °ø°Ý ¼º°ø ¸øÇÔ 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}

		// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
		ClearSkillUsingStatus(sTargetH);
		
		// v1.432 ¼Ó¼ºº° ´ë¹ÌÁö °¨¼Ò 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}

		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// ¸¶¹ý ´ë¹ÌÁö Àý°¨ È¿°ú¸¦ °¡Áø ¾ÆÀÌÅÛÀÌ´Ù.
			
			// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ´ë¹ÌÁö¸¦ ÁÙÀÎ´Ù. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // ¿¡¸Ó¶öµå ¹ÝÁö 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // ·çºñ ¹ÝÁö 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// ¸¶¹ý µ¥¹ÌÁö Àý°¨ ¾ÆÀÌÅÛÀÌ ºÎ¼­Áø´Ù. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// ¸¶¹ý µ¥¹ÌÁö Àý°¨ ¾ÆÀÌÅÛÀÇ ¼ö¸í¸¸ ÁÙÀÎ´Ù. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 Ãß°¡µÈ °íÁ¤ ¸¶¹ý ´ë¹ÌÁö Àý°¨
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT¿¡ µû¸¥ ´ë¹ÌÁö °¨¼Ò 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// Çà¿îÈ¿°ú·Î Á×À½À» ¸ð¸éÇÑ´Ù.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// ¸¸¾à ¸¶¹ý º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;

		// v1.432 Æ¯¼ö ´É·Â Áß ¸ðµç ´ë¹ÌÁö¸¦ ¸·´Â È¿°ú°¡ È°¼ºÈ­ µÈ °æ¿ì ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}
		
		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {
				// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û 
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ý°ø°Ý ÆÐ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSize)) return;

		//if (m_pNpcList[sTargetH]->m_cActionLimit != 0) return;
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 5:
			return;
		}

		// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ¾Æ±ºÀÌ³ª Áß¸³ÀÇ °ø°Ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}

		// ¸¸¾à °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í °ø°ÝÀÚ°¡ ¾ÈÀü °ø°Ý ¸ðµå¶ó¸é °ø°Ý·ÂÀº Àý¹Ý. v1.3¿¡¼­ °ø°Ý·ÂÀÌ ¾Æ´Ï¶ó ¸¶³ª¸¦ ´õ °¨¼Ò½ÃÅ²´Ù.
		//if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE))  
		//	iDamage = iDamage / 2; 

		// ¸ó½ºÅÍ°¡ ¸¶¹ý ´ë¹ÌÁö Èí¼ö·üÀÌ ÀÖ´Ù¸é(AbsDamage°¡ 0º¸´Ù Å©´Ù) ¿ø·¡ ¸¶¹ý ´ë¹ÌÁö¸¦ °¨¼Ò½ÃÅ²´Ù.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// ¸¸¾à ¸¶¹ý º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC°¡ »ç¸ÁÇß´Ù.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// °ø°Ý´çÇßÁö¸¸ »ì¾ÆÀÖ´Ù. ¹Ý°ÝÇÑ´Ù.
			
			// ÆíÀÌ °°À¸¸é ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}
			
			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// µ¿Á·ÀÌ°í ÆíÀÌ °°À¸¸é ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit°¡ 1ÀÌ¸é ¹Ý°ÝÀ» ÇÏÁö ¾Ê´Â´Ù. ¿ÀÁ÷ ¿òÁ÷ÀÏ¼ö¸¸ ÀÖÀ¸´Ï.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û.

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				// Crusade
				int iExp;

				// NPC¿¡ ´ëÇÑ °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°ÝÀÚ¿¡°Ô ÁØ´Ù. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStockÀ» ¿Ã¸°´Ù. ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;
											
						if (bExp == TRUE) 
							 m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;
						
						if (bExp == TRUE) 
							 m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_Damage_Spot_DamageMove(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sAtkX, short sAtkY, short sV1, short sV2, short sV3, BOOL bExp, int iAttr)
{
 int iDamage, iSideCondition, iIndex, iRemainLife;
 DWORD dwTime;
 char cAttackerSide;
 register double dTmp1, dTmp2, dTmp3;
 short sTgtX, sTgtY;
 int iMoveDamage;

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	if (cAttackerType == DEF_OWNERTYPE_NPC)
		if (m_pNpcList[sAttackerH] == NULL) return;

	dwTime = timeGetTime();
	sTgtX = 0;
	sTgtY = 0;
	
	// ÇØ´ç Å¸ÄÏ¿¡°Ô ´ë¹ÌÁö¸¦ ¸ÔÀÎ´Ù. 
	iDamage = iDice(sV1, sV2) + sV3;
	if (iDamage <= 0) iDamage = 0;

	// °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é Mag¿¡ µû¸¥ º¸³Ê½º ´ë¹ÌÁö¸¦ °¡»ê 
	switch (cAttackerType) {
	case DEF_OWNERTYPE_PLAYER:
		dTmp1 = (double)iDamage;
		if (m_pClientList[sAttackerH]->m_iMag <= 0)
			 dTmp2 = 1.0f;
		else dTmp2 = (double)m_pClientList[sAttackerH]->m_iMag;
			
		dTmp2 = dTmp2 / 3.3f;
		dTmp3 = dTmp1 + (dTmp1 * (dTmp2 / 100.0f));
		iDamage = (int)(dTmp3 +0.5f);
		if (iDamage <= 0) iDamage = 0;

		// v1.432 2001 4 7 13 7
		iDamage += m_pClientList[sAttackerH]->m_iAddMagicalDamage;

		// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 1.33¹è 
		if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
			iDamage += iDamage/3;

		// Crusade : Àü¸éÀü ¸ðµåÀÏ¶§ ´ëÀÎ °ø°Ý·Â 1.33¹è 
		if ((cTargetType == DEF_OWNERTYPE_PLAYER) && (m_bIsCrusadeMode == TRUE) && (m_pClientList[sAttackerH]->m_iCrusadeDuty == 1)) 
			iDamage += iDamage/3;

		cAttackerSide = m_pClientList[sAttackerH]->m_cSide;
		break;

	case DEF_OWNERTYPE_NPC:
		cAttackerSide = m_pNpcList[sAttackerH]->m_cSide;
		break;
	}

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		// °ø°Ý ´ë»óÀÌ Á¸ÀçÇÏÁö ¾ÊÀ¸¸é ¸®ÅÏ 
		if (m_pClientList[sTargetH] == NULL) return;
		// ÀÌ¹Ì Á×¾î ÀÖ´Ù¸é Ã³¸® ¾ÈÇÔ.
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
		// ·¢À¸·Î ÀÎÇØ º¸È£¸¦ ¹Þ¾Æ¾ß ÇÑ´Ù¸é 
		if ((dwTime - m_pClientList[sTargetH]->m_dwTime) > DEF_RAGPROTECTIONTIME) return;
		// °ø°ÝÀÚ°¡ À§Ä¡ÇÑ ¸ÊÀÌ °ø°Ý ºÒ°¡´É ¸ÊÀÌ¶ó¸é 
		if (m_pMapList[ m_pClientList[sTargetH]->m_cMapIndex ]->m_bIsAttackEnabled == FALSE) return;
		// v1.41 °ø°ÝÀÚ°¡ Áß¸³ÀÌ¸é ´ëÀÎ °ø°ÝÀÌ ºÒ°¡´ÉÇÏ´Ù. 
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsNeutral == TRUE) && (m_pClientList[sTargetH]->m_iPKCount == 0)) return;
		
		// ¸¸¾à °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í °ø°ÝÀÚ°¡ ¾ÈÀü °ø°Ý ¸ðµå¶ó¸é °ø°ÝÀÇ ÀÇ¹Ì°¡ ¾ø´Ù. 
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) { 
			
			if (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE) {
				iSideCondition = iGetPlayerRelationship(sAttackerH, sTargetH);
				if ((iSideCondition == 7) || (iSideCondition == 2) || (iSideCondition == 6)) {
					// ¾Æ¹« È¿°ú ¾øÀ½. ¸¶³ª ¼Òºñ·®ÀÌ ÁÙ¾úÀ¸¹Ç·Î 
				}
				else {
					// °°Àº ÆíÀÌÁö¸¸ ¸¸¾à »çÅõÀå ³»¿¡¼­ ÆíÀÌ °°´Ù¸é °ø°Ý Ã³¸®¸¦ ÇØ¾ßÇÑ´Ù.
					if (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
						if (m_pClientList[sAttackerH]->m_iGuildGUID != m_pClientList[sTargetH]->m_iGuildGUID) {
							// »çÅõÀå ³»¿¡¼­ ´Ù¸¥ ±æµå´Ù. °ø°ÝÀÌ °¡´ÉÇÏ´Ù. 
						}
						else return;
					}
					else return;
				}
			}

			// ¸¶¹ý º¸È£ È¤Àº ¾ÈÀü ¿µ¿ªÀÌ¶ó¸é °ø°Ý ¼º°ø ¸øÇÔ 
			if (m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->iGetAttribute(m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY, 0x00000005) != 0) return;
		}
		
		// ½ºÅ³ÀÇ »ç¿ë»óÅÂ¸¦ ¸ðµÎ ¹«È¿È­ ÇÑ´Ù.
		ClearSkillUsingStatus(sTargetH);

		// v1.432 ¼Ó¼ºº° ´ë¹ÌÁö °¨¼Ò 
		switch (iAttr) {
		case 1:
			if (m_pClientList[sTargetH]->m_iAddAbsEarth != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsEarth;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 2:
			if (m_pClientList[sTargetH]->m_iAddAbsAir != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsAir;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 3:
			if (m_pClientList[sTargetH]->m_iAddAbsFire != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsFire;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		case 4:
			if (m_pClientList[sTargetH]->m_iAddAbsWater != 0) {
				dTmp1 = (double)iDamage;
				dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsWater;
				dTmp3 = (dTmp2/100.0f)*dTmp1;
				iDamage = iDamage - (int)(dTmp3);
				if (iDamage < 0) iDamage = 0;
			}
			break;

		default: break;
		}
		
		iIndex = m_pClientList[sTargetH]->m_iMagicDamageSaveItemIndex;
		if ((iIndex != -1) && (iIndex >= 0) && (iIndex < DEF_MAXITEMS)) {
			// ¸¶¹ý ´ë¹ÌÁö Àý°¨ È¿°ú¸¦ °¡Áø ¾ÆÀÌÅÛÀÌ´Ù.
			
			// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ´ë¹ÌÁö¸¦ ÁÙÀÎ´Ù. 
			switch (m_pClientList[sTargetH]->m_pItemList[iIndex]->m_sIDnum) {
			case 335: // ¿¡¸Ó¶öµå ¹ÝÁö 20%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.2f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
						
			case 337: // ·çºñ ¹ÝÁö 10%
				dTmp1 = (double)iDamage;
				dTmp2 = dTmp1 * 0.1f;
				dTmp3 = dTmp1 - dTmp2;
				iDamage = (int)(dTmp3 +0.5f);
				break;
			}
			if (iDamage <= 0) iDamage = 0;
			
			iRemainLife = m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan;			
			if (iRemainLife <= iDamage) {
				// ¸¶¹ý µ¥¹ÌÁö Àý°¨ ¾ÆÀÌÅÛÀÌ ºÎ¼­Áø´Ù. 
				ItemDepleteHandler(sTargetH, iIndex, TRUE);
			}
			else {
				// ¸¶¹ý µ¥¹ÌÁö Àý°¨ ¾ÆÀÌÅÛÀÇ ¼ö¸í¸¸ ÁÙÀÎ´Ù. 
				m_pClientList[sTargetH]->m_pItemList[iIndex]->m_wCurLifeSpan -= iDamage;
			}
		}

		// v1.42 Ãß°¡µÈ °íÁ¤ ¸¶¹ý ´ë¹ÌÁö Àý°¨
		if (m_pClientList[sTargetH]->m_iAddAbsMD != 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)m_pClientList[sTargetH]->m_iAddAbsMD;
			dTmp3 = (dTmp2/100.0f)*dTmp1;
			iDamage = iDamage - (int)dTmp3;
		}

		// v1.4 VIT¿¡ µû¸¥ ´ë¹ÌÁö °¨¼Ò 
		if (cTargetType == DEF_OWNERTYPE_PLAYER) {
			iDamage -= (iDice(1, m_pClientList[sTargetH]->m_iVit/10) - 1);
			if (iDamage <= 0) iDamage = 0;
		}

		// ¸¸¾à ¸¶¹ý º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
	
		if ((m_pClientList[sTargetH]->m_bIsLuckyEffect == TRUE) && 
			(iDice(1,10) == 5) && (m_pClientList[sTargetH]->m_iHP <= iDamage)) {
			// Çà¿îÈ¿°ú·Î Á×À½À» ¸ð¸éÇÑ´Ù.
			iDamage = m_pClientList[sTargetH]->m_iHP - 1;
		}

		// v1.432 Æ¯¼ö ´É·Â Áß ¸ðµç ´ë¹ÌÁö¸¦ ¸·´Â È¿°ú°¡ È°¼ºÈ­ µÈ °æ¿ì ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sTargetH]->m_bIsSpecialAbilityEnabled == TRUE)) {
			switch (m_pClientList[sTargetH]->m_iSpecialAbilityType) {
			case 51:
			case 52:
				// 
				return;
			}
		}

		m_pClientList[sTargetH]->m_iHP -= iDamage;
		if (m_pClientList[sTargetH]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(sTargetH, sAttackerH, cAttackerType, iDamage);	
		}
		else {
			if (iDamage > 0) {

				// v1.44 »çÅõÀåÀÌ¸é ´ë¹ÌÁö 80ÀÌ»óÀÏ¶§ ¹Ð¸°´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pMapList[m_pClientList[sAttackerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) 
					 iMoveDamage = 80;
				else iMoveDamage = 50;

				if (iDamage >= iMoveDamage) {
					// ´ë¹ÌÁö°¡ 50ÀÌ»óÀÌ¸é Æ¨±ä´Ù.
					char cDamageMoveDir;
					sTgtX = m_pClientList[sTargetH]->m_sX;
					sTgtY = m_pClientList[sTargetH]->m_sY;

					if (sTgtX == sAtkX) {
						if (sTgtY == sAtkY)     goto EDSD_SKIPDAMAGEMOVE;
						else if (sTgtY > sAtkY) cDamageMoveDir = 5;
						else if (sTgtY < sAtkY) cDamageMoveDir = 1;
					}
					else if (sTgtX > sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 3;
						else if (sTgtY > sAtkY) cDamageMoveDir = 4;
						else if (sTgtY < sAtkY) cDamageMoveDir = 2;
					}
					else if (sTgtX < sAtkX) {
						if (sTgtY == sAtkY)     cDamageMoveDir = 7;
						else if (sTgtY > sAtkY) cDamageMoveDir = 6;
						else if (sTgtY < sAtkY) cDamageMoveDir = 8;							
					}

					// v1.44 ¹Ð·Á³¯¶§ ´ë¹ÌÁö¸¦ ÀÔ·ÂÇÑ´Ù.
					m_pClientList[sTargetH]->m_iLastDamage = iDamage;
					// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// Æ¨°Ü ³ª°¡¶ó´Â ¸Þ½ÃÁö ÀÔ·Â 	
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_DAMAGEMOVE, cDamageMoveDir, iDamage, NULL, NULL);
				}
				else {
EDSD_SKIPDAMAGEMOVE:;
					// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
					// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û 
					SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				}

				// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
				if (m_pClientList[sTargetH]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->ClearOwner(0, sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
					m_pMapList[m_pClientList[sTargetH]->m_cMapIndex]->SetOwner(sTargetH, DEF_OWNERTYPE_PLAYER, m_pClientList[sTargetH]->m_sX, m_pClientList[sTargetH]->m_sY);
				}
			
				if (m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ý°ø°Ý ÆÐ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if ((m_bIsCrusadeMode == TRUE) && (cAttackerSide == m_pNpcList[sTargetH]->m_cSize)) return;
		//if (m_pNpcList[sTargetH]->m_cActionLimit != 0) return;
		switch (m_pNpcList[sTargetH]->m_cActionLimit) {
		case 1:
		case 2:
		case 4:
		case 5:
			return;
		}
		
		// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ¾Æ±ºÀÌ³ª Áß¸³ÀÇ °ø°Ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
		if (cAttackerType == DEF_OWNERTYPE_PLAYER) {
			switch (m_pNpcList[sTargetH]->m_sType) {
			case 40:
			case 41:
				if ((m_pClientList[sAttackerH]->m_cSide == 0) || (m_pNpcList[sTargetH]->m_cSide == m_pClientList[sAttackerH]->m_cSide)) return;
				break;
			}
		}
		// ¸¸¾à °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾îÀÌ°í °ø°ÝÀÚ°¡ ¾ÈÀü °ø°Ý ¸ðµå¶ó¸é °ø°Ý·ÂÀº Àý¹Ý. v1.3¿¡¼­ °ø°Ý·ÂÀÌ ¾Æ´Ï¶ó ¸¶³ª¸¦ ´õ °¨¼Ò½ÃÅ²´Ù.
		//if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_bIsSafeAttackMode == TRUE))  
		//	iDamage = iDamage / 2; 

		// ¸ó½ºÅÍ°¡ ¸¶¹ý ´ë¹ÌÁö Èí¼ö·üÀÌ ÀÖ´Ù¸é(AbsDamage°¡ 0º¸´Ù Å©´Ù) ¿ø·¡ ¸¶¹ý ´ë¹ÌÁö¸¦ °¨¼Ò½ÃÅ²´Ù.
		if (m_pNpcList[sTargetH]->m_iAbsDamage > 0) {
			dTmp1 = (double)iDamage;
			dTmp2 = (double)(m_pNpcList[sTargetH]->m_iAbsDamage)/100.0f;
			dTmp3 = dTmp1 * dTmp2;
			dTmp2 = dTmp1 - dTmp3;
			iDamage = (int)dTmp2;
			if (iDamage < 0) iDamage = 1;
		}

		// ¸¸¾à ¸¶¹ý º¸È£ÁßÀÌ¶ó¸é ´ë¹ÌÁö´Â 1/2 
		if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ] == 2)
			iDamage = iDamage / 2;
		
		m_pNpcList[sTargetH]->m_iHP -= iDamage;
		if (m_pNpcList[sTargetH]->m_iHP < 0) {
			// NPC°¡ »ç¸ÁÇß´Ù.
			NpcKilledHandler(sAttackerH, cAttackerType, sTargetH, iDamage);
		}
		else {
			// °ø°Ý´çÇßÁö¸¸ »ì¾ÆÀÖ´Ù. ¹Ý°ÝÇÑ´Ù.

			// ÆíÀÌ °°À¸¸é ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
			switch (cAttackerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide) return;
				break;
			}

			if ((iDice(1,3) == 2) && (m_pNpcList[sTargetH]->m_cActionLimit == 0)) {

				// µ¿Á·ÀÌ°í ÆíÀÌ °°À¸¸é ¹Ý°ÝÇÏÁö ¾Ê´Â´Ù.
				if ((cAttackerType == DEF_OWNERTYPE_NPC) && 
					(m_pNpcList[sAttackerH]->m_sType == m_pNpcList[sTargetH]->m_sType) &&
					(m_pNpcList[sAttackerH]->m_cSide == m_pNpcList[sTargetH]->m_cSide)) return;

				// ActionLimit°¡ 1ÀÌ¸é ¹Ý°ÝÀ» ÇÏÁö ¾Ê´Â´Ù. ¿ÀÁ÷ ¿òÁ÷ÀÏ¼ö¸¸ ÀÖÀ¸´Ï.
				m_pNpcList[sTargetH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
				m_pNpcList[sTargetH]->m_sBehaviorTurnCount = 0;		
				m_pNpcList[sTargetH]->m_iTargetIndex = sAttackerH;
				m_pNpcList[sTargetH]->m_cTargetType  = cAttackerType;

				// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
				m_pNpcList[sTargetH]->m_dwTime = dwTime;

				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û
				SendEventToNearClient_TypeA(sTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);
				// ¿©±â¼­ Ç¥È¿ µ¿ÀÛ°°Àº°ÍÀ» À§ÇÑ ¸Þ½ÃÁö ¹ß¼Û.

				if (m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
					m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(sTargetH, DEF_OWNERTYPE_NPC, DEF_MAGICTYPE_HOLDOBJECT);
				}

				//Crusade
				int iExp;

				// NPC¿¡ ´ëÇÑ °ø°ÝÀÌ ¼º°øÇßÀ¸¹Ç·Î °ø°ÝÀÚ°¡ ÇÃ·¹ÀÌ¾î¶ó¸é ÀÔÈù ´ë¹ÌÁö ¸¸Å­ÀÇ °æÇèÄ¡¸¦ °ø°ÝÀÚ¿¡°Ô ÁØ´Ù. 
				if ( (m_pNpcList[sTargetH]->m_iNoDieRemainExp > 0) && (m_pNpcList[sTargetH]->m_bIsSummoned != TRUE) && 
					 (cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL) ) {
					// ExpStockÀ» ¿Ã¸°´Ù. ´Ü ¼ÒÈ¯¸÷ÀÎ °æ¿ì °æÇèÄ¡¸¦ ¿Ã¸®Áö ¾Ê´Â´Ù.
					if (m_pNpcList[sTargetH]->m_iNoDieRemainExp > iDamage) {
						// Crusade
						iExp = iDamage;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;
						
						if (bExp == TRUE) 
							 m_pClientList[sAttackerH]->m_iExpStock += iExp;     //iDamage;
						else m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(iDamage/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp -= iDamage;
					}
					else {
						// Crusade
						iExp = m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						if ((m_bIsCrusadeMode == TRUE) && (iExp > 10)) iExp = 10;

						if (bExp == TRUE) 
							 m_pClientList[sAttackerH]->m_iExpStock += iExp;     //m_pNpcList[sTargetH]->m_iNoDieRemainExp;
						else m_pClientList[sAttackerH]->m_iExpStock += (iExp/2); //(m_pNpcList[sTargetH]->m_iNoDieRemainExp/2);
						m_pNpcList[sTargetH]->m_iNoDieRemainExp = 0;
					}
				}
			}
		}
		break;
	}
}

void CGame::Effect_HpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iHP, iMaxHP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// ÇØ´ç Å¸ÄÏÀÇ HP¸¦ ¿Ã¸°´Ù. 
	iHP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxHP = (3*m_pClientList[sTargetH]->m_iVit) + (2*m_pClientList[sTargetH]->m_iLevel) + (m_pClientList[sTargetH]->m_iStr/2); // v1.4

		// v1.432 Heal·Îµµ ºí·¯µå ¼Òµå·ù HP ÃÖ´ëÄ¡ Á¦ÇÑÀº Àû¿ëµÊ
		if (m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown != 0) 
			iMaxHP = iMaxHP - (iMaxHP/m_pClientList[sTargetH]->m_iSideEffect_MaxHPdown);

		if (m_pClientList[sTargetH]->m_iHP < iMaxHP) {
			m_pClientList[sTargetH]->m_iHP += iHP;
			
			if (m_pClientList[sTargetH]->m_iHP > iMaxHP) m_pClientList[sTargetH]->m_iHP = iMaxHP;
			if (m_pClientList[sTargetH]->m_iHP <= 0)     m_pClientList[sTargetH]->m_iHP = 1;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return;
		if (m_pNpcList[sTargetH]->m_iHP <= 0) return;
		if (m_pNpcList[sTargetH]->m_bIsKilled == TRUE) return;

		iMaxHP = m_pNpcList[sTargetH]->m_iHitDice*4;
		if (m_pNpcList[sTargetH]->m_iHP < iMaxHP) {
			m_pNpcList[sTargetH]->m_iHP += iHP;

			if (m_pNpcList[sTargetH]->m_iHP > iMaxHP) m_pNpcList[sTargetH]->m_iHP = iMaxHP;
			if (m_pNpcList[sTargetH]->m_iHP <= 0)     m_pNpcList[sTargetH]->m_iHP = 1;
		}
		break;
	}
}

void CGame::Effect_SpDown_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ³»¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP > 0) {
			
			//v1.42 
			if (m_pClientList[sTargetH]->m_iTimeLeft_FirmStaminar == 0) {
				m_pClientList[sTargetH]->m_iSP -= iSP;
				if (m_pClientList[sTargetH]->m_iSP < 0) m_pClientList[sTargetH]->m_iSP = 0;
				SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
			}
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}


void CGame::Effect_SpUp_Spot(short sAttackerH, char cAttackerType, short sTargetH, char cTargetType, short sV1, short sV2, short sV3)
{
 int iSP, iMaxSP;
 DWORD dwTime = timeGetTime();

	if (cAttackerType == DEF_OWNERTYPE_PLAYER)
		if (m_pClientList[sAttackerH] == NULL) return;

	// ÇØ´ç Å¸ÄÏÀÇ Sp¸¦ ¿Ã¸°´Ù.
	iSP = iDice(sV1, sV2) + sV3;
	
	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return;
		if (m_pClientList[sTargetH]->m_bIsKilled == TRUE) return;
	
		iMaxSP = (2*m_pClientList[sTargetH]->m_iStr) + (2*m_pClientList[sTargetH]->m_iLevel);
		if (m_pClientList[sTargetH]->m_iSP < iMaxSP) {
			m_pClientList[sTargetH]->m_iSP += iSP;
			
			if (m_pClientList[sTargetH]->m_iSP > iMaxSP) 
				m_pClientList[sTargetH]->m_iSP = iMaxSP;

			SendNotifyMsg(NULL, sTargetH, DEF_NOTIFY_SP, NULL, NULL, NULL, NULL);
		}
		break;

	case DEF_OWNERTYPE_NPC:
		// NPC´Â ½ºÅÂ¹Ì³Ê °³³äÀÌ ¾ø´Ù.
		break;
	}
}


BOOL CGame::bCheckResistingMagicSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 double dTmp1, dTmp2, dTmp3;
 int    iTargetMagicResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 ¿î¿µÀÚ¿¡ ´ëÇÑ ¸¶¹ý °ø°ÝÀº ¹«ÀÇ¹Ì 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;

		cTargetDir = m_pClientList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pClientList[sTargetH]->m_cSkillMastery[3] +m_pClientList[sTargetH]->m_iAddMR; // 3¹ø Resisting Magic
		// MagÀÌ 50º¸´Ù Å©¸é º¸³Ê½º ¸¶¹ý ¹æ¾î·ü Ãß°¡
		if (m_pClientList[sTargetH]->m_iMag > 50) 
			iTargetMagicResistRatio += (m_pClientList[sTargetH]->m_iMag - 50);
		// Ãß°¡ ¸¶¹ý ¹æ¾î·ü ´õÇÔ 
		iTargetMagicResistRatio += m_pClientList[sTargetH]->m_iAddResistMagic;
		cProtect = m_pClientList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		cTargetDir = m_pNpcList[sTargetH]->m_cDir;
		iTargetMagicResistRatio = m_pNpcList[sTargetH]->m_cResistMagic;
		cProtect = m_pNpcList[sTargetH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_PROTECT ]; 
		break;
	}

	// ¸íÁß·ü ÀÌÀü¿¡ ¸¶¹ýº¸È£°¡ °É·ÁÀÖ´Ù¸é ¹«Á¶°Ç ¼º°ø: ´Ü ¸íÁß·üÀÌ 1000º¸´Ù Å©¸é °í·ÁÇÑ´Ù.
	if ((iHitRatio < 1000) && (cProtect == 2)) return TRUE;
	// ¸¸¾à ¸íÁß·üÀÌ 10000 ÀÌ»óÀÌ¶ó¸é 9½áÅ¬ ÀÌ»óÀÇ ¸¶¹ýÀÌ¶õ ÀÇ¹Ì. ´Ù½Ã 10000À» »©¼­ Á¦ ¸íÁß·üÀ» °è»êÇÑ´Ù.
	if (iHitRatio >= 10000) iHitRatio -= 10000;

	if (iTargetMagicResistRatio < 1) iTargetMagicResistRatio = 1;

	// ÃÖÁ¾ °ø°Ý ¸íÁß·üÀ» ±¸ÇÑ´Ù. 
	dTmp1 = (double)(iHitRatio);
	dTmp2 = (double)(iTargetMagicResistRatio);

	dTmp3 = (dTmp1 / dTmp2)*50.0f;
	iDestHitRatio = (int)(dTmp3); 

	// ÃÖ¼Ò °ø°Ý ¸íÁß·üÀ» º¸ÀåÇÑ´Ù. 
	if (iDestHitRatio < DEF_MINIMUMHITRATIO) iDestHitRatio = DEF_MINIMUMHITRATIO;
	// ÃÖ´ë °ø°Ý ¸íÁß·üÀ» Á¦ÇÑÇÑ´Ù.
	if (iDestHitRatio > DEF_MAXIMUMHITRATIO) iDestHitRatio = DEF_MAXIMUMHITRATIO;
	
	if (iDestHitRatio >= 100) return FALSE; // ¸¶¹ýÀº ¸íÁßÇß´Ù.

	iResult = iDice(1, 100);
	if (iResult <= iDestHitRatio) return FALSE;

	// ¸¶¹ý ÀúÇ×ÀÌ ¼º°øÇßÀ¸¹Ç·Î Resisting MagicÀÇ SSNÀ» Áõ°¡½ÃÅ²´Ù.
	if (cTargetType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sTargetH, 3, 1);

	return TRUE;
}


BOOL CGame::bCheckResistingIceSuccess(char cAttackerDir, short sTargetH, char cTargetType, int iHitRatio)
{
 // ³Ãµ¿µÉ °ÍÀÎ°¡ÀÇ È®·ü °è»ê.
 double dTmp1, dTmp2, dTmp3;
 int    iTargetIceResistRatio, iDestHitRatio, iResult;
 char   cTargetDir, cProtect;								 

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sTargetH] == NULL) return FALSE;
		// v1.4 ¿î¿µÀÚ¿¡ ´ëÇÑ ³Ãµ¿°ø°ÝÀº ¹«ÀÇ¹Ì 
		if (m_pClientList[sTargetH]->m_iAdminUserLevel > 0) return TRUE;
		iTargetIceResistRatio = m_pClientList[sTargetH]->m_iAddAbsWater*2; 
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sTargetH] == NULL) return FALSE;
		iTargetIceResistRatio = (m_pNpcList[sTargetH]->m_cResistMagic) - (m_pNpcList[sTargetH]->m_cResistMagic/3); // ¿©±â¿¡ ¾óÀ½ ¹æ¾î ¼öÄ¡ ÀÔ·Â. NPCÀÇ °æ¿ì ¸¶¹ý ÀúÇ×ÀÇ 70% ¼öÁØ 
		break;
	}
	
	if (iTargetIceResistRatio < 1) iTargetIceResistRatio = 1;
	
	iResult = iDice(1, 100);
	if (iResult <= iTargetIceResistRatio) return TRUE;
	
	return FALSE;
}


BOOL CGame::bSetItemToBankItem(int iClientH, class CItem * pItem)
{
 register int i, iRet;
 DWORD * dwp;
 WORD  * wp;
 char  * cp;
 short * sp;
 char cData[100];		   
	
	// ¼ÒÁöÇÏ°í ÀÖ´Â ¾ÆÀÌÅÛÀ» º¸°üÇÑ´Ù.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (pItem == NULL) return FALSE;


	for (i = 0; i < DEF_MAXBANKITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemInBankList[i] == NULL) {
		// ºñ¾îÀÖ´Â À§Ä¡¸¦ Ã£¾Ò´Ù.
		
		// ¼ÒÁöÇ° ¹«°Ô¸¦ »¬ ÇÊ¿ä´Â ¾ø´Ù.
		
		m_pClientList[iClientH]->m_pItemInBankList[i] = pItem;
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMTOBANK;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

		*cp = i; // À§Ä¡ ÀúÀå 
		cp++;

		// 1°³.
		*cp = 1;
		cp++;

		memcpy(cp, pItem->m_cName, 20);
		cp += 20;

		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;

		*cp = pItem->m_cItemType;
		cp++;

		*cp = pItem->m_cEquipPos;
		cp++;

		*cp = (char)0; 
		cp++;

		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
	
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;

		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;

		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		// v1.432
		sp = (short *)cp;
		*sp = pItem->m_sItemEffectValue2;
		cp += 2;

		// v1.42
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;

		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 55);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù. v1.41 Á¦°ÅÇÏÁö ¾Ê´Â´Ù.
			// DeleteClient(iClientH, TRUE, TRUE);
			return TRUE; // v1.41 FALSE¸¦ ¹ÝÈ¯ÇÏ¸é ¾ÆÀÌÅÛÀÌ ¹Ù´Ú¿¡ º¹»çµÈ´Ù.
		}

		return TRUE;
	}

	// ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¿©À¯°ø°£ÀÌ ¾ø´Ù.
	return FALSE;
}

BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// ½ºÅ³ÀÇ Æ÷ÀÎÆ®°¡ ÃÊ°úµÇ¾ú´Ù. ÃÊ°úµÈ Æ÷ÀÎÆ® ¸¸Å­ ·çÇÁ¸¦ µ¹¸ç SSNÀÌ °¡Àå ³·Àº ½ºÅ³À» ³»¸°´Ù.	
		while (iRemainPoint > 0) {
			
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// ÁöÁ¤µÈ ½ºÅ³ÀÌ ÀÖ´Ù. 
				switch (m_pClientList[iClientH]->m_iDownSkillIndex) {
				case 3: // ¸¶¹ý ÀúÇ×

				/* ÀÌ ½ºÅ³µµ 0À¸·Î µÈ´Ù.
				case 4:
				case 5:
				case 7:
					// 20ÀÌÇÏ·Î´Â ¶³¾îÁú ¼ö ¾ø´Â ±âº»½ºÅ³
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 20) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 ´Ù¿î ½ÃÅ³ ½ºÅ³Àº ÃÖ¼Ò 20 ÀÌÇÏ·Î´Â ¶³¾îÁú ¼ö ¾ø´Ù. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				*/

				default:
					// ½ºÅ³ÀÌ 20 ÀÌÇÏÀÇ »óÅÂ¶ó¸é ±×´ë·Î 0À¸·Î ¶³¾î ¶ß¸°´Ù.
					if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
						sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
					}
					else {
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						// ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
						iDownSkillSSN = 99999999;
						for (i = 0; i < DEF_MAXSKILLTYPE; i++)
						if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 21) && (i != iSkill) && 
							(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
							// V1.22 ´Ù¿î ½ÃÅ³ ½ºÅ³Àº ÃÖ¼Ò 20 ÀÌÇÏ·Î´Â ¶³¾îÁú ¼ö ¾ø´Ù. 
							iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
							sDownSkillIndex = i;
						}
					}
					break;
				}
			}
			// ÇöÀç 1º¸´Ù Å« ½ºÅ³ Áß¿¡¼­ °¡Àå ÀÛÀº SSNÀ» °®´Â ½ºÅ³Àº sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// ½ºÅ³ÀÌ ³·¾ÆÁ³À½À» ¾Ë¸°´Ù. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// ³·Ãß¾î¾ß ÇÒ ½ºÅ³À» Ã£Áö ¸øÇß´Ù. ÀÌ·³ ¾ÈµÇ´Âµ¥ 
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

/* ¹®Á¦ÀÇ ¹«ÇÑ·çÇÁ 
  
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i;
 int iRemainPoint, iTotalPoints, iWeaponIndex, iDownSkillSSN, iDownPoint;
 short sDownSkillIndex;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// ½ºÅ³ÀÇ Æ÷ÀÎÆ®°¡ ÃÊ°úµÇ¾ú´Ù. ÃÊ°úµÈ Æ÷ÀÎÆ® ¸¸Å­ ·çÇÁ¸¦ µ¹¸ç SSNÀÌ °¡Àå ³·Àº ½ºÅ³À» ³»¸°´Ù.	
		while (iRemainPoint > 0) {
			sDownSkillIndex = -1; // v1.4
			if (m_pClientList[iClientH]->m_iDownSkillIndex != -1) { 
				// ÁöÁ¤µÈ ½ºÅ³ÀÌ ÀÖ´Ù. 
				// ½ºÅ³ÀÌ 20 ÀÌÇÏÀÇ »óÅÂ¶ó¸é ±×´ë·Î 0À¸·Î ¶³¾î ¶ß¸°´Ù.
				if (m_pClientList[iClientH]->m_cSkillMastery[m_pClientList[iClientH]->m_iDownSkillIndex] > 0) {
					sDownSkillIndex = m_pClientList[iClientH]->m_iDownSkillIndex;
				}
				else {
					// ÁöÁ¤µÈ ½ºÅ³ÀÌ 0ÀÌ´Ù. ´Ù¸¥ ½ºÅ³À» °Ë»öÇÑ´Ù.
					iDownSkillSSN = 99999999;
					for (i = 0; i < DEF_MAXSKILLTYPE; i++)
					if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
						(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
						
						iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
						sDownSkillIndex = i;
					}
				}
			} 
			else {
				// ÁöÁ¤µÈ ½ºÅ³ÀÌ ¾ø´Ù. ³»¸± ½ºÅ³À» °Ë»öÇÑ´Ù.
				iDownSkillSSN = 99999999;
				for (i = 0; i < DEF_MAXSKILLTYPE; i++)
				if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 0) && (i != iSkill) && 
					(m_pClientList[iClientH]->m_iSkillSSN[i] <= iDownSkillSSN)) {
					
					iDownSkillSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
					sDownSkillIndex = i;
				}
			}
			
			// ÇöÀç 1º¸´Ù Å« ½ºÅ³ Áß¿¡¼­ °¡Àå ÀÛÀº SSNÀ» °®´Â ½ºÅ³Àº sDownSkillIndex 
			if (sDownSkillIndex != -1) {
				
				if (m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] <= 20) // v1.4
				 	 iDownPoint = m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex];
				else iDownPoint = 1;

				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= iDownPoint; // v1.4
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = m_iSkillSSNpoint[m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]+1] - 1;
				iRemainPoint -= iDownPoint; // v1.4
				
				// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio -= iDownPoint; // v1.4
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// ½ºÅ³ÀÌ ³·¾ÆÁ³À½À» ¾Ë¸°´Ù. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// ³·Ãß¾î¾ß ÇÒ ½ºÅ³À» Ã£Áö ¸øÇß´Ù. ÀÌ·³ ¾ÈµÇ´Âµ¥ 
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}

*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iRemainPoint, iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sDownSkillLevel;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	iRemainPoint = iTotalPoints - DEF_MAXSKILLPOINTS;

	if (iRemainPoint > 0) {
		// ½ºÅ³ÀÇ Æ÷ÀÎÆ®°¡ ÃÊ°úµÇ¾ú´Ù. ÃÊ°úµÈ Æ÷ÀÎÆ® ¸¸Å­ ·çÇÁ¸¦ µ¹¸ç SSNÀÌ °¡Àå ³·Àº ½ºÅ³À» ³»¸°´Ù.	
		while (iRemainPoint != 0) {
			
			sDownSkillIndex = -1;
			sDownSkillLevel = 100;
			for (i = 0; i < DEF_MAXSKILLTYPE; i++)
			if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && 
				(m_pClientList[iClientH]->m_cSkillMastery[i] < sDownSkillLevel)) {
			
				sDownSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[i];
				sDownSkillIndex = i;
			}
			// ÇöÀç ½ºÅ³ ¼öÁØ¿¡¼­ 0º¸´Ù Å©°í °¡Àå ÀÛÀº ½ºÅ³Àº sDownSkillIndex 
			
			if (sDownSkillIndex != -1) {
				m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex]--;
				m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;
				iRemainPoint--;
				
				// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
					// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}

				if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
					// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
					iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
					if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
						// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
						m_pClientList[iClientH]->m_iHitRatio--;
						if (m_pClientList[iClientH]->m_iHitRatio < 0) m_pClientList[iClientH]->m_iHitRatio = 0;
					}
				}
				// ½ºÅ³ÀÌ ³·¾ÆÁ³À½À» ¾Ë¸°´Ù. 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			}
			else {
				// ³·Ãß¾î¾ß ÇÒ ½ºÅ³À» Ã£Áö ¸øÇß´Ù.
				return FALSE;
			}
		}
		return TRUE;
	}

	return FALSE;
}
*/

/*
BOOL CGame::bCheckTotalSkillMasteryPoints(int iClientH, int iSkill)
{
 register int i, j;
 int iTotalPoints, iWeaponIndex;
 short sDownSkillIndex, sComSSN;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	iTotalPoints = 0;
	for (i = 0; i <	DEF_MAXSKILLTYPE; i++) 
		iTotalPoints += m_pClientList[iClientH]->m_cSkillMastery[i];

	if (iTotalPoints > DEF_MAXSKILLPOINTS) {
		// ´Ù¸¥ ½ºÅ³ÀÇ Æ÷ÀÎÆ®¸¦ DEF_MAXSKILLPOINTS¼öÁØÀ¸·Î ³»·Á¾ß ÇÑ´Ù. SkillÀÌ 1 ÀÌ»óÀÌ°í SSNÀÌ °¡Àå ÀÛÀº SkillÀ» 1³»¸°´Ù.
		
		sDownSkillIndex = -1;
		sComSSN = 10000;
		for (i = 0; i < DEF_MAXSKILLTYPE; i++)
		if ((m_pClientList[iClientH]->m_cSkillMastery[i] >= 1) && (i != iSkill) && (m_pClientList[iClientH]->m_iSkillSSN[i] < sComSSN)) {
			sComSSN = m_pClientList[iClientH]->m_iSkillSSN[i];
			sDownSkillIndex = i;
		}
		
		if (sDownSkillIndex != -1) {
			m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex] -= (iTotalPoints - DEF_MAXSKILLPOINTS);
			m_pClientList[iClientH]->m_iSkillSSN[sDownSkillIndex] = 0;

			// ¸¸¾à ³·¾ÆÁø ½ºÅ³ÀÌ ÇöÀç »ç¿ëÁßÀÎ ¹«±â¿Í °ü·ÃÀÌ ÀÖ´Ù¸é ¸íÁß·üÀ» ³·Ãß¾î¾ß ÇÑ´Ù. 
			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ] != -1) {
				// ¾ç¼Õ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_TWOHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// È°·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}

			if (m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ] != -1) {
				// ¹«±â°¡ ÀåÂøµÇ¾î ÀÖ¾ú´Ù. 
				iWeaponIndex = m_pClientList[iClientH]->m_sItemEquipmentStatus[ DEF_EQUIPPOS_RHAND ];
				if (m_pClientList[iClientH]->m_pItemList[iWeaponIndex]->m_sRelatedSkill == sDownSkillIndex) {
					// °ËÀÌ³ª Mace·ùÀÇ »ç¿ë¿¡ ÀÇÇÑ ½ºÅ³ÀÇ ÇÏ¶ôÀÌ¾ú´Ù. ¸íÁß·üÀ» ³·Ãá´Ù. 
					m_pClientList[iClientH]->m_iHitRatio -= (iTotalPoints - DEF_MAXSKILLPOINTS);
				}
			}
	
			// ½ºÅ³ÀÌ ³·¾ÆÁ³À½À» ¾Ë¸°´Ù. 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, sDownSkillIndex, m_pClientList[iClientH]->m_cSkillMastery[sDownSkillIndex], NULL, NULL);
			return TRUE;
		}
		
	}

	return FALSE;
}
*/


void CGame::OnKeyDown(WPARAM wParam, LPARAM lParam)
{
	switch (wParam) {
	case VK_F1:
		m_bF1pressed = TRUE;
		break;
	case VK_F4:
		m_bF4pressed = TRUE;
		break;
	case VK_F12:
		m_bF12pressed = TRUE;
		break;
	}
}

void CGame::OnKeyUp(WPARAM wParam, LPARAM lParam)
{
 int i;
 char * cp, cTemp[120];
 
	switch (wParam) {
	case VK_F2:
				
		/*
		char cTxt[120];
		for (i = 1; i <= 200; i++){
			wsprintf(cTxt, "Level %d:  Exp %d", i, iGetLevelExp(i));
			PutLogFileList(cTxt);
		}
		
		// Å×½ºÆ® 
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 3;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS STARTED(by Log-server connection Lost Emulation)!!!");
		}
		*/
		break;
	
	case VK_F1:
		m_bF1pressed = FALSE;
		break;
	case VK_F4:
		m_bF4pressed = FALSE;
		break;
	case VK_F12:
		m_bF12pressed = FALSE;
		break;

	case VK_F6:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement1...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 1, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F7:
		if (m_bF1pressed == TRUE) {
			PutLogList("(!) Send server shutdown announcement2...");
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERSHUTDOWN, 2, NULL, NULL, NULL);
			}
		}
		break;

	case VK_F9:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) Resume Crusade Mode...");
			LocalStartCrusadeMode(NULL);
		}
		break;

	case VK_F11:
		if ((m_bF1pressed == TRUE)) {
			PutLogList("(!!!) ManualEndCrusadeMode: side 0");
			ManualEndCrusadeMode(0);
		}
		break;

	//Crusade Testcode
	case VK_HOME:
		if ((m_bF1pressed == TRUE)) {
			GlobalStartCrusadeMode();
		}
		break;

	case VK_END:
		//LocalEndCrusadeMode();
		break;

	case VK_INSERT:
		_GrandMagicLaunchMsgSend(1, 1);
		MeteorStrikeMsgHandler(1);
		break;

	case VK_DELETE:
		_GrandMagicLaunchMsgSend(1, 2);
		MeteorStrikeMsgHandler(2);
		break;
	}
}

int CGame::iGetFollowerNumber(short sOwnerH, char cOwnerType)
{
 register int i, iTotal;

	iTotal = 0;

	for (i = 1; i < DEF_MAXNPCS; i++) 
	if ( (m_pNpcList[i] != NULL) && (m_pNpcList[i]->m_cMoveType == DEF_MOVETYPE_FOLLOW) ) {

		if ((m_pNpcList[i]->m_iFollowOwnerIndex == sOwnerH) && (m_pNpcList[i]->m_cFollowOwnerType == cOwnerType))
			iTotal++;
	}

	return iTotal;
}

BOOL CGame::bRegisterDelayEvent(int iDelayType, int iEffectType, DWORD dwLastTime, int iTargetH, char cTargetType, char cMapIndex, int dX, int dY, int iV1, int iV2, int iV3)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] == NULL) {
		
		m_pDelayEventList[i] = new class CDelayEvent;

		m_pDelayEventList[i]->m_iDelayType = iDelayType;
		m_pDelayEventList[i]->m_iEffectType = iEffectType;

		m_pDelayEventList[i]->m_cMapIndex = cMapIndex;
		m_pDelayEventList[i]->m_dX = dX;
		m_pDelayEventList[i]->m_dY = dY;

		m_pDelayEventList[i]->m_iTargetH    = iTargetH;
		m_pDelayEventList[i]->m_cTargetType = cTargetType;
		m_pDelayEventList[i]->m_iV1         = iV1;
		m_pDelayEventList[i]->m_iV2         = iV2;
		m_pDelayEventList[i]->m_iV3         = iV3; 

		m_pDelayEventList[i]->m_dwTriggerTime = dwLastTime;

		return TRUE;
	}

	return FALSE;
}

void CGame::DelayEventProcessor()
{
 register int i, iSkillNum, iResult;
 DWORD dwTime = timeGetTime();



	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if ((m_pDelayEventList[i] != NULL) && (m_pDelayEventList[i]->m_dwTriggerTime < dwTime)) {

		// ÀÌº¥Æ®°¡ µ¿ÀÛÇÒ ½Ã°£ÀÌ µÆ´Ù. µ¿ÀÛÈÄ »èÁ¦µÈ´Ù.
		switch (m_pDelayEventList[i]->m_iDelayType) {
		case DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT:
			CalcMeteorStrikeEffectHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;

		case DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE:
			DoMeteorStrikeDamageHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_METEORSTRIKE:
			MeteorStrikeHandler(m_pDelayEventList[i]->m_cMapIndex);
			break;
		
		case DEF_DELAYEVENTTYPE_USEITEM_SKILL:
			// ¾ÆÀÌÅÛ »ç¿ë¿¡ µû¸¥ °á°ú °è»ê, Åëº¸ 
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				iSkillNum = m_pDelayEventList[i]->m_iEffectType;
				
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH] == NULL ) break;
				// ±â¼ú »ç¿ëÀÌ ¹«È¿È­ µÇ¾ú´Ù¸é ¹«½Ã. 
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] == FALSE ) break;
				// ±â¼ú »ç¿ë ½Ã°£ ID°¡ ´Þ¶óµµ ¹«½Ã v1.12
				if ( m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] != m_pDelayEventList[i]->m_iV2) break;
				
				// ±â¼ú »ç¿ë »óÅÂ ÇØÁ¦ 
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_bSkillUsingStatus[iSkillNum] = FALSE;
				m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_iSkillUsingTimeID[iSkillNum] = NULL;
				
				// ÀÌÁ¦ SkillÀÇ È¿°ú¿¡ µû¸¥ °è»êÀ» ÇÑ´Ù. 
				iResult = iCalculateUseSkillItemEffect(m_pDelayEventList[i]->m_iTargetH, m_pDelayEventList[i]->m_cTargetType,
				 	                                   m_pDelayEventList[i]->m_iV1, iSkillNum, m_pDelayEventList[i]->m_cMapIndex, m_pDelayEventList[i]->m_dX, m_pDelayEventList[i]->m_dY);

				// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_SKILLUSINGEND, iResult, NULL, NULL, NULL);
				break;
			}
			break;
		
		case DEF_DELAYEVENTTYPE_DAMAGEOBJECT:
			break;

		case DEF_DELAYEVENTTYPE_MAGICRELEASE:
			// ÇÒ´çµÇ¾ú´ø ¸¶¹ýÈ¿°ú º¯¼ö¸¦ Å¬¸®¾îÇÑ´Ù.
			switch (m_pDelayEventList[i]->m_cTargetType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				SendNotifyMsg(NULL, m_pDelayEventList[i]->m_iTargetH, DEF_NOTIFY_MAGICEFFECTOFF, 
					          m_pDelayEventList[i]->m_iEffectType, m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ], NULL, NULL);
				
				m_pClientList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// Berserk È¿°ú ÇØÁ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);

				// polymorph È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pClientList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_PLAYER, FALSE);
				break;
			
			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ] == NULL) break;
				
				m_pNpcList[ m_pDelayEventList[i]->m_iTargetH ]->m_cMagicEffectStatus[ m_pDelayEventList[i]->m_iEffectType ] = NULL;
				
				// Invisibility È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_INVISIBILITY)
					SetInvisibilityFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// Berserk È¿°ú ÇØÁ¦
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_BERSERK)
					SetBerserkFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);

				// polymorph È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_POLYMORPH) {
					m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sType = m_pNpcList[m_pDelayEventList[i]->m_iTargetH]->m_sOriginalType;
					SendEventToNearClient_TypeA(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
				}

				// Ice È¿°ú ÇØÁ¦ 
				if (m_pDelayEventList[i]->m_iEffectType == DEF_MAGICTYPE_ICE)
					SetIceFlag(m_pDelayEventList[i]->m_iTargetH, DEF_OWNERTYPE_NPC, FALSE);
				break;
			}
			break;
		}
		
		delete m_pDelayEventList[i];
		m_pDelayEventList[i] = NULL;
	}
}



BOOL CGame::bRemoveFromDelayEventList(int iH, char cType, int iEffectType)
{
 register int i;

	for (i = 0; i < DEF_MAXDELAYEVENTS; i++) 
	if (m_pDelayEventList[i] != NULL) {
		
		if (iEffectType == NULL) {
			// Effect Á¾·ù¿¡ »ó°ü¾øÀÌ ¸ðµÎ »èÁ¦ 	
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
		else {
			// ÇØ´ç Effect¸¸ »èÁ¦.
			if ( (m_pDelayEventList[i]->m_iTargetH == iH) && (m_pDelayEventList[i]->m_cTargetType == cType) &&
				 (m_pDelayEventList[i]->m_iEffectType == iEffectType) ) {
				delete m_pDelayEventList[i];
				m_pDelayEventList[i] = NULL;
			}
		}
	}
	
	return TRUE;
}

void CGame::SetInvisibilityFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x10;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFEF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x10;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFEF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}

void CGame::SetBerserkFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x20;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFDF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x20;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFDF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}


void CGame::SetIceFlag(short sOwnerH, char cOwnerType, BOOL bStatus)
{
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x40;
		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFBF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return;
		if (bStatus == TRUE) 
			 m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x40;
		else m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFFBF;
		// ¿ÜÇüÀÌ ¹Ù²ï°ÍÀ» Åëº¸ 
		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		break;
	}
}


void CGame::SendObjectMotionRejectMsg(int iClientH)
{
 char  * cp, cData[30];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	// ÀÌµ¿ÀÌ ºÒ°¡´ÉÇÏ´Ù. 
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
 	*dwp = MSGID_RESPONSE_MOTION;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOTION_REJECT;
	
	cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sX; 
	cp += 2;
	sp  = (short *)cp;
	*sp = m_pClientList[iClientH]->m_sY; 
	cp += 2;
	
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 10);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return;
	}
	return;
}

int CGame::_iGetTotalClients()
{
 register int i, iTotal;

	iTotal = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) iTotal++;

	return iTotal;
}

void CGame::DynamicObjectEffectProcessor()
{
 register int i, ix, iy, iIndex;
 short sOwnerH, iDamage, sType;
 char  cOwnerType;
 DWORD dwTime = timeGetTime(), dwRegisterTime;
	
	for (i = 0; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		switch (m_pDynamicObjectList[i]->m_sType) {
		case DEF_DYNAMICOBJECT_PCLOUD_BEGIN:
			// Æ÷ÀÌÁð Å¬¶ó¿ìµå
			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Poison Damage¸¦ ÀÔ´Â´Ù.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// ¸¶ºñ »óÅÂ°¡ Ç®¸°´Ù.	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Poison È¿°ú
							if ( (bCheckResistingMagicSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, 100) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_bIsPoisoned == FALSE) ) {
								
								m_pClientList[sOwnerH]->m_bIsPoisoned  = TRUE;
								m_pClientList[sOwnerH]->m_iPoisonLevel = m_pDynamicObjectList[i]->m_iV1;
								m_pClientList[sOwnerH]->m_dwPoisonTime = dwTime;
								// Áßµ¶µÇ¾úÀ½À» ¾Ë¸°´Ù. 
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_POISON, m_pClientList[sOwnerH]->m_iPoisonLevel, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						// ¸ó½ºÅÍÀÇ Áßµ¶È¿°ú´Â ¾ÆÁ÷ ±¸Çö ¾ÈµÊ
						if (m_pNpcList[sOwnerH] == NULL) break;

						// ÀÌ·± ½ÄÀ¸·Î ´ë¹ÌÁöÀÇ Å©±â¸¦ °áÁ¤
						if (m_pDynamicObjectList[i]->m_iV1 < 20)
							 iDamage = iDice(1,6);
						else iDamage = iDice(1,8);

						// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
							iDamage = 0;
							break;
						}
						
						// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // ÀÏ¹Ý
						case 3: // ´õ¹Ì·ù
						case 5: // °ÇÃà¹° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Áßµ¶±¸¸§¿¡ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
						break;
					}
				}
			}
			break;
						
		case DEF_DYNAMICOBJECT_ICESTORM:
			// Ice-Storm ·ùÀÇ ¾óÀ½ È¸¿À¸®.
			for (ix = m_pDynamicObjectList[i]->m_sX -2; ix <= m_pDynamicObjectList[i]->m_sX+2; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -2; iy <= m_pDynamicObjectList[i]->m_sY+2; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Ice Damage¸¦ ÀÔ´Â´Ù.
					switch (cOwnerType) {
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(3,3) + 5;
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] == 1) {
									// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ´Ü ÆÐ·²¶óÀÌÁî µÈ°ÍÀº Ç®¸®Áö ¾Ê´Â´Ù. 	
									// 1: Hold-Person 
									// 2: Paralize
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}

							// v1.42 Ice È¿°ú
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_PLAYER, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
								
								m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
									                sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);

								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTON, DEF_MAGICTYPE_ICE, 1, NULL, NULL);
							}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(3,3) + 5;

						// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
							iDamage = 0;
							break;
						}
						
						// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // ÀÏ¹Ý
						case 3: // ´õ¹Ì·ù
						case 5: // °ÇÃà¹° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);

							// v1.42 Ice È¿°ú
							if ( (bCheckResistingIceSuccess(1, sOwnerH, DEF_OWNERTYPE_NPC, m_pDynamicObjectList[i]->m_iV1) == FALSE) &&
								 (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] == 0) ) {
																
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_ICE ] = 1;
								SetIceFlag(sOwnerH, cOwnerType, TRUE);
								// È¿°ú°¡ ÇØÁ¦µÉ ¶§ ¹ß»ýÇÒ µô·¹ÀÌ ÀÌº¥Æ®¸¦ µî·ÏÇÑ´Ù.
								bRegisterDelayEvent(DEF_DELAYEVENTTYPE_MAGICRELEASE, DEF_MAGICTYPE_ICE, dwTime + (20*1000), 
								                    sOwnerH, cOwnerType, NULL, NULL, NULL, 1, NULL, NULL);
							}
						}
					   	break;
					}
				}

				// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					iDamage = iDice(3,2);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// ±ÙÃ³¿¡ Fire Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_FIRE) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		
		case DEF_DYNAMICOBJECT_FIRE:
			// Fire-Wall·ùÀÇ Å¸´Â ºÒ²É
			if (m_pDynamicObjectList[i]->m_iCount == 1) {
				// ±ÙÃ³¿¡ Å¸´Â ¹°°ÇÀÌ ÀÖ´Ù¸é ¹øÁø´Ù. 
				CheckFireBluring(m_pDynamicObjectList[i]->m_cMapIndex, m_pDynamicObjectList[i]->m_sX, m_pDynamicObjectList[i]->m_sY);
			}
			m_pDynamicObjectList[i]->m_iCount++;
			if (m_pDynamicObjectList[i]->m_iCount > 10) m_pDynamicObjectList[i]->m_iCount = 10; 


			for (ix = m_pDynamicObjectList[i]->m_sX -1; ix <= m_pDynamicObjectList[i]->m_sX+1; ix++)
			for (iy = m_pDynamicObjectList[i]->m_sY -1; iy <= m_pDynamicObjectList[i]->m_sY+1; iy++) {
				
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if (sOwnerH != NULL) {
					// Fire Damage¸¦ ÀÔ´Â´Ù.
					switch (cOwnerType) {
					
					case DEF_OWNERTYPE_PLAYER:
						if (m_pClientList[sOwnerH] == NULL) break;
						if (m_pClientList[sOwnerH]->m_bIsKilled == TRUE) break;
						// v1.41 Áß¸³ÀÌ°í ÀüÅõ¸ðµå°¡ ¾Æ´Ï¸é ÇÇÇØ¸¦ ÀÔÁö ¾Ê´Â´Ù.
						//if ((m_pClientList[sOwnerH]->m_bIsNeutral == TRUE) && (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) == 0) break;

						iDamage = iDice(1,6);
						m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
						if (m_pClientList[sOwnerH]->m_iHP <= 0) {
							// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
							ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  					}
						else {
							if (iDamage > 0) {
								// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
								SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

								if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
									// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. Fire Field·Î´Â ÆÐ·²¶óÀÌÁî µÈ°Íµµ Ç®¸°´Ù. 	
									// 1: Hold-Person 
									// 2: Paralize	
									SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
									m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
									bRemoveFromDelayEventList(sOwnerH, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
								}
						 	}
						}
						break;

					case DEF_OWNERTYPE_NPC:
						if (m_pNpcList[sOwnerH] == NULL) break;
						
						iDamage = iDice(1,6);

						// ÀüÀï¿ë ±¸Á¶¹°Áß ±×·£µå ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ´Â ÇÊµå·ù ¸¶¹ý¿¡ ´ë¹ÌÁö¸¦ ÀÔÁö ¾Ê´Â´Ù.
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 40:
						case 41:
							iDamage = 0;
							break;
						}
												
						// HP¿¡¼­ »«´Ù. Action Limit¿¡ µû¶ó Ã³¸®ÇÑ´Ù.
						switch (m_pNpcList[sOwnerH]->m_cActionLimit) {
						case 0: // ÀÏ¹Ý
						case 3: // ´õ¹Ì·ù
						case 5: // °ÇÃà¹° 
							m_pNpcList[sOwnerH]->m_iHP -= iDamage;
							break;
						}
						//if (m_pNpcList[sOwnerH]->m_cActionLimit == 0) 
						//	m_pNpcList[sOwnerH]->m_iHP -= iDamage;

						if (m_pNpcList[sOwnerH]->m_iHP <= 0) {
							// NPC°¡ »ç¸ÁÇß´Ù.
							NpcKilledHandler(sOwnerH, cOwnerType, sOwnerH, 0); //v1.2 Å¸¼­ Á×À¸¸é ¸¶Áö¸· ´ë¹ÌÁö°¡ 0. ¾ÆÀÌÅÛÀ» ½±°Ô ±¸ÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ.
						}
						else {
							// Damage¸¦ ÀÔÀº Ãæ°ÝÀ¸·Î ÀÎÇÑ Áö¿¬È¿°ú.
							if (iDice(1,3) == 2)
								m_pNpcList[sOwnerH]->m_dwTime = dwTime;
							
							if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
								// Hold µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. 	
								m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
							}
						
							// NPC¸¦ µµ¸Á°¡´Â ¸ðµå·Î ÀüÈ¯½ÃÅ²´Ù.
					 		SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, 0, NULL);
						}
					   	break;
					}
				}

				// Á×ÀºÃ´ÇÏ°í ÀÖ´Â Ä³¸¯ÀÌ ÀÖ´Ù¸é
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
			 	     (m_pClientList[sOwnerH]->m_iHP > 0) ) {
					// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					iDamage = iDice(1,6);
					m_pClientList[sOwnerH]->m_iHP -= iDamage;
						
					if (m_pClientList[sOwnerH]->m_iHP <= 0) {
						// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
						ClientKilledHandler(sOwnerH, sOwnerH, cOwnerType, iDamage);	
	  				}
					else {
						if (iDamage > 0) {
							// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
							SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
						}
					}
				}

				// ±ÙÃ³¿¡ Ice Object°¡ ÀÖ´Ù¸é ¼ö¸íÀ» ÁÙÀÎ´Ù.
				m_pMapList[m_pDynamicObjectList[i]->m_cMapIndex]->bGetDynamicObject(ix, iy, &sType, &dwRegisterTime, &iIndex);
				if ((sType == DEF_DYNAMICOBJECT_ICESTORM) && (m_pDynamicObjectList[iIndex] != NULL)) 
					m_pDynamicObjectList[iIndex]->m_dwLastTime = m_pDynamicObjectList[iIndex]->m_dwLastTime - (m_pDynamicObjectList[iIndex]->m_dwLastTime/10);
			}
			break;
		}
	}
}


void CGame::ClearSkillUsingStatus(int iClientH)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	
	for (i = 0; i < DEF_MAXSKILLTYPE; i++) {
		m_pClientList[iClientH]->m_bSkillUsingStatus[i] = FALSE;
		m_pClientList[iClientH]->m_iSkillUsingTimeID[i] = NULL; //v1.12
	}

	// ¸¸¾à ÀÌº¥Æ® ³¬½Ã¿Í °°Àº °ÍÀ» ÇÏ°í ÀÖ¾ú´Ù¸é ¿©±â¼­ ÇØÁ¦µÇ¾úÀ½À» Åëº¸ÇØ ÁØ´Ù. 
	
	if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) {
		// ÀÌº¥Æ® ³¬½Ã ¸ðµå¿´´Ù. ÇØÁ¦½ÃÅ²´Ù. 
		
		// Ä«¿îÆ® °¨¼Ò
		if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] != NULL) 
			m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_sEngagingCount--;

		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHCANCELED, NULL, NULL, NULL, NULL);
	}

}

int CGame::iCalculateUseSkillItemEffect(int iOwnerH, char cOwnerType, char cOwnerSkill, int iSkillNum, char cMapIndex, int dX, int dY)
{
 class CItem * pItem;
 char  cItemName[21];
 short lX, lY;
 int   iResult, iFish;

	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iOwnerH] == NULL) return 0;
		if (m_pClientList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pClientList[iOwnerH]->m_sX;
		lY = m_pClientList[iOwnerH]->m_sY;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iOwnerH] == NULL) return 0;
		if (m_pNpcList[iOwnerH]->m_cMapIndex != cMapIndex) return 0;
		lX = m_pNpcList[iOwnerH]->m_sX;
		lY = m_pNpcList[iOwnerH]->m_sY;
		break;
	}

	// ½ºÅ³ »ç¿ë ¿©ºÎ ÁÖ»çÀ§¸¦ ±¼¸°´Ù. 
	if (cOwnerSkill == 0) return 0;
	
	// ½ºÅ³ÀÌ 100ÀÌ¶ó°í ÇØµµ °¡²û ³¬½Ã¸¦ ½ÇÆÐÇÏ°Ô ÇÏ±â À§ÇØ¼­ 1D105 
	iResult = iDice(1, 105);
	if (cOwnerSkill <= iResult)	return 0;  // ½ÇÆÐ´Ù.

	// ¶¥¿¡¼­´Â ³¬½Ã°¡ ºÒ°¡´É 
	if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0;

	// ¼º°øÇßÀ¸¹Ç·Î ½ºÅ³ Ä«¿îÆ®¸¦ ¿Ã¸°´Ù.
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(iOwnerH, iSkillNum, 1);

	switch (m_pSkillConfigList[iSkillNum]->m_sType) {
	case DEF_SKILLEFFECTTYPE_TAMING:
		// ±æµéÀÌ±â ±â¼ú: dX, dY ºÎ±ÙÀÇ ¸ó½ºÅÍ¸¦ ±æµéÀÎ´Ù.
		_TamingHandler(iOwnerH, iSkillNum, cMapIndex, dX, dY);
		break;
	
	case DEF_SKILLEFFECTTYPE_GET: 
		// ¾ÆÀÌÅÛÀ» ¾ò´Â ±â¼úÀÌ¾ú´Ù. 
		ZeroMemory(cItemName, sizeof(cItemName));
		switch (m_pSkillConfigList[iSkillNum]->m_sValue1) {
		case 1:
			// ±¤¹° 
			wsprintf(cItemName, "Meat");
			break;

		case 2:
			// ¹°°í±â 
			// ³¬½ÃÀÇ °æ¿ì À§Ä¡¿Í ½Ã°£´ëÀÇ ¿µÇâ¿¡ µû¶ó ¶Ç ¼º°ø·üÀÌ ´Þ¶óÁø´Ù. 
			//if (m_pMapList[cMapIndex]->bGetIsWater(dX, dY) == FALSE) return 0; 
			
			// ±ÙÃ³¿¡ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ¹°°í±â°¡ Á¸ÀçÇÑ´Ù¸é º»°Ý³¬½Ã ¸ðµå·Î µé¾î°£´Ù.
			if (cOwnerType == DEF_OWNERTYPE_PLAYER) {
				iFish = iCheckFish(iOwnerH, cMapIndex, dX, dY);
		   		if (iFish == NULL) wsprintf(cItemName, "Fish");
			}
			else wsprintf(cItemName, "Fish");
			break;
		}

		if (strlen(cItemName) != 0) {
			
			// ³¬½Ã¿¡ ¼º°øÇß´Ù¸é ¸Þ½ÃÁö¸¦ Àü¼Û.
			if (memcmp(cItemName, "Fish", 6) == 0) {
				SendNotifyMsg(NULL, iOwnerH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
				// v1.41 ¾à°£ÀÇ °æÇèÄ¡ »ó½Â 
				m_pClientList[iOwnerH]->m_iExpStock += iDice(1,2);
			}
			
			pItem = new class CItem;
			if (pItem == NULL) return 0;
			if (_bInitItemAttr(pItem, cItemName) == TRUE) {
				// ¾ÆÀÌÅÛÀ» ³õ´Â´Ù. 
				m_pMapList[cMapIndex]->bSetItem(lX, lY, pItem);
		
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, cMapIndex,
					lX, lY, pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4
			}
		}
		break;
	}

	return 1;
}



void CGame::UseSkillHandler(int iClientH, int iV1, int iV2, int iV3)
{
 char  cOwnerType;
 short sAttackerWeapon, sOwnerH;
 int   iResult, iPlayerSkillLevel;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((iV1 < 0) || (iV1 >= DEF_MAXSKILLTYPE)) return;
	if (m_pSkillConfigList[iV1]	== NULL) return;
	// ÀÌ¹Ì ±â¼úÀ» »ç¿ëÁßÀÌ¶óµµ ¸®ÅÏ.
	if (m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] == TRUE) return;

	// v1.3 !!1ÇØÅ· °É·¯³»±â¿ë! 
	/*
	if (iV1 != 19) {
		m_pClientList[iClientH]->m_iAbuseCount++;
		if ((m_pClientList[iClientH]->m_iAbuseCount % 30) == 0) {
			wsprintf(G_cTxt, "(!) ÇØÅ· ¿ëÀÇÀÚ(%s) Skill(%d) Tries(%d)",m_pClientList[iClientH]->m_cCharName, 
				                                                       iV1, m_pClientList[iClientH]->m_iAbuseCount);
			PutLogFileList(G_cTxt);
		}
	}
	*/

	// ÇÃ·¹ÀÌ¾îÀÇ ±â¼ú¼öÁØ¿¡ µû¶ó ¼º°ø¿©ºÎ¸¦ °è»êÇÑ´Ù. 
	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[iV1];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ½ÇÆÐ´Ù. 
		// ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
		return;
	}

	// iV1ÀÌ ±â¼ú ¹øÈ£ 
	switch (m_pSkillConfigList[iV1]->m_sType) {
	case DEF_SKILLEFFECTTYPE_PRETEND:
		switch (m_pSkillConfigList[iV1]->m_sValue1) {
		case 1:
			// Á×ÀºÃ´ÇÏ±â ±â¼úÀÌ´Ù.	
			
			// v1.44 »çÅõÀåÀÌ¸é Á×ÀºÃ´ÇÏ±â ¸øÇÑ´Ù.
			if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFightZone == TRUE) {
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			//¸¸¾à ¹Ù´Ú¿¡ ½ÃÃ¼°¡ ÀÖ´Ù¸é Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ¼ö ¾ø´Ù. 
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetDeadOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			if (sOwnerH != NULL) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}
			
			// Á×ÀºÃ´ ÇÏ°íÀÚ ÇÏ´Â ÁÖº¯¿¡ ¹°Ã¼°¡ ÀÖ¾îµµ ÇÒ ¼ö ¾ø´Ù. 
			iResult = 0;
			if (m_pClientList[iClientH]->m_iAdminUserLevel <= 0) {
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY);
				iResult += sOwnerH;

				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY-1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX-1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, m_pClientList[iClientH]->m_sX+1, m_pClientList[iClientH]->m_sY+1);
				iResult += sOwnerH;
			}

			if (iResult != 0) {
				// Á×ÀºÃ´ ÇÏ±â¸¦ ÇÒ ÀÚ¸®¿¡ ½ÃÃ¼°¡ ÀÖ¾î ±â¼ú »ç¿ëÀÌ ÁßÁö µÇ¾úÀ½À» ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILLUSINGEND, NULL, NULL, NULL, NULL);
				return;
			}

			// ½ºÅ³ Ä«¿îÆ® ¿Ã¸°´Ù. <-- ³»ºÎ¿¡¼­ Ä«¿îÆÃÀ» ÇØ¾ß ¾û¶×ÇÑ ½ºÅ³ÀÌ ¿À¸£´Â °æ¿ì°¡ ¾ø´Ù. 
			CalculateSSN_SkillIndex(iClientH, iV1, 1);
			
			// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô Á×´Â µ¿ÀÛ Àü¼Û.
			sAttackerWeapon = 1;
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, 0, sAttackerWeapon, NULL);
			// Á¤»ó À§Ä¡¿¡¼­ Áö¿î´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(14, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			// Á×Àº À§Ä¡ Ç¥½Ã¸¦ ÇÑ´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetDeadOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
			break;
		}
		break;

	}

	m_pClientList[iClientH]->m_bSkillUsingStatus[iV1] = TRUE;
}

void CGame::ReqSellItemHandler(int iClientH, char cItemID, char cSellToWhom, int iNum, char * pItemName)
{
 char cItemCategory;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 BOOL   bNeutral;
 DWORD  dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2, dwMul1, dwMul2;

	// »ç¿ëÀÚÀÇ ¾ÆÀÌÅÛ ÆÈ±â ¿ä±¸.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;

	switch (cSellToWhom) {
	case 15:
		// »óÁ¡ ¾ÆÁÜ¸¶ 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
			// ÀûÇÕÇÏ´Ù. ¹«Á¶°Ç ¹Ý°ª 
			iPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2)*iNum;
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0)    iPrice = 1;
			if (iPrice > 65500) iPrice = 65500;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, (WORD)iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;
	
	case 24:
		// ´ëÀå°£ ÁÖÀÎÀÌ´Ù. ÆÈ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÇ Á¾·ù°¡ ÀûÇÕÇÑÁö¸¦ °Ë»çÇÑ´Ù. 
		cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;
		if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
			// ÀûÇÕÇÏ´Ù. °¡°ÝÀ» °è»ê Åëº¸ÇÑ´Ù.
			
			// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
			sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;

			if (sRemainLife == 0) {
				// °íÀå³­ ¾ÆÀÌÅÛÀº ÆÈ ¼ö ¾ø´Ù
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			}
			else {
				d1 = (double)sRemainLife;
				if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
					 d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
				else d2 = 1.0f;
				d3 = (d1 / d2) * 0.5f;
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
				d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
				
				iPrice = (int)d3;
				iPrice = iPrice*iNum;
				
				dwAddPrice1 = 0;
				dwAddPrice2 = 0;
				// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
					// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
					// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
					// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
					switch (dwSWEType) {
					case 6: dwMul1 = 2; break;  // °¡º­¿î 
					case 8: dwMul1 = 2; break;  // °­È­µÈ
					case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
					case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
					case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
					case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
					case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
					case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
					default: dwMul1 = 1; break;
					}

					d1 = (double)iPrice*dwMul1;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice1 = (int)(d1 + d3);
				}

				// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
				if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
					dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
					dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
					// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
					//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
					//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
					//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
					switch (dwSWEType) {
					case 1: 
					case 12: dwMul2 = 2; break;
					
					case 2:
					case 3:
					case 4:
					case 5:
					case 6:
					case 7: dwMul2 = 4; break;
					
					case 8:
					case 9:
					case 10:
					case 11: dwMul2 = 6; break;
					}
					
					d1 = (double)iPrice*dwMul2;
					switch (dwSWEValue) {
					case 1: d2 = 10.0f; break;
					case 2: d2 = 20.0f; break;
					case 3: d2 = 30.0f; break;
					case 4: d2 = 35.0f; break;
					case 5: d2 = 40.0f; break;
					case 6: d2 = 50.0f; break;
					case 7: d2 = 100.0f; break;
					case 8: d2 = 200.0f; break;
					case 9: d2 = 300.0f; break;
					case 10: d2 = 400.0f; break;
					case 11: d2 = 500.0f; break;
					case 12: d2 = 700.0f; break;
					case 13: d2 = 900.0f; break;
					default: d2 = 0.0f; break;
					}
					d3 = d1*(d2/100.0f);

					dwAddPrice2 = (int)(d1 + d3);
				}

				iPrice = iPrice + dwAddPrice1 + dwAddPrice2;

				//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
				if (bNeutral == TRUE) iPrice = iPrice/2;
				if (iPrice <= 0)    iPrice = 1;
				if (iPrice > 65500) iPrice = 65500;

				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SELLITEMPRICE, cItemID, sRemainLife, (WORD)iPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName, iNum);
			}
		}
		else SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTSELLITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
		break;

	default:
		break;
	}
}

void CGame::ReqSellItemConfirmHandler(int iClientH, char cItemID, int iNum, char * pString)
{
 class CItem * pItemGold;
 short sRemainLife;
 int   iPrice;
 double d1, d2, d3;
 char   * cp, cItemName[21], cData[120], cItemCategory;
 DWORD  * dwp, dwMul1, dwMul2, dwSWEType, dwSWEValue, dwAddPrice1, dwAddPrice2;
 WORD   * wp;
 int    iEraseReq, iRet;
 short * sp;
 BOOL   bNeutral;


	// ¾ÆÀÌÅÛÀ» ÆÈ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;
	if (iNum <= 0) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount < iNum) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// v1.42
	bNeutral = FALSE;
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) bNeutral = TRUE;

	iPrice = 0;
	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// ¹«±â·ù´Ù
  		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ °¡°ÝÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		
		if (sRemainLife <= 0) {
			// ¸Á°¡Áø ¾ÆÀÌÅÛÀº ÆÈÁö ¸øÇÑ´Ù.	
			return;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			iPrice = (short)d3;
			iPrice = iPrice*iNum;

			dwAddPrice1 = 0;
			dwAddPrice2 = 0;
			// ¾ÆÀÌÅÛ Æ¯¼ºÄ¡¿¡ µû¸¥ °¡°Ý »ó½Â 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
				switch (dwSWEType) {
				case 6: dwMul1 = 2; break;  // °¡º­¿î 
				case 8: dwMul1 = 2; break;  // °­È­µÈ
				case 5: dwMul1 = 3; break;  // ¹ÎÃ¸ÀÇ
				case 1: dwMul1 = 4; break;  // ÇÊ»ìÀÇ 
				case 7: dwMul1 = 5; break;  // ¿¹¸®ÇÑ
				case 2: dwMul1 = 6; break;  // Áßµ¶ÀÇ
				case 3: dwMul1 = 15; break; // Á¤ÀÇÀÇ 
				case 9: dwMul1 = 20; break; // °í´ë¹®¸í 
				default: dwMul1 = 1; break;
				}

				d1 = (double)iPrice*dwMul1;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice1 = (int)(d1 + d3);
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				switch (dwSWEType) {
				case 1: 
				case 12: dwMul2 = 2; break;
					
				case 2:
				case 3:
				case 4:
				case 5:
				case 6:
				case 7: dwMul2 = 4; break;
					
				case 8:
				case 9:
				case 10:
				case 11: dwMul2 = 6; break;
				}
					
				d1 = (double)iPrice*dwMul2;
				switch (dwSWEValue) {
				case 1: d2 = 10.0f; break;
				case 2: d2 = 20.0f; break;
				case 3: d2 = 30.0f; break;
				case 4: d2 = 35.0f; break;
				case 5: d2 = 40.0f; break;
				case 6: d2 = 50.0f; break;
				case 7: d2 = 100.0f; break;
				case 8: d2 = 200.0f; break;
				case 9: d2 = 300.0f; break;
				case 10: d2 = 400.0f; break;
				case 11: d2 = 500.0f; break;
				case 12: d2 = 700.0f; break;
				case 13: d2 = 900.0f; break;
				default: d2 = 0.0f; break;
				}
				d3 = d1*(d2/100.0f);
				dwAddPrice2 = (int)(d1 + d3);
			}

			iPrice = iPrice + dwAddPrice1 + dwAddPrice2;

			//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
			if (bNeutral == TRUE) iPrice = iPrice/2;
			if (iPrice <= 0) iPrice = 1;
			if (iPrice > 60000) iPrice = 60000;

			// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

			// ÆÈ ¾ÆÀÌÅÛÀ» »èÁ¦ 
			if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
				(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
				// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
				// v1.41 !!!
				SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
			}
			else ItemDepleteHandler(iClientH, cItemID, FALSE);
		}
	}
	else 
	if ( (cItemCategory >= 11) && (cItemCategory <= 50) ) {
		// ½ÄÇ°, ÀâÈ­µîÀÇ ¹Ý°ª¹°°Çµé 
		iPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice/2; 
		iPrice = iPrice*iNum;

		//v1.42 Áß¸³ÀÎ °æ¿ì ¹ÝÀÇ ¹Ý°ª.
		if (bNeutral == TRUE) iPrice = iPrice/2;
		if (iPrice <= 0) iPrice = 1;
	
		// ¾ÆÀÌÅÛÀ» ÆÈ¾Ò´Ù´Â ¸Þ½ÃÁö Àü¼Û (´ÙÀÌ¾ó·Î±× ¹Ú½º ºñÈ°¼ºÈ­¿ë)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMSOLD, cItemID, NULL, NULL, NULL);

		// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó ÀûÀýÇÑ Ã³¸®¸¦ ÇÑ´Ù.
		if ((m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
			(m_pClientList[iClientH]->m_pItemList[cItemID]->m_cItemType == DEF_ITEMTYPE_ARROW)) {
			// ¼ö·® °³³äÀÌ ÀÖ´Ù¸é °¹¼ö¸¦ ÁÙÀÎ´Ù.
			// v1.41 !!!
			SetItemCount(iClientH, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_dwCount - iNum);
		}
		else ItemDepleteHandler(iClientH, cItemID, FALSE);
	}

	// Gold¸¦ Áõ°¡½ÃÅ²´Ù. ¸¸¾à ÆÇ °¡°ÝÀÌ 0 È¤Àº ¸¶ÀÌ³Ê½ºÀÌ¸é ±ÝÀ» ÁÖÁö ¾Ê´Â´Ù.
	if (iPrice <= 0) return;

	pItemGold = new class CItem;
	ZeroMemory(cItemName, sizeof(cItemName));
	wsprintf(cItemName, "Gold");
	_bInitItemAttr(pItemGold, cItemName);
	
	pItemGold->m_dwCount = iPrice;
	
	if (_bAddClientItemList(iClientH, pItemGold, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		*cp = 1;
		cp++;
		
		memcpy(cp, pItemGold->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItemGold->m_dwCount;
		cp += 4;
		
		*cp = pItemGold->m_cItemType;
		cp++;
		
		*cp = pItemGold->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sLevelLimit;
		cp += 2;
		
		*cp = pItemGold->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItemGold->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItemGold->m_sSpriteFrame;
		cp += 2;

		*cp = pItemGold->m_cItemColor;
		cp++;

		*cp = (char)pItemGold->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItemGold->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItemGold->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
		
		if (iEraseReq == 1)
			delete pItemGold;
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			break;
		}
	}
	else {
		// Áß·® ÃÊ°úµîÀÇ ¹®Á¦·Î Ãß°¡ ½ÇÆÐ.
		// ¹ÞÁö ¸øÇßÀ¸¹Ç·Î ¹Ù´Ú¿¡ ¶³¾îÁø´Ù. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			m_pClientList[iClientH]->m_sY, pItemGold);
		
		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			pItemGold->m_sSprite, pItemGold->m_sSpriteFrame, pItemGold->m_cItemColor); // v1.4 color

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);
		
		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}

void CGame::ReqRepairItemHandler(int iClientH, char cItemID, char cRepairWhom, char * pString)
{
 char cItemCategory;
 short sRemainLife, sPrice;
 double d1, d2, d3;

	// ¾ÆÀÌÅÛÀ» °íÄ¡°Ú´Ù´Â ¿ä±¸.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( (cItemCategory >= 1) && (cItemCategory <= 10) ) {
		// ¹«±â·ù´Ù
  		
		// ¸¸¾à ¹«±â¸¦ ´ëÀå°£ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 24) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else if ( ((cItemCategory >= 43) && (cItemCategory <= 50)) || ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ³¬½Ã´ë, °î±ªÀÌ µî°ú °°Àº ºñ¹«±â·ù ¼ö¸®°¡´É ¾ÆÀÌÅÛ. ¿Ê, ºÎÃ÷·ù
		
		// ¸¸¾à »óÁ¡ ÁÖÀÎÀÌ ¾Æ´Ñ ÀÌ¿¡°Ô °íÃÄ´Þ¶ó°í ÇÑ´Ù¸é ÇÒ ¼ö ¾ø´Ù. 
		if (cRepairWhom != 15) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 2, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
			return;
		}
		
		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)sRemainLife;
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_REPAIRITEMPRICE, cItemID, sRemainLife, sPrice, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
	else {
		// °íÄ¥¼ö ¾ø´Â ¾ÆÀÌÅÛÀÌ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTREPAIRITEM, cItemID, 1, NULL, m_pClientList[iClientH]->m_pItemList[cItemID]->m_cName);
	}
}

void CGame::ReqRepairItemCofirmHandler(int iClientH, char cItemID, char * pString)
{
 short    sRemainLife, sPrice;
 char   * cp, cItemCategory, cData[120];
 double   d1, d2, d3;
 DWORD  * dwp, dwGoldCount;
 WORD   * wp;
 int      iRet, iGoldWeight;

	// ¾ÆÀÌÅÛÀ» ¼ö¸®ÇÏ°Ú´Ù´Â °ÍÀÌ °áÁ¤µÇ¾ú´Ù.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	if ((cItemID < 0) || (cItemID >= 50)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemID] == NULL) return;

	//testcode
	//PutLogList("Repair!");

	cItemCategory = m_pClientList[iClientH]->m_pItemList[cItemID]->m_cCategory;

	// ¾ÆÀÌÅÛÀÇ Á¾·ù¿¡ µû¶ó °¡°Ý °è»ê.
  	if ( ((cItemCategory >= 1) && (cItemCategory <= 10)) || ((cItemCategory >= 43) && (cItemCategory <= 50)) || 
		 ((cItemCategory >= 11) && (cItemCategory <= 12))) {
		// ¹«±â·ù È¤Àº ³¬½Ã´ë, °î±ªÀÌ¿Í °°Àº ¾ÆÀÌÅÛ, ¿Ê, ½Å¹ß 

  		// ¿ø·¡ ¾ÆÀÌÅÛÀÇ ¼ö¸í°ú ºñ±³ÇØ¼­ °¨°¡ »ó°¢À» °è»ê, ¾ÆÀÌÅÛÀÇ ¼ö¸® ºñ¿ëÀ» ¸Å±ä´Ù.
		sRemainLife = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan;
		if (sRemainLife == 0) {
			// ¿ÏÀüÈ÷ ¸Á°¡Áø °ÍÀÌ¶ó¸é ¿ø·¡°¡°ÝÀÇ Àý¹ÝÀÌ µç´Ù. 
			sPrice = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2;
		}
		else {
			d1 = (double)abs(sRemainLife);
			if (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan != 0)
				d2 = (double)abs(m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan);
			else d2 = 1.0f;
			d3 = (d1 / d2) * 0.5f;
			d2 = (double)m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice; // ¿ø·¡ °¡°Ý 
			d3 = d3 * d2; // Ãß»êµÈ °¡°Ý 
			
			sPrice = (m_pClientList[iClientH]->m_pItemList[cItemID]->m_wPrice / 2) - (short)d3;
		}
		
		// sPrice¸¸Å­ÀÇ µ·ÀÌ µÇ¸é °íÄ¥ ¼ö ÀÖÀ¸³ª ºÎÁ·ÇÏ¸é °íÄ¥ ¼ö ¾ø´Ù. 
		dwGoldCount = dwGetItemCount(iClientH, "Gold");
		
		if ( dwGoldCount < (DWORD)sPrice ) {
			// ÇÃ·¹ÀÌ¾î°¡ °®°íÀÖ´Â Gold°¡ ¾ÆÀÌÅÛ ¼ö¸® ºñ¿ë¿¡ ºñÇØ Àû´Ù. °íÄ¥ ¼ö ¾øÀ½.
			dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
			*dwp = MSGID_NOTIFY;
			wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
			*wp  = DEF_NOTIFY_NOTENOUGHGOLD;
			cp   = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
			*cp  = cItemID;
			cp++;
			
			iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 7);
			switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
				DeleteClient(iClientH, TRUE, TRUE);
				return;
			}
			return;
		}
		else {
			//µ·ÀÌ ÃæºÐÇÏ´Ù. °íÄ¥ ¼ö ÀÖ´Ù. 
			
			// ¾ÆÀÌÅÛÀÇ ¼ö¸íÀ» ´Ã¸®°í Åëº¸ÇÑ´Ù. !BUG POINT À§Ä¡°¡ Áß¿äÇÏ´Ù. ¸ÕÀú ¼ö¸íÀ» ´Ã¸®°í µ·ÀÇ Ä«¿îÆ®¸¦ ³·Ãá´Ù.
			m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan = m_pClientList[iClientH]->m_pItemList[cItemID]->m_wMaxLifeSpan;
		 	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMREPAIRED, cItemID, m_pClientList[iClientH]->m_pItemList[cItemID]->m_wCurLifeSpan, NULL, NULL);
			
			iGoldWeight = SetItemCount(iClientH, "Gold", dwGoldCount - sPrice );
			
			// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
			iCalcTotalWeight(iClientH);

			//v1.4 ¸¶À»ÀÇ ÀÚ±Ý¿¡ ´õÇÑ´Ù. 
			m_stCityStatus[m_pClientList[iClientH]->m_cSide].iFunds += sPrice;
		}
	}
	else {
		// °íÄ¥ ÇÊ¿ä°¡ ¾ø´Â ¾ÆÀÌÅÛ 
		// ÇØÅ·ÀÌ³ª ¹ö±×¿¡ ÀÇÇÑ °ÍÀÏµí 
	}
}

int CGame::iCalcTotalWeight(int iClientH)
{
 register int i, iWeight;
 short sItemIndex;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Âø¿ëÇÏÁö ¾Ê¾Æµµ È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ È¿°ú. ¼ÒÁöÇÏ°í ÀÖ¾îµµ È¿°ú°¡ ÀÖ±â ¶§¹®¿¡ ¿©±â¼­ °Ë»ç.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// ¼ö¸íÀÌ ÀÖ¾î¾ß È¿°ú°¡ ÀÖ´Ù.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}

	iWeight = 0;
	for (i = 0; i < DEF_MAXITEMS; i++)
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		
		iWeight += iGetItemWeight(m_pClientList[iClientH]->m_pItemList[i], m_pClientList[iClientH]->m_pItemList[i]->m_dwCount);
	}

	m_pClientList[iClientH]->m_iCurWeightLoad = iWeight;

	return iWeight;	
}

void CGame::CheckAndNotifyPlayerConnection(int iClientH, char * pMsg, DWORD dwSize)
{
 char   seps[] = "= \t\n";
 char   * token, * cp, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;
 WORD * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	if (strlen(token) > 10) 
		 memcpy(cName, token, 10);	
	else memcpy(cName, token, strlen(token));

	// cNameÀÇ ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î°¡ Á¢¼ÓÁßÀÎÁö Ã£´Â´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if ((m_pClientList[i] != NULL) && (memcmp(cName, m_pClientList[i]->m_cCharName, 10) == 0)) {
		// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, m_pClientList[i]->m_cCharName);

		delete pStrTok;
		return;
	}

	//SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	// ÇöÀç ¼­¹ö¿¡ Ä³¸¯ÀÌ Á¢¼ÓÇÏ°í ÀÖÁö ¾Ê´Ù. ´Ù¸¥ ¼­¹ö¿¡ Á¢¼Ó ¿©ºÎ¸¦ ¹¯´Â´Ù.

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_REQUEST_FINDCHARACTER;
	cp++;

	wp = (WORD *)cp;
	*wp = m_wServerID_GSS;
	cp += 2;

	wp = (WORD *)cp;
	*wp = iClientH;
	cp += 2;

	memcpy(cp, cName, 10);
	cp += 10;

	bStockMsgToGateServer(cBuff, 15);

	delete pStrTok;
}



void CGame::ToggleWhisperPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if (dwMsgSize <= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token == NULL) {
		// ±Ó¼Ó¸» »ó´ë°¡ ÁöÁ¤µÇÁö ¾Ê¾Ò´Ù. ±Ó¼Ó¸» ¸ðµå¸¦ ÇØÁ¦ÇÑ´Ù. 
		m_pClientList[iClientH]->m_iWhisperPlayerIndex = -1;
		// ±Ó¼Ó¸» »óÅÂ°¡ ÇØÁ¦µÇ¾úÀ½À» Åëº¸. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEOFF, NULL, NULL, NULL, cName);
	}
	else {
		if (strlen(token) > 10)	
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù. 
			// ÀÚ±â ÀÚ½ÅÀÌ¶ó¸é ÇÒ´çÇÏÁö ¾Ê´Â´Ù.
			if (i == iClientH) {
				delete pStrTok;
				return;
			}
			//ÀÎµ¦½º¸¦ ÇÒ´ç 
			m_pClientList[iClientH]->m_iWhisperPlayerIndex = i;
		   	// ±Ó¼Ó¸» »óÅÂ°¡ ¼³Á¤µÇ¾úÀ½À» Åëº¸ 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_WHISPERMODEON, NULL, NULL, NULL, cName);
			delete pStrTok;
			return;
		}
		
		// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î°¡ ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
 
	delete pStrTok;
}


void CGame::SetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char cTemp[256];
 register int i;


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize - 7) <= 0) return;

	ZeroMemory(cTemp, sizeof(cTemp));
	memcpy(cTemp, (pMsg + 7), dwMsgSize - 7);
	
	// °ø¹é¶õÀ» ¾ð´õ¹Ù·Î ¹Ù²Û´Ù. 
	for (i = 0; i < 256; i++)
		if (cTemp[i] == ' ') cTemp[i] = '_';

	// ¿¡·¯ ¹æÁö ÄÚµå 
	cTemp[255] = NULL;

	ZeroMemory(m_pClientList[iClientH]->m_cProfile, sizeof(m_pClientList[iClientH]->m_cProfile));
	strcpy(m_pClientList[iClientH]->m_cProfile, cTemp);
}

void CGame::GetPlayerProfile(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256], cBuff2[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ð ÇÁ·ÎÇÊÀ» ¾ò°íÀÚ ÇÏ´Â »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
		
			ZeroMemory(cBuff2, sizeof(cBuff2));
			wsprintf(cBuff2, "%s´ÔÀÇ ÇÁ·ÎÇÊ: %s", cName, m_pClientList[i]->m_cProfile);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERPROFILE, NULL, NULL, NULL, cBuff2);

			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}


void CGame::___RestorePlayerCharacteristics(int iClientH)
{
	int iStr, iDex, iInt, iVit, iMag, iCharisma;
	int iOriginalPoint, iCurPoint, iVerifyPoint, iToBeRestoredPoint;
	int iMax, iA, iB;
	BOOL bFlag;
	char cTxt[120];
	return;
	if (m_pClientList[iClientH] == NULL) return;

	// ¸ÕÀú °ªÀ» ¹é¾÷ÇÑ´Ù. 
	iStr = m_pClientList[iClientH]->m_iStr;
	iDex = m_pClientList[iClientH]->m_iDex;
	iInt = m_pClientList[iClientH]->m_iInt;
	iVit = m_pClientList[iClientH]->m_iVit;
	iMag = m_pClientList[iClientH]->m_iMag;
	iCharisma = m_pClientList[iClientH]->m_iCharisma;


	iCurPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
		m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
		m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

	iOriginalPoint = (m_pClientList[iClientH]->m_iLevel - 1)*3 + 70;

	iToBeRestoredPoint = iOriginalPoint - iCurPoint;

	// º¹±¸ÇÒ ÇÊ¿ä°¡ ¾ø´Ù¸é ±ÍÈ¯.
	if (iToBeRestoredPoint == 0) return;

	if (iToBeRestoredPoint > 0) {
		// ÀÌÁ¦ iToBeRestoredPoint ¸¸Å­ÀÇ Æ÷ÀÎÆ®¸¦ º¹±¸ÇÑ´Ù. 
		// ¸ÕÀú 10 ÀÌÇÏÀÇ Æ÷ÀÎÆ®°¡ ÀÖ´Ù¸é ¿ì¼±ÀûÀ¸·Î Ã¤¿î´Ù. 
		while (1) {
			bFlag = FALSE;

			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < 10)) {
				m_pClientList[iClientH]->m_iStr++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < 10)) {
				m_pClientList[iClientH]->m_iMag++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < 10)) {
				m_pClientList[iClientH]->m_iInt++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < 10)) {
				m_pClientList[iClientH]->m_iDex++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iVit < 10)) {
				m_pClientList[iClientH]->m_iVit++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}
			if ((iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iCharisma < 10)) {
				m_pClientList[iClientH]->m_iCharisma++;
				iToBeRestoredPoint--;
				bFlag = TRUE;
			}

			if (bFlag == FALSE)          break;
			if (iToBeRestoredPoint <= 0) break; 
		}

		// ¸Ç¼Õ °ÝÅõ ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, StrÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[5];

		if (m_pClientList[iClientH]->m_iStr < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iStr < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iStr == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ¹«±â »ç¿ë ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, Dex°¡ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[7];
		iB = m_pClientList[iClientH]->m_cSkillMastery[8];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;
		iA = m_pClientList[iClientH]->m_cSkillMastery[9];
		if (iA > iMax) iMax = iA;
		iA = m_pClientList[iClientH]->m_cSkillMastery[6];
		if (iA > iMax) iMax = iA;


		if (m_pClientList[iClientH]->m_iDex < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iDex < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iDex == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// Á×ÀºÃ´ÇÏ±â ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, IntÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iMax = m_pClientList[iClientH]->m_cSkillMastery[19];

		if (m_pClientList[iClientH]->m_iInt < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iInt < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iInt == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ¸¶¹ý ½ºÅ³ÀÇ ÃÖ´ëÄ¡´Â iMax, MagÀÌ iMax/2º¸´Ù ³·´Ù¸é ±×¸¸Å­ ¿Ã¸°´Ù. 
		iA = m_pClientList[iClientH]->m_cSkillMastery[3];
		iB = m_pClientList[iClientH]->m_cSkillMastery[4];
		if (iA > iB) 
			iMax = iA;
		else iMax = iB;

		if (m_pClientList[iClientH]->m_iMag < (iMax/2)) {

			while (1) {
				if ( (iToBeRestoredPoint > 0) && (m_pClientList[iClientH]->m_iMag < (iMax/2)) ) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}

				if (m_pClientList[iClientH]->m_iMag == (iMax/2)) break;
				if (iToBeRestoredPoint <= 0) break; 
			}
		}

		// ³²Àº Æ÷ÀÎÆ®¸¦ ·£´ýÇÏ°Ô ¿Ã¸°´Ù.
		while (iToBeRestoredPoint != 0) {
			switch (iDice(1,6)) {
			case 1:
				if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iStr++;
					iToBeRestoredPoint--;
				}
				break;
			case 2:
				if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iVit++;
					iToBeRestoredPoint--;
				}
				break;
			case 3:
				if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iDex++;
					iToBeRestoredPoint--;
				}
				break;
			case 4:
				if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iMag++;
					iToBeRestoredPoint--;
				}
				break;
			case 5:
				if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iInt++;
					iToBeRestoredPoint--;
				}
				break;
			case 6:
				if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
					m_pClientList[iClientH]->m_iCharisma++;
					iToBeRestoredPoint--;
				}
				break;
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Minor) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// ¿¡·¯´Ù. ÀÌÀü °ªÀ¸·Î º¹±¸.
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Minor) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
	else {
		// ÇØÅ·ÀÌ³ª ¿¡·¯¿¡ ÀÇÇØ¼­ Æ¯¼ºÄ¡°¡ ¿À¹öµÈ °æ¿ìÀÌ´Ù. ¿À¹öµÈ Æ÷ÀÎÆ®¸¸Å­ »«´Ù. iToBeRestoredPoint°¡ ¸¶ÀÌ³Ê½º»óÅÂ! 

		// ¸ÕÀú Æ¯¼ºÄ¡ Á¦ÇÑÄ¡¸¦ ¿À¹öÇÑ °ªÀ» »«´Ù.
		while (1) {
			bFlag = FALSE;
			if (m_pClientList[iClientH]->m_iStr > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iStr--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iDex > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iDex--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iVit > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iVit--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iInt > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iInt--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iMag > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iMag--;
				iToBeRestoredPoint++;
			}

			if (m_pClientList[iClientH]->m_iCharisma > DEF_CHARPOINTLIMIT) {
				bFlag = TRUE;
				m_pClientList[iClientH]->m_iCharisma--;
				iToBeRestoredPoint++;
			}

			if (bFlag == FALSE)	break;
			if (iToBeRestoredPoint >= 0) break;
		}

		if (iToBeRestoredPoint < 0) {
			// ³²Àº Æ÷ÀÎÆ® ¸¸Å­ ·£´ýÇÏ°Ô ¼±ÅÃµÈ Æ¯¼ºÄ¡ÀÇ °ªÀ» ³»¸°´Ù.
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr > 10) {
						m_pClientList[iClientH]->m_iStr--;
						iToBeRestoredPoint++;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit > 10) {
						m_pClientList[iClientH]->m_iVit--;
						iToBeRestoredPoint++;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex > 10) {
						m_pClientList[iClientH]->m_iDex--;
						iToBeRestoredPoint++;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag > 10) {
						m_pClientList[iClientH]->m_iMag--;
						iToBeRestoredPoint++;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt > 10) {
						m_pClientList[iClientH]->m_iInt--;
						iToBeRestoredPoint++;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma > 10) {
						m_pClientList[iClientH]->m_iCharisma--;
						iToBeRestoredPoint++;
					}
					break;
				}
			}
		}
		else {
			// °è»êÀ» Çß´õ´Ï ´Ù½Ã °ªÀÌ ¿À¹öµÇ¾ú´Ù. ÀÌ·²¼ö°¡ ÀÖÀ»±î?
			while (iToBeRestoredPoint != 0) {
				switch (iDice(1,6)) {
				case 1:
					if (m_pClientList[iClientH]->m_iStr < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iStr++;
						iToBeRestoredPoint--;
					}
					break;
				case 2:
					if (m_pClientList[iClientH]->m_iVit < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iVit++;
						iToBeRestoredPoint--;
					}
					break;
				case 3:
					if (m_pClientList[iClientH]->m_iDex < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iDex++;
						iToBeRestoredPoint--;
					}
					break;
				case 4:
					if (m_pClientList[iClientH]->m_iMag < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iMag++;
						iToBeRestoredPoint--;
					}
					break;
				case 5:
					if (m_pClientList[iClientH]->m_iInt < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iInt++;
						iToBeRestoredPoint--;
					}
					break;
				case 6:
					if (m_pClientList[iClientH]->m_iCharisma < DEF_CHARPOINTLIMIT) {
						m_pClientList[iClientH]->m_iCharisma++;
						iToBeRestoredPoint--;
					}
					break;
				}
			}
		}

		// º¹±¸°¡ ¼º°øÀûÀ¸·Î µÇ¾ú´ÂÁö È®ÀÎÇÑ´Ù. 
		iVerifyPoint = m_pClientList[iClientH]->m_iStr + m_pClientList[iClientH]->m_iInt + 
			m_pClientList[iClientH]->m_iVit + m_pClientList[iClientH]->m_iDex + 
			m_pClientList[iClientH]->m_iMag + m_pClientList[iClientH]->m_iCharisma;

		if (iVerifyPoint != iOriginalPoint)	{
			wsprintf(cTxt, "(T_T) RestorePlayerCharacteristics(Over) FAIL! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);

			// ¿¡·¯´Ù. ±×·¯³ª ÀÌÀü °ªÀ¸·Î º¹±¸ÇÒ ¼ö´Â ¾ø´Ù. ÃÊ°úÇÏ¹Ç·Î
			/*
			m_pClientList[iClientH]->m_iStr = iStr;
			m_pClientList[iClientH]->m_iDex = iDex;
			m_pClientList[iClientH]->m_iInt = iInt;
			m_pClientList[iClientH]->m_iVit = iVit;
			m_pClientList[iClientH]->m_iMag = iMag;
			m_pClientList[iClientH]->m_iCharisma = iCharisma;
			*/
		}
		else {
			wsprintf(cTxt, "(^o^) RestorePlayerCharacteristics(Over) SUCCESS! Player(%s)-(%d/%d)", m_pClientList[iClientH]->m_cCharName, iVerifyPoint, iOriginalPoint);
			PutLogList(cTxt);
		}
	}
}

void CGame::CalcTotalItemEffect(int iClientH, int iEquipItemID, BOOL bNotify)
{
 register short sItemIndex;
 int  i, iArrowIndex, iPrevSAType;
 char cEquipPos;
 double dV1, dV2, dV3;
 DWORD  dwSWEType, dwSWEValue;
 short  sTemp;

   	if (m_pClientList[iClientH] == NULL) return;

	if ( (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]   != -1) &&
		 (m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_TWOHAND] != -1) ) {
		
		// Àß¸øµÈ ¹«±â ÀåÂø Á¶ÇÕÀÌ´Ù. µÑ Áß ÇÏ³ª¸¦ ³»·Á ³õ´Â´Ù. 
		if (m_pClientList[iClientH]->m_pItemList[ m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] ] != NULL) {
			// ÇÑ¼Õ °ËÀÇ ÀåÂø »óÅÂ¸¦ ÇØÁ¦ÇÑ´Ù. 
			m_pClientList[iClientH]->m_bIsItemEquipped[m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND]] = FALSE;
			m_pClientList[iClientH]->m_sItemEquipmentStatus[DEF_EQUIPPOS_RHAND] = -1;
		}
	}

	m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
	m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;  

	m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
	m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
	m_pClientList[iClientH]->m_cAttackBonus_L      = 0;

	m_pClientList[iClientH]->m_iHitRatio = 0;
	//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM = 0;
	//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  = 0;

	m_pClientList[iClientH]->m_iDefenseRatio = m_pClientList[iClientH]->m_iDex * 2;

	//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM = 0;
	//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  = 0;
			
	m_pClientList[iClientH]->m_iDamageAbsorption_Shield = 0;
	
	for (i = 0; i < DEF_MAXITEMEQUIPPOS; i++)
	m_pClientList[iClientH]->m_iDamageAbsorption_Armor[i]  = 0;

	m_pClientList[iClientH]->m_iManaSaveRatio  = 0;
	m_pClientList[iClientH]->m_iAddResistMagic = 0;

	m_pClientList[iClientH]->m_iAddPhysicalDamage = 0;
	m_pClientList[iClientH]->m_iAddMagicalDamage  = 0;

	m_pClientList[iClientH]->m_bIsLuckyEffect  = FALSE;
	m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = -1;
	m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = 0;

	m_pClientList[iClientH]->m_iAddAbsAir   = 0;	// ¼Ó¼ºº° ´ë¹ÌÁö Èí¼ö
	m_pClientList[iClientH]->m_iAddAbsEarth = 0;
	m_pClientList[iClientH]->m_iAddAbsFire  = 0;
	m_pClientList[iClientH]->m_iAddAbsWater = 0;

	m_pClientList[iClientH]->m_iCustomItemValue_Attack  = 0;
	m_pClientList[iClientH]->m_iCustomItemValue_Defense = 0;

	m_pClientList[iClientH]->m_iMinAP_SM = 0;
	m_pClientList[iClientH]->m_iMinAP_L  = 0;

	m_pClientList[iClientH]->m_iMaxAP_SM = 0;
	m_pClientList[iClientH]->m_iMaxAP_L  = 0;

	m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = 0;	// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ
	m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = 0;	// Èñ±Í ¾ÆÀÌÅÛ È¿°ú °ª

	m_pClientList[iClientH]->m_iAddHP = m_pClientList[iClientH]->m_iAddSP = m_pClientList[iClientH]->m_iAddMP = 0; 
	m_pClientList[iClientH]->m_iAddAR = m_pClientList[iClientH]->m_iAddPR = m_pClientList[iClientH]->m_iAddDR = 0;
	m_pClientList[iClientH]->m_iAddMR = m_pClientList[iClientH]->m_iAddAbsPD = m_pClientList[iClientH]->m_iAddAbsMD = 0;
	m_pClientList[iClientH]->m_iAddCD = m_pClientList[iClientH]->m_iAddExp = m_pClientList[iClientH]->m_iAddGold = 0;	
	
	iPrevSAType = m_pClientList[iClientH]->m_iSpecialAbilityType;

	m_pClientList[iClientH]->m_iSpecialAbilityType     = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityLastSec  = 0;
	m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = 0;
	
	m_pClientList[iClientH]->m_iAlterItemDropIndex = -1;
	// Âø¿ëÇÏÁö ¾Ê¾Æµµ È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ.
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  (m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) {
		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		case DEF_ITEMEFFECTTYPE_ALTERITEMDROP:
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan > 0) {
				// ¼ö¸íÀÌ ÀÖ¾î¾ß È¿°ú°¡ ÀÖ´Ù.
				m_pClientList[iClientH]->m_iAlterItemDropIndex = sItemIndex;
			}
			break;
		}
	}
	
	// Âø¿ëÀ» ÇØ¾ß È¿°ú°¡ ÀÖ´Â ¾ÆÀÌÅÛ 
	for (sItemIndex = 0; sItemIndex < DEF_MAXITEMS; sItemIndex++)
	if  ((m_pClientList[iClientH]->m_pItemList[sItemIndex] != NULL) && 
		 (m_pClientList[iClientH]->m_bIsItemEquipped[sItemIndex] == TRUE)) {

		cEquipPos = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos;

		switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
		
		case DEF_ITEMEFFECTTYPE_MAGICDAMAGESAVE:
			// ¸¶¹ý µ¥¹ÌÁö Àý°¨ ¾ÆÀÌÅÛ. ÀÎµ¦½º¸¦ ÀúÀåÇÑ´Ù.
			m_pClientList[iClientH]->m_iMagicDamageSaveItemIndex = sItemIndex;
			break;
		
		case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
		case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
		case DEF_ITEMEFFECTTYPE_ATTACK:
			// ¹«±â ÀåÂø È¿°ú
			m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
			m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
			m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue3;
			m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
			m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue5;
			m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue6;
						
			// °ø°Ý¹«±âÀÇ ÇØ´ç ½ºÅ³¸¸Å­ÀÇ ¸íÁß·üÀ» ´õÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«±âÀÇ °ø°Ý´ë»óº° ¸íÁß·ü °¡°¨Ä¡¸¦ ´õÇÑ´Ù.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			// ÇÃ·¹ÀÌ¾î°¡ »ç¿ëÇÏ´Â ¹«±âÀÇ ½ºÅ³À» ÀúÀåÇÑ´Ù. 
			m_pClientList[iClientH]->m_sUsingWeaponSkill = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill;
			
			// v1.41 Custom-Made ¾ÆÀÌÅÛÀÌ¶ó¸é È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Attack += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				// ¿¡·¯ º¸Á¤¿ë 
				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = 100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < -100)
					m_pClientList[iClientH]->m_iCustomItemValue_Attack = -100;

				if (m_pClientList[iClientH]->m_iCustomItemValue_Attack > 0) {
					// ¾ç¼ö¸é ¹«±âÀÇ Å¸°ÝÄ¡ ÃÖ¼Ò°ªÀÌ ÃÖ´ë 5±îÁö ¿Ã¶ó°£´Ù.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMinAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM + 
														   m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMinAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L + 
														   m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;

					// ¼öÄ¡ Á¶Á¤ 
					if (m_pClientList[iClientH]->m_iMinAP_SM < 1) m_pClientList[iClientH]->m_iMinAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMinAP_L < 1)  m_pClientList[iClientH]->m_iMinAP_L = 1;

					// ÃÖ¼Ò°ªÀÌ ÃÖ´ë°ªº¸´Ù Å©¸é ÃÖ´ë°ª¸¸Å­ 
					if (m_pClientList[iClientH]->m_iMinAP_SM > (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMinAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMinAP_L > (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMinAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MinAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMinAP_SM, m_pClientList[iClientH]->m_iMinAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
				else if (m_pClientList[iClientH]->m_iCustomItemValue_Attack < 0) {
					// À½¼ö¸é ¹«±âÀÇ Å¸°ÝÄ¡ ÃÖ´ë°ªÀÌ ÃÖ´ë 5±îÁö ³»·Á°£´Ù.
					dV2 = (double)m_pClientList[iClientH]->m_iCustomItemValue_Attack;
					dV1 = (dV2/100.0f)*(5.0f);
					m_pClientList[iClientH]->m_iMaxAP_SM = m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM 
														   + m_pClientList[iClientH]->m_cAttackBonus_SM + (int)dV1;
					
					m_pClientList[iClientH]->m_iMaxAP_L  = m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L 
														   + m_pClientList[iClientH]->m_cAttackBonus_L + (int)dV1;
					
					// ¼öÄ¡ Á¶Á¤ 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < 1) m_pClientList[iClientH]->m_iMaxAP_SM = 1;
					if (m_pClientList[iClientH]->m_iMaxAP_L < 1)  m_pClientList[iClientH]->m_iMaxAP_L = 1;

					// ÃÖ´ë°ªÀÌ ÃÖ¼Ò°ªº¸´Ù ÀÛÀ¸¸é ÃÖ¼Ò°ª¸¸Å­ 
					if (m_pClientList[iClientH]->m_iMaxAP_SM < (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM)) 
						m_pClientList[iClientH]->m_iMaxAP_SM = (m_pClientList[iClientH]->m_cAttackDiceThrow_SM * m_pClientList[iClientH]->m_cAttackDiceRange_SM + m_pClientList[iClientH]->m_cAttackBonus_SM);
					
					if (m_pClientList[iClientH]->m_iMaxAP_L < (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L)) 
						m_pClientList[iClientH]->m_iMaxAP_L = (m_pClientList[iClientH]->m_cAttackDiceThrow_L * m_pClientList[iClientH]->m_cAttackDiceRange_L + m_pClientList[iClientH]->m_cAttackBonus_L);
					
					//testcode
					//wsprintf(G_cTxt, "MaxAP: %d %d +(%d)", m_pClientList[iClientH]->m_iMaxAP_SM, m_pClientList[iClientH]->m_iMaxAP_L, (int)dV1);
					//PutLogList(G_cTxt);
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Main È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ 10-¸¶¹ý ¼º°øÀÇ
				m_pClientList[iClientH]->m_iSpecialWeaponEffectType  = (int)dwSWEType;	
				m_pClientList[iClientH]->m_iSpecialWeaponEffectValue = (int)dwSWEValue;

				switch (dwSWEType) {
				case 7: // ¿¹¸®ÇÑ 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // °í´ë¹®¸íÀÇ
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
			}

			// ÀÏ¹Ý °ø°Ý ÀÌ¿ÜÀÇ È¿°ú¸¦ ¼³Á¤.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_ATTACK_MAXHPDOWN:
				// ÃÖ´ë HP °¨¼Ò È¿°ú
				m_pClientList[iClientH]->m_iSideEffect_MaxHPdown = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE:
				// ¸¶³ª Àý¾à È¿°ú: ¸¶³ª Àý°¨·üÀº ÃÖ´ë 80%
				m_pClientList[iClientH]->m_iManaSaveRatio    += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue4;
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_DEFENSE:
				// Ãß°¡ ¹°¸® ¹æ¾î ´É·Â È¿°ú 
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[DEF_EQUIPPOS_BODY] += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				break;

			case DEF_ITEMEFFECTTYPE_ATTACK_SPECABLTY:
				// Æ¯¼ö ´É·Â Á¾·ù
				m_pClientList[iClientH]->m_iSpecialAbilityType    = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Æ¯¼ö ´É·Â Áö¼Ó ½Ã°£
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// ÀåÂø À§Ä¡ ±â¾ïÇØ ³õ´Â´Ù.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
								
				// Æ¯¼ö ´É·Â ¼³Á¤µÊÀ» ¾Ë·ÁÁØ´Ù.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;

		case DEF_ITEMEFFECTTYPE_ADDEFFECT:
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) {
			case 1:
				// Ãß°¡ ¸¶¹ý ÀúÇ× Áõ°¡ 
				m_pClientList[iClientH]->m_iAddResistMagic += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 2:
				// ¸¶³ª Àý¾à È¿°ú 
				m_pClientList[iClientH]->m_iManaSaveRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				// ¸¶³ª Àý°¨·üÀº ÃÖ´ë 80%
				if (m_pClientList[iClientH]->m_iManaSaveRatio > 80) m_pClientList[iClientH]->m_iManaSaveRatio = 80;
				break;

			case 3:
				// °íÁ¤ ¹°¸® ´ë¹ÌÁö È¿°ú. ¸ðµç ¹°¸® °ø°Ý¿¡ ´ëÇØ¼­ °íÁ¤ ´ë¹ÌÁö°¡ ºÙ´Â´Ù. 
				m_pClientList[iClientH]->m_iAddPhysicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 4:
				// Ãß°¡ ¹°¸® ¹æ¾î·Â 
				m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 5:
				// Çà¿î È¿°ú?
				if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 != 0)
					 m_pClientList[iClientH]->m_bIsLuckyEffect = TRUE;
				else m_pClientList[iClientH]->m_bIsLuckyEffect = FALSE;
				break;

			case 6:
				// °íÁ¤ ¸¶¹ý ´ë¹ÌÁö È¿°ú. ¸ðµç ¸¶¹ý °ø°Ý¿¡ ´ëÇØ¼­ °íÁ¤ ´ë¹ÌÁö°¡ ºÙ´Â´Ù. 
				m_pClientList[iClientH]->m_iAddMagicalDamage += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 7:
				m_pClientList[iClientH]->m_iAddAbsAir += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 8:
				m_pClientList[iClientH]->m_iAddAbsEarth += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 9:
				m_pClientList[iClientH]->m_iAddAbsFire += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 10:
				// ¹°°è¿­ °ø°Ý ´ë¹ÌÁö °¨¼Ò´Â ¾ó¾îºÙÀ» È®·üÀÇ °¨¼ÒÈ¿°ú°¡ ÀÖ´Ù. (2¹è·Î È®·ü °è»êµÊ)
				m_pClientList[iClientH]->m_iAddAbsWater += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;

			case 11:
				// µ¶¼º ÀúÇ×.
				m_pClientList[iClientH]->m_iAddPR += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2;
				break;
			}
			break;
			
		case DEF_ITEMEFFECTTYPE_ATTACK_ARROW:
			// È­»ìÀ» ÇÊ¿ä·Î ÇÏ´Â ¹«±â(È°·ù)
			// ¹«±âÀÇ °ø°ÝÈ¿°ú´Â ¾î¶² È­»ìÀÌ ¼±ÅÃµÇ´À³Ä¿¡ µû¶ó ´Þ¶óÁø´Ù. ¾ÆÀÌÅÛÁß È­»ìÀ» Ã£¾Æ ÇÒ´çÇÑ´Ù.
			if ( (m_pClientList[iClientH]->m_cArrowIndex != -1) && 
				 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cArrowIndex] == NULL) ) {
				// ArrowIndex¿¡ È­»ìÀÌ ¾ø´Ù. (ºñ¾îÀÖ´Â ¾ÆÀÌÅÛ) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			}
			else if (m_pClientList[iClientH]->m_cArrowIndex == -1) 
				m_pClientList[iClientH]->m_cArrowIndex = _iGetArrowItemIndex(iClientH);
			
			if (m_pClientList[iClientH]->m_cArrowIndex == -1) {
				// È­»ìÀÌ ¾ø´Ù.
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = 0;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = 0;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = 0;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = 0;
				m_pClientList[iClientH]->m_cAttackBonus_L      = 0;
			}
			else {
				iArrowIndex = m_pClientList[iClientH]->m_cArrowIndex;
				m_pClientList[iClientH]->m_cAttackDiceThrow_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue1;
				m_pClientList[iClientH]->m_cAttackDiceRange_SM = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue2;
				m_pClientList[iClientH]->m_cAttackBonus_SM     = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue3;
				m_pClientList[iClientH]->m_cAttackDiceThrow_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue4;
				m_pClientList[iClientH]->m_cAttackDiceRange_L  = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue5;
				m_pClientList[iClientH]->m_cAttackBonus_L      = m_pClientList[iClientH]->m_pItemList[iArrowIndex]->m_sItemEffectValue6;
			}
			
			// °ø°Ý¹«±âÀÇ ÇØ´ç ½ºÅ³¸¸Å­ÀÇ ¸íÁß·üÀ» ´õÇÑ´Ù. 
			m_pClientList[iClientH]->m_iHitRatio += m_pClientList[iClientH]->m_cSkillMastery[ m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sRelatedSkill ]; 
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù. ¹«±âÀÇ °ø°Ý´ë»óº° ¸íÁß·ü °¡°¨Ä¡¸¦ ´õÇÑ´Ù.
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			// m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			break;
			
		case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
		case DEF_ITEMEFFECTTYPE_DEFENSE:
			// ¹æ¾î±¸ ÀåÂø È¿°ú.
			// ¹æ¾î±¸°¡ ÀåÂøµÇ¾ú´Ù.	ÇöÀç Defense Ratio¿¡¼­ ¹æ¾î±¸ÀÇ ´É·ÂÄ¡¸¸Å­ÀÇ ¼ö¸¦ ´õÇÑ´Ù.
			m_pClientList[iClientH]->m_iDefenseRatio += m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
			
			// v1.432 »ç¿ëÇÏÁö ¾Ê´Â´Ù.
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_SM += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSM_HitRatio;
			//m_pClientList[iClientH]->m_iHitRatio_ItemEffect_L  += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sL_HitRatio;
			
			// v1.41 Custom-Made ¾ÆÀÌÅÛÀÌ¶ó¸é È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. 
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000001) != NULL) {
				m_pClientList[iClientH]->m_iCustomItemValue_Defense += m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				
				// º¸³Ê½º ¹æ¾î·Â °è»ê 
				dV2 = (double)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2;
				dV3 = (double)m_pClientList[iClientH]->m_pItemList[ sItemIndex ]->m_sItemEffectValue1;
				dV1 = (double)(dV2 / 100.0f)*dV3;
					
				dV1 = dV1 / 2.0f;
				// ÀÌ °ªÀ» ´õÇÑ´Ù. 
				m_pClientList[iClientH]->m_iDefenseRatio += (int)dV1;
				if (m_pClientList[iClientH]->m_iDefenseRatio <= 0) m_pClientList[iClientH]->m_iDefenseRatio = 1;

				//testcode
				//wsprintf(G_cTxt, "Custom-Defense: %d", (int)dV1);
				//PutLogList(G_cTxt);
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Main È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00F00000) >> 20;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x000F0000) >> 16;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 4-ÀúÁÖÀÇ 
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
			
				switch (dwSWEType) {
				case 7: // ¿¹¸®ÇÑ 
					m_pClientList[iClientH]->m_cAttackDiceRange_SM++;
					m_pClientList[iClientH]->m_cAttackDiceRange_L++;
					break;

				case 9: // °í´ë¹®¸íÀÇ
					m_pClientList[iClientH]->m_cAttackDiceRange_SM += 2;
					m_pClientList[iClientH]->m_cAttackDiceRange_L  += 2;
					break;
				}
			}

			// v1.42 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é Sub È¿°ú¸¦ ¼³Á¤ÇÑ´Ù. °ø°Ý¹«±â´Â 1°³¸¸ ÀåÂøµÈ´Ù°í ÇßÀ»¶§¸¸ À¯È¿ÇÔ.
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) != NULL) {
				dwSWEType  = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x0000F000) >> 12;  
				dwSWEValue = (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute & 0x00000F00) >> 8;
				
				// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
				//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
				//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
				//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)
				
				switch (dwSWEType) {
				case 0:  break;
				case 1:  m_pClientList[iClientH]->m_iAddPR += (int)dwSWEValue*7; break;
				case 2:  m_pClientList[iClientH]->m_iAddAR += (int)dwSWEValue*7; break;
				case 3:  m_pClientList[iClientH]->m_iAddDR += (int)dwSWEValue*7; break;
				case 4:  m_pClientList[iClientH]->m_iAddHP += (int)dwSWEValue*7; break;
				case 5:  m_pClientList[iClientH]->m_iAddSP += (int)dwSWEValue*7; break;
				case 6:  m_pClientList[iClientH]->m_iAddMP += (int)dwSWEValue*7; break;
				case 7:  m_pClientList[iClientH]->m_iAddMR += (int)dwSWEValue*7; break;
				case 8:  m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (int)dwSWEValue*3; break;
				case 9:  m_pClientList[iClientH]->m_iAddAbsMD += (int)dwSWEValue*3; break;
				case 10: m_pClientList[iClientH]->m_iAddCD    += (int)dwSWEValue; break;
				case 11: m_pClientList[iClientH]->m_iAddExp   += (int)dwSWEValue*10; break;
				case 12: m_pClientList[iClientH]->m_iAddGold  += (int)dwSWEValue*10; break;
				}
			}

			switch ( cEquipPos ) {
			case DEF_EQUIPPOS_LHAND:
				// ¹æ¾î±¸ Áß ¹æÆÐ°¡ ÀåÂø µÇ¾ú´Ù. 
				// ¹æÆÐ¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö È¿°ú ÇÒ´çÇÑ´Ù. ¹æ¾î°ªÀÇ 70% ¼öÁØ 
				m_pClientList[iClientH]->m_iDamageAbsorption_Shield	= (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1) - (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1)/3;
				break;
			default:
				// °©¿Ê¿¡ ÀÇÇÑ Ãæ°Ý Èí¼ö È¿°ú¸¦ ´õÇÑ´Ù. ¹æ¾î°ªÀÇ 70% ¼öÁØ <- v1.43 100%·Î º¯°æµÇ¾ú´Ù. V2!
				m_pClientList[iClientH]->m_iDamageAbsorption_Armor[m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cEquipPos] += (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2);
				break;
			}

			// ÀÏ¹Ý °ø°Ý ÀÌ¿ÜÀÇ È¿°ú¸¦ ¼³Á¤.
			switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
			case DEF_ITEMEFFECTTYPE_DEFENSE_SPECABLTY:
				// Æ¯¼ö ´É·Â Á¾·ù
				m_pClientList[iClientH]->m_iSpecialAbilityType = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffect;
				// Æ¯¼ö ´É·Â Áö¼Ó ½Ã°£
				m_pClientList[iClientH]->m_iSpecialAbilityLastSec = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpecialEffectValue1; 
				// ÀåÂø À§Ä¡ ±â¾ïÇØ ³õ´Â´Ù.
				m_pClientList[iClientH]->m_iSpecialAbilityEquipPos = (int)cEquipPos;
				
				// Æ¯¼ö ´É·Â ¼³Á¤µÊÀ» ¾Ë·ÁÁØ´Ù.
				if ((bNotify == TRUE) && (iEquipItemID == (int)sItemIndex))
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 2, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityTime, NULL);
				break;
			}
			break;
		}
	}

	//v1.432
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) && (bNotify == TRUE)) {
		// Æ¯¼ö ´É·ÂÀÌ ÇØÁ¦µÇ¾ú´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 4, NULL, NULL, NULL);
		// ¸¸¾à Æ¯¼ö ´É·Â »ç¿ë ÁßÀÌ¾ú´Ù¸é ¿Ü¸ðµµ º¯È­ÇÏ¸ç »ç¿ëµµ Á¾·á.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// È¿°ú ºñÆ® Å¬¸®¾î
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
	
	if ((iPrevSAType != 0) && (m_pClientList[iClientH]->m_iSpecialAbilityType != 0) && 
		(iPrevSAType != m_pClientList[iClientH]->m_iSpecialAbilityType) && (bNotify == TRUE)) {
		// Æ¯¼ö ´É·Â »ç¿ë µµÁß¿¡ Æ¯¼ö ´É·ÂÀ» ¹Ù²Ù¸é ´É·Â »ç¿ëÀÌ ¸ØÃá´Ù.
		if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) {
			// »ç¿ë½Ã°£ÀÌ ´Ù µÇ¾ú´Ù.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SPECIALABILITYSTATUS, 3, NULL, NULL, NULL);
			m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled = FALSE;
			// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
			m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;
			// È¿°ú ºñÆ® Å¬¸®¾î
			sTemp = m_pClientList[iClientH]->m_sAppr4;
			sTemp = sTemp & 0xFF0F;
			m_pClientList[iClientH]->m_sAppr4 = sTemp;
			// ¿ÜÇüÀÌ º¯ÇßÀ½À» ¾Ë¸°´Ù.
			SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		}
	}
}

int CGame::_iGetPlayerNumberOnSpot(short dX, short dY, char cMapIndex, char cRange)
{
 register int ix, iy, iSum = 0;
 short sOwnerH;
 char  cOwnerType;

	for (ix = dX - cRange; ix <= dX + cRange; ix++)
	for (iy = dY - cRange; iy <= dY + cRange; iy++) {
		m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER))
			iSum++;
	}

	return iSum;
}

void CGame::RequestAdminUserMode(int iClientH, char * pData)
{
	// ¿î¿µÀÚ ¸ðµå¸¦ È®ÀÎÇÏ±â À§ÇØ¼­´Â ÀÏ´Ü ÀÌ ¸Þ½ÃÁö¸¦ Àü¼ÛÇÏ´Â Å¬¶óÀÌ¾ðÆ®¸¦ °®°í ÀÖ¾î¾ß ÇÑ´Ù. 
	// ¶ÇÇÑ ³¯Â¥¸¦ Á¶ÇÕÇØ¼­ »ý¼ºµÇ´Â È®ÀÎ ÄÚµå°¡ ÀÏÄ¡ÇØ¾ß ÇÑ´Ù. 

}

BOOL CGame::bAnalyzeCriminalAction(int iClientH, short dX, short dY, BOOL bIsCheck)
{
 int   iNamingValue, tX, tY;
 short sOwnerH;
 char  cOwnerType, cName[11], cNpcName[21];
 char  cNpcWaypoint[11];

	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return FALSE;
	if (m_bIsCrusadeMode == TRUE) return FALSE;

	// dX, dY¿¡ ´ëÇÑ Áö¼ÓÀû À§ÇØ ÇàÀ§°¡ ¹üÁË¿¡ ÇØ´çÇÏ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
	m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

	if ((cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL)) {
		if (_bGetIsPlayerHostile(iClientH, sOwnerH) != TRUE) {
			// ¹üÁËÇàÀ§´Ù. ¸¶À»¿¡ ÀÖ¾ú´Ù¸é ¼ÒÈ¯ °¡µå·Î °ø°Ý½ÃÅ²´Ù. 
			if (bIsCheck == TRUE) return TRUE;

			ZeroMemory(cNpcName, sizeof(cNpcName));
			if (strcmp(m_pClientList[iClientH]->m_cMapName, "aresden") == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (strcmp(m_pClientList[iClientH]->m_cMapName, "elvine") == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else  if (strcmp(m_pClientList[iClientH]->m_cMapName, "default") == 0) 
				strcpy(cNpcName, "Guard-Neutral");
			else strcpy(cNpcName, "XXX");  // <- ÀÌ°ÍÀº ¸¶À»ÀÌ ¾Æ´Ï¹Ç·Î NPC¸¦ »ý¼ºÇÏÁö ¸øÇÏ°Ô ÇÏ±â À§ÇÔ 

			iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			}
			else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
				
				ZeroMemory(cName, sizeof(cName));
			   	wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[iClientH]->m_sX;
				tY = (int)m_pClientList[iClientH]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// °ø°Ý ¸ñÇ¥¸¦ ÇÒ´çÇÑ´Ù.
					bSetNpcAttackMode(cName, iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}
			//
		}
	}

	return FALSE;
}

BOOL CGame::_bGetIsPlayerHostile(int iClientH, int sOwnerH)
{
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[sOwnerH]  == NULL) return FALSE;

	// ÀÚ±â ÀÚ½Å¿¡ ´ëÇÑ °ø°ÝÀº ¹üÁË¶ó º¼ ¼ö ¾ø´Ù. 
	if (iClientH == sOwnerH) return TRUE;

	if (m_pClientList[iClientH]->m_cSide == 0) {
		// °ø°ÝÀÚ´Â ¿©ÇàÀÚÀÌ´Ù.
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌ¸é Àû¼ºÀÌ¸ç ±× ÀÌ¿Ü¿¡´Â ¾Æ´Ï´Ù. 
		if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 return TRUE;
		else return FALSE;
	}
	else {
		// °ø°ÝÀÚ´Â ¼Ò¼Ó ¸¶À»À» °®°í ÀÖ´Ù. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[sOwnerH]->m_cSide) {
			// ¼­·Î »çÀÌµå°¡ ´Ù¸£´Ù. 
			if (m_pClientList[sOwnerH]->m_cSide == 0) {
				if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
				 	 return TRUE;
				else return FALSE;
			}
			else return TRUE;
		}
		else {
			if (m_pClientList[sOwnerH]->m_iPKCount != 0) 
			 	 return TRUE;
			else return FALSE;
		}
	}

	return FALSE;
}

void CGame::bSetNpcAttackMode(char * cName, int iTargetH, char cTargetType, BOOL bIsPermAttack)
{
 register int i, iIndex;
	
	for (i = 1; i < DEF_MAXNPCS; i++)
	if ((m_pNpcList[i] != NULL) && (memcmp(m_pNpcList[i]->m_cName, cName, 5) == 0) ) {
		iIndex = i;
		goto NEXT_STEP_SNAM1;

		//testcode
		//PutLogList("bSetNpcAttackMode - Npc found");
	}
	// °°Àº ÀÌ¸§À» °¡Áø NPC°¡ ¾ø´Ù.
	return;

NEXT_STEP_SNAM1:;

	switch (cTargetType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[iTargetH] == NULL) return;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[iTargetH] == NULL) return;
		break;
	}

	// ¸ñÇ¥¹°À» ÇÒ´çÇÑ´Ù. 
	m_pNpcList[iIndex]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
	m_pNpcList[iIndex]->m_sBehaviorTurnCount = 0;		
	m_pNpcList[iIndex]->m_iTargetIndex = iTargetH;
	m_pNpcList[iIndex]->m_cTargetType  = cTargetType;

	// ¿µ±¸ °ø°Ý ¸ðµå ¿©ºÎ ¼³Á¤ 
	m_pNpcList[iIndex]->m_bIsPermAttackMode = bIsPermAttack;

	//testcode
	//PutLogList("bSetNpcAttackMode - complete");
}


void CGame::PoisonEffect(int iClientH, int iV1)
{
 int iPoisonLevel, iDamage, iPrevHP, iProb;

	// Áßµ¶À¸·Î Á×Áö´Â ¾Ê´Â´Ù. ´Ù¸¸ Ã¼·ÂÀÌ °è¼Ó ±ïÀÌ°í ÃÖ¼Ò 1¸¸ ³²´Â´Ù. 
	if (m_pClientList[iClientH] == NULL)     return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;

	iPoisonLevel = m_pClientList[iClientH]->m_iPoisonLevel;

	iDamage = iDice(1, iPoisonLevel);
	
	iPrevHP = m_pClientList[iClientH]->m_iHP;
	m_pClientList[iClientH]->m_iHP -= iDamage;
	if (m_pClientList[iClientH]->m_iHP <= 0) m_pClientList[iClientH]->m_iHP = 1;

	if (iPrevHP != m_pClientList[iClientH]->m_iHP)
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);

	// µ¶¼º ÀúÇ× È®·ü·Î Áßµ¶ÀÌ Ç®¸± ¼ö ÀÖ´Ù.
	iProb = m_pClientList[iClientH]->m_cSkillMastery[23] -10 +m_pClientList[iClientH]->m_iAddPR;
	if (iProb <= 10) iProb = 10;
	if (iDice(1,100) <= iProb) {
		m_pClientList[iClientH]->m_bIsPoisoned = FALSE;
		// Áßµ¶ÀÌ Ç®·ÈÀ½À» ¾Ë¸°´Ù. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_POISON, NULL, NULL, NULL);
	}
}



BOOL CGame::bCheckResistingPoisonSuccess(short sOwnerH, char cOwnerType)
{
 int iResist, iResult;
	
	// µ¶¼º ÀúÇ×ÀÌ ¼º°øÇß´ÂÁö¸¦ °è»êÇÑ´Ù. 
	switch (cOwnerType) {
	case DEF_OWNERTYPE_PLAYER:
		if (m_pClientList[sOwnerH] == NULL) return FALSE;
		iResist = m_pClientList[sOwnerH]->m_cSkillMastery[23] +m_pClientList[sOwnerH]->m_iAddPR;
		break;

	case DEF_OWNERTYPE_NPC:
		if (m_pNpcList[sOwnerH] == NULL) return FALSE;
		iResist = 0;
		break;
	}

	iResult = iDice(1, 100);
  	if (iResult >= iResist) // µ¶¼º ÀúÇ× ½ÇÆÐ. Áßµ¶µÈ´Ù.
		return FALSE;

	// µ¶¼º ÀúÇ× ¼º°ø. ÇÃ·¹ÀÌ¾î¶ó¸é ½ºÅ³À» ¿Ã¸°´Ù. 
	if (cOwnerType == DEF_OWNERTYPE_PLAYER)
		CalculateSSN_SkillIndex(sOwnerH, 23, 1);

	return TRUE;
}

BOOL CGame::bCheckBadWord(char * pString)
{
 char * cp;

	// ½ºÆ®¸µÀ» °Ë»öÇÏ¸ç ¿å¼³ÀÌ ÀÖ´ÂÁö¸¦ Ã£´Â´Ù. 
	cp = pString;
	while (*cp != NULL) {
		
		cp++;
	}

	return FALSE;
}

void CGame::CheckDayOrNightMode()
{
 SYSTEMTIME SysTime;	
 char cPrevMode;
 int  i;

	// ÇöÀç ½Ã°£¿¡ µû¶ó ³· È¤Àº ¹ãÀ» °áÁ¤ÇÑ´Ù. 
	// ÁÖ, ¾ß°£ ¸ðµå ¼³Á¤ 
	cPrevMode = m_cDayOrNight;
 
	GetLocalTime(&SysTime);
	if (SysTime.wMinute >= DEF_NIGHTTIME) 
		 m_cDayOrNight = 2;
	else m_cDayOrNight = 1;

	if (cPrevMode != m_cDayOrNight) {
		// ÁÖ, ¾ß°£ ¸ðµå°¡ º¯°æµÇ¾ú´Ù. ÁÖ, ¾ß°£ ¸ðµåÀÇ ¿µÇâÀ» ¹Þ´Â ¸Ê¿¡ Á¸ÀçÇÏ´Â Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¾Ë¸°´Ù. 
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			if ((m_pClientList[i]->m_cMapIndex >= 0) && 
				(m_pMapList[m_pClientList[i]->m_cMapIndex] != NULL) &&
				(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_bIsFixedDayMode == FALSE))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_TIMECHANGE, m_cDayOrNight, NULL, NULL, NULL);	
		}
	}
}


void CGame::ShutUpPlayer(int iClientH, char * pMsg, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i, iTime;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 1) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		// ´ÙÀ½ ÅäÅ«Àº Á¤Áö ½ÃÅ³ ½Ã°£. 
		token = pStrTok->pGet();
		if (token == NULL) 
			 iTime = 0;
		else iTime = atoi(token);
	
		if (iTime < 0) iTime = 0;
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			m_pClientList[i]->m_iTimeLeft_ShutUp = iTime; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ 
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERSHUTUP, iTime*3, NULL, NULL, cName);
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, iTime*3, NULL, NULL, cName);

			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Shutup (%s %d)", m_pClientList[iClientH]->m_cCharName, 
				     m_pClientList[i]->m_cCharName, iTime*3);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}

	delete pStrTok;
	return;
}


void CGame::SetPlayerReputation(int iClientH, char * pMsg, char cValue, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;
	if (m_pClientList[iClientH]->m_iLevel < 15) return;

	if ((m_pClientList[iClientH]->m_iTimeLeft_Rating != 0) || (m_pClientList[iClientH]->m_iPKCount != 0)) {
		// Æò°¡¸¦ ³»¸± ½Ã°£ÀÌ µÇÁö ¾Ê¾Ò°Å³ª ¹üÁËÀÚ´Â Æò°¡¸¦ ³»¸± ¼ö ¾ø´Ù. ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, m_pClientList[iClientH]->m_iTimeLeft_Rating, NULL, NULL, NULL);
		return;
	}
	else if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		// ¼Ò¼Ó ¸¶À»ÀÌ ¾ø´Â »ç¶÷Àº ÆòÆÇÀ» ³»¸± ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTRATING, 0, NULL, NULL, NULL);
		return;	
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pMsg, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ð ÆòÆÇÀ» Æò°¡ÇÒ »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cName, token, 10);
		else memcpy(cName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0)) {
			
			if (i != iClientH) {
				// ÀÚ±â ÀÚ½ÅÀ» Æò°¡ÇÒ ¼ö´Â ¾ø´Ù.
				if (cValue == 0) 
					m_pClientList[i]->m_iRating--;
				else if (cValue == 1)
					m_pClientList[i]->m_iRating++;
				
				if (m_pClientList[i]->m_iRating > 10000)  m_pClientList[i]->m_iRating = 10000;
				if (m_pClientList[i]->m_iRating < -10000) m_pClientList[i]->m_iRating = -10000;
				// Æò°¡¸¦ ³»·ÈÀ¸¹Ç·Î ½Ã°£ °£°ÝÀ» Àç ÇÒ´ç. 
				m_pClientList[iClientH]->m_iTimeLeft_Rating = 20*60;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RATINGPLAYER, cValue, NULL, NULL, cName);
				
				delete pStrTok;
				return;
			}
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cName);
	}
	
	delete pStrTok;
	return;
}

BOOL CGame::bReadNotifyMsgListFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode;
 char seps[] = "=\t\n;";
 class CStrTok * pStrTok;
 int   i;

	cReadMode = 0;
	m_iTotalNoticeMsg = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		PutLogList("(!) Notify Message list file not found!...");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading Notify Message list file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();
		//token = strtok( cp, seps );   
		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					for (i = 0; i < DEF_MAXNOTIFYMSGS; i++) 
					if (m_pNoticeMsgList[i] == NULL) {
						m_pNoticeMsgList[i] = new class CMsg;	
						m_pNoticeMsgList[i]->bPut(NULL, token, strlen(token), NULL, NULL);
						m_iTotalNoticeMsg++;
						goto LNML_NEXTSTEP1;
					}
LNML_NEXTSTEP1:;					
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "notify_msg", 10) == 0) cReadMode = 1;
			}
			
			token = pStrTok->pGet();
			//token = strtok( NULL, seps );
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}
 

void CGame::NoticeHandler()
{
 char  cTemp, cBuffer[1000], cKey;
 DWORD dwSize, dwTime = timeGetTime();
 register int i, iMsgIndex, iTemp;

	// °øÁö»çÇ×ÀÌ 1°³ ÀÌÇÏ¶ó¸é º¸³¾ ÇÊ¿ä°¡ ¾ø´Ù.
	if (m_iTotalNoticeMsg <= 1) return;

	if ((dwTime - m_dwNoticeTime) > DEF_NOTICETIME) {
		// °øÁö»çÇ×À» Àü¼ÛÇÒ ½Ã°£ÀÌ µÇ¾ú´Ù. 
		m_dwNoticeTime = dwTime;	
		do {
			iMsgIndex = iDice(1, m_iTotalNoticeMsg) - 1;
		} while (iMsgIndex == m_iPrevSendNoticeMsg);

		m_iPrevSendNoticeMsg = iMsgIndex;
		
		ZeroMemory(cBuffer, sizeof(cBuffer));
		if (m_pNoticeMsgList[iMsgIndex] != NULL) {
			m_pNoticeMsgList[iMsgIndex]->Get(&cTemp, cBuffer, &dwSize, &iTemp, &cKey);
		}
		
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if (m_pClientList[i] != NULL) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_NOTICEMSG, NULL, NULL, NULL, cBuffer);
		}
	}
}


void CGame::ResponseSavePlayerDataReplyHandler(char * pData, DWORD dwMsgSize)
{
 char * cp, cCharName[11];
 register int i;

	ZeroMemory(cCharName, sizeof(cCharName));
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	memcpy(cCharName, cp, 10);

	// ÀÌÁ¦ ÀÌ ÀÌ¸§À» °®´Â Å¬¶óÀÌ¾ðÆ®¸¦ Ã£¾Æ Á¢¼ÓÀ» ²÷¾îµµ ÁÁ´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù. 
	for (i = 0; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cCharName, 10) == 0) {
			// °°Àº ÀÌ¸§À» °¡Áø Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. Á¢¼ÓÀ» Á¾·áÇÏ¶ó´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
			SendNotifyMsg(NULL, i, DEF_NOTIFY_SERVERCHANGE, NULL, NULL, NULL, NULL);
		}
	}
}

void CGame::CalcExpStock(int iClientH)
{
	BOOL bIsLevelUp;
	class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iExpStock <= 0) return;
	if (m_pClientList[iClientH]->m_iLevel >= m_iPlayerMaxLevel) return;

	// Æ÷»ó°ú Æä³ÎÆ¼°¡ ¾ø´Â ¸Ê À§¿¡ ¼­ ÀÖ´Ù¸é °æÇèÄ¡´Â ¿Ã¶ó°¡Áö ¾Ê´Â´Ù.
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cType == DEF_MAPTYPE_NOPENALTY_NOREWARD) {
		m_pClientList[iClientH]->m_iExpStock = 0;
		return;
	}

	// ±×µ¿¾È ÃàÀû µÇ¾ú´ø °æÇèÄ¡¸¦ °è»êÇÑ´Ù. 
	m_pClientList[iClientH]->m_iExp += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iAutoExpAmount += m_pClientList[iClientH]->m_iExpStock;
	m_pClientList[iClientH]->m_iExpStock = 0;

	if (bCheckLimitedUser(iClientH) == FALSE) {
		// Ã¼ÇèÆÇ »ç¿ëÀÚ Á¦ÇÑ¿¡ ÇØ´çµÇÁö ¾ÊÀ¸¸é °æÇèÄ¡°¡ ¿Ã¶ú´Ù´Â Åëº¸¸¦ ÇÑ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXP, NULL, NULL, NULL, NULL);
	}
	// ·¹º§ÀÌ ¿Ã¶ú´ÂÁö¸¦ °Ë»çÇÑ´Ù.
	bIsLevelUp = bCheckLevelUp(iClientH);

	if ((bIsLevelUp == TRUE) && (m_pClientList[iClientH]->m_iLevel <= 20)) {
		// ÃÊº¸¿ë Gold Áö±Þ. ·¹º§ 1~20±îÁö 6000 Gold Áö±Þ.
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, "Gold") == FALSE) {
			delete pItem;
			return;
		}
		else pItem->m_dwCount = (DWORD)300;
		bAddItem(iClientH, pItem, NULL);
	}
	if (bIsLevelUp == TRUE) {
		m_pClientList[iClientH]->m_iLU_Pool += DEF_TOTALLEVELUPPOINT;
		wsprintf(G_cTxt, "(*) Level Up: Char(%s) Level (%d) DEF_TOTALLEVELUPPOINT (%d) m_pClientList[iClientH]->m_iLU_Pool (%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iLevel, DEF_TOTALLEVELUPPOINT, m_pClientList[iClientH]->m_iLU_Pool);		
		PutLogList(G_cTxt);
	}
}

void CGame::___RestorePlayerRating(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iRating < -10000) m_pClientList[iClientH]->m_iRating = 0;
	if (m_pClientList[iClientH]->m_iRating >  10000) m_pClientList[iClientH]->m_iRating = 0;
}

int CGame::iGetExpLevel(int iExp)
{
 register int i;

	// °æÇèÄ¡°¡ ¾î´À ·¹º§ ¼öÁØ¿¡ ¼ÓÇÏ´ÂÁö ÆÇ´ÜÇÑ´Ù.
	for (i = 1; i < 199; i++) 
	if ((m_iLevelExpTable[i] <= iExp) && (m_iLevelExpTable[i+1] > iExp)) return i;

	return 0;
}

void CGame::AdminOrder_CallGuard(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
 class  CStrTok * pStrTok;
 register int i, iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
	 		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	
			
			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
			else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
			else strcpy(cNpcName, "Guard-Neutral");  // <- ÀÌ°ÍÀº ¸¶À»ÀÌ ¾Æ´Ï¹Ç·Î Áß¸³ °¡µå¸¦ »ý¼º½ÃÅ²´Ù.
			
			iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			}
			else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;
				
				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
					// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					// °¡µå¸¦ »ý¼º½ÃÄ×´Ù. °ø°Ý ¸ñÇ¥¸¦ ÇÒ´çÇÑ´Ù.
					bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
			}

			delete pStrTok;
			return;
		}

		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}
void CGame::AdminOrder_Kill(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11], Name[11];
	class  CStrTok * pStrTok;
	register int i, iNamingValue, tX, tY;
	int sAttackerWeapon, sDamage;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}

	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//

	if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		token = cName;
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	

				m_pClientList[i]->m_iHP = 0;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = TRUE;
				m_pClientList[i]->m_iLastDamage = sDamage;
				//			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[i]->m_iLastDamage, NULL, NULL);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDYING, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				/*			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
				else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
				else strcpy(cNpcName, "Guard-Neutral");  // <- ÀÌ°ÍÀº ¸¶À»ÀÌ ¾Æ´Ï¹Ç·Î Áß¸³ °¡µå¸¦ »ý¼º½ÃÅ²´Ù.

				iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
				}
				else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;

				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
				&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
				// °¡µå¸¦ »ý¼º½ÃÄ×´Ù. °ø°Ý ¸ñÇ¥¸¦ ÇÒ´çÇÑ´Ù.
				bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
				}
				*/
				delete pStrTok;
				return;
			}

			// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 

void CGame::AdminOrder_Revive(int iClientH, char * pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cCharName[11], cName[11], cTargetName[11], cBuff[256], cNpcName[21], cNpcWaypoint[11];
	class  CStrTok * pStrTok;
	register int i, iNamingValue, tX, tY;
	int sAttackerWeapon, sDamage, sHP;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));
	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);


	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//


	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	if (token != NULL) {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, token);
	} else {
		ZeroMemory(cName, sizeof(cName));
		strcpy(cName, "null");
	}


	token = pStrTok->pGet();
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);
	//
	if (token != NULL) {
		sDamage = atoi(token);
	} else {
		sDamage = 1;
	}
	token = pStrTok->pGet();
	if (token != NULL) {
		sHP = atoi(token);
	} else {
		sHP = 1;
	}

	token = cName;
	//if (token == NULL) { token = "null"; }
	if (cName != NULL) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. 	

				m_pClientList[i]->m_iHP = sHP;
				if (iGetMaxHP(i) < m_pClientList[i]->m_iHP) m_pClientList[i]->m_iHP = iGetMaxHP(i);
				m_pClientList[i]->m_bIsKilled = FALSE;
				m_pClientList[i]->m_iLastDamage = sDamage;
				//			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGEMOVE, m_pClientList[i]->m_iLastDamage, NULL, NULL);
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				sAttackerWeapon = 1;
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, sDamage, sAttackerWeapon, NULL);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(14, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				m_pMapList[m_pClientList[i]->m_cMapIndex]->SetDeadOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);

				/*			if (memcmp(m_pClientList[i]->m_cMapName, "aresden", 7) == 0) 
				strcpy(cNpcName, "Guard-Aresden");			
				else if (memcmp(m_pClientList[i]->m_cMapName, "elvine", 6) == 0) 
				strcpy(cNpcName, "Guard-Elvine");
				else strcpy(cNpcName, "Guard-Neutral");  // <- ÀÌ°ÍÀº ¸¶À»ÀÌ ¾Æ´Ï¹Ç·Î Áß¸³ °¡µå¸¦ »ý¼º½ÃÅ²´Ù.

				iNamingValue = m_pMapList[ m_pClientList[i]->m_cMapIndex ]->iGetEmptyNamingValue();
				if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
				}
				else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = m_pClientList[i]->m_cMapIndex+65;

				tX = (int)m_pClientList[i]->m_sX;
				tY = (int)m_pClientList[i]->m_sY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[i]->m_cMapIndex ]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
				&tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, TRUE) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
				// °¡µå¸¦ »ý¼º½ÃÄ×´Ù. °ø°Ý ¸ñÇ¥¸¦ ÇÒ´çÇÑ´Ù.
				bSetNpcAttackMode(cName, i, DEF_OWNERTYPE_PLAYER, TRUE);
				}
				}
				*/
				delete pStrTok;
				return;
			}

			// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
} 
void CGame::AdminOrder_SummonDemon(int iClientH)
{
 char cName[21], cNpcName[21], cNpcWaypoint[11];	
 register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;
	
	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {
		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Demon");	
		
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Demon", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
void CGame::AdminOrder_SummonDeath(int iClientH)
{
	char cName[21], cNpcName[21], cNpcWaypoint[11];	
	register int iNamingValue, tX, tY;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {
		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, "Wyvern");	

		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;

		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)m_pClientList[iClientH]->m_sX;
		tY = (int)m_pClientList[iClientH]->m_sY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
		else {
			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Summon Death", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);
		}
	}

}
// v1.4311-3 Ãß°¡ ¿î¿µÀÚ°¡ »çÅõÀåÀ» ¿¹¾àÇÑ´Ù.
void CGame::AdminOrder_ReserveFightzone(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 int iNum ;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;


	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if( m_iFightzoneNoForceRecall == 0 ) {
		m_iFightzoneNoForceRecall = 1 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -5, NULL, NULL, NULL);
	} else {
		m_iFightzoneNoForceRecall = 0 ; 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -4, NULL, NULL, NULL);
	}

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	iNum = atoi(token) - 1;
			
	if ( m_iFightZoneReserve[iNum] != -1) {
		// Admin Log
		wsprintf(G_cTxt, "Admin Order(%s):  %d FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);
		
		m_iFightZoneReserve[iNum] = - 1 ;        // ¿î¿µÀÚ°¡ ¿¹¾àÇÑ »çÅõÀåÀº -1 °ªÀÌ µé¾î°£´Ù.
												 // ÀÌÁ¦ºÎÅÍ °è¼Ó ´Ù¸¥ À¯Àú´Â ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
		// ¿î¿µÀÚ°¡ »çÅõÀå ¿¹¾à¿¡ ¼º°øÇÏ´Â °æ¿ì 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, iNum+1, NULL, NULL, NULL);
		
	}  else {	// ¿î¿µÀÚ°¡ ¿¹¾àÇÑ »çÅõÀåÀ» ´Ù½Ã ¿¹¾àÇÏ¸é ¿¹¾àÀÌ Ãë¼ÒµÈ´Ù.
		wsprintf(G_cTxt, "Admin Order(%s):  %d Cancel FightzoneReserved", m_pClientList[iClientH]->m_cCharName, iNum );
		PutAdminLogFileList(G_cTxt);

		m_iFightZoneReserve[iNum] = 0 ;       
		// ¿î¿µÀÚ°¡ »çÅõÀå ¿¹¾àÀ» Ãë¼ÒÇÏ´Â °æ¿ì       -3 °ªÀ» ³Ñ°ÜÁØ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -3, NULL, NULL, NULL);

	}
		
	return;
}


void CGame::AdminOrder_CloseConn(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	/*
	//v1.42 ±æµåÀü¿ë ÀÓ½Ã ÄÚµå 
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) && (m_pClientList[iClientH]->m_iSkillSSN[59] == 1)) {
		goto AOCC_PASS;
	}
	*/

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ °ð Ã¤ÆÃÀ» ºÒ°¡´ÉÇÏ°Ô ¸¸µé »ç¿ëÀÚ ÀÌ¸§ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
			// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. °­Á¦·Î Á¢¼ÓÀ» ²÷´Â´Ù.	
			if (m_pClientList[i]->m_bIsInitComplete == TRUE) {
				// v1.22 °­Á¦ Á¢¼Ó Á¾·áµÈ Å¬¶óÀÌ¾ðÆ®´Â ºí¸®µù ¾ÆÀÏ·£µå·Î ÅÚ·¹Æ÷Æ®µÈ´Ù.
				DeleteClient(i, TRUE, TRUE, TRUE, TRUE);
			}

			// Admin Log
			wsprintf(G_cTxt, "Admin Order(%s): Close Conn", m_pClientList[iClientH]->m_cCharName);
			PutAdminLogFileList(G_cTxt);

			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



// v1.4311-3 Ãß°¡¹× º¯°æ ÇÔ¼ö  ±æµå¿ø °­Åð ¸í·É void CGame::UserCommand_BanGuildsman
void CGame::UserCommand_BanGuildsman(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iGuildRank != 0 ) {
		// ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ï¾î¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOGUILDMASTERLEVEL, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cTargetName, sizeof(cTargetName));
	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
   	
	if (token != NULL) {
		// tokenÀÌ ±æµå¸¦ Å»Åð½ÃÅ³ »ç¶÷ 
		if (strlen(token) > 10) 
			 memcpy(cTargetName, token, 10);
		else memcpy(cTargetName, token, strlen(token));
		
		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0) ) {
			// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. °­Á¦·Î ±æµå¸¦ °­Åð ½ÃÅ²´Ù. 

			if (memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[i]->m_cGuildName, 20) != 0)  {
				// ÀÚ½ÅÀÇ ±æµå¿øÀÌ ¾Æ´Ï¶ó Çã¶ôÀÌ ºÒ°¡´ÉÇÏ´Ù.
				
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTBANGUILDMAN, NULL, NULL, NULL, NULL);
				delete pStrTok;
				return;
			}
			// ±æµå Á¤º¸ È­ÀÏ¿¡¼­ Å»ÅðÇÑ ±æµå¿øÀÇ ÀÌ¸§À» »èÁ¦ÇÑ´Ù.
			bSendMsgToLS(MSGID_REQUEST_UPDATEGUILDINFO_DELGUILDSMAN, i);
		
			// ´Ù¸¥ ±æµå¿øµé¿¡°Ô ±æµå¿øÀÇ Å»Åð¸¦ ¾Ë¸°´Ù.
			SendGuildMsg(i, DEF_NOTIFY_DISMISSGUILDSMAN, NULL, NULL, NULL);
	
			// ±æµåÀÇ ÀÌ¸§À» ÃÊ±âÈ­ÇØ ÁØ´Ù.
			ZeroMemory(m_pClientList[i]->m_cGuildName, sizeof(m_pClientList[i]->m_cGuildName));
			strcpy(m_pClientList[i]->m_cGuildName, "NONE");
			m_pClientList[i]->m_iGuildRank = -1; 
			m_pClientList[i]->m_iGuildGUID = -1;

			// ±æµå ¸¶½ºÅÍ¿¡°Ô °­Á¦ Å»Åð¿¡ ¼º°øÇßÀ½À» ¾Ë¸®´Â ¸Þ½ÃÁö¸¦ º¸³»ÁØ´Ù.
		    SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SUCCESSBANGUILDMAN, NULL, NULL, NULL, NULL);
			
			// °­Á¦ Å»ÅðµÈ ±æµå¿ø¿¡°Ô °­Á¦ Å»Åð µÇ¾úÀ½À» ¾Ë¸°´Ù.
			SendNotifyMsg(iClientH, i, DEF_COMMONTYPE_BANGUILD, NULL, NULL, NULL, NULL);
		
			// Æ¯¼ºÀÌ ¹Ù²î¹Ç·Î ¿Ü¾çÀ» »õ·Î º¸³½´Ù. 
			SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
		
			delete pStrTok;
			return;
		}
		// ÇöÀç Á¢¼ÓÁßÀÌ ¾Æ´Ï´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PLAYERNOTONGAME, NULL, NULL, NULL, cTargetName);
	}

	delete pStrTok;
	return;
}



void CGame::UserCommand_DissmissGuild(int iClientH, char * pData, DWORD dwMsgSize)
{

}


int CGame::iCreateFish(char cMapIndex, short sX, short sY, short sType, class CItem * pItem, int iDifficulty, DWORD dwLastTime)
{
 register int i, iDynamicHandle;

	// ¸ÊÀÇ À§Ä¡°¡ ¹°ÀÎÁö È®ÀÎÇÑ´Ù. 
	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	if (m_pMapList[cMapIndex]->bGetIsWater(sX, sY) == FALSE) return NULL;

	for (i = 1; i < DEF_MAXFISHS; i++) 
	if (m_pFish[i] == NULL) {
		// ºó °ø°£¿¡ ¹°°í±â¸¦ ¸¸µç´Ù.
		m_pFish[i] = new class CFish(cMapIndex, sX, sY, sType, pItem, iDifficulty);
		if (m_pFish[i] == NULL) return NULL;
 		
		// Dynamic Object¸¦ ¹ß»ý½ÃÅ²´Ù. Owner¿¡ Fish ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
		switch (pItem->m_sIDnum) {
		case 101: // »¡°­¹°°í±â
		case 102: // ÃÊ·Ï¹°°í±â
		case 103: // ³ë¶û¹°°í±â
		case 570:
		case 571:
		case 572:
		case 573:
		case 574:
		case 575:
		case 576:
		case 577:	
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISH, cMapIndex, sX, sY, dwLastTime);
			break;
		default: 
			// ¹°°í±â°¡ ¾Æ´Ñ ´Ù¸¥ ¾ÆÀÌÅÛ 
			iDynamicHandle = iAddDynamicObjectList(i, NULL, DEF_DYNAMICOBJECT_FISHOBJECT, cMapIndex, sX, sY, dwLastTime);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pFish[i];
			m_pFish[i] = NULL;
			return NULL;
		}
		m_pFish[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMapList[cMapIndex]->m_iCurFish++;

		return i;
	}

	return NULL;
}


BOOL CGame::bDeleteFish(int iHandle, int iDelMode)
{
 register int i, iH;
 DWORD dwTime;
		
	if (m_pFish[iHandle] == NULL) return FALSE;
	
	dwTime = timeGetTime();

	// ¿¬°üµÇ¾î ÀÖ´Â DynamicObject¸¦ »èÁ¦ÇÑ´Ù.
	iH = m_pFish[iHandle]->m_sDynamicObjectHandle;
	
	if (m_pDynamicObjectList[iH] != NULL) {
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iH]->m_cMapIndex, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, m_pDynamicObjectList[iH]->m_sType, iH, NULL);
		// ¸Ê¿¡¼­ »èÁ¦ÇÑ´Ù.
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iH]->m_sX, m_pDynamicObjectList[iH]->m_sY, dwTime);
		m_pMapList[m_pDynamicObjectList[iH]->m_cMapIndex]->m_iCurFish--;

		delete m_pDynamicObjectList[iH];
		m_pDynamicObjectList[iH] = NULL;
	}

	// ÀÌ ¹°°í±â¿Í ¿¬°áµÇ¾î ÀÖ´Â ÇÃ·¹ÀÌ¾îµé¿¡°Ô ¹°°í±â°¡ »ç¶óÁ® ³¬½Ã°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) &&
			(m_pClientList[i]->m_iAllocatedFish == iHandle)) {
			// ¸Þ½ÃÁö Àü¼Û 
			SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCANCELED, iDelMode, NULL, NULL, NULL);
			ClearSkillUsingStatus(i); // v1.4 ³¬½Ã ½ºÅ³À» Å¬¸®¾îÇÑ´Ù.
 		}
	}
	
	// »èÁ¦ÇÑ´Ù.
	delete m_pFish[iHandle];
	m_pFish[iHandle] = NULL;

	return TRUE;
}


int CGame::iCheckFish(int iClientH, char cMapIndex, short dX, short dY)
{
 register int i;
 short sDistX, sDistY;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if ((cMapIndex < 0)	|| (cMapIndex >= DEF_MAXMAPS)) return 0;

	// ¸ÊÀÇ Æ¯Á¤ À§Ä¡ ³»¿¡ ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®°¡ ÀÖ´ÂÁö ÆÇ´ÜÇÑ´Ù. 
	for (i = 1; i < DEF_MAXDYNAMICOBJECTS; i++) 
	if (m_pDynamicObjectList[i] != NULL) {
		sDistX = abs(m_pDynamicObjectList[i]->m_sX - dX);
		sDistY = abs(m_pDynamicObjectList[i]->m_sY - dY);
		
		if ((m_pDynamicObjectList[i]->m_cMapIndex == cMapIndex) && 
			((m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISH) || (m_pDynamicObjectList[i]->m_sType == DEF_DYNAMICOBJECT_FISHOBJECT)) &&
			(sDistX <= 2) && (sDistY <= 2)) {
			// ¹°°í±â ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ®¸¦ Ã£¾Ò´Ù. ÀÌÁ¦ ÀÌ ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ÀÎµ¦½º¸¦ ¼ÒÀ¯ÇÑ FishÀÇ ÀÎµ¦½º¸¦ ¹ÝÈ¯ÇÑ´Ù. 

			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ] == NULL) return 0;
			if (m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount >= DEF_MAXENGAGINGFISH) return 0;

			// ÀÌ¹Ì ³¬½Ã¸ðµå¿¡ µé¾î°¡ ÀÖ´Â Ä³¸¯ÅÍ´Â Áßº¹ µ¿ÀÛÀÌ ºÒ°¡´É.
			if (m_pClientList[iClientH]->m_iAllocatedFish != NULL) return 0;
			if (m_pClientList[iClientH]->m_cMapIndex != cMapIndex) return 0;
			// ÀÌÁ¦ Ä³¸¯ÅÍ¿¡°Ô ³¬½Ã ¸ðµå¸¦ ½ÃÀÛÇÒ °ÍÀ» ÇÒ´çÇÑ´Ù.
			m_pClientList[iClientH]->m_iAllocatedFish = m_pDynamicObjectList[i]->m_sOwner;
			m_pClientList[iClientH]->m_iFishChance = 1;
			// ÀÌ Ä³¸¯ÅÍ´Â ³¬½Ã ½ºÅ³À» »ç¿ëÁßÀÓÀ» ¼³Á¤.
			m_pClientList[iClientH]->m_bSkillUsingStatus[1] = TRUE;

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EVENTFISHMODE, (m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_wPrice/2), m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSprite,
				          m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_sSpriteFrame, m_pFish[m_pDynamicObjectList[i]->m_sOwner]->m_pItem->m_cName);

			// Ä«¿îÆ® Áõ°¡ 
			m_pFish[ m_pDynamicObjectList[i]->m_sOwner ]->m_sEngagingCount++;
			
			return i;
		}
	}

	return 0;
}

void CGame::FishProcessor()
{
 register int i, iSkillLevel, iResult, iChangeValue;

	// ÀÌº¥Æ® ³¬½Ã ¸ðµå°¡ ÇÒ´çµÈ ÇÃ·¹ÀÌ¾îµéÀ» Ã³¸®ÇÑ´Ù.
	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && 
			(m_pClientList[i]->m_iAllocatedFish != NULL)) {
		
			if (m_pFish[ m_pClientList[i]->m_iAllocatedFish ] == NULL) break;	
	
			// ÀÌ ÇÃ·¹ÀÌ¾î¿¡°Ô ÇÒ´çµÈ ¹°°í±â°¡ ÀÖ´Ù. ³¬À» È®·üÀ» Àç°è»êÇÏ¿© Åëº¸ÇØ ÁØ´Ù. 
			// ³¬½Ã ±â¼úÀÇ ½ºÅ³ 
			iSkillLevel  = m_pClientList[i]->m_cSkillMastery[1];
			// ¹°°í±âÀÇ ³­ÀÌµµ¿¡ µû¶ó ½ºÅ³ ·¹º§ÀÌ ¶³¾îÁø´Ù. 
			iSkillLevel -= m_pFish[m_pClientList[i]->m_iAllocatedFish]->m_iDifficulty;
			if (iSkillLevel <= 0) iSkillLevel = 1;
			
			iChangeValue = iSkillLevel / 10;
			if (iChangeValue <= 0) iChangeValue = 1;
			iChangeValue = iDice(1, iChangeValue);

			iResult = iDice(1, 100);
			if (iSkillLevel > iResult)	{
				// ½ºÅ³ ÁÖ»çÀ§ ±¼¸² ¼º°ø. ³¬À» È®·ü Áõ°¡.
				m_pClientList[i]->m_iFishChance += iChangeValue;
				if (m_pClientList[i]->m_iFishChance > 99) m_pClientList[i]->m_iFishChance = 99;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
			else if (iSkillLevel < iResult) {
				// ½ºÅ³ ÁÖ»çÀ§ ±¼¸² ½ÇÆÐ. ³¬À» È®·ü °¨¼Ò.	
				m_pClientList[i]->m_iFishChance -= iChangeValue;
				if (m_pClientList[i]->m_iFishChance < 1) m_pClientList[i]->m_iFishChance = 1;

				SendNotifyMsg(NULL, i, DEF_NOTIFY_FISHCHANCE, m_pClientList[i]->m_iFishChance, NULL, NULL, NULL);
			}
		}
	}
}



void CGame::AdminOrder_CreateFish(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cItemName[21];
 class  CStrTok * pStrTok;
 class  CItem   * pItem;
 register int tX, tY, iType;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	tX = tY = iType = 0;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		tX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		tY = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		iType = atoi(token);
	}

	if ((tX != 0) && (tY != 0) && (iType != 0)) {
		// ÀÌ ÁÂÇ¥¿¡ ¹°°í±â¸¦ ¸¸µç´Ù.
		pItem = new class CItem;
		if (pItem == NULL) {
			delete pStrTok;
			return;
		}
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "¹°°í±â");
		if (_bInitItemAttr(pItem, cItemName) == TRUE) {
   			iCreateFish(m_pClientList[iClientH]->m_cMapIndex, tX, tY, iType, pItem, 1, 60000*20);
		}
		else delete pItem;
   	}

	delete pStrTok;
	return;
}

void CGame::AdminOrder_Teleport(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cMapName[256];
 class  CStrTok * pStrTok;
 register int dX, dY;
 BOOL   bFlag;

	dX = dY = -1;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dX = atoi(token);
	}

	token = pStrTok->pGet();
	if (token != NULL) {
		dY = atoi(token);
	}

	bFlag = FALSE;
	if (strcmp("arefarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvfarm", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresden", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aresdend1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cath_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wrhus_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gshop_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("gldhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("cityhall_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone4", cMapName) == 0) bFlag = TRUE;
	if (strcmp("areuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("aremidl", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("elvine", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("elvined1", cMapName) == 0)    bFlag = TRUE;
	if (strcmp("cath_2", cMapName) == 0)      bFlag = TRUE;
	if (strcmp("wrhus_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gshop_2", cMapName) == 0)     bFlag = TRUE;
	if (strcmp("gldhall_2", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("cityhall_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("bsmith_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("wzdtwr_2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("huntzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvuni", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvmidr", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvmidl", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("dglv2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("dglv4", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("bisle", cMapName) == 0)   bFlag = TRUE;
	if (strcmp("default", cMapName) == 0) bFlag = TRUE;
	
	if (strcmp("fightzone1", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone2", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone3", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone4", cMapName) == 0) bFlag = TRUE;

	if (strcmp("fightzone5", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone6", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone7", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone8", cMapName) == 0) bFlag = TRUE;
	if (strcmp("fightzone9", cMapName) == 0) bFlag = TRUE;

	if (strcmp("middleland", cMapName) == 0) bFlag = TRUE;
	// v1.4334 ¿î¿µÀÚ ÅÚ·¹Æ÷Æ® 
	if (strcmp("middled1n", cMapName) == 0) bFlag = TRUE;
	if (strcmp("middled1x", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arebrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("arebrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("elvbrk11", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk12", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk21", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvbrk22", cMapName) == 0) bFlag = TRUE;

	if (strcmp("arewrhus", cMapName) == 0) bFlag = TRUE;
	if (strcmp("elvwrhus", cMapName) == 0) bFlag = TRUE;

	//2.20 
	if (strcmp("icebound", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("fightzone10", cMapName) == 0) bFlag = TRUE; 

	// v3.2 
	if (strcmp("druncncity", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniaa", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("inferniab", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("maze", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("procella", cMapName) == 0) bFlag = TRUE; 
	if (strcmp("abaddon", cMapName) == 0) bFlag = TRUE; 

	if (bFlag == TRUE)
		RequestTeleportHandler(iClientH, "2   ", cMapName, dX, dY);
   	
	delete pStrTok;
	return;
}


void CGame::ReqGetFishThisTimeHandler(int iClientH)
{
 register int iResult, iFishH;
 class CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_iAllocatedFish == NULL) return;
	if (m_pFish[m_pClientList[iClientH]->m_iAllocatedFish] == NULL) return;

	// ³¬½Ã ½ºÅ³ »ç¿ëÁßÀÓÀ» ÇØÁ¦½ÃÅ²´Ù.
	m_pClientList[iClientH]->m_bSkillUsingStatus[1] = FALSE;

	iResult = iDice(1, 100);
	if (m_pClientList[iClientH]->m_iFishChance >= iResult) {
		// ÀÌ ¹°°í±â¸¦ ³¬´Âµ¥ ¼º°øÇÏ¿´´Ù!
		
		// °æÇèÄ¡ Áõ°¡ 
		m_pClientList[iClientH]->m_iExpStock += iDice(m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty, 5);
		// ½ºÅ³ Áõ°¡ 
		CalculateSSN_SkillIndex(iClientH, 1, m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_iDifficulty);

		// ¾ÆÀÌÅÛ Æ÷ÀÎÅÍ¸¦ ¾ò¾î¿Â´Ù.
		pItem = m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem;
		m_pFish[m_pClientList[iClientH]->m_iAllocatedFish]->m_pItem = NULL;

		// ³¬Àº ¾ÆÀÌÅÛÀ» ¹Ù´Ú¿¡ ¶³¾î¶ß¸°´Ù.
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                       m_pClientList[iClientH]->m_sY, 
															       pItem);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4 color

		// ³¬½Ã ¼º°ø ¸Þ½ÃÁö Àü¼Û 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHSUCCESS, NULL, NULL, NULL, NULL);
		iFishH = m_pClientList[iClientH]->m_iAllocatedFish;
		m_pClientList[iClientH]->m_iAllocatedFish = NULL;
				
		// ¹°°í±â¸¦ Áö¿ì°í ¸®ÅÏ 
		bDeleteFish(iFishH, 1); // <- ¿©±â¼­ ´Ù¸¥ ³¬½Ã²Ûµé¿¡°Ô ¸Þ½ÃÁö°¡ Àü¼ÛµÉ °ÍÀÌ´Ù.
		return;
	}

	// ³¬´Âµ¥ ½ÇÆÐ! 
	m_pFish[ m_pClientList[iClientH]->m_iAllocatedFish ]->m_sEngagingCount--;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FISHFAIL, NULL, NULL, NULL, NULL);
	
	m_pClientList[iClientH]->m_iAllocatedFish = NULL;
}


void CGame::FishGenerator() 
{ 
 register int i, iP, tX, tY, iRet; 
 char  cItemName[21]; 
 short sDifficulty; 
 DWORD dwLastTime; 
 class CItem * pItem; 

	for (i = 0; i < DEF_MAXMAPS; i++) { 
		if ((iDice(1,10) == 5) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_iCurFish < m_pMapList[i]->m_iMaxFish)) { 
    
			iP = iDice(1, m_pMapList[i]->m_iTotalFishPoint) - 1; 
			if ((m_pMapList[i]->m_FishPointList[iP].x == -1) || (m_pMapList[i]->m_FishPointList[iP].y == -1)) break; 

			tX = m_pMapList[i]->m_FishPointList[iP].x + (iDice(1,3) - 2); 
			tY = m_pMapList[i]->m_FishPointList[iP].y + (iDice(1,3) - 2); 

			pItem = new class CItem; 
			if (pItem == NULL) break; 
                   
			// ¸¸µé ¹°°í±â Á¾·ù¿Í ³­ÀÌµµ, Áö¼Ó ½Ã°£À» °áÁ¤ÇÑ´Ù. 
			ZeroMemory(cItemName, sizeof(cItemName)); 
			switch (iDice(1,9)) { 
			case 1:   strcpy(cItemName, "RedCarp"); sDifficulty = iDice(1,10) + 20; break; 
			case 2:   strcpy(cItemName, "GreenCarp"); sDifficulty = iDice(1,5)  + 10; break; 
			case 3:   strcpy(cItemName, "GoldCarp"); sDifficulty = iDice(1,10) + 1;  break; 
			case 4:   strcpy(cItemName, "CrucianCarp"); sDifficulty = 1;  break;    
			case 5:   strcpy(cItemName, "BlueSeaBream"); sDifficulty = iDice(1,15) + 1;  break; 
			case 6:   strcpy(cItemName, "RedSeaBream"); sDifficulty = iDice(1,18) + 1;  break; 
			case 7:   strcpy(cItemName, "Salmon"); sDifficulty = iDice(1,12) + 1;  break; 
			case 8:   strcpy(cItemName, "GrayMullet"); sDifficulty = iDice(1,10) + 1;  break; 
			case 9: 
				// °¡²û °¡´Ù ³¬À» ¼ö ÀÖ´Â Æ¯¼ö ¾ÆÀÌÅÛ 
				switch (iDice(1,150)) { 
				case 1: 
				case 2: 
				case 3: 
					strcpy(cItemName, "PowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 10: 
				case 11: 
					strcpy(cItemName, "SuperPowerGreenPotion"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 20: 
					strcpy(cItemName, "Dagger+2"); 
					sDifficulty = iDice(5,4) + 30; 
					break; 

				case 30: 
					strcpy(cItemName, "LongSword+2"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 40: 
					strcpy(cItemName, "Scimitar+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 50: 
					strcpy(cItemName, "Rapier+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 60: 
					strcpy(cItemName, "Flameberge+2"); 
					sDifficulty = iDice(5,4) + 60; 
					break; 

				case 70: 
					strcpy(cItemName, "WarAxe+2"); 
					sDifficulty = iDice(5,4) + 50; 
					break; 

				case 90: 
					strcpy(cItemName, "Ruby"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 

				case 95: 
					strcpy(cItemName, "Diamond"); 
					sDifficulty = iDice(5,4) + 40; 
					break; 
				} 
			break; 
			} 
			dwLastTime  = (60000 * 10) + (iDice(1,3) - 1)*(60000 * 10); 

			if (_bInitItemAttr(pItem, cItemName) == TRUE) { 
				iRet = iCreateFish(i, tX, tY, 1, pItem, sDifficulty, dwLastTime); 
			} 
			else { 
				delete pItem; 
				pItem = NULL; 
			} 
		} 
	}                                         
}


int CGame::_iCalcPlayerNum(char cMapIndex, short dX, short dY, char cRadius)
{
 register int ix, iy, iRet;
 class CTile * pTile;	

	// Ã³¸® ¼Óµµ¸¦ ³ôÀÌ±â À§ÇØ ÇÔ¼ö¸¦ ÄÝÇÏÁö ¾Ê´Â´Ù.
	if ((cMapIndex < 0)	|| (cMapIndex > DEF_MAXMAPS)) return 0;
	if (m_pMapList[cMapIndex] == NULL) return 0;

	iRet = 0;
	for (ix = dX - cRadius; ix <= dX + cRadius; ix++)
	for (iy = dY - cRadius; iy <= dY + cRadius; iy++) {
		if ( (ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			 (iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY) ) {
			// ÁÂÇ¥¸¦ ¹þ¾î³ª¹Ç·Î Ã³¸®ÇÏÁö ¾Ê´Â´Ù.	
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_sOwner != NULL) && (pTile->m_cOwnerClass == DEF_OWNERTYPE_PLAYER))
				iRet++;
		}
	}

	return iRet;
}


void CGame::WhetherProcessor()
{
 char cPrevMode;
 int i, j;
 DWORD dwTime;

	dwTime = timeGetTime();
  
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) {
			// ³¯¾¾°¡ º¯µ¿µÇ¾î¾ß ÇÏ´Â ¸ÊÀÌ¶ó¸é Ã³¸®ÇÑ´Ù.
			cPrevMode = m_pMapList[i]->m_cWhetherStatus;
			// ³¯¾¾ÀÇ º¯µ¿À» °è»êÇÑ´Ù. 
			if (m_pMapList[i]->m_cWhetherStatus != NULL) {
				// ÇöÀç ³¯¾¾°¡ ÀÛµ¿ÁßÀÌ´Ù. ¸ØÃâ¶§°¡ µÇ¾úÀ¸¸é ¸ØÃá´Ù.
				if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
					m_pMapList[i]->m_cWhetherStatus = NULL;
			}
			else {
				// Á¶°Ç¿¡ µû¶ó ³¯¾¾¸¦ ÀÛµ¿½ÃÅ°´ø°¡ ¸»´ø°¡ °áÁ¤ÇÑ´Ù. 
				if (iDice(1,150) == 50) {
					// ÀÏ´Ü °£´ÜÇÑ Á¶°ÇÀ¸·Î ÀÛµ¿ ½ÃÀÛ 
					m_pMapList[i]->m_cWhetherStatus = iDice(1,3); // 4~6 : Snow
					m_pMapList[i]->m_dwWhetherStartTime = dwTime;
					m_pMapList[i]->m_dwWhetherLastTime  = 60000*3 + 60000*iDice(1,7);
				}
			}
			
			if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) {
				// ³¯¾¾°¡ º¯°æµÇ¾ú´Ù. 
				for (j = 1; j < DEF_MAXCLIENTS; j++) 
				if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
					SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);	
			}
		
			if ((m_pMapList[i]->m_cWhetherStatus == 3) && (iDice(1, 50) == 1) && (strcmp(m_pMapList[i]->m_cName, "middleland") == 0)) {
				// ºñ°¡ ¸Å¿ì ¸¹ÀÌ ¿À´Â °æ¿ì 20ÃÊ¸¶´Ù 50ºÐÀÇ 1 È®·ü·Î ¹Ìµé·£µå¿¡ ¹ø°³°¡ ÃÄ¼­ ±ê¹ßÀ» ¾ø¾Ö¹ö¸°´Ù.
				_DeleteRandomOccupyFlag(i);
			}
		}
	}
}

// v1.4311-3 Ãß°¡ ÇÔ¼ö  »çÅõÀå ¿¹¾à ÃÊ±âÈ­¹× »ç¿ëÀÚ¿¡°Ô ¿¹¾àÀÌ Ãë¼Ò µÇ¾úÀ½ ¾Ë¸°´Ù.FightzoneReserveProcessor 
void CGame::FightzoneReserveProcessor()
{/*
 register int i;
	
	PutLogList("CAN FIGHTZONE RESERVE!!");
			
	// ¿¹¾àµÈ »çÅõÀåµéÀ» ÃÊ±âÈ­ ½ÃÅ²´Ù.  10°³ÀÇ »çÅõÀåÀÇ ÀÔÀåÀ» Çã¶ôÇÑ´Ù.
	for (i=0 ; i < DEF_MAXFIGHTZONE ; i++ ) {

		if (m_iFightZoneReserve[i] == -1 ) continue ; // ¿î¿µÀÚ°¡ ¿¹¾àÇÑ »çÅõÀåÀº ¿¹¾àÀÌ ºÒ°¡´ÉÇÏ´Ù.
		m_iFightZoneReserve[i] = 0 ;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++) {
		// »çÅõÀåÀ» ¿¹¾àÇÑ À¯ÀúÀÎÁö¸¦ È®ÀÎÇÑ´Ù. 
		// »çÅõÀåÀ» ¿¹¾àÇÑ À¯Àú¿¡°Ô »çÅõÀå ¿¹¾àÀÌ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
		if((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iFightzoneNumber != 0))
				SendNotifyMsg(NULL, i, DEF_NOTIFY_FIGHTZONERESERVE, -2, NULL, NULL, NULL);
	}*/
}




int CGame::iGetWhetherMagicBonusEffect(short sType, char cWheatherStatus)
{
 int iWheatherBonus;

	iWheatherBonus = 0;
	switch (cWheatherStatus) {
	case 0: break;
	case 1:
	case 2:
	case 3:
		// Àü±â°è¿­ ¸¶¹ýÀÇ °æ¿ì ºñ°¡ ¿À¸é º¸³Ê½º Å¸°ÝÄ¡°¡ ºÙ´Â´Ù. ¹Ý¸é ÆÄÀÌ¾î °è¿­ ¸¶¹ýÀÇ Å¸°ÝÄ¡´Â ³·¾ÆÁø´Ù.
		switch (sType) {
		case 10:
		case 37:
		case 43:
		case 51:
			//iWheatherBonus = 2*cWheatherStatus;
			iWheatherBonus = 1;
			break;

		case 20:
		case 30:
			//iWheatherBonus = -2*cWheatherStatus;
			iWheatherBonus = -1;
			break;
		}
   		break;
	}

	return iWheatherBonus;
}


int CGame::iGetPlayerRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// º»ÀÎÀÌ ¹üÁËÀÚÀÌÇÏ¸é »ó´ë¹æÀÌ ¸¶À»ÀÌ °°Àº °æ¿ì À§Çù. ´Ù¸£¸é Àû 
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) {
			 iRet = 7; // À§Çù 
		}
		else iRet = 2; // Àû   
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌÇÏ¸é
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 6; // ¸¶À»ÀÌ °°À¸¸é PK
		else iRet = 2; // ´Ù¸£¸é ±×³É Àû 
	}
	else {
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// µÑ ´Ù 0(Traveler)ÀÌ ¾Æ´Ï¸é ÀûÀÌ´Ù.
				iRet = 2;
			}
			else {
				iRet = 0;
			}
		}	
		else {
			// ¾Æ±ºÀÌ´Ù. ±æµå¿ø¿©ºÎ¸¦ ÆÇ´Ü.
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// ±æµå ÀÌ¸§ÀÌ °°´Ù. 
				if (m_pClientList[iOpponentH]->m_iGuildRank == 0)
					 iRet = 5;	// ±æµå ·©Å©°¡ 0. ±æµå¸¶½ºÅÍÀÌ´Ù.
				else iRet = 3;	// °°Àº ±æµå¿ø
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// ±æµå À§Ä¡´Â °°°í ±æµå ÀÌ¸§ÀÌ ´Ù¸£´Ù.
				iRet = 4; // ´Ù¸¥ ±æµå¿ø 
			}
			else iRet = 1; // ±×³É °°ÀºÆí 
		}
	}

	return iRet;
}


int CGame::iGetPlayerABSStatus(int iWhatH, int iRecvH)
{
	// Àý´ëÀûÀÎ Ä³¸¯ÅÍÀÇ ¼Ò¼ÓÀ» ¾ò´Â´Ù. 
	/*
		0: ¹«¼Ò¼Ó 

		1: ¾Æ·¹½ºµ§ ¼Ò¼Ó
		2: ¾Æ·¹½ºµ§ ¹üÁËÀÚ
		3: ¾Æ·¹½ºµ§ °°Àº ±æµå¿ø
		4: ¾Æ·¹½ºµ§ ´Ù¸¥ ±æµå¿ø
		5: ¾Æ·¹½ºµ§ °°Àº ±æµå¸¶½ºÅÍ  
		6: ¾Æ·¹½ºµ§ ´Ù¸¥ ±æµå¸¶½ºÅÍ

		8:  ¿¤¹ÙÀÎ ¼Ò¼Ó
		9:  ¿¤¹ÙÀÎ ¹üÁËÀÚ
		10: ¿¤¹ÙÀÎ °°Àº ±æµå¿ø
		11: ¿¤¹ÙÀÎ ´Ù¸¥ ±æµå¿ø
		12: ¿¤¹ÙÀÎ °°Àº ±æµå¸¶½ºÅÍ  
		13: ¿¤¹ÙÀÎ ´Ù¸¥ ±æµå¸¶½ºÅÍ

		15: ¹«¼Ò¼Ó ¹üÁËÀÚ 
	*/

	if (m_pClientList[iWhatH] == NULL) return 0;
	if (m_pClientList[iRecvH] == NULL) return 0;

	if (memcmp(m_pClientList[iWhatH]->m_cLocation, "NONE", 4) == 0) {
		// ¹«¼Ò¼ÓÀÌ´Ù.
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// ¹«¼Ò¼Ó ¹üÁËÀÚ 
			return 15;
		}
		else return 0;
	}
	else if (memcmp(m_pClientList[iWhatH]->m_cLocation, "aresden", 7) == 0) {
		// ¾Æ·¹½ºµ§ ¼Ò¼Ó 
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// ¾Æ·¹½ºµ§ÀÇ ¹üÁËÀÚ 
			return 2;
		}
		else {
			if (m_pClientList[iWhatH]->m_iGuildRank == 0) {
				// ¾Æ·¹½ºµ§ ±æµå¸¶½ºÅÍ 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// ³» ±æµå ¸¶½ºÅÍ 
					return 5;
				}
				else {
					// ´Ù¸¥ ±æµå ¸¶½ºÅÍ 
					// v1.44 »çÅõÀåÀÌ¸é ´Ù¸¥ ±æµå´Â ÀûÀÌ´Ù.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 2;
					else return 6;
				}
			}
			else if (m_pClientList[iWhatH]->m_iGuildRank == 12) { 
				// ¾Æ·¹½ºµ§ ±æµå¿ø 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// °°Àº ±æµå¿ø 
					return 3;
				}
				else {
					// ´Ù¸¥ ±æµå¿ø 
					// v1.44 »çÅõÀåÀÌ¸é ´Ù¸¥ ±æµå´Â ÀûÀÌ´Ù.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 2;
					else return 4;
				}
			}
			else {
				// ¾Æ·¹½ºµ§ ½Ã¹Î 
				return 1;
			}
		}
	}
	else if (memcmp(m_pClientList[iWhatH]->m_cLocation, "elvine", 6) == 0) {
		// ¿¤¹ÙÀÎ ¼Ò¼Ó 
		if (m_pClientList[iWhatH]->m_iPKCount != 0) {
			// ¿¤¹ÙÀÎÀÇ ¹üÁËÀÚ 
			return 9;
		}
		else {
			if (m_pClientList[iWhatH]->m_iGuildRank == 0) {
				// ¿¤¹ÙÀÎ ±æµå¸¶½ºÅÍ 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// ³» ±æµå ¸¶½ºÅÍ 
					return 12;
				}
				else {
					// ´Ù¸¥ ±æµå ¸¶½ºÅÍ 
					// v1.44 »çÅõÀåÀÌ¸é ´Ù¸¥ ±æµå´Â ÀûÀÌ´Ù.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 9;
					else return 13;
				}
			}
			else if (m_pClientList[iWhatH]->m_iGuildRank == 12) { 
				// ¿¤¹ÙÀÎ ±æµå¿ø 
				if (memcmp(m_pClientList[iWhatH]->m_cGuildName, m_pClientList[iRecvH]->m_cGuildName, 20) == 0) {
					// °°Àº ±æµå¿ø 
					return 10;
				}
				else {
					// ´Ù¸¥ ±æµå¿ø
					// v1.44 »çÅõÀåÀÌ¸é ´Ù¸¥ ±æµå´Â ÀûÀÌ´Ù.
					if (m_pMapList[m_pClientList[iRecvH]->m_cMapIndex]->m_bIsFightZone == TRUE) 
						 return 9;
					else return 11;
				}
			}
			else {
				// ¿¤¹ÙÀÎ ½Ã¹Î 
				return 8;
			}
		}
	}

	return 0;
}

int CGame::iGetNpcRelationship(int iWhatH, int iRecvH) 
{ 
	int iRet; 

	if (m_pClientList[iRecvH] == NULL) return 0; 
	if (m_pNpcList[iWhatH] == NULL) return 0; 

	iRet = 0; 
	switch (m_pNpcList[iWhatH]->m_cSide) { 
	case 10: iRet |= 8; //Fixed, Original 15 
	case 1:  iRet = (iRet | 4) | 2; //Fixed, Original 1 
	case 2:  iRet |= 4; //Fixed, Orignal 8 
	} 

	return iRet; 
} 

/*
int CGame::iGetNpcRelationship(int iWhatH, int iRecvH)
{
 int iRet;

	if (m_pClientList[iRecvH] == NULL) return 0;
	if (m_pNpcList[iWhatH] == NULL) return 0;

	switch (m_pNpcList[iWhatH]->m_cSide) {
	case 0:  return 0;
	case 10: return 15;
	case 1:  return 1;
	case 2:  return 8;
	}

	return 0;
}
*/

/*
int CGame::iGetNpcRelationship(int iClientH, int iOpponentH)
{
 int iRet;
	
	// ÇÃ·¹ÀÌ¾î¿Í NPCÀÇ °ü°è¸¦ ±¸ÇØ NPC¿¡°Ô ÁØ´Ù.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iOpponentH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// º»ÀÎÀÌ ¹üÁËÀÚÀÌÇÏ¸é NPC´Â ¸ðµÎ ÀûÀÌ´Ù.
		iRet = 2;
	}
	else {
		// º»ÀÎÀº ¹«°íÇÏ´Ù. 
		if (m_pNpcList[iOpponentH]->m_cSide == 0)
			iRet = 0; // ¸÷ÀÌ Áß¸³ÀÌ¶ó¸é ¹«Á¶°Ç Áß¸³ 
		else
		if (m_pNpcList[iOpponentH]->m_cSide == 10) 
			iRet = 2; // ¸÷ÀÌ ÀÏ¹Ý¸÷ÀÌ¶ó¸é ¹«Á¶°Ç Àû 
		else if (m_pClientList[iClientH]->m_cSide == m_pNpcList[iOpponentH]->m_cSide) 
			iRet = 1;  // ¼ÒÈ¯¸÷°ú ³ª¿ÍÀÇ ÆíÀÌ °°´Ù¸é °°ÀºÆí 
		else if (m_pClientList[iClientH]->m_cSide == 0) 
			 iRet = 0; // ³»°¡ Áß¸³ÀÌ´Ï ¼ÒÈ¯¸÷°ú´Â Áß¸³ 
		else iRet = 2; // ¼ÒÈ¯¸÷°ú ³»°¡ ÆíÀÌ ´Ù¸£´Ï±ñ ¼ÒÈ¯¸÷Àº Àû 
	}
	
	return iRet;
}
*/

int CGame::iGetPlayerRelationship_SendEvent(int iClientH, int iOpponentH)
{
 int iRet;
	
	// ¿©±â¼­ »çÀÌµå °è»êÇÏ´Â ¹æ¹ýÀº °üÁ¡ÀÌ ´Ù¸£¹Ç·Î ÁÖÀÇÇÑ´Ù. 
    // ³» µ¥ÀÌÅÍ¸¦ ÀÛ¼ºÇÏ´Â °ÍÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ÀÌ¿¡°Ô º¸³»´Â µ¥ÀÌÅÍ¸¦ ÀÛ¼ºÇÏ´Â °ÍÀÓÀ» ÁÖÀÇ.
	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	iRet = 0;

	if (m_pClientList[iClientH]->m_iPKCount != 0) {
		// ³»°¡ ¹üÁËÀÚÀÌÇÏ¸é »ó´ë¹æ¿¡°Ô´Â ¸¶À»ÀÌ ´Ù¸¦ °æ¿ì Àû, ¾Æ´Ï¸é PK·Î ÀÎ½ÄµÈ´Ù.
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) != 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 2; // Àû 
		else iRet = 6; // PK 
	}
	else if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// ³»°¡ ¹«°íÇÏ°í »ó´ë¹æÀÌ ¹üÁËÀÚÀÌÇÏ¸é »ó´ë¹æ¿¡°Ô ¸¶À»ÀÌ ´Ù¸¦ °æ¿ì Àû, ¾Æ´Ï¸é À§ÇùÀ¸·Î ÀÎ½ÄµÈ´Ù.
		if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) != 0) &&
			(memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) != 0) && (memcmp(m_pClientList[iOpponentH]->m_cLocation, "NONE", 4) != 0)) 
			 iRet = 2; // Àû
		else {
			iRet = 7; // À§Çù
		}
	}
	else {
		// »ó´ë¹æµµ ³ªµµ ¹üÁËÀÚ°¡ ¾Æ´Ï´Ù. 
		if (m_pClientList[iClientH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// ³ªÀÇ Æí°ú »ó´ë¹æÀÇ ÆíÀÌ ´Ù¸£´Ù. 
			if ((m_pClientList[iClientH]->m_cSide != 0) && (m_pClientList[iOpponentH]->m_cSide != 0)) {
				// ³ªµµ Áß¸³ÀÌ ¾Æ´Ï°í »ó´ë¹æµµ Áß¸³ÀÌ ¾Æ´Ï¶ó¸é 0(Traveler)ÀÌ ¾Æ´Ï¸é ÀûÀ¸·Î ÀÎ½ÄµÈ´Ù.
				iRet = 2;
			}
			else {
				// ÇÑÂÊÀÌ Áß¸³ÀÌ¹Ç·Î »ó´ë¹æ¿¡°Ô Áß¸³À¸·Î ÀÎ½ÄµÈ´Ù.
				iRet = 0;
			}
		}	
		else {
			// °°ÀºÆí. µÑ´Ù Áß¸³ÀÌ°Å³ª °°Àº ¸¶À» ¼Ò¼Ó. ±æµå¿ø¿©ºÎ¸¦ ÆÇ´Ü.
			if ((m_pClientList[iClientH]->m_cSide == m_pClientList[iOpponentH]->m_cSide) && 
				(m_pClientList[iClientH]->m_cSide == 0)) {
				iRet = 0; // µÑ´Ù Áß¸³ÀÌ¹Ç·Î Áß¸³.
			}
			else			
			if ((memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) ) {
				// ±æµå ÀÌ¸§ÀÌ °°´Ù. 
				if (m_pClientList[iClientH]->m_iGuildRank == 0)
					 iRet = 5;	// ³» ±æµå ·©Å©°¡ 0. ±æµå¸¶½ºÅÍ·Î »ó´ë¹æ¿¡°Ô ÀÎ½ÄµÈ´Ù.
				else iRet = 3;	// °°Àº ±æµå¿ø
			}
			else 
			if ((memcmp(m_pClientList[iClientH]->m_cLocation, m_pClientList[iOpponentH]->m_cLocation, 10) == 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iOpponentH]->m_cGuildName, "NONE", 4) != 0) &&
				(memcmp(m_pClientList[iClientH]->m_cGuildName, m_pClientList[iOpponentH]->m_cGuildName, 20) != 0)) {
				// ±æµå ÀÌ¸§Àº ´Ù¸£³ª ±æµå À§Ä¡´Â °°°í ±æµå ÀÌ¸§ÀÌ ´Ù¸£´Ù.
				iRet = 4; // ´Ù¸¥ ±æµå¿ø 
			}
			else {
				iRet = 1; // ±×³É °°ÀºÆí 
			}
		}
	}

	return iRet;
}


int CGame::iGetNpcRelationship_SendEvent(int iNpcH, int iOpponentH)
{
 int iRet;
	
	// ¿©±â¼­ »çÀÌµå °è»êÇÏ´Â ¹æ¹ýÀº °üÁ¡ÀÌ ´Ù¸£¹Ç·Î ÁÖÀÇÇÑ´Ù. 
    // ³»(NPC) µ¥ÀÌÅÍ¸¦ ÀÛ¼ºÇÏ´Â °ÍÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ÀÌ¿¡°Ô º¸³»´Â µ¥ÀÌÅÍ¸¦ ÀÛ¼ºÇÏ´Â °ÍÀÓÀ» ÁÖÀÇ.
	if (m_pClientList[iOpponentH] == NULL) return 0;
	if (m_pClientList[iOpponentH]->m_bIsInitComplete == FALSE) return 0;

	if (m_pNpcList[iNpcH] == NULL) return 0;

	iRet = 0;

	if (m_pClientList[iOpponentH]->m_iPKCount != 0) {
		// »ó´ë¹æÀÌ ¹üÁËÀÚÀÌÇÏ¸é ÆíÀÌ °°À¸¸é À§ÇùÀ¸·Î ¾Æ´Ï¸é NPC ÀûÀ¸·Î ÀÎ½ÄµÈ´Ù.
		if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[iOpponentH]->m_cSide)
			 iRet = 7; 
		else iRet = 2;
	}
	else {
		if (m_pNpcList[iNpcH]->m_cSide != m_pClientList[iOpponentH]->m_cSide) {
			// ¸÷ÀÇ Æí°ú »ó´ë¹æÀÇ ÆíÀÌ ´Ù¸£´Ù.
			if (m_pNpcList[iNpcH]->m_cSide == 10) 
				iRet = 2; // ¸÷ÀÌ ÀÏ¹Ý ¸÷ÀÌ´Ù. »ó´ë¹æ¿¡°Ô´Â ÀûÀ¸·Î ÀÎ½ÄµÈ´Ù.
			else 
			if (m_pNpcList[iNpcH]->m_cSide == 0) iRet = 0; // ¸÷ÀÌ Áß¸³ÀÌ¸é ¹«Á¶°Ç Áß¸³ 	
			else 
			if (m_pClientList[iOpponentH]->m_cSide == 0) 
				 iRet = 0; // »ó´ë¹æÀÌ Áß¸³ÀÌ´Ù. ¼ÒÈ¯¸÷°ú Áß¸³°úÀÇ °ü°è´Â Áß¸³. 
			else iRet = 2; // ¼ÒÈ¯¸÷°ú ½Ã¹Î ÀÌ»óÀÎµ¥ ÆíÀÌ ´Ù¸£¹Ç·Î Àû 
			
		}
		else iRet = 1; // °°Àº Æí 
	}

	return iRet;
}


int CGame::iGetMapIndex(char * pMapName)
{
 register int i, iMapIndex;
 char cTmpName[256];

	ZeroMemory(cTmpName, sizeof(cTmpName));
	strcpy(cTmpName, pMapName);

	iMapIndex = -1;
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) {
		if (memcmp(m_pMapList[i]->m_cName, pMapName, 10) == 0) 
			iMapIndex = i;
	}

	return iMapIndex;
}



int CGame::_iForcePlayerDisconect(int iNum)
{
 register int i, iCnt;

	iCnt = 0;
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		if (m_pClientList[i]->m_bIsInitComplete == TRUE)
			 DeleteClient(i, TRUE, TRUE);
		else DeleteClient(i, FALSE, FALSE);
		iCnt++;
		if (iCnt >= iNum) break;
	}

	return iCnt;
}

void CGame::SpecialEventHandler()
{
 DWORD dwTime;
 
	// Æ¯º°ÇÑ ÀÌº¥Æ®¸¦ »ý¼ºÇÑ´Ù. 
	dwTime = timeGetTime();

	if ((dwTime - m_dwSpecialEventTime) < DEF_SPECIALEVENTTIME) return;
	m_dwSpecialEventTime  = dwTime;
	m_bIsSpecialEventTime = TRUE;
	
	switch (iDice(1,180)) {
	case 98: m_cSpecialEventType = 2; break; // µ¥¸ó È¤Àº À¯´ÏÄÜÀÌ ³ª¿Ã °¡´É¼ºÀº 30ºÐ¿¡ 1¹ø 1/30
	default: m_cSpecialEventType = 1; break;
	}
}

void CGame::AdminOrder_CheckIP(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cIP[21], cInfoString[500];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// tokenÀÌ IP addressÀÌ´Ù. 
		ZeroMemory(cIP, sizeof(cIP));
		strcpy(cIP, token);

		for (i = 1; i < DEF_MAXCLIENTS; i++) 
		if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cIPaddress, cIP, strlen(cIP)) == 0)) {
			// ¿ä±¸ÇÑ ÁÖ¼Ò¿Í ÀÏÄ¡ÇÏ´Â Å¬¶óÀÌ¾ðÆ® ¹ß°ß. 
			ZeroMemory(cInfoString, sizeof(cInfoString));
			wsprintf(cInfoString, "Name(%s/%s) Loc(%s: %d %d) Level(%d:%d) Init(%d) IP(%s)", 
				     m_pClientList[i]->m_cAccountName, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cMapName, 
					 m_pClientList[i]->m_sX, m_pClientList[i]->m_sY, 
					 m_pClientList[i]->m_iLevel, NULL/*m_pClientList[i]->m_cAccountStatus*/,
					 m_pClientList[i]->m_bIsInitComplete, m_pClientList[i]->m_cIPaddress);

			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_IPACCOUNTINFO, NULL, NULL, NULL, cInfoString);
		}
	}

	
	delete pStrTok;
}

void CGame::ToggleSafeAttackModeHandler(int iClientH) //v1.1
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return;

	// ¾ÈÀü °ø°Ý ¸ðµå¸¦ Åä±ÛÇÑ´Ù. 
	if (m_pClientList[iClientH]->m_bIsSafeAttackMode == TRUE) 
		 m_pClientList[iClientH]->m_bIsSafeAttackMode = FALSE;
	else m_pClientList[iClientH]->m_bIsSafeAttackMode = TRUE;

	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SAFEATTACKMODE, NULL, NULL, NULL, NULL);
}

void CGame::NpcRequestAssistance(int iNpcH)
{
 register int ix, iy, sX, sY;
 short sOwnerH;
 char  cOwnerType;
	
	// iNpc ±Ù¹æ¿¡ ÀÖ´Â ÀüÅõÁßÀÌ ¾Æ´Ñ NPC¿¡°Ô µµ¿òÀ» ¿äÃ»ÇÑ´Ù. 
	if (m_pNpcList[iNpcH] == NULL) return;

	sX = m_pNpcList[iNpcH]->m_sX;
	sY = m_pNpcList[iNpcH]->m_sY;

	for (ix = sX - 8; ix <= sX + 8; ix++)
	for (iy = sY - 8; iy <= sY + 8; iy++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
		if ((sOwnerH != NULL) && (m_pNpcList[sOwnerH] != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && 
			(iNpcH != sOwnerH) && (m_pNpcList[sOwnerH]->m_cSide == m_pNpcList[iNpcH]->m_cSide) &&
			(m_pNpcList[sOwnerH]->m_bIsPermAttackMode == FALSE) && (m_pNpcList[sOwnerH]->m_cBehavior == DEF_BEHAVIOR_MOVE)) {
			
			// Á¶°Ç¿¡ ºÎÇÕÇÏ´Â NPC¸¦ Ã£¾Ò´Ù. 
			m_pNpcList[sOwnerH]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
			m_pNpcList[sOwnerH]->m_sBehaviorTurnCount = 0;		
			m_pNpcList[sOwnerH]->m_iTargetIndex = m_pNpcList[iNpcH]->m_iTargetIndex;
			m_pNpcList[sOwnerH]->m_cTargetType  = m_pNpcList[iNpcH]->m_cTargetType;

			return;
		}
	}
}

void CGame::ForceDisconnectAccount(char *pAccountName, WORD wCount)
{
 register int i;

	// Áßº¹µÈ °èÁ¤À» °®°íÀÖ´Â Ä³¸¯ÅÍ¸¦ »èÁ¦ÇÑ´Ù. 
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cAccountName, pAccountName, 10) == 0)) {
		wsprintf(G_cTxt, "<%d> Force disconnect account: CharName(%s) AccntName(%s) Count(%d)", i, m_pClientList[i]->m_cCharName, m_pClientList[i]->m_cAccountName, wCount);
		PutLogList(G_cTxt);
		
		// v1.42 Ä«¿îÆÃ ÇÃ·¡±×¸¦ È°¼ºÈ­ ÇØ¾ß ÇÑ´Ù. 
		//DeleteClient(i, TRUE, TRUE);

		//v1.4312
		SendNotifyMsg(NULL, i, DEF_NOTIFY_FORCEDISCONN, wCount, NULL, NULL, NULL);
	}
}

void CGame::AdminOrder_Polymorph(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 


	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	if (token != NULL) {
		// ¾ÆÁ÷ ±¸ÇöµÇÁö ¾Ê¾Ò´Ù. Æú¸®¸ðÇÁ ·çÆ¾ÀÌ ¿Ï¼ºµÈ ÈÄ µ¿ÀÛÇÒ °ÍÀÓ. 
	}

	delete pStrTok;
}

void CGame::AdminOrder_SetInvi(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 
		if (token[0] == '1') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
		if (token[0] == '0') SetInvisibilityFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

BOOL CGame::bOnClose()
{
	if (m_bIsServerShutdowned == FALSE) 
		if (MessageBox(NULL, "Player data not saved! Shutdown server now?", m_cServerName, MB_ICONEXCLAMATION | MB_YESNO) == IDYES) return TRUE;
		else return FALSE;
	else return TRUE;
		
	return FALSE;
}
void CGame::AdminOrder_SendMSG(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256], cTemp[256];
	int    iPass, iSwitch;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	iSwitch = atoi(token);

	token2 = pStrTok->pGet();
	
	iPass = atoi(token2);

	wsprintf(cTemp, "token (%s) token2 (%s) iPass(%d)", token, token2, iPass);
	PutLogList(cTemp);

	if (iSwitch == 1) {
		SendNotifyMsg(NULL, iClientH, (DEF_NOTIFY_LEVELUP + iPass), NULL, NULL, NULL, NULL);
		//SendMsg(iClientH, DEF_OWNERTYPE_PLAYER, FALSE, lPass);
	}
	if (iSwitch == 0) {
		SendNotifyMsg(NULL, iClientH, (DEF_NOTIFY_LEVELUP - iPass), NULL, NULL, NULL, NULL);
		//SendMsg(iClientH, DEF_OWNERTYPE_PLAYER, FALSE, lPass);
	}
	delete pStrTok;
}
void CGame::AdminOrder_SetStatus(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, * token2, cBuff[256];
	int    iPass;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	token2 = pStrTok->pGet();

	iPass = (int)token2;
	if (token != NULL) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 


		if (token[0] == '1')
		{
			SetStatusFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE, iPass);
			//SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			//m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}
		else
			SetStatusFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE, iPass);
			//if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}
//SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus, int iPass)

	delete pStrTok;
}
void CGame::AdminOrder_SetZerk(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 


		if (token[0] == '1')
		{
			SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
			m_pClientList[iClientH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_BERSERK ] = (char)m_pMagicConfigList[32]->m_sValue4;
		}
		else
			if (token[0] == '0') SetBerserkFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

void CGame::AdminOrder_SetFreeze(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256]; 
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token != NULL) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é Åõ¸íÀ¸·Î ¼¼Æ®. '0'ÀÌ¸é ÇØÁ¦ 
		if (token[0] == '1') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, TRUE);
		else
			if (token[0] == '0') SetIceFlag(iClientH, DEF_OWNERTYPE_PLAYER, FALSE);
	}

	delete pStrTok;
}

void CGame::_CheckAttackType(int iClientH, short *spType)
{
 WORD wType;

	if (m_pClientList[iClientH] == NULL) return;
	wType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	switch (*spType) {
	case 2:	
		// È­»ìÀÌ ¾ø´Ù¸é È­»ì Effect´Â ³ÖÁö ¾Ê´Â´Ù. 
		if (m_pClientList[iClientH]->m_cArrowIndex == -1) *spType = 0;
		// È° °ø°ÝÀÎµ¥ ÀåÂøÇÑ ¹«±â°¡ È°ÀÌ ¾Æ´Ï´Ù. ÀÏ¹Ý °ø°ÝÀ¸·Î ÀüÈ¯.
		if (wType < 40) *spType = 1;
		break;

	case 20:
		// ¸Ç¼Õ ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[5] < 100) *spType = 1;
		break;

	case 21: 
		// ´Ü°Ë ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[7] < 100) *spType = 1;
		break;

	case 22: 
		// Ææ½Ì ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[9] < 100) *spType = 1;
		break;

	case 23: 
		// Àå°Ë ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)   *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[8] < 100) *spType = 1;
		break;

	case 24: 
		// µµ³¢ ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 1;
		if (m_pClientList[iClientH]->m_cSkillMastery[10] < 100) *spType = 1;
		break;

	case 25: 
		// È° ÇÊ»ì±â 
		if (m_pClientList[iClientH]->m_iSuperAttackLeft <= 0)  *spType = 2;
		if (m_pClientList[iClientH]->m_cSkillMastery[6] < 100) *spType = 2;
		if (m_pClientList[iClientH]->m_cArrowIndex == -1)      *spType = 0;
		// È° °ø°ÝÀÎµ¥ ÀåÂøÇÑ ¹«±â°¡ È°ÀÌ ¾Æ´Ï´Ù. ÀÏ¹Ý °ø°ÝÀ¸·Î ÀüÈ¯.
		if (wType < 40) *spType = 1;
		break;
	}
}


void CGame::ReqCreatePortionHandler(int iClientH, char *pData)
{
 DWORD * dwp;
 WORD  * wp;
 char  * cp, cI[6], cPortionName[21], cData[120];
 int    iRet, i, j, iEraseReq, iSkillLimit, iSkillLevel, iResult, iDifficulty;
 short * sp, sItemIndex[6], sTemp;
 short  sItemNumber[6], sItemArray[12];
 BOOL   bDup, bFlag;
 class  CItem * pItem;

	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	for (i = 0; i < 6; i++) {
		cI[i] = -1;
		sItemIndex[i]  = -1;
		sItemNumber[i] = 0;
	}

	cp = (char *)(pData + 11);
	cI[0] = *cp;
	cp++;
	cI[1] = *cp;
	cp++;
	cI[2] = *cp;
	cp++;
	cI[3] = *cp;
	cp++;
	cI[4] = *cp;
	cp++;
	cI[5] = *cp;
	cp++;
	// Æ÷¼ÇÀÇ Àç·á ÀÎµ¦½º¸¦ ¹Þ¾Ò´Ù. ÀÌ Àç·á°¡ Æ÷¼ÇÀ» ¸¸µé ¼ö ÀÖ´Â Á¶ÇÕÀÎÁö È®ÀÎÇÑ´Ù. 

	// µ¥ÀÌÅÍ°¡ À¯È¿ÇÑ ¾ÆÀÌÅÛ ÀÎµ¦½ºÀÎÁö Ã¼Å©ÇÑ´Ù.
	for (i = 0; i < 6; i++) {
		if (cI[i] >= DEF_MAXITEMS) return;
		if ((cI[i] >= 0) && (m_pClientList[iClientH]->m_pItemList[cI[i]] == NULL)) return;
	}

	for (i = 0; i < 6; i++)
	if (cI[i] >= 0) {
		// ¸ÕÀú ÀÌ¹Ì ÀÖ´Â ¸®½ºÆ®ÀÎÁö °Ë»ö 
		bDup = FALSE;
		for (j = 0; j < 6; j++) 
		if (sItemIndex[j] == cI[i]) {
			// ÀÖ´Ù. Ä«¿îÆ® Áõ°¡ 
			sItemNumber[j]++;
			bDup = TRUE;
		}
		if (bDup == FALSE) {
			// ¾ø´Ù. »õ·Î Ãß°¡ÇÑ´Ù.
			for (j = 0; j < 6; j++) 
			if (sItemIndex[j] == -1) {
				sItemIndex[j] = cI[i];
				sItemNumber[j]++;
				goto RCPH_LOOPBREAK;
			}
RCPH_LOOPBREAK:;
		}
	}
	
	// ¾ÆÀÌÅÛ ¸®½ºÆ®°¡ ¸¸µé¾î Á³´Ù. ¼ÒºñµÇ´Â ¾ÆÀÌÅÛÀÌ¶ó¸é °¹¼ö¸¦ È®ÀÎÇÑ´Ù. 
	for (i = 0; i < 6; i++) 
	if (sItemIndex[i] != -1) {
		if (sItemIndex[i] < 0) return;
		if ((sItemIndex[i] >= 0) && (sItemIndex[i] >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]] == NULL) return;
		// ¾ÆÀÌÅÛÀÌ °¹¼ö°¡ ¿À¹öÇØµµ ¸®ÅÏ.
		if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount < sItemNumber[i]) return;
	}

	// ¾ÆÀÌÅÛÀ» ¾ÆÀÌÅÛ ¾ÆÀÌµð ¹øÈ£°¡ Å« ¼ø¼­ºÎÅÍ Á¤·ÄÇÑ´Ù. Bubble Sort
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i < 5; i++) 
		if ((sItemIndex[i] != -1) && (sItemIndex[i+1] != -1)) {
			if ((m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum) <
				(m_pClientList[iClientH]->m_pItemList[sItemIndex[i+1]]->m_sIDnum)) {
				// ¹Ù²Û´Ù.
				sTemp = sItemIndex[i+1];
				sItemIndex[i+1] = sItemIndex[i];
				sItemIndex[i] = sTemp;
				sTemp = sItemNumber[i+1];
				sItemNumber[i+1] = sItemNumber[i];
				sItemNumber[i] = sTemp;
				bFlag = TRUE;
			}
		}
	}

	//testcode
	/*
	char cTemp[120];
	char cTxt1[120];
	char cTxt2[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	ZeroMemory(cTxt2, sizeof(cTxt2));
	for (i = 0; i < 6; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		if (sItemIndex[i] != -1)
			 wsprintf(cTemp, "(%d) ", m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum);
		else strcpy(cTemp, "(*)");
		strcat(cTxt1, cTemp);

		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "(%d) ", sItemNumber[i]);
		strcat(cTxt2, cTemp);
	}
	PutLogList(cTxt1);
	PutLogList(cTxt2);
	*/

	// µ¥ÀÌÅÍ¿¡ ÀÌ»óÀÌ ¾øÀ½ÀÌ È®ÀÎµÇ¾ú´Ù. Æ÷¼Ç Á¦ÀÛ ¹è¿­À» ÀÛ¼ºÇÑ´Ù. 
	j = 0;
	for (i = 0; i < 6; i++) {
		if (sItemIndex[i] != -1)
			 sItemArray[j] = m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_sIDnum;
		else sItemArray[j] = sItemIndex[i];
		sItemArray[j+1] = sItemNumber[i];
		j += 2;
	}

	//testcode
	/*
	char cTemp[120], cTxt1[120];
	ZeroMemory(cTxt1, sizeof(cTxt1));
	for (i = 0; i < 12; i++) {
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d", sItemArray[i]);
		strcat(cTxt1, cTemp);
	}
	PutLogList(cTxt1);
	*/

	// sItemArrayÀÇ 12°¡Áö ¹è¿­°ú ÀÏÄ¡ÇÏ´Â Æ÷¼ÇÀ» ¸®½ºÆ®¿¡¼­ °Ë»öÇÑ´Ù. 
	ZeroMemory(cPortionName, sizeof(cPortionName));

	for (i = 0; i < DEF_MAXPORTIONTYPES; i++) 
	if (m_pPortionConfigList[i] != NULL) {
		bFlag = FALSE;
		for (j = 0; j < 12; j++) 
		if (m_pPortionConfigList[i]->m_sArray[j] != sItemArray[j]) bFlag = TRUE;
		
		if (bFlag == FALSE) {
			// Æ÷¼Ç Á¶ÇÕÀÌ ÀÏÄ¡ÇÏ´Â ¸®½ºÆ®¸¦ ¹ß°ßÇß´Ù. 
			ZeroMemory(cPortionName, sizeof(cPortionName));
			memcpy(cPortionName, m_pPortionConfigList[i]->m_cName, 20);
			iSkillLimit = m_pPortionConfigList[i]->m_iSkillLimit;
			iDifficulty = m_pPortionConfigList[i]->m_iDifficulty;
		}
	}

	// Á¶ÇÕÀÌ ÀÏÄ¡ÇÏ´Â Æ÷¼ÇÀÌ ¾øÀ¸¹Ç·Î ¹«½Ã
	if (strlen(cPortionName) == 0) {
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMATCHINGPORTION, NULL, NULL, NULL, NULL);
		return;
	}

	// ÇÃ·¹ÀÌ¾îÀÇ ¿¬±Ý¼ú ½ºÅ³ ¼öÁØ
	iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[12];
	if (iSkillLimit > iSkillLevel) {
		// ÇÃ·¹ÀÌ¾îÀÇ ½ºÅ³ÀÌ ³·¾Æ ¸¸µé ¼ö ¾ø´Â Æ÷¼ÇÀÌ´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOWPORTIONSKILL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// Æ÷¼ÇÀÇ Á¦ÀÛ ³­ÀÌµµ¿¡ µû¶ó ¼º°ø·üÀ» Á¶Á¤ÇÑ´Ù.
	iSkillLevel -= iDifficulty;
	if (iSkillLevel <= 0) iSkillLevel = 1;

	iResult = iDice(1,100);
	if (iResult > iSkillLevel) {
		// ½ºÅ³ ½ÇÆÐ 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONFAIL, NULL, NULL, NULL, cPortionName);
		return;
	}

	// ¸ðµç Á¶°ÇÀÌ ¸¸Á·µÇ¾î Æ÷¼ÇÀ» ¸¸µé ¼ö ÀÖ´Ù. ½ºÅ³Ä«¿îÆ®µµ Áõ°¡ 
	CalculateSSN_SkillIndex(iClientH, 12, 1);
	
	// ¸¸Á·ÇÏ´Â Æ÷¼Ç Á¶ÇÕÀÌ ÀÖ´Ù¸é strlen(cPortionName)ÀÌ 0ÀÌ ¾Æ´Ï´Ù. ÀÌ¹Ì °Ë»çÇßÁö¸¸ 
	if (strlen(cPortionName) != 0) {
		pItem = NULL;
		pItem = new class CItem;
		if (pItem == NULL) return;

		// Æ÷¼ÇÀ» Á¦ÀÛÇßÀ¸¹Ç·Î Àç·á¸¦ ¾ø¾Ø´Ù.
		for (i = 0; i < 6; i++)
		if (sItemIndex[i] != -1) {
			if (m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cItemType == DEF_ITEMTYPE_CONSUME)
				// v1.41 !!!
				SetItemCount(iClientH, sItemIndex[i], //     m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_cName,
				             m_pClientList[iClientH]->m_pItemList[sItemIndex[i]]->m_dwCount - sItemNumber[i]);
			else ItemDepleteHandler(iClientH, sItemIndex[i], FALSE);
		}

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_PORTIONSUCCESS, NULL, NULL, NULL, cPortionName);
		// v1.41 ¼Ò·®ÀÇ °æÇèÄ¡ Áõ°¡ 
		m_pClientList[iClientH]->m_iExpStock += iDice(1, (iDifficulty/3));

		if ((_bInitItemAttr(pItem, cPortionName) == TRUE)) {
			// Æ÷¼Ç ¾ÆÀÌÅÛÀÌ ¸¸µé¾îÁ³´Ù. ÇÃ·¹ÀÌ¾îÀÇ ¾ÆÀÌÅÛ ¸®½ºÆ®¿¡ µî·ÏÇÑ´Ù. ¸¸¾à °ø°£ÀÌ ¾ø°Å³ª 
			// ¹«°Ô°¡ ¸ðÀÚ¶ó¸é ¹ß ¹Ø¿¡ ¶³¾îÁ®¾ß ÇÑ´Ù.
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				ZeroMemory(cData, sizeof(cData));
				// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				
				// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
				cp++;
				*/
				
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
				
				// ºñ½Ñ ¾ÆÀÌÅÛÀ» ¹Þ¾Ò´Ù¸é µ¥ÀÌÅÍ¸¦ ÀúÀåÇÑ´Ù. 
				//if ((pItem->m_wPrice * pItem->m_dwCount) > 1000) 
				//	SendMsgToLS(MSGID_REQUEST_SAVEPLAYERDATA, iClientH);
			}
			else {
				// ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
				// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
					                                                         m_pClientList[iClientH]->m_sY, pItem);
				
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
					                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				
				// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					break;
				}
			}
		}
		else {
			delete pItem;
			pItem = NULL;
		}
	}
}



BOOL CGame::_bDecodePortionConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iPortionConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Æ÷¼Ç ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! PORTION configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pPortionConfigList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! PORTION configuration file error - Duplicate portion number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[atoi(token)] = new class CPortion;
					iPortionConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Æ÷¼Ç ÀÌ¸§ 
					ZeroMemory(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, sizeof(m_pPortionConfigList[iPortionConfigListIndex]->m_cName));
					memcpy(m_pPortionConfigList[iPortionConfigListIndex]->m_cName, token, strlen(token));
					cReadModeB = 3;
					break;

				default:
					// ¸¶¹ý Á¾·ù m_sArray[0~10]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[cReadModeB - 3] = atoi(token);
					cReadModeB++;
					break;

				case 14:
					// ¸¶Áö¸· m_sArray[11]
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_sArray[11] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// ½ºÅ³ Á¦ÇÑÄ¡ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 16;
					break;
	
				case 16:
					// ³­ÀÌµµ
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! MAGIC configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pPortionConfigList[iPortionConfigListIndex]->m_iDifficulty = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "portion", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! PORTION configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) PORTION(Total:%d) configuration - success!", iPortionConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::LocalSavePlayerData(int iClientH)
{
 char * pData, * cp, cFn[256], cDir[256], cTxt[256], cCharDir[256];
 int    iSize;
 FILE * pFile;
 SYSTEMTIME SysTime;

	// ·Î±× ¼­¹ö·ÎÀÇ ¿¬°áÀÌ Á¾·áµÇ¾î ÀÓ½Ã·Î °ÔÀÓ¼­¹ö ³»ÀÇ Æú´õ¿¡ ÀúÀåÇÑ´Ù. 
	if (m_pClientList[iClientH] == NULL) return;
 
	pData = new char[30000];
	if (pData == NULL) return;
	ZeroMemory(pData, 30000);

	cp = (char *)(pData);
	iSize = _iComposePlayerDataFileContents(iClientH, cp);

	GetLocalTime(&SysTime);
	ZeroMemory(cCharDir, sizeof(cDir));
	wsprintf(cCharDir, "Character_%d_%d_%d_%d", SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);

	ZeroMemory(cDir, sizeof(cDir));
	ZeroMemory(cFn, sizeof(cFn));
	strcat(cFn,cCharDir);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	wsprintf(cTxt, "AscII%d", (unsigned char)m_pClientList[iClientH]->m_cCharName[0]);
	strcat(cFn, cTxt);
	strcpy(cDir, cFn);
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn, m_pClientList[iClientH]->m_cCharName);
	strcat(cFn, ".txt");

	// µð·ºÅä¸®¸¦ ¸¸µç´Ù.
	_mkdir(cCharDir);
	_mkdir(cDir);

	// (char*)cp ºÎÅÍ (dwMsgSize - 36)Å©±â±îÁö°¡ ÆÄÀÏ¿¡ ÀúÀåµÉ µ¥ÀÌÅÍÀÌ´Ù.
	if (iSize == 0) {
		PutLogList("(!) Character data body empty: Cannot create & save temporal player data file.");
		delete pData;
		return;
	}

	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		wsprintf(cTxt, "(!) Cannot create temporal player data file : Name(%s)", cFn);
		PutLogList(cTxt);
	}
	else {
		wsprintf(cTxt, "(!) temporal player data file saved : Name(%s)", cFn);
		PutLogList(cTxt);
		fwrite(cp, iSize, 1, pFile);
	}
	
	if (pFile != NULL) fclose(pFile);
	delete pData;
}

void CGame::MineralGenerator()
{
 register int i, iP, tX, tY, iRet;
 
	for (i = 0; i < DEF_MAXMAPS; i++) {
		if ((iDice(1,4) == 1) && (m_pMapList[i] != NULL) && 
			(m_pMapList[i]->m_bMineralGenerator == TRUE) && 
			(m_pMapList[i]->m_iCurMineral < m_pMapList[i]->m_iMaxMineral)) {
	
			iP = iDice(1, m_pMapList[i]->m_iTotalMineralPoint) - 1;
			if ((m_pMapList[i]->m_MineralPointList[iP].x == -1) || (m_pMapList[i]->m_MineralPointList[iP].y == -1)) break;

			tX = m_pMapList[i]->m_MineralPointList[iP].x;
			tY = m_pMapList[i]->m_MineralPointList[iP].y;

		   	iRet = iCreateMineral(i, tX, tY, m_pMapList[i]->m_cMineralGeneratorLevel);
		}
	}		
}

int CGame::iCreateMineral(char cMapIndex, int tX, int tY, char cLevel)
{
 register int i, iDynamicHandle, iMineralType;

	if ((cMapIndex < 0) || (cMapIndex >= DEF_MAXMAPS)) return NULL;
	if (m_pMapList[cMapIndex] == NULL) return NULL;
	
	for (i = 1; i < DEF_MAXMINERALS; i++) 
	if (m_pMineral[i] == NULL) {
		// ºó °ø°£¿¡ ±¤¹°µ¢ÀÌ¸¦ ¸¸µç´Ù.
		iMineralType = iDice(1, cLevel);
		m_pMineral[i] = new class CMineral(iMineralType, cMapIndex, tX, tY, 1);
		if (m_pMineral[i] == NULL) return NULL;
 		
		iDynamicHandle = NULL;
		switch (iMineralType) {
		case 1: // ±¤¹°·ù
		case 2:
		case 3:
		case 4:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
				
		case 5: // º¸¼®·ù 
		case 6:
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL2, cMapIndex, tX, tY, NULL, i);
			break;
		
		default:
			// ¿¡·¯ ¹æÁö¿ë ÄÚµå 
			iDynamicHandle = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_MINERAL1, cMapIndex, tX, tY, NULL, i);
			break;
		}
		
		if (iDynamicHandle == NULL) {
			delete m_pMineral[i];
			m_pMineral[i] = NULL;
			return NULL;
		}
		m_pMineral[i]->m_sDynamicObjectHandle = iDynamicHandle;
		m_pMineral[i]->m_cMapIndex = cMapIndex;
		
		// ³­ÀÌµµ¿Í ¼ö·®À» ÀÔ·ÂÇÑ´Ù.
		switch (iMineralType) {
		case 1: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		case 2: m_pMineral[i]->m_iDifficulty = 15; m_pMineral[i]->m_iRemain = 15; break;
		case 3: m_pMineral[i]->m_iDifficulty = 20; m_pMineral[i]->m_iRemain = 10; break;
		case 4: m_pMineral[i]->m_iDifficulty = 50; m_pMineral[i]->m_iRemain = 8; break;
		case 5: m_pMineral[i]->m_iDifficulty = 70; m_pMineral[i]->m_iRemain = 6; break;
		case 6: m_pMineral[i]->m_iDifficulty = 90; m_pMineral[i]->m_iRemain = 4; break;
		default: m_pMineral[i]->m_iDifficulty = 10; m_pMineral[i]->m_iRemain = 20; break;
		}

		// ¸ÊÀÇ ¹Ì³×¶ö ¼ö Áõ°¡
		m_pMapList[cMapIndex]->m_iCurMineral++;
	
		return i;
	}

	return NULL;
}


void CGame::_CheckMiningAction(int iClientH, int dX, int dY)
{
 short sType;
 DWORD dwRegisterTime;
 int   iDynamicIndex, iSkillLevel, iResult;
 char  cMineralName[21];
 class CItem * pItem;
 WORD  wWeaponType;
	
	if (m_pClientList[iClientH] == NULL)  return;

	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->bGetDynamicObject(dX, dY, &sType, &dwRegisterTime, &iDynamicIndex);
	
	switch (sType) {
	case DEF_DYNAMICOBJECT_MINERAL1:
	case DEF_DYNAMICOBJECT_MINERAL2:
		// ±¤¹°Ã¤Ãë¸¦ ½ÃµµÇÑ Ä³¸¯ÅÍÀÇ Á¶°ÇÀ» »ìÇÉ´Ù. °î±ªÀÌ¸¦ µé°í ÀÖ´Â°¡? ±¤¹° Ã¤Ãë ½ºÅ³Àº? 
		// °î±ªÀÌ¿¡ ÇØ´çÇÏ´Â ¿ÜÇüÀÌ¸é Åë°ú 
		wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);
		if (wWeaponType == 25) {
			// ÇÈ¾×½º¸¦ µé°í ÀÖ´Ù. ±¤¹° Ã¤Ãë °¡´É 
		}
		else return;

		// ÀüÅõ ¸ð¼ÇÀÌ ¾Æ´Ï´õ¶óµµ ¸®ÅÏ 
		if ((m_pClientList[iClientH]->m_sAppr2 & 0xF000) == 0) return;

		iSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[0];
		if (iSkillLevel == 0) break;
				
		if (m_pDynamicObjectList[iDynamicIndex] == NULL) break;
		// Ä³´Â ±¤¹°ÀÇ ³­ÀÌµµ¸¸Å­ ½ºÅ³À» ³·Ãá´Ù.
		iSkillLevel -= m_pMineral[ m_pDynamicObjectList[iDynamicIndex]->m_iV1 ]->m_iDifficulty;
		if (iSkillLevel <= 0) iSkillLevel = 1;

		iResult = iDice(1, 100);
		if (iResult <= iSkillLevel) {
			// È®·üÀº ¼º°øÇß´Ù. ±¤¹°Ã¤Ãë ±â¼ú Áõ°¡ 
			CalculateSSN_SkillIndex(iClientH, 0, 1);
						
			// ÇÃ·¹ÀÌ¾îÀÇ ¹ß ¹Ø¿¡ ±¤¹°À» ¶³¾î¶ß¸°´Ù. 
			ZeroMemory(cMineralName, sizeof(cMineralName)); 
			switch (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_cType) { 
			case 1: 
				switch (iDice(1,4)) { 
				case 1: 
				case 2: 
				case 3:    
					strcpy(cMineralName, "Coal"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 4:    
					strcpy(cMineralName, "IronOre"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				} 
				break; 
			case 2: 
				switch (iDice(1,4)) { 
				case 1: 
				case 2: 
					strcpy(cMineralName, "Coal"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 3:    
				case 4:    
					strcpy(cMineralName, "IronOre"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				} 
				break; 
			case 3: 
				switch (iDice(1,6)) { 
				case 1: 
					strcpy(cMineralName, "Coal"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 2: 
				case 3:    
				case 4:    
				case 5: 
					strcpy(cMineralName, "IronOre"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 6: 
					if (iDice(1,8) == 3) { 
						if (iDice(1,2) == 1) { 
							strcpy(cMineralName, "SilverNugget"); 
							m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
						} 
						else { 
							strcpy(cMineralName, "IronOre"); 
							m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
						} 
					} 
					else { 
						strcpy(cMineralName, "IronOre"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					} 
					break; 
					} 
				break; 
			case 4: 
				switch (iDice(1,6)) { 
			case 1: 
					strcpy(cMineralName, "Coal"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 2: 
				case 3:    
				case 4:    
				case 5: 
					strcpy(cMineralName, "IronOre"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					break; 
				case 6: 
					if (iDice(1,8) == 3) { 
						if (iDice(1,4) == 3) { 
							if (iDice(1,4) == 3) { 
								strcpy(cMineralName, "Mithral"); 
								m_pClientList[iClientH]->m_iExpStock += iDice(1,15); 
							} 
							else { 
								strcpy(cMineralName, "GoldNugget"); 
								m_pClientList[iClientH]->m_iExpStock += iDice(1,5); 
							} 
						} 
						else { 
							strcpy(cMineralName, "SilverNugget"); 
							m_pClientList[iClientH]->m_iExpStock += iDice(1,4); 
						} 
					} 
					else { 
						strcpy(cMineralName, "IronOre"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(1,3); 
					} 
					break; 
				} 
				break; 
			case 5: 
				switch (iDice(1,18)) { 
					case 3: 
						strcpy(cMineralName, "Sapphire"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
						break; 
					default: 
						strcpy(cMineralName, "Crystal"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
						break; 
				} 
				break; 
			case 6: 
				switch (iDice(1,5)) { 
				case 1: 
					if (iDice(1,6) == 3) { 
					strcpy(cMineralName, "Emerald"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
					} 
					else { 
						strcpy(cMineralName, "Crystal"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
					} 
					break; 
				case 2: 
					if (iDice(1,6) == 3) { 
						strcpy(cMineralName, "Sapphire"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
					} 
					else { 
						strcpy(cMineralName, "Crystal"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
					} 
					break; 
				case 3: 
					if (iDice(1,6) == 3) { 
						strcpy(cMineralName, "Ruby"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,4); 
					} 
					else { 
						strcpy(cMineralName, "Crystal"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
					} 
					break; 
				case 4: 
					strcpy(cMineralName, "Crystal"); 
					m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
					break; 
				case 5: 
					if (iDice(1,12) == 3) { 
						strcpy(cMineralName, "Diamond"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,5); 
					} 
					else { 
						strcpy(cMineralName, "Crystal"); 
						m_pClientList[iClientH]->m_iExpStock += iDice(2,3); 
					} 
				} 
				break; 
			} 
			
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cMineralName) == FALSE) {
				delete pItem;
			}
			else {
				// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
						                                                     m_pClientList[iClientH]->m_sY, pItem);
				// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
					                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
						                    pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); // v1.4
				//testcode
				//wsprintf(G_cTxt, "Mining Success: %s", cMineralName); 
				//PutLogList(G_cTxt);
			}

			// ±¤¹°ÀÇ ³²Àº ·®À» ÁÙÀÌ°í 0ÀÎ°æ¿ì »èÁ¦ÇÑ´Ù.
			m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain--;
			if (m_pMineral[m_pDynamicObjectList[iDynamicIndex]->m_iV1]->m_iRemain <= 0) {
				// ±¤¹°ÀÌ ¸ðµÎ ¼Ò¸ðµÇ¾ú´Ù. Delete Mineral 
				bDeleteMineral(m_pDynamicObjectList[iDynamicIndex]->m_iV1);

				// µ¿Àû °´Ã¼ »èÁ¦
				delete m_pDynamicObjectList[iDynamicIndex];
				m_pDynamicObjectList[iDynamicIndex] = NULL;
			}
		}
		break;

	default: 
		break;
	}
}


BOOL CGame::bDeleteMineral(int iIndex)
{
 int iDynamicIndex;
 DWORD dwTime;

	dwTime = timeGetTime();
	
	if (m_pMineral[iIndex] == NULL) return FALSE;
	iDynamicIndex = m_pMineral[iIndex]->m_sDynamicObjectHandle;
	if (m_pDynamicObjectList[iDynamicIndex] == NULL) return FALSE;

	SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex, 
		                        m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, 
								m_pDynamicObjectList[iDynamicIndex]->m_sType, iDynamicIndex, NULL);
	// ¸Ê¿¡¼­ ±¤¹° µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
	m_pMapList[m_pDynamicObjectList[iDynamicIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, dwTime);
	// ±¤¹°ÀÌ »ç¶óÁ³À¸¹Ç·Î ÀÌµ¿ÀÌ °¡´ÉÇÏ°Ô ÇÑ´Ù. 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->SetTempMoveAllowedFlag(m_pDynamicObjectList[iDynamicIndex]->m_sX, m_pDynamicObjectList[iDynamicIndex]->m_sY, TRUE);
			
	// ±¤¹° °³Ã¼ ¼ö °¨¼Ò 
	m_pMapList[m_pMineral[iIndex]->m_cMapIndex]->m_iCurMineral--;

	// ±¤¹° °´Ã¼ »èÁ¦ 
	delete m_pMineral[iIndex];
	m_pMineral[iIndex] = NULL;

	return TRUE;
}

void CGame::NpcTalkHandler(int iClientH, int iWho)
{
 char cRewardName[21], cTargetName[21];
 int iResMode, iQuestNum, iQuestType, iRewardType, iRewardAmount, iContribution, iX, iY, iRange, iTargetType, iTargetCount;

	iQuestNum = 0;
	ZeroMemory(cTargetName, sizeof(cTargetName));
	if (m_pClientList[iClientH] == NULL) return;
	switch (iWho) {
	case 1:	// ±æµåÈ¦ 
		break;
	case 2:	// ÀÏ¹Ý »óÁ¡ 
		break;
	case 3:	// ¹«±â »óÁ¡
		break;
	case 4:	// ½ÃÃ»
		iQuestNum = _iTalkToNpcResult_Cityhall(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		break;
	case 5:	// Ã¢°í
		break;
	case 6:	// ¸¶¹ý»çÅ¸¿ö
		break;

	case 32: // À¯´ÏÄÜ
		break;

	case 21: // °æºñ 
		// °æºñº´°úÀÇ ´ëÈ­´Â º°µµ·Î Ã³¸®ÇÑ´Ù. Äù½ºÆ®¿Í ¿¬°üÀÌ ¾øÀ» ¼ö ÀÖÀ¸¹Ç·Î. 
		iQuestNum = _iTalkToNpcResult_Guard(iClientH, &iQuestType, &iResMode, &iRewardType, &iRewardAmount, &iContribution, cTargetName, &iTargetType, &iTargetCount, &iX, &iY, &iRange); 
		if (iQuestNum >= 1000) return; // Quest ¹øÈ£°¡ 1000À» ³Ñ¾î¼­¸é ¹«½ÃÇÑ´Ù.
		break;
	}

	ZeroMemory(cRewardName, sizeof(cRewardName));
	if (iQuestNum > 0) {
		// ÇÒ´çµÈ Äù½ºÆ®°¡ ÀÖ´Ù.
		if (iRewardType > 1) {
			// Æ÷»óÇ°ÀÌ ¾ÆÀÌÅÛÀÌ´Ù.
			strcpy(cRewardName, m_pItemConfigList[iRewardType]->m_cName);
		}
		else {
			switch (iRewardType) {
			case -10: strcpy(cRewardName, "°æÇèÄ¡"); break;
			}
		}

		// Á¦ÀÇÇÑ Äù½ºÆ®¸¦ ±â·ÏÇØ ³õ´Â´Ù.
		m_pClientList[iClientH]->m_iAskedQuest        = iQuestNum;		// Äù½ºÆ® ¹øÈ£ 
		m_pClientList[iClientH]->m_iQuestRewardType   = iRewardType;	// Äù½ºÆ® ÇØ°á½Ã »óÇ° Á¾·ù -> ¾ÆÀÌÅÛÀÇ ID°ªÀÌ´Ù.
		m_pClientList[iClientH]->m_iQuestRewardAmount = iRewardAmount;	// »óÇ° °¹¼ö 
	
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, iQuestType, iResMode, iRewardAmount, cRewardName, iContribution,
			          iTargetType, iTargetCount, iX, iY, iRange, cTargetName);
	}
	else {
		// ¸®ÅÏ°ªÀÌ À½¼öÀÌ¸é Äù½ºÆ® ¹øÈ£°¡ ¾Æ´Ñ ÀÏ¹ÝÀûÀÎ ´ëÈ­ ¹øÈ£¸¦ ÀÇ¹ÌÇÑ´Ù. Àý´ë°ªÀÌ 100À» ´õÇØ º¸³½´Ù. 
		// Return Code
		// -1:101  : ÇöÀç ÀÓ¹« ¼öÇàÁß
		// -2:102  : ¸¶À»ÀÌ ´Ù¸£°Å³ª Áß¸³Àº ÀÓ¹«¸¦ ¾òÀ» ¼ö ¾ø´Ù.    
		// -3:103  : ¹üÁËÀÚ´Â ÀÓ¹«¸¦ ¾òÀ» ¼ö ¾ø´Ù.
		// -4:104  : ÇöÀç Á¶°Ç¿¡ ¸Â´Â ÀÓ¹«°¡ ¾ø´Ù. ÀÌ°æ¿ì ´Ù¸¥ ´ëÈ­ ³»¿ëÀ¸·Î ´ëÃ¼ÇÑ´Ù.
		// -5:105  : Äù½ºÆ®°¡ ¿Ï·áµÇ¾î ÇØ´ç ºÎºÐ¿¡¼­ Ã³¸®µÇ¾ú´Ù. ¿©±â¼­´Â ¸Þ½ÃÁö¸¦ º¸³¾ ÇÊ¿ä ¾ø´Ù.

		//    111  : ±æµåÈ¦ ÀÏ¹Ý Äù½ºÆ® ¿Ï·á½Ã 
		//    112  : ÀÏ¹Ý»óÁ¡ ÀÏ¹Ý Äù½ºÆ® ¿Ï·á½Ã
		//    113  : ¹«±â»óÁ¡ ÀÏ¹Ý Äù½ºÆ® ¿Ï·á½Ã
		//    114  : ½ÃÃ» ÀÏ¹Ý Äù½ºÆ® ¿Ï·á½Ã 
		//    115  : Ã¢°í Äù½ºÆ® ¿Ï·á½Ã 
		//    116  : ¸¶¹ý»ç Å¸¿ö Äù½ºÆ® ¿Ï·á½Ã 

		//    121~126  : Äù½ºÆ® ¿Ï·áµÇ¾úÀ¸³ª »óÇ°À» ¼ÒÁöÇÒ ¼ö ¾ø´Ù´Â ¸Þ½ÃÁö 
		//    131~136  : ÀÏ¹Ý ´ëÈ­ 

		switch (iQuestNum) {
		case  0: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (iWho+130), NULL, NULL, NULL, NULL); break;
		case -1:
		case -2:
		case -3:
		case -4: SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, abs(iQuestNum)+100, NULL, NULL, NULL, NULL); break;
		case -5: break;
		}
	}
}

void CGame::CheckFireBluring(char cMapIndex, int sX, int sY)
{
 register int ix, iy, iItemNum;
 register short sSpr, sSprFrame;
 char  cItemColor;
 class CItem * pItem;

	for (ix = sX -1; ix <= sX +1; ix++)
	for (iy = sY -1; iy <= sY +1; iy++) {
		// ¸¸¾à ÀÌ À§Ä¡¿¡ ¹ßÈ­¼º ¾ÆÀÌÅÛÀÌ ÀÖ´Ù¸é Áö¿ì°í ºÒ ¿ÀºêÁ§Æ®¸¦ ³õ´Â´Ù.	
		iItemNum = m_pMapList[cMapIndex]->iCheckItem(ix, iy);
				
		switch (iItemNum) {
		case 355: 
			// ¼®ÅºÀÌ´Ù. ¾ÆÀÌÅÛÀ» Áö¿ì°í ºÒÀ» ¸¸µç´Ù.
			pItem = m_pMapList[cMapIndex]->pGetItem(ix, iy, &sSpr, &sSprFrame, &cItemColor);
			if (pItem != NULL) delete pItem;
			iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_FIRE, cMapIndex, ix, iy, 6000);	

			SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_SETITEM, cMapIndex,
				                        ix, iy, sSpr, sSprFrame, cItemColor);
			break;
		}
	}
}



void CGame::AdminOrder_GetNpcStatus(int iClientH, char * pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cNpcName[256];
 class  CStrTok * pStrTok;
 register int i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cNpcName, sizeof(cNpcName));
		strcpy(cNpcName, token);
	}

	for (i = 0; i < DEF_MAXNPCS; i++) 
	if (m_pNpcList[i] != NULL) {
		if (memcmp(m_pNpcList[i]->m_cName, cNpcName, 5) == 0) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINIFO, 1, i, NULL, NULL);	
		}
	}

	delete pStrTok;
	return;
}


int CGame::_iGetWeaponSkillType(int iClientH)
{
 WORD wWeaponType;

	if (m_pClientList[iClientH] == NULL) return 0;

	
	// ÇöÀç ¹«ÀåÇÑ ¹«±âÀÇ ½ºÅ³ ¹øÈ£¸¦ ¹ÝÈ¯ 
	wWeaponType = ((m_pClientList[iClientH]->m_sAppr2 & 0x0FF0) >> 4);

	if (wWeaponType == 0) {
		// ¸Ç¼Õ°ø°Ý 
		return 5;
	}
	else if ((wWeaponType >= 1) && (wWeaponType <= 2)) {
		// ´Ü°Ë·ù
		return 7;
	}
	else if ((wWeaponType > 2) && (wWeaponType < 20)) {
		if (wWeaponType == 7) 
			 return 9; // Ææ½Ì°Ë
		else return 8; // Àå°Ë 
	}
	else if ((wWeaponType >= 20) && (wWeaponType < 40)) {
		// µµ³¢·ù 
		return 10;
	}
	else if (wWeaponType >= 40) {
		// È°·ù  
		return 6;
	}
	
	return 1;
}


// ÄÞº¸ °ø°Ý º¸³Ê½º Å×ÀÌºí
//                             1 2 3 
static int ___iCAB5[]  = {0,0, 0,1,2};
static int ___iCAB6[]  = {0,0, 0,1,2};
static int ___iCAB7[]  = {0,0, 1,2,3};
static int ___iCAB8[]  = {0,0, 0,1,2};
static int ___iCAB9[]  = {0,0, 2,4,6};
static int ___iCAB10[] = {0,0, 1,2,3};

int CGame::iGetComboAttackBonus(int iSkill, int iComboCount)
{
	if (iComboCount <= 1) return 0;
	if (iComboCount > 6) return 0;
	switch (iSkill) {
	case 5: // ¸Ç¼Õ °ø°Ý
		return ___iCAB5[iComboCount];
		break;
	case 6: // È°°ø°Ý 
		return ___iCAB6[iComboCount];
		break;
	case 7: // ´Ü°Ë °ø°Ý
		return ___iCAB7[iComboCount];
		break;
	case 8: // Àå°Ë °ø°Ý 
		return ___iCAB8[iComboCount];
		break;
	case 9: // Ææ½Ì °ø°Ý 
		return ___iCAB9[iComboCount];
		break;
	case 10: // µµ³¢°ø°Ý 
		return ___iCAB10[iComboCount];
		break;
	}

	return 0;
}

void CGame::SetDownSkillIndexHandler(int iClientH, int iSkillIndex)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((iSkillIndex < 0) || (iSkillIndex >= DEF_MAXSKILLTYPE)) return;

	if (m_pClientList[iClientH]->m_cSkillMastery[iSkillIndex] > 0)
		m_pClientList[iClientH]->m_iDownSkillIndex = iSkillIndex;

	// ´Ù¿î ½ºÅ³À» ¼³Á¤ÇßÀ¸´Ï ÀÀ´äÀ» º¸³½´Ù. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_DOWNSKILLINDEXSET, m_pClientList[iClientH]->m_iDownSkillIndex, NULL, NULL, NULL);
}


BOOL CGame::_bDepleteDestTypeItemUseEffect(int iClientH, int dX, int dY, short sItemIndex, short sDestItemID)
{
 BOOL bRet;

	// À§Ä¡¸¦ ÁöÁ¤ÇÏ°í »ç¿ë ÈÄ »ç¶óÁö´Â ¾ÆÀÌÅÛ È¿°ú Ã³¸® ºÎºÐ 
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return FALSE;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return FALSE;

	switch (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectType) {
	case DEF_ITEMEFFECTTYPE_OCCUPYFLAG:
		// ¿µÅä Á¡·É¿ë ±ê¹ßÀÌ´Ù. m_sItemEffectValue1 °¡ »çÀÌµå, m_sItemSpecEffectValue1ÀÌ EK ¼ö¸¦ ³ªÅ¸³½´Ù. m_sItemEffectValue2¹øÀÌ 1ÀÌ¸é Admin Flag
		
		// ¸¶½ºÅÍ ±ê¹ßÀÌ¸é ¾Æ¹«µ¥³ª ²ÈÀ» ¼ö ÀÖ°í EKNumÀº ¹«Á¶°Ç 100ÀÌ´Ù.
		if ((BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 == TRUE)
			m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1 = 100;
		
		bRet =  __bSetOccupyFlag(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				 m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue1,    //!!! SpecValue!!!
								 iClientH, // ¼³Ä¡ÀÚ 
								 (BOOL)m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2 ); //
		if (bRet == TRUE) {
			// ±ê¹ß ¼³Ä¡ ¼º°ø.
		}
		else {
			// ±ê¹ß ¼³Ä¡ ½ÇÆÐ¸¦ Åëº¸ÇÑ´Ù.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOTFLAGSPOT, NULL, NULL, NULL, NULL);
		}
		return bRet;

	// crusade
	case DEF_ITEMEFFECTTYPE_CONSTRUCTIONKIT:
		// °Ç¼³ Å°Æ®ÀÌ´Ù. ¹Ìµé·£µå¿¡¼­¸¸ »ç¿ë °¡´ÉÇÔ. m_sItemEffectValue1: °ÇÃà¹° Á¾·ù, m_sItemEffectValue2: °ÇÃà ½Ã°£ 
		bRet = __bSetConstructionKit(m_pClientList[iClientH]->m_cMapIndex, dX, dY,                                 // 
			                         m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1,        //
				 				     m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue2,        //
								     iClientH); // ¼³Ä¡ÀÚ 
		if (bRet == TRUE) {
			// °Ç¼³ ½ÃÀÛ 
		}
		else {
			// °Ç¼³ ½ÇÆÐ			
		}
		return bRet;
	
	case DEF_ITEMEFFECTTYPE_DYE:
		// ¾ÆÀÌÅÛ ¿°»ö: ¾ÆÀÌÅÛ °ªÀÌ À¯È¿ÇÑ°¡ Ã¼Å©.
		if ((sDestItemID >= 0) && (sDestItemID < DEF_MAXITEMS)) {
			if (m_pClientList[iClientH]->m_pItemList[sDestItemID] != NULL) {
				if ( (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 11) ||
					 (m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cCategory == 12) ) {
					// ¿°»öÀÌ °¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù.
					m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor = m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemEffectValue1;
					// »ö ¼Ó¼ºÀÌ ¹Ù²î¾úÀ½À» ¾Ë·ÁÁØ´Ù. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, m_pClientList[iClientH]->m_pItemList[sDestItemID]->m_cItemColor, NULL, NULL);
					return TRUE;
				}
				else {
					// ¿°»öÀÌ ºÒ°¡´ÉÇÑ ¾ÆÀÌÅÛÀÌ´Ù. 
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMCOLORCHANGE, sDestItemID, -1, NULL, NULL);
					return FALSE;
				}
			}
		}	
		break;

	default:
		break;
	}

	return TRUE;
}


BOOL CGame::__bSetOccupyFlag(char cMapIndex, int dX, int dY, int iSide, int iEKNum, int iClientH, BOOL bAdminFlag)
{
 register int ix,iy,tx,ty,fx,fy;
 int   iLocalSide, iLocalEKNum, iDynamicObjectIndex, iIndex, iPrevStatus;
 class CTile * pTile;
 BOOL  bFlag;
 DWORD dwTime = timeGetTime();
	
	// Å©·ç¼¼ÀÌµå ¸ðµå¿¡¼­´Â ±ê¹ß ¼³Ä¡ ºÒ°¡.
	return FALSE;

	// ¹Ìµé·£µå°¡ ¾Æ´ÑÁö¿ªÀ» Á¡·ÉÇÒ ¼ö´Â ¾ø´Ù.

	if (cMapIndex != m_iMiddlelandMapIndex) return FALSE;

	if ((dX < 25) || (dX >= m_pMapList[cMapIndex]->m_sSizeX - 25) || 
		(dY < 25) || (dY >= m_pMapList[cMapIndex]->m_sSizeY - 25)) return FALSE;

	if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) {
		if ((bAdminFlag == FALSE) && (m_pClientList[iClientH]->m_cSide != iSide)) return FALSE;
	}

	// ²È°íÀÚ ÇÏ´Â ÀÚ¸®¿¡ ±ê¹ßÀÌ ¾ø¾î¾ß ÇÑ´Ù.
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	if (pTile->m_iOccupyFlagIndex != NULL) return FALSE;
	if (pTile->m_bIsMoveAllowed == FALSE)  return FALSE;

	// ³Ê¹« °¡±î¿î ÀÎÁ¢ Áö¿ª¿¡ ±ê¹ßÀÌ ÀÖ¾îµµ ¼³Ä¡ÇÒ ¼ö ¾ø´Ù. 
	for (ix = dX-5; ix <= dX+5; ix++) 
	for (iy = dY-5; iy <= dY+5; iy++) {
		if ((ix == dX) && (iy == dY)) {
			// ²ÈÀ» ±ê¹ßÀÇ À§Ä¡´Â °í·ÁÇÏÁö ¾Ê´Â´Ù.
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);			
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
				// °°ÀºÆí ±ê¹ßÀÌ ³Ê¹« ÀÎÁ¢ÇÏ¿© ²ÉÇô ÀÖÀ¸¸é ²ÈÀ» ¼ö ¾ø´Ù. ÀûÀÇ ±ê¹ßÀº »ó°ü ¾ø´Ù. v1.4    
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) return FALSE;
			}
		}
	}

	if (m_pMapList[cMapIndex]->m_iTotalOccupyFlags >= DEF_MAXOCCUPYFLAG) {
		// ´õÀÌ»ó ¼³Ä¡ÇÒ ±ê¹ß °¹¼ö°¡ ³²¾ÆÀÖÁö ¾Ê´Ù.
		return FALSE;
	}
	
	// ¸ÕÀú ±ÙÃ³¿¡ °°ÀºÆí 
	bFlag = FALSE;
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((dX < 0) || (dX >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(dY < 0) || (dY >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
				
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide == iSide) {
					bFlag = TRUE;	
					goto SOF_LOOPBREAK1;
				}
			}
		}
	}

SOF_LOOPBREAK1:;

	// Master Flag°¡ ¾Æ´Ñµ¥ ÀÎÁ¢ºÎÀ§¿¡ ÇÃ·¡±×°¡ ¾ø¾î ¼³Ä¡ÇÒ ¼ö ¾ø´Ù. 
	if ((bFlag == FALSE) && (bAdminFlag == FALSE)) return FALSE;

	// Crusade
	// °¡Àå °¡±îÀÌ¿¡ Á¸ÀçÇÏ´Â Àû ±ê¹ßÀ» Ã£´Â´Ù.
	int iTemp, iDistance = 9999999;
	int iMinFlagIndex = -1;
	class CTile * pMinTile;
	
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL) &&
				(m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide != iSide)) {
				// ´Ù¸¥ ÆíÀÇ ±ê¹ßÀ» Ã£¾Ò´Ù.
				iTemp = (dX - ix)*(dX - ix) + (dY - iy)*(dY - iy);
				if (iTemp < iDistance) {
					iDistance = iTemp;
					iMinFlagIndex = pTile->m_iOccupyFlagIndex;
					pMinTile = pTile;
				}
			}
		}
	}
	// ·çÇÁ¸¦ ´Ù µ¹°í³ª¸é ÇöÀç ¼³Ä¡ÇÑ ±ê¹ß·ÎºÎÅÍ °¡Àå °¡±î¿î ÀûÀÇ ±ê¹ß ÀÎµ¦½º(iMinFlagIndex)°¡ ±¸ÇØÁø´Ù. ¸¸¾à ÀÌ°ªÀÌ -1ÀÌ¸é °¡±î¿î ±ê¹ßÀÌ ¾øÀ½À» ÀÇ¹Ì.
	
	if (iMinFlagIndex != -1) {
		// ±ÙÁ¢ÇÑ Àû ±ê¹ßÀÌ ÀÖ´Ù. Àû ±ê¹ß »èÁ¦
		fx = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_sX;
		fy = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_sY;
		iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_cSide;
		iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_iEKCount;

		// ±ê¹ß °´Ã¼¼ö °¨¼Ò 
		m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;
				
		iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex]->m_iDynamicObjectIndex;
		// Å¬¶óÀÌ¾ðÆ®¿¡°Ô ±ê¹ßÀÌ »ç¶óÁüÀ» ¾Ë¸®°í 
		SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
									m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
									m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
		// ¸Ê¿¡¼­ ±ê¹ß µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
		m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
		
		// ±ê¹ß °´Ã¼¸¦ »èÁ¦ 
		delete m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex];
		m_pMapList[cMapIndex]->m_pOccupyFlag[iMinFlagIndex] = NULL;

		// Å¸ÀÏ »óÀÇ ±ê¹ß ÀÎµ¦½º¸¦ »èÁ¦
		pMinTile->m_iOccupyFlagIndex = NULL;

		// µ¿Àû °´Ã¼ »èÁ¦ 
		delete m_pDynamicObjectList[iDynamicObjectIndex];
		m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

		// ÀÌ ±ê¹ßÀ» »èÁ¦ÇÏ¹Ç·Î ¿µÇâ±Ç ³»ÀÇ °ªÀ» º¯°æ½ÃÄÑ¾ß ÇÑ´Ù. *** ¸Ç ¸¶Áö¸·¿¡ Ã³¸®ÇØ¾ß ÇÑ´Ù.
		for (tx = fx - 10; tx <= fx + 10; tx++)
		for (ty = fy - 8; ty <= fy + 8; ty++) {	
			if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
				// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
				iPrevStatus = pTile->m_iOccupyStatus;
				// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
				switch (iLocalSide) {
				case 1: 
					pTile->m_iOccupyStatus += iLocalEKNum;
					if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
					break;
				case 2:
					pTile->m_iOccupyStatus -= iLocalEKNum;
					if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
					break;
				}
			}
		}
	}
	//

	// ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ¼³Ä¡ 
	switch (iSide) {
	case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
	}
	
	// Crusade ¿¡¼­´Â ±ê¹ßÀÌ ¹«Á¶°Ç EK°¡ 1·Î ¼¼ÆÃµÈ´Ù.
	iEKNum = 1;
	// ±ê¹ß µî·Ï ¹× ¸Ê¿¡ Ç¥½Ã.
	iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
	if (iIndex < 0) {
		// ´õÀÌ»ó ±ê¹ßÀ» ¼³Ä¡ÇÒ ¼ö°¡ ¾ø´Ù. ±ê¹ß ¸®½ºÆ®°¡ ´ÙÃ¡´Ù. ÀÌ·± °æ¿ì°¡ ¹ß»ýÇØ¼­´Â ¾ÈµÈ´Ù(±ê¹ßÀÌ Áö¿öÁöÁö¸¦ ¾ÊÀ½)!	
		// ¿ø·¡´Â ¼³Ä¡Çß´ø ±ê¹ß °´Ã¼¸¦ ±×´ë·Î »èÁ¦ÇØ¾ß ÇÑ´Ù!
		return TRUE; 
	}
	
	pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
	pTile->m_iOccupyFlagIndex = iIndex;
		
	// ±ê¹ß °¹¼ö°¡ ´Ã¾î³µ´Ù.
	m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

	// ±ê¹ß ¼³Ä¡ È¿°ú: ¿µÇâ±Ç ¼³Á¤ 
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
			switch (iSide) {
			case 1: 
				pTile->m_iOccupyStatus -= iEKNum; 
				break;
			case 2:	
				pTile->m_iOccupyStatus += iEKNum; 
				break;
			}
		}
	}
	
	// v1.41 ÀÌÁ¦ Àü·«Àû À§Ä¡µé¿¡ ´ëÇÑ Á¡·É °ªµéÀ» °è»êÇÑ´Ù. 
	iPrevStatus = m_iStrategicStatus;
	_CheckStrategicPointOccupyStatus(cMapIndex);
	if ((iPrevStatus * m_iStrategicStatus) < 0) {
		// Àü·«Àû Á¡·É »óÅÂ°¡ ¹Ù²î¾ú´Ù. ¸ðÁ¾ÀÇ Á¶Ä¡¸¦ ÃëÇÑ´Ù. ±ê¹ßÀ» ²ÈÀº »ç¶÷¿¡°Ô Æ÷»óÇÏ°í »ó´ë¹æ ¸¶À»¿¡ Æä³ÎÆ¼¸¦ ¸ÔÀÎ´Ù.
	}

	return TRUE;

	/*
	// ¿µ¿ª ³»¿¡ ÀÖ´Â Àû ÇÃ·¡±×µéÀ» °Ë»öÇÏ¸ç ºñ±³ÇÏ¿© °á°ú¸¦ Ã¼Å©ÇÑ´Ù.
	for (ix = dX - 10; ix <= dX + 10; ix++)
	for (iy = dY - 8; iy <= dY + 8; iy++) {	
		if (iEKNum <= 0) goto SOF_LOOPBREAK2; 

		if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
			(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
			// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
		}
		else {
			pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
			if ((pTile->m_iOccupyFlagIndex != NULL) && (pTile->m_iOccupyFlagIndex > 0) && 
				(pTile->m_iOccupyFlagIndex < DEF_MAXOCCUPYFLAG) && (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] != NULL)) {
			
				if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide != iSide) {
					// ÆíÀÌ ´Ù¸¥ ±ê¹ßÀ» Ã£¾Ò´Ù. 
					if (m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount <= iEKNum) {
						// ±ê¹ßÀÇ EKCountº¸´Ù ¼³Ä¡ÇÏ·Á´Â ±ê¹ßÀÇ EKÄ«¿îÆ®°¡ °°°Å³ª ´õ Å©´Ù. ÀÌ ±ê¹ßÀº »èÁ¦µÈ´Ù. 
						
						// Crusade
						// ±ê¹ßÀÇ EKÄ«¿îÆ® ¸¸Å­ ¼³Ä¡ÀÚ¿¡°Ô °æÇèÄ¡ ¹èºÐ 
						//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
						//	m_pClientList[iClientH]->m_iExpStock += m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount * 40;
												

						fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
						fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;
						iLocalSide  = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide;
						iLocalEKNum = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;

						// ±ê¹ß °´Ã¼ °¨¼Ò 
						m_pMapList[cMapIndex]->m_iTotalOccupyFlags--;
						
						// ¸ÕÀú EKNumÀ» °¨¼Ò½ÃÅ°°í
						iEKNum -= m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount;
						
						iDynamicObjectIndex = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iDynamicObjectIndex;
						// Å¬¶óÀÌ¾ðÆ®¿¡°Ô ±ê¹ßÀÌ »ç¶óÁüÀ» ¾Ë¸®°í 
						SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
													m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
													m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
						// ¸Ê¿¡¼­ ±ê¹ß µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
						m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
						// ±ê¹ß °´Ã¼¸¦ »èÁ¦ 
						delete m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex];
						m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex] = NULL;

						// Å¸ÀÏ »óÀÇ ±ê¹ß ÀÎµ¦½º¸¦ »èÁ¦
						pTile->m_iOccupyFlagIndex = NULL;

						// µ¿Àû °´Ã¼ »èÁ¦ 
						delete m_pDynamicObjectList[iDynamicObjectIndex];
						m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

						// ÀÌ ±ê¹ßÀ» »èÁ¦ÇÏ¹Ç·Î ¿µÇâ±Ç ³»ÀÇ °ªÀ» º¯°æ½ÃÄÑ¾ß ÇÑ´Ù. *** ¸Ç ¸¶Áö¸·¿¡ Ã³¸®ÇØ¾ß ÇÑ´Ù.
						for (tx = fx - 10; tx <= fx + 10; tx++)
						for (ty = fy - 8; ty <= fy + 8; ty++) {	
							if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
								(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
								// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
							}
							else {
								pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
								iPrevStatus = pTile->m_iOccupyStatus;
								// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
								switch (iLocalSide) {
								case 1: 
									pTile->m_iOccupyStatus += iLocalEKNum;
									if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
									break;
								case 2:
									pTile->m_iOccupyStatus -= iLocalEKNum;
									if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
									break;
								}
							}
						}
					}
					else {
						// ±ê¹ßÀÇ EKCount°¡ ´õ Å©´Ù. ÀÌ¹Ì ¼³Ä¡µÈ ±ê¹ßÀÇ ¼ö¸íÀ» ÁÙÀÌ°í ±ê¹ßÀº ¼³Ä¡µÇÁö ¾Ê´Â´Ù.
						m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_iEKCount -= iEKNum;
						iLocalSide = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_cSide;
						
						// ±ê¹ßÀÇ ¼ö¸íÀÌ ÁÙ¾îµç ¸¸Å­ ¿µÇâ±Ç ³»ÀÇ °ªÀ» ÀçÁ¶Á¤ÇÑ´Ù.
						fx = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sX;
						fy = m_pMapList[cMapIndex]->m_pOccupyFlag[pTile->m_iOccupyFlagIndex]->m_sY;

						// ÀÌ ±ê¹ßÀÇ ¿µÇâ±Ç ³»ÀÇ °ªÀ» º¯°æ½ÃÄÑ¾ß ÇÑ´Ù.
						for (tx = fx - 10; tx <= fx + 10; tx++)
						for (ty = fy - 8; ty <= fy + 8; ty++) {	
							if ((tx < 0) || (tx >= m_pMapList[cMapIndex]->m_sSizeX) || 
								(ty < 0) || (ty >= m_pMapList[cMapIndex]->m_sSizeY)) {
								// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
							}
							else {
								pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + tx + ty*m_pMapList[cMapIndex]->m_sSizeY);
								// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
								switch (iLocalSide) {
								case 1: 
									pTile->m_iOccupyStatus += iEKNum;
									if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
									break;
								case 2:
									pTile->m_iOccupyStatus -= iEKNum;
									if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
									break;
								}
							}
						}

						iEKNum = 0;
					}
				}
			}
		}
	}
	
SOF_LOOPBREAK2:;
	

	// EKNumÀÌ 0º¸´Ù Å©¸é ±ê¹ßÀ» ¼³Ä¡ÇÑ´Ù.
	if (iEKNum > 0) {
		// ´ÙÀÌ³ª¹Í ¿ÀºêÁ§Æ® ¼³Ä¡ 
		switch (iSide) {
		case 1:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ARESDENFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
		case 2:	iDynamicObjectIndex = iAddDynamicObjectList(NULL, NULL, DEF_DYNAMICOBJECT_ELVINEFLAG1, cMapIndex, dX, dY, NULL, NULL);	break;
		}
			
		// ±ê¹ß µî·Ï ¹× ¸Ê¿¡ Ç¥½Ã.
		iIndex = m_pMapList[cMapIndex]->iRegisterOccupyFlag(dX, dY, iSide, iEKNum, iDynamicObjectIndex);
		if (iIndex < 0) {
			// ´õÀÌ»ó ±ê¹ßÀ» ¼³Ä¡ÇÒ ¼ö°¡ ¾ø´Ù. ±ê¹ß ¸®½ºÆ®°¡ ´ÙÃ¡´Ù. ÀÌ·± °æ¿ì°¡ ¹ß»ýÇØ¼­´Â ¾ÈµÈ´Ù(±ê¹ßÀÌ Áö¿öÁöÁö¸¦ ¾ÊÀ½)!	
			// ¿ø·¡´Â ¼³Ä¡Çß´ø ±ê¹ß °´Ã¼¸¦ ±×´ë·Î »èÁ¦ÇØ¾ß ÇÑ´Ù!
			return TRUE; 
		}

		// Crusade
		// ±ê¹ßÀÇ EKÄ«¿îÆ® ¸¸Å­ ¼³Ä¡ÀÚ¿¡°Ô °æÇèÄ¡ ¹èºÐ 
		//if ((iClientH > 0) && (m_pClientList[iClientH] != NULL)) 
		//	m_pClientList[iClientH]->m_iExpStock += iEKNum * 25;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + dX + dY*m_pMapList[cMapIndex]->m_sSizeY);
		pTile->m_iOccupyFlagIndex = iIndex;
		
		// ±ê¹ß °¹¼ö°¡ ´Ã¾î³µ´Ù.
		m_pMapList[cMapIndex]->m_iTotalOccupyFlags++;

		// ±ê¹ß ¼³Ä¡ È¿°ú: ¿µÇâ±Ç ¼³Á¤ 
		for (ix = dX - 10; ix <= dX + 10; ix++)
		for (iy = dY - 8; iy <= dY + 8; iy++) {	
			if ((ix < 0) || (ix >= m_pMapList[cMapIndex]->m_sSizeX) || 
				(iy < 0) || (iy >= m_pMapList[cMapIndex]->m_sSizeY)) {
				// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
			}
			else {
				pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + ix + iy*m_pMapList[cMapIndex]->m_sSizeY);
				// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
				switch (iSide) {
				case 1: 
					pTile->m_iOccupyStatus -= iEKNum; 
					break;
				case 2:	
					pTile->m_iOccupyStatus += iEKNum; 
					break;
				}
			}
		}
	}

	// v1.41 ÀÌÁ¦ Àü·«Àû À§Ä¡µé¿¡ ´ëÇÑ Á¡·É °ªµéÀ» °è»êÇÑ´Ù. 
	iPrevStatus = m_iStrategicStatus;
	_CheckStrategicPointOccupyStatus(cMapIndex);
	if ((iPrevStatus * m_iStrategicStatus) < 0) {
		// Àü·«Àû Á¡·É »óÅÂ°¡ ¹Ù²î¾ú´Ù. ¸ðÁ¾ÀÇ Á¶Ä¡¸¦ ÃëÇÑ´Ù. ±ê¹ßÀ» ²ÈÀº »ç¶÷¿¡°Ô Æ÷»óÇÏ°í »ó´ë¹æ ¸¶À»¿¡ Æä³ÎÆ¼¸¦ ¸ÔÀÎ´Ù.

	}

	return TRUE;
	*/
}


void CGame::SetSummonMobAction(int iClientH, int iMode, DWORD dwMsgSize, char *pData)
{
 register int i, iTargetIndex;
 char   seps[] = "= \t\n";
 char   * token, cTargetName[11], cBuff[256];
 class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 0: // Free ¸ðµå
	case 1: // Hold ¸ðµå
		//  ¸¶½ºÅÍ°¡ iClientHÀÎ ¸÷µéÀÇ Á¦¾î¸ðµå¸¦ º¯°æÇÑ´Ù.
		for (i = 0; i < DEF_MAXNPCS; i++)
		if (m_pNpcList[i] != NULL) {
			if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
				 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
				 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

				m_pNpcList[i]->m_iSummonControlMode = iMode;
				m_pNpcList[i]->m_bIsPermAttackMode  = FALSE;
				m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_MOVE;
				m_pNpcList[i]->m_sBehaviorTurnCount = 0;
				m_pNpcList[i]->m_iTargetIndex       = NULL;
			}
		}
		break;
	
	case 2:
		// °ø°Ý ¸ðµå - ¸ñÇ¥¹°À» ¾ò¾î¿Â´Ù. 
		if ((dwMsgSize)	<= 0) return;
		memcpy(cBuff, pData, dwMsgSize);

		pStrTok = new class CStrTok(cBuff, seps);
		token = pStrTok->pGet();
		token = pStrTok->pGet();
   	
		iTargetIndex = 0;
		if (token != NULL) {
			// tokenÀÌ °ð °ø°ÝÇÒ »ç¿ëÀÚ ÀÌ¸§ 
			if (strlen(token) > 10) 
				 memcpy(cTargetName, token, 10);
			else memcpy(cTargetName, token, strlen(token));
	 				
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (memcmp(m_pClientList[i]->m_cCharName, cTargetName, 10) == 0)) {
				// ¸ñÇ¥ Ä³¸¯ÅÍ¸¦ Ã£¾Ò´Ù. ÀÎµ¦½º ÀúÀå 
				iTargetIndex = i;
				goto SSMA_SKIPSEARCH;
			}
		}

SSMA_SKIPSEARCH:;

		if ( (iTargetIndex != 0) && (m_pClientList[iTargetIndex]->m_cSide != 0) && 
			 (m_pClientList[iTargetIndex]->m_cSide != m_pClientList[iClientH]->m_cSide) ) {
			// ¸ñÇ¥¹°ÀÌ Á¸ÀçÇÑ´Ù¸é ÇÒ´çÇÑ´Ù. 
			for (i = 0; i < DEF_MAXNPCS; i++)
			if (m_pNpcList[i] != NULL) {
				if ( (m_pNpcList[i]->m_bIsSummoned == TRUE) && 
					 (m_pNpcList[i]->m_iFollowOwnerIndex == iClientH) &&
					 (m_pNpcList[i]->m_cFollowOwnerType == DEF_OWNERTYPE_PLAYER) ) {

					m_pNpcList[i]->m_iSummonControlMode = iMode;
					m_pNpcList[i]->m_cBehavior          = DEF_BEHAVIOR_ATTACK;
					m_pNpcList[i]->m_sBehaviorTurnCount = 0;		
					m_pNpcList[i]->m_iTargetIndex       = iTargetIndex;
					m_pNpcList[i]->m_cTargetType        = DEF_OWNERTYPE_PLAYER;
					m_pNpcList[i]->m_bIsPermAttackMode  = TRUE;
				}
			}
		}
		break;
	}
}

void CGame::GetOccupyFlagHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iEKNum;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 3) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "¾Æ·¹½ºµ§±ê¹ß"); break;
	case 2: strcpy(cItemName, "¿¤¹ÙÀÎ±ê¹ß");   break;
	}

	// ReqPurchaseItemHandler¿¡¼­ °¡Á®¿Â ·çÆ¾À» °íÃÆÀ½.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î EK °ªÀ» »©µµ µÈ´Ù.
				if (m_pClientList[iClientH]->m_iEnemyKillCount > 12) {
					iEKNum = 12;
					m_pClientList[iClientH]->m_iEnemyKillCount -= 12;
				}
				else {
					iEKNum = m_pClientList[iClientH]->m_iEnemyKillCount;
					m_pClientList[iClientH]->m_iEnemyKillCount = 0;
				}
								
				// EKNumÀ» ÀÔ·ÂÇÑ´Ù.
				pItem->m_sItemSpecEffectValue1 = iEKNum;

				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				wsprintf(G_cTxt, "(*) Get Flag : Char(%s) Flag-EK(%d) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, iEKNum, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
					
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				/*
				*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
				cp++;
				*/
											
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// º¯°æµÈ ¿¡³Ê¹Ì Å³À» ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}



// v1.4311-3 Ãß°¡  ÇÔ¼ö ÀÔÀå±ÇÀ» ÁÖ´Â ÇÔ¼ö   GetFightzoneTicketHandler 
void CGame::GetFightzoneTicketHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq, iMonth, iDay, iHour;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iFightZoneTicketNumber <= 0) { 
		// ÀÔÀå±ÇÀ» ´Ù »ç¿ëÇßÀ½À» ¾Ë¸°´Ù.
		// »çÅõÀå ¹øÈ£°¡ À½¼ö¸é ¿¹¾àÀº Çß´Âµ¥ ÀÔÀå±ÇÀ» ´Ù ¹ÞÀº°æ¿ì ..
		m_pClientList[iClientH]->m_iFightzoneNumber  *= -1;
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_FIGHTZONERESERVE, -1, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cItemName, sizeof(cItemName));

	if (m_pClientList[iClientH]->m_iFightzoneNumber == 1) 
		strcpy(cItemName,"ArenaTicket") ;
	else  wsprintf(cItemName,"ArenaTicket(%d)",m_pClientList[iClientH]->m_iFightzoneNumber ) ;

	pItem = new class CItem;
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¿¡·¯ ¹æÁö¿ë ÄÚµå
		if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
			
		// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î ÀÔÀå±Ç°³¼ö¸¦ »©µµ µÈ´Ù. 
		m_pClientList[iClientH]->m_iFightZoneTicketNumber = m_pClientList[iClientH]->m_iFightZoneTicketNumber -1 ;
				
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		
		iMonth = m_pClientList[iClientH]->m_iReserveTime / 10000 ;
		iDay = (m_pClientList[iClientH]->m_iReserveTime - iMonth*10000) /100 ;
	    iHour = m_pClientList[iClientH]->m_iReserveTime - iMonth*10000 - iDay*100 ;

		pItem->m_sTouchEffectValue1 = iMonth ;
		pItem->m_sTouchEffectValue2 = iDay ;
		pItem->m_sTouchEffectValue3 = iHour ;
		
		
		wsprintf(G_cTxt, "(*) Get FIGHTZONETICKET : Char(%s) TICKENUMBER (%d)(%d)(%d)", m_pClientList[iClientH]->m_cCharName, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3	);		
		PutLogFileList(G_cTxt);
		PutLogList(G_cTxt);

		ZeroMemory(cData, sizeof(cData));

		// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		// 1°³ È¹µæÇß´Ù.
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
				
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
				
		*cp = pItem->m_cItemType;
		cp++;
				
		*cp = pItem->m_cEquipPos;
		cp++;
				
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
				
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
				
		*cp = pItem->m_cGenderLimit;
		cp++;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
				
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
				
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;

		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
				
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
													
		if (iEraseReq == 1) delete pItem;
				
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);
				
		switch (iRet) {
		case DEF_XSOCKEVENT_QUENEFULL:
		case DEF_XSOCKEVENT_SOCKETERROR:
		case DEF_XSOCKEVENT_CRITICALERROR:
		case DEF_XSOCKEVENT_SOCKETCLOSED:
				// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}	
	else {
		// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
		delete pItem;

		// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
		iCalcTotalWeight(iClientH);

		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		switch (iRet) {
			case DEF_XSOCKEVENT_QUENEFULL:
			case DEF_XSOCKEVENT_SOCKETERROR:
			case DEF_XSOCKEVENT_CRITICALERROR:
			case DEF_XSOCKEVENT_SOCKETCLOSED:
			// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}		
}

int CGame::_iComposeFlagStatusContents(char * pData)
{
 SYSTEMTIME SysTime;
 char cTxt[120];
 int i;

	if (m_iMiddlelandMapIndex < 0) return 0;

	GetLocalTime(&SysTime);
	strcat(pData, "[FILE-DATE]\n\n");
	
	wsprintf(cTxt, "file-saved-date: %d %d %d %d %d\n", SysTime.wYear, SysTime.wMonth, SysTime.wDay, SysTime.wHour, SysTime.wMinute);
	strcat(pData, cTxt);
	strcat(pData, "\n\n");
	
	// 
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++) 
	if (m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i] != NULL) { 
		
		wsprintf(cTxt,"flag = %d %d %d %d", m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_cSide,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sX,
										    m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_sY,
			                                m_pMapList[m_iMiddlelandMapIndex]->m_pOccupyFlag[i]->m_iEKCount);
		strcat(pData, cTxt);
		strcat(pData, "\n");
	}

	strcat(pData, "\n\n");

	return strlen(pData);
}


BOOL CGame::_bDecodeOccupyFlagSaveFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token;
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iFlagIndex = 0;
 int  iSide;
 class CStrTok * pStrTok;
 int dX, dY, iEKNum, iTotalFlags;

	if (m_iMiddlelandMapIndex < 0) {
		PutLogList("(!) This game server does not managing Middleland Map. OcuupyFlag data ignored.");
		return FALSE;
	}

	iTotalFlags = 0;

	pContents = new char[dwMsgSize+10];
	ZeroMemory(pContents, dwMsgSize+10);
	memcpy(pContents, pData, dwMsgSize - 9);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Side
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					iSide = atoi(token);
					cReadModeB = 2;
					break;
				
				case 2:
					// X ÁÂÇ¥ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
										
					dX = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Y ÁÂÇ¥  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}

					dY = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// EKNum
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					iEKNum = atoi(token);
					
					// µ¥ÀÌÅÍ¸¦ ¸ðµÎ ¸¸µé¾úÀ¸¹Ç·Î ±ê¹ßÀ» µî·ÏÇÑ´Ù. (!!! Master Flag·Î Ã³¸®ÇØ¾ß¸¸ ¼³Ä¡ÇÒ ¼ö ÀÖ´Ù)
					if (__bSetOccupyFlag(m_iMiddlelandMapIndex, dX, dY, iSide, iEKNum, -1, TRUE) == TRUE)
						iTotalFlags++;
					
					cReadModeA = 0;
					cReadModeB = 0;
					break;
				}
				
			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "flag", 4) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! OccupyFlag save file contents error!");
		return FALSE;
	}

	wsprintf(G_cTxt, "(!) OccupyFlag save file decoding success! Total(%d)", iTotalFlags); 
	PutLogList(G_cTxt);

	return TRUE;
}
//Hero Code by Zabuza
void CGame::GetHeroMantleHandler(int iClientH,int iItemID,char * pString) 
{ 
 int   i, iNum, iRet, iEraseReq; 
 char  * cp, cData[256], cItemName[21]; 
 class CItem * pItem; 
 DWORD * dwp; 
 short * sp; 
 WORD  * wp; 

   if (m_pClientList[iClientH] == NULL) return; 
   if (m_pClientList[iClientH]->m_iEnemyKillCount < 100) return; 
   if (m_pClientList[iClientH]->m_cSide == 0) return; 
   switch(iItemID) 
   { 
   case 142: 
   case 143: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<300) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=300; 
      break; 

   case 130: 
   case 131: 
   case 132: 
   case 133: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<150) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=150; 
      if(m_pClientList[iClientH]->m_iContribution<20) return; 
      m_pClientList[iClientH]->m_iContribution-=20; 
      break; 
   case 134: 
   case 135: 
   case 136: 
   case 137: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<100) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=100; 
      if(m_pClientList[iClientH]->m_iContribution<20) return; 
      m_pClientList[iClientH]->m_iContribution-=20; 
      break; 
   case 126: 
   case 127: 
   case 128: 
   case 129: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<300) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=300; 
      if(m_pClientList[iClientH]->m_iContribution<30) return; 
      m_pClientList[iClientH]->m_iContribution-=30; 
      break; 
   case 138: 
   case 139: 
   case 140: 
   case 141: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<200) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=200; 
      if(m_pClientList[iClientH]->m_iContribution<20) return; 
      m_pClientList[iClientH]->m_iContribution-=20; 
      break; 
   case 118: 
   case 119: 
   case 120: 
   case 121: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<100) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=100; 
      if(m_pClientList[iClientH]->m_iContribution<10) return; 
      m_pClientList[iClientH]->m_iContribution-=10; 
      break; 
   case 122: 
   case 123: 
   case 124: 
   case 125: 
      if(m_pClientList[iClientH]->m_iEnemyKillCount<250) return; 
      m_pClientList[iClientH]->m_iEnemyKillCount-=250; 
      if(m_pClientList[iClientH]->m_iContribution<15) return; 
      m_pClientList[iClientH]->m_iContribution-=15; 
      break; 
   default: 
      return; 
      break; 
   } 
   /* 
   Hero Cape -> 141-142 //EK 300 CONTR 0 
   Hero Helm -> 130-133 //EK 150 CONTR 20 
   Hero Cap -> 134-137 //EK 100 CONTR 20 
   Hero Armor -> 126-129 //EK 300 CONTR 30 
   Hero Robe -> 138-141 //EK 200 CONTR 20 
   Hero Hauberk -> 118-121 //EK 100 CONTR 10 
   Hero Leggings -> 122-125 //EK 250 CONTR 15 
   */ 
   ZeroMemory(cItemName, sizeof(cItemName)); 
   memcpy(cItemName,m_pItemConfigList[iItemID]->m_cName,20); 
   // ReqPurchaseItemHandler에서 가져온 루틴을 고쳤음. 
   iNum = 1; 
   for (i = 1; i <= iNum; i++) 
   { 
      pItem = new class CItem; 
      if (_bInitItemAttr(pItem, cItemName) == FALSE) 
      { 
         // 구입하고자 하는 아이템이 아이템 리스트상에 없다. 구입이 불가능하다. 
         delete pItem; 
      } 
      else { 
                                  
         if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) { 
            // 에러 방지용 코드 
            if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0; 
             
            // 아이템을 받을 수 있다는 것이 확정 되었으므로 EK 값을 빼도 된다. 
             

            //testcode 로그파일에 기록한다. 
            //wsprintf(G_cTxt, "(*) Get HeroItem : Char(%s) Player-EK(%d) Player-Contr(%d) Hero Obtained(%s)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount, m_pClientList[iClientH]->m_iContribution,cItemName); 
            //PutLogFileList(G_cTxt); 

            // 아이템에 사용자 고유 번호를 입력한다. 다른 캐릭터는 이 아이템을 사용할 수가 없다. 
            pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER; 
            pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1; 
            pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2; 
            pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3; 
            // 아이템 얻었다는 메시지를 전송한다. 
            dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
            *dwp = MSGID_NOTIFY; 
            wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
            *wp  = DEF_NOTIFY_ITEMOBTAINED; 
            cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2); 
            // 1개 획득했다. 
            *cp = 1; 
            cp++; 
             
            memcpy(cp, pItem->m_cName, 20); 
            cp += 20; 
             
            dwp  = (DWORD *)cp; 
            *dwp = pItem->m_dwCount; 
            cp += 4; 
             
            *cp = pItem->m_cItemType; 
            cp++; 
             
            *cp = pItem->m_cEquipPos; 
            cp++; 
             
            *cp = (char)0; // 얻은 아이템이므로 장착되지 않았다. 
            cp++; 
             
            sp  = (short *)cp; 
            *sp = pItem->m_sLevelLimit; 
            cp += 2; 
             
            *cp = pItem->m_cGenderLimit; 
            cp++; 
             
            wp = (WORD *)cp; 
            *wp = pItem->m_wCurLifeSpan; 
            cp += 2; 
             
            wp = (WORD *)cp; 
            *wp = pItem->m_wWeight; 
            cp += 2; 
             
            sp  = (short *)cp; 
            *sp = pItem->m_sSprite; 
            cp += 2; 
             
            sp  = (short *)cp; 
            *sp = pItem->m_sSpriteFrame; 
            cp += 2; 

            *cp = pItem->m_cItemColor; 
            cp++; 

            *cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
            cp++; 
             
            dwp = (DWORD *)cp; 
            *dwp = pItem->m_dwAttribute; 
            cp += 4; 
            /* 
            *cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-Item인지의 여부 
            cp++; 
            */ 
                                  
            if (iEraseReq == 1) delete pItem; 
             
            // 아이템 정보 전송 
            iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53); 
             
            // 소지품 총 중량 재 계산 
            iCalcTotalWeight(iClientH); 
             
            switch (iRet) { 
            case DEF_XSOCKEVENT_QUENEFULL: 
            case DEF_XSOCKEVENT_SOCKETERROR: 
            case DEF_XSOCKEVENT_CRITICALERROR: 
            case DEF_XSOCKEVENT_SOCKETCLOSED: 
               // 메시지를 보낼때 에러가 발생했다면 제거한다. 
               DeleteClient(iClientH, TRUE, TRUE); 
               return; 
            } 

            // 변경된 에너미 킬을 알려준다. 
            SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL); 
         } 
         else 
         { 
            // 공간이 부족해 아이템을 얻을 수 없다. 
            delete pItem; 

            // 소지품 총 중량 재 계산 
            iCalcTotalWeight(iClientH); 

            dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID); 
            *dwp = MSGID_NOTIFY; 
            wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE); 
            *wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM; 
             
            iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6); 
            switch (iRet) { 
            case DEF_XSOCKEVENT_QUENEFULL: 
            case DEF_XSOCKEVENT_SOCKETERROR: 
            case DEF_XSOCKEVENT_CRITICALERROR: 
            case DEF_XSOCKEVENT_SOCKETCLOSED: 
               // 메시지를 보낼때 에러가 발생했다면 제거한다. 
               DeleteClient(iClientH, TRUE, TRUE); 
               return; 
            } 
         } 
      } 
    } 
}

/* //Old 2.03 HeroCape code
void CGame::GetHeroMantleHandler(int iClientH)
{
 int   i, iNum, iRet, iEraseReq;
 char  * cp, cData[256], cItemName[21];
 class CItem * pItem;
 DWORD * dwp;
 short * sp;
 WORD  * wp;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iEnemyKillCount < 300) return;
	if (m_pClientList[iClientH]->m_cSide == 0) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: strcpy(cItemName, "AresdenHeroCape"); break;
	case 2: strcpy(cItemName, "ElvineHeroCape");   break;
	}

	// ReqPurchaseItemHandler¿¡¼­ °¡Á®¿Â ·çÆ¾À» °íÃÆÀ½.
	iNum = 1;
	for (i = 1; i <= iNum; i++) {

		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
											
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Ù´Â °ÍÀÌ È®Á¤ µÇ¾úÀ¸¹Ç·Î EK °ªÀ» »©µµ µÈ´Ù.
				if (m_pClientList[iClientH]->m_iEnemyKillCount >= 300) {
					m_pClientList[iClientH]->m_iEnemyKillCount -= 300;
				}

				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				wsprintf(G_cTxt, "(*) Get Mantle : Char(%s) Player-EK(%d)", m_pClientList[iClientH]->m_cCharName, m_pClientList[iClientH]->m_iEnemyKillCount);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
								
				// ¾ÆÀÌÅÛ ¾ò¾ú´Ù´Â ¸Þ½ÃÁö¸¦ Àü¼ÛÇÑ´Ù.
				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_ITEMOBTAINED;
				
				cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
				// 1°³ È¹µæÇß´Ù.
				*cp = 1;
				cp++;
				
				memcpy(cp, pItem->m_cName, 20);
				cp += 20;
				
				dwp  = (DWORD *)cp;
				*dwp = pItem->m_dwCount;
				cp += 4;
				
				*cp = pItem->m_cItemType;
				cp++;
				
				*cp = pItem->m_cEquipPos;
				cp++;
				
				*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
				cp++;
				
				sp  = (short *)cp;
				*sp = pItem->m_sLevelLimit;
				cp += 2;
				
				*cp = pItem->m_cGenderLimit;
				cp++;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wCurLifeSpan;
				cp += 2;
				
				wp = (WORD *)cp;
				*wp = pItem->m_wWeight;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSprite;
				cp += 2;
				
				sp  = (short *)cp;
				*sp = pItem->m_sSpriteFrame;
				cp += 2;

				*cp = pItem->m_cItemColor;
				cp++;

				*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
				cp++;
				
				dwp = (DWORD *)cp;
				*dwp = pItem->m_dwAttribute;
				cp += 4;
				
				//*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
				//cp++;
				
											
				if (iEraseReq == 1) delete pItem;
				
				// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
				
				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);
				
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}

				// º¯°æµÈ ¿¡³Ê¹Ì Å³À» ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ENEMYKILLS, m_pClientList[iClientH]->m_iEnemyKillCount, NULL, NULL, NULL);
			}
			else 
			{
				// °ø°£ÀÌ ºÎÁ·ÇØ ¾ÆÀÌÅÛÀ» ¾òÀ» ¼ö ¾ø´Ù.
				delete pItem;

				// ¼ÒÁöÇ° ÃÑ Áß·® Àç °è»ê 
				iCalcTotalWeight(iClientH);

				dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
				*dwp = MSGID_NOTIFY;
				wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
				*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
				
				iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
				switch (iRet) {
				case DEF_XSOCKEVENT_QUENEFULL:
				case DEF_XSOCKEVENT_SOCKETERROR:
				case DEF_XSOCKEVENT_CRITICALERROR:
				case DEF_XSOCKEVENT_SOCKETCLOSED:
					// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
					DeleteClient(iClientH, TRUE, TRUE);
					return;
				}
			}
		}
 	}
}
*/
void CGame::_SetItemPos(int iClientH, char *pData)
{
 char * cp, cItemIndex;
 short * sp, sX, sY;

	if (m_pClientList[iClientH] == NULL) return;
	
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	cItemIndex = *cp;
	cp++;

	sp = (short *)cp;
	sX = *sp;
	cp += 2;

	sp = (short *)cp;
	sY = *sp;
	cp += 2;

	// Àß¸øµÈ ÁÂÇ¥°ª º¸Á¤ 
	if (sY < -10) sY = -10; 

	if ((cItemIndex < 0) || (cItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[cItemIndex] != NULL) {
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].x = sX;
		m_pClientList[iClientH]->m_ItemPosList[cItemIndex].y = sY;
	}
}

void CGame::CheckUniqueItemEquipment(int iClientH)
{
 register int i, iDamage;

	if (m_pClientList[iClientH] == NULL) return;
	// v1.3 À¯´ÏÅ© ¾ÆÀÌÅÛÀÇ ÀåÂø »óÅÂ¸¦ ÆÇ´ÜÇÑ´Ù. Æ¯Á¤ÀÎ¸¸ÀÌ Âø¿ë °¡´ÉÇÑ ¾ÆÀÌÅÛÀ» ÀåÂøÇÑ °æ¿ì ¹þ°ÜÁø´Ù.

	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) {
		if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectType == DEF_ITET_UNIQUE_OWNER) &&
			 (m_pClientList[iClientH]->m_bIsItemEquipped[i] == TRUE) ) {
			// Touch Effect TypeÀÌ DEF_ITET_OWNERÀÌ¸é Touch Effect Value 1, 2, 3ÀÌ ÁÖÀÎ Ä³¸¯ÅÍÀÇ °íÀ¯°ªÀ» °®´Â´Ù. 
						
			if ( (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue1 == m_pClientList[iClientH]->m_sCharIDnum1) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue2 == m_pClientList[iClientH]->m_sCharIDnum2) &&
				 (m_pClientList[iClientH]->m_pItemList[i]->m_sTouchEffectValue3 == m_pClientList[iClientH]->m_sCharIDnum3) ) {
				// ID °ªÀÌ ¸Â´Ù.
			}
			else {
				// ÀÚ½ÅÀÇ °ÍÀÌ ¾Æ´Ï¹Ç·Î Âø¿ëÀÌ ÇØÁ¦µÈ´Ù.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ITEMRELEASED, m_pClientList[iClientH]->m_pItemList[i]->m_cEquipPos, i, NULL, NULL);
				ReleaseItemHandler(iClientH, i, TRUE);
				// v1.4 ´ë¹ÌÁö¸¦ ¾ò´Â´Ù. 
				iDamage = iDice(10, 10);
				m_pClientList[iClientH]->m_iHP -= iDamage;
				if (m_pClientList[iClientH]->m_iHP <= 0) {
					ClientKilledHandler(iClientH, NULL, NULL, iDamage);
				}
			}
		}
	}
}

void CGame::_BWM_Init(int iClientH, char *pData)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_bIsBWMonitor = TRUE;
	wsprintf(G_cTxt, "(*) BWMonitor(%d) registered.", iClientH);
	PutLogList(G_cTxt);
}

void CGame::_BWM_Command_Shutup(char *pData)
{
 char * cp, cName[11];
 register int i;

	cp = (char *)(pData + 16);

	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 10);

	for (i = 1; i < DEF_MAXCLIENTS; i++) 
	if (m_pClientList[i] != NULL) {
		if (memcmp(m_pClientList[i]->m_cCharName, cName, 10) == 0) {
			m_pClientList[i]->m_iTimeLeft_ShutUp = 20*3*10; // 1ÀÌ 3ÃÊ´Ù. 20ÀÌ¸é 1ºÐ ¿åÀ» ÇÏ¸é ¹«Á¶°Ç Æä³ÎÆ¼ 10ºÐ  
			SendNotifyMsg(NULL, i, DEF_NOTIFY_PLAYERSHUTUP, 20*3*10, NULL, NULL, cName);
			
			// Admin Log
			wsprintf(G_cTxt, "BWordMonitor shutup(%s %d)", cName, 20*3*10);
			PutAdminLogFileList(G_cTxt);

			return;
		}
	}
}

void CGame::ExchangeItemHandler(int iClientH, short sItemIndex, int iAmount, short dX, short dY, WORD wObjectID, char *pItemName)
{
 short sOwnerH;
 char  cOwnerType;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((sItemIndex < 0) || (sItemIndex >= DEF_MAXITEMS)) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex] == NULL) return;
	if (m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwCount < iAmount) return;
	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) return;
	if (wObjectID >= DEF_MAXCLIENTS) return;

	// ¾ÆÀÌÅÛÀ» ´©±¸¿Í ±³È¯ÇÏ°Ú´Ù´Â ¸Þ½ÃÁö°¡ µµÂøÇß´Ù. »ó´ë¹æ¿¡°Ô ¾Ë¸®°í ¾çÂÊ ¸ðµÎ ±³È¯Ã¢À» ¿­µµ·Ï ÇÑ´Ù. 
	//ÀÌÁ¦ dX, dY¿¡ ÀÖ´Â ¿ÀºêÁ§Æ®¿¡°Ô ¼Òºñ¼º ¾ÆÀÌÅÛÀ» °Ç³×ÁØ´Ù. 
	m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
	
	if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_PLAYER)) {
		// v1.4 ÁÖ°íÀÚ ÇÑ °´Ã¼¿Í ¸Â´ÂÁö ÆÇ´ÜÇÑ´Ù.
		if (wObjectID != NULL) { 
			if (wObjectID < 10000) {
				// ÇÃ·¹ÀÌ¾î 
				if (m_pClientList[wObjectID] != NULL) {
					if ((WORD)sOwnerH != wObjectID) sOwnerH = NULL;
				}
			}
			else sOwnerH = NULL;
		}
		
		if ((sOwnerH == NULL) || (m_pClientList[sOwnerH] == NULL)) {
			//¾ÆÀÌÅÛ ±³È¯À» ¿äÃ»ÇÑ ÇÃ·¹ÀÌ¾î¿¡°Ô ÇØ´ç À§Ä¡¿¡ ÇÃ·¹ÀÌ¾î°¡ ¾øÀ½À» ¾Ë¸°´Ù. 
			_ClearExchangeStatus(iClientH); 
		}
		else {
			if ((m_pClientList[sOwnerH]->m_bIsExchangeMode == TRUE) || (m_pClientList[sOwnerH]->m_sAppr2 & 0xF000) ||
				(m_pMapList[m_pClientList[sOwnerH]->m_cMapIndex]->m_bIsFightZone == TRUE)) {
				// »ó´ë¹æÀÌ ÀÌ¹Ì ±³È¯ ÁßÀÌ°Å³ª ÀüÅõ¸ðµå, È¤Àº »çÅõÀåÀÌ´Ù. ±³È¯¸ðµå·Î µé¾î°¥ ¼ö ¾ø´Ù. 
				_ClearExchangeStatus(iClientH);
			}
			else {
				// ±³È¯¸ðµå°¡ ½ÃÀÛµÇ¾ú´Ù. ÀÎµ¦½º, ÀÌ¸§ ÀúÀå  
				m_pClientList[iClientH]->m_bIsExchangeMode = TRUE;
				m_pClientList[iClientH]->m_iExchangeH = sOwnerH;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
				strcpy(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[sOwnerH]->m_cCharName);

				// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛ ÀÎµ¦½º, ¼ö·® ÀúÀå 
				m_pClientList[iClientH]->m_cExchangeItemIndex  = (char)sItemIndex;
				m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
				ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
				memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, 20);
				
				m_pClientList[sOwnerH]->m_bIsExchangeMode  = TRUE;
				m_pClientList[sOwnerH]->m_iExchangeH = iClientH;
				ZeroMemory(m_pClientList[sOwnerH]->m_cExchangeName, sizeof(m_pClientList[sOwnerH]->m_cExchangeName));
				strcpy(m_pClientList[sOwnerH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName);

				SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_OPENEXCHANGEWINDOW, 0, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);

				SendNotifyMsg(iClientH, sOwnerH, DEF_NOTIFY_OPENEXCHANGEWINDOW, 1, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSprite, 
				              m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_cItemColor,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wCurLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_wMaxLifeSpan,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_sItemSpecEffectValue2 +100,
							  m_pClientList[iClientH]->m_pItemList[sItemIndex]->m_dwAttribute);
			}
		}
	}
	else {
		// NPC¿Í´Â ¹°°ÇÀ» ±³È¯ÇÒ ¼ö ¾ø´Ù.
		_ClearExchangeStatus(iClientH);
	}
}



void CGame::SetExchangeItem(int iClientH, int iItemIndex, int iAmount)
{
 int iExH;

	if (m_pClientList[iClientH] == NULL) return;

	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
		if ( (m_pClientList[iExH] == NULL) || (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ) {
			// ±³È¯ÇÒ »ó´ë¹æÀÌ ¾ø°Å³ª ±³È¯ÇÏ°íÀÚ Çß´ø ±× Ä³¸¯ÅÍ°¡ ¾Æ´Ï´Ù. 	

		}
		else {
			// ±³È¯ÇÏ°íÀÚ ÇÏ´Â »ó´ë¹æ¿¡°Ô ¾ÆÀÌÅÛÀ» ¾Ë·ÁÁØ´Ù. 
			// ÇØ´ç ¾ÆÀÌÅÛÀÌ Á¸ÀçÇÏ´ÂÁö, ¼ö·®ÀÌ ¸Â´ÂÁö Ã¼Å©ÇÑ´Ù. 
			if ((iItemIndex < 0) || (iItemIndex >= DEF_MAXITEMS)) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex] == NULL) return;
			if (m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwCount < iAmount) return;

			// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛ ÀÎµ¦½º, ¼ö·® ÀúÀå 
			m_pClientList[iClientH]->m_cExchangeItemIndex  = iItemIndex;
			m_pClientList[iClientH]->m_iExchangeItemAmount = iAmount;
			ZeroMemory(m_pClientList[iClientH]->m_cExchangeItemName, sizeof(m_pClientList[iClientH]->m_cExchangeItemName));
			memcpy(m_pClientList[iClientH]->m_cExchangeItemName, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, 20);
			
			SendNotifyMsg(iClientH, iClientH, DEF_NOTIFY_SETEXCHANGEITEM, 0, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute); 

			SendNotifyMsg(iClientH, iExH, DEF_NOTIFY_SETEXCHANGEITEM, 1, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSprite,
				          m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sSpriteFrame, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cName, iAmount, m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_cItemColor,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wCurLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_wMaxLifeSpan,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_sItemSpecEffectValue2 +100,
						  m_pClientList[iClientH]->m_pItemList[iItemIndex]->m_dwAttribute);
		}
	}
	else {
		// ±³È¯ ¸ðµå°¡ ¾Æ´Ï¹Ç·Î 
	}
}


void CGame::ConfirmExchangeItem(int iClientH)
{
 int iExH;
 int iItemWeightA, iItemWeightB, iWeightLeftA, iWeightLeftB, iAmountLeft;
 class CItem * pItemA, * pItemB, * pItemAcopy, * pItemBcopy;
 
	if (m_pClientList[iClientH] == NULL) return;
		
	if ((m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) && (m_pClientList[iClientH]->m_iExchangeH != NULL)) {
		iExH = m_pClientList[iClientH]->m_iExchangeH;
	
		// v1.42 ¼³¸¶ ÀÌ·± °æ¿ì°¡?
		if (iClientH == iExH) return;

		if (m_pClientList[iExH] != NULL) {
			if ( (memcmp(m_pClientList[iClientH]->m_cExchangeName, m_pClientList[iExH]->m_cCharName, 10) != 0) ||
			     (m_pClientList[iExH]->m_bIsExchangeMode != TRUE) ||
				 (memcmp(m_pClientList[iExH]->m_cExchangeName, m_pClientList[iClientH]->m_cCharName, 10) != 0) ) {
				// ±³È¯ÇÏ°íÀÚ Çß´ø ±× Ä³¸¯ÅÍ°¡ ¾Æ´Ï´Ù. ±³È¯ »óÅÂ´Â Ãë¼Ò.
				_ClearExchangeStatus(iClientH);
				_ClearExchangeStatus(iExH);
				return;
			}
			else {
				m_pClientList[iClientH]->m_bIsExchangeConfirm = TRUE;
				if (m_pClientList[iExH]->m_bIsExchangeConfirm == TRUE) {
					// »ó´ë¹æµµ ±³È¯ÀÇ»ç¸¦ ¹àÇû´Ù. ±³È¯ÀÌ ¼º¸³ÇÒ ¼ö ÀÖ´ÂÁö °è»êÇÑ´Ù. ¾ÆÀÌÅÛ °¹¼ö, ¹«°Ô Á¦ÇÑÀ» ÆÇ´Ü.
					
					if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex] == NULL) ||
						 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL) ) {
						// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ø´Ù. ±³È¯ ºÒ°¡´É.
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					else if ( (memcmp(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, m_pClientList[iClientH]->m_cExchangeItemName, 20) != 0) ||
						      (memcmp(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, m_pClientList[iExH]->m_cExchangeItemName, 20) != 0) ) {
						// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ´Ù¸£´Ù. ±³È¯ ºÒ°¡´É.
						_ClearExchangeStatus(iClientH);
						_ClearExchangeStatus(iExH);
						return;
					}
					else {
						// ¸ÕÀú ¹«°Ô °è»ê. ³²Àº Áß·®À» °è»êÇÑ´Ù. 
						iWeightLeftA = _iCalcMaxLoad(iClientH) - iCalcTotalWeight(iClientH);
						iWeightLeftB = _iCalcMaxLoad(iExH) - iCalcTotalWeight(iExH);
							
						//iItemWeightA = m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_wWeight * 
						//	           m_pClientList[iClientH]->m_iExchangeItemAmount;

						//iItemWeightB = m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_wWeight * 
						//	           m_pClientList[iExH]->m_iExchangeItemAmount;

						// v1.432
						iItemWeightA = iGetItemWeight(m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex],
							                          m_pClientList[iClientH]->m_iExchangeItemAmount);

						iItemWeightB = iGetItemWeight(m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex],
													  m_pClientList[iExH]->m_iExchangeItemAmount);

						if ((iWeightLeftA < iItemWeightB) || (iWeightLeftB < iItemWeightA)) {
							// ±³È¯ÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¹«°Ô°ø°£ÀÌ ¾ø´Ù. ±³È¯ ºÒ°¡´É. 
							_ClearExchangeStatus(iClientH);
							_ClearExchangeStatus(iExH);
							return;
						}
						else {
							// ¾ÆÀÌÅÛ °¹¼ö°¡ ³²¾Æ ÀÖ´ÂÁö È®ÀÎÇÑ´Ù.
							if ( (_iGetItemSpaceLeft(iClientH) == 0) || (_iGetItemSpaceLeft(iExH) == 0) ) {
								// ¾ÆÀÌÅÛÀ» ¹ÞÀ» °ø°£ÀÌ ³²¾ÆÀÖÁö ¾Ê´Ù.  ±³È¯ ºÒ°¡´É 
								_ClearExchangeStatus(iClientH);
								_ClearExchangeStatus(iExH);
								return;
							}
							else {
								// ¸¶Áö¸·À¸·Î ¼ö·®´ÜÀ§ ¾ÆÀÌÅÛÀÌ¸é ±³È¯ÇÏ°íÀÚ Çß´ø °¹¼ö´ë·Î Á¸ÀçÇÏ´ÂÁö °Ë»çÇÑ´Ù.
								
								// ¼ö·®´ÜÀ§°¡ ÀÖ´Â ¾ÆÀÌÅÛÀÇ °æ¿ì´Â »õ·Î »ý¼ºÀ» ½ÃÄÑ¾ß ³ª´­¼ö ÀÖ´Ù.
								if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									
									if (m_pClientList[iClientH]->m_iExchangeItemAmount > m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_dwCount) {
										// ±³È¯ÇÏ°íÀÚ Çß´ø ¼ö·®º¸´Ù ¾ÆÀÌÅÛÀÌ Àû´Ù. ±×µ¿¾È ÁÙ¾îµé¾ú´Ù.
										_ClearExchangeStatus(iClientH);
										_ClearExchangeStatus(iExH);
										return;		
									}
									pItemA = new class CItem;
									_bInitItemAttr(pItemA, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									pItemA->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;

									// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
									pItemAcopy = new class CItem;
									_bInitItemAttr(pItemAcopy, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemAcopy, pItemA);
									pItemAcopy->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;
								}
								else {
									pItemA = (class CItem *)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex];
									pItemA->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;

									// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
									pItemAcopy = new class CItem;
									_bInitItemAttr(pItemAcopy, m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemAcopy, pItemA);
									pItemAcopy->m_dwCount = m_pClientList[iClientH]->m_iExchangeItemAmount;
								}


								if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									
									if (m_pClientList[iExH]->m_iExchangeItemAmount > m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_dwCount) {
										// ±³È¯ÇÏ°íÀÚ Çß´ø ¼ö·®º¸´Ù ¾ÆÀÌÅÛÀÌ Àû´Ù. ±×µ¿¾È ÁÙ¾îµé¾ú´Ù.
										_ClearExchangeStatus(iClientH);
										_ClearExchangeStatus(iExH);
										return;		
									}
									pItemB = new class CItem;
									_bInitItemAttr(pItemB, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									pItemB->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;

									// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
									pItemBcopy = new class CItem;
									_bInitItemAttr(pItemBcopy, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemBcopy, pItemB);
									pItemBcopy->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;
								}
								else {
									pItemB = (class CItem *)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex];
									pItemB->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;

									// ·Î±×¸¦ ³²±â±â À§ÇÑ ¾ÆÀÌÅÛ º¹»ç¹° 
									pItemBcopy = new class CItem;
									_bInitItemAttr(pItemBcopy, m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName);
									bCopyItemContents(pItemBcopy, pItemB);
									pItemBcopy->m_dwCount = m_pClientList[iExH]->m_iExchangeItemAmount;
								}

								// ¸ÕÀú ¾ÆÀÌÅÛÀ» ³ÖÀº ÈÄ 
								bAddItem(iClientH, pItemB, NULL);
								bAddItem(iExH, pItemA, NULL);

								// ¾ÆÀÌÅÛÀ» ³ÖÀº ´ÙÀ½ pItemA, pItemB´Â »èÁ¦µÇ¾î NULLÀÏ ¼ö ÀÖ´Ù!

								// v1.41 Èñ±Í ¾ÆÀÌÅÛÀ» ¶³¾î¶ß¸° °ÍÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù.
								_bItemLog(DEF_ITEMLOG_GIVE, iClientH, iExH, pItemAcopy);
								_bItemLog(DEF_ITEMLOG_GIVE, iExH, iClientH, pItemBcopy);

								delete pItemAcopy;
								pItemAcopy = NULL;
								delete pItemBcopy;
								pItemBcopy = NULL;
		
								// ±³È¯ÇÑ ¾ÆÀÌÅÛÀÇ ÀÎµ¦½º¸¦ Áö¿î´Ù.
								if ( (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									//
									iAmountLeft = (int)m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_dwCount - m_pClientList[iClientH]->m_iExchangeItemAmount;
									if (iAmountLeft < 0) iAmountLeft = 0;	 
									// v1.41 !!!
									SetItemCount(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex, iAmountLeft);
									// m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
									//
								}
								else {
									// ¸¸¾à ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇØÁ¦ÇÑ´Ù.
									ReleaseItemHandler(iClientH, m_pClientList[iClientH]->m_cExchangeItemIndex, TRUE);
									SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iClientH]->m_cExchangeItemIndex, m_pClientList[iClientH]->m_iExchangeItemAmount, NULL, m_pClientList[iExH]->m_cCharName);
									m_pClientList[iClientH]->m_pItemList[m_pClientList[iClientH]->m_cExchangeItemIndex] = NULL;
								}

								// v1.42 ###BUG POINT!!! m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL
								if (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] == NULL) {
								
								
								}

								if ( (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_CONSUME) ||
									 (m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cItemType == DEF_ITEMTYPE_ARROW) ) {
									//
									iAmountLeft = (int)m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_dwCount - m_pClientList[iExH]->m_iExchangeItemAmount;
									if (iAmountLeft < 0) iAmountLeft = 0;	  
									// v1.41 !!!
									SetItemCount(iExH, m_pClientList[iExH]->m_cExchangeItemIndex, iAmountLeft);
									// m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex]->m_cName, iAmountLeft);
									//
								}
								else {
									// ¸¸¾à ÀåÂøµÈ ¾ÆÀÌÅÛÀÌ¶ó¸é ÇØÁ¦ÇÑ´Ù.
									ReleaseItemHandler(iExH, m_pClientList[iExH]->m_cExchangeItemIndex, TRUE);
									SendNotifyMsg(NULL, iExH, DEF_NOTIFY_GIVEITEMFIN_ERASEITEM, m_pClientList[iExH]->m_cExchangeItemIndex, m_pClientList[iExH]->m_iExchangeItemAmount, NULL, m_pClientList[iClientH]->m_cCharName);
									m_pClientList[iExH]->m_pItemList[m_pClientList[iExH]->m_cExchangeItemIndex] = NULL;
								}

								// ±³È¯ÀÌ ¿Ï·áµÇ¾ú´Ù´Â ¸Þ½ÃÁö¸¦ º¸³» ÁØ´Ù. 
								m_pClientList[iClientH]->m_bIsExchangeMode = FALSE;
								m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
								m_pClientList[iClientH]->m_cExchangeItemIndex = -1;
								ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
								m_pClientList[iClientH]->m_iExchangeH = NULL;

								m_pClientList[iExH]->m_bIsExchangeMode = FALSE;
								m_pClientList[iExH]->m_bIsExchangeConfirm = FALSE;
								m_pClientList[iExH]->m_cExchangeItemIndex = -1;
								ZeroMemory(m_pClientList[iExH]->m_cExchangeName, sizeof(m_pClientList[iExH]->m_cExchangeName));
								m_pClientList[iExH]->m_iExchangeH = NULL;
								
								SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);
								SendNotifyMsg(NULL, iExH,     DEF_NOTIFY_EXCHANGEITEMCOMPLETE, NULL, NULL, NULL, NULL);

								// ¹«°Ô Àç¼³Á¤
								iCalcTotalWeight(iClientH);
								iCalcTotalWeight(iExH);
								return;
							}
						}
					}
				}
			}
		}
		else {
			// ±³È¯ÇÒ »ó´ë¹æÀÌ ¾ø´Ù. ±³È¯Àº Ãë¼Ò µÈ´Ù.
			_ClearExchangeStatus(iClientH);
			return;
		}
	}
}



int CGame::_iGetItemSpaceLeft(int iClientH)
{
 int i, iTotalItem;

	iTotalItem = 0;
	for (i = 0; i < DEF_MAXITEMS; i++) 
	if (m_pClientList[iClientH]->m_pItemList[i] != NULL) iTotalItem++;

	return (DEF_MAXITEMS - iTotalItem);
}

BOOL CGame::bAddItem(int iClientH, CItem * pItem, char cMode)
{
 char * cp, cData[256];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int iRet, iEraseReq;


	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/
		
		if (iEraseReq == 1) {
			//testcode
			//wsprintf(G_cTxt, "AddItem: Delete (%s)", pItem->m_cName);
			//PutLogFileList(G_cTxt);
			delete pItem;
			pItem = NULL;
		}
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		return TRUE;
	}
	else {
		// ¾ÆÀÌÅÛÀ» Àü´Þ¹ÞÀº Ä³¸¯ÅÍ°¡ ´õÀÌ»ó ¾ÆÀÌÅÛÀ» º¸°üÇÒ ¼ö ¾ø´Â »óÅÂÀÌ´Ù.
		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¹ö¸°´Ù. 
		m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->bSetItem(m_pClientList[iClientH]->m_sX, 
			                                                         m_pClientList[iClientH]->m_sY, 
			                                                         pItem);
		
		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pClientList[iClientH]->m_cMapIndex,
			                        m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY,  
			                        pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color
		
		// ´õÀÌ»ó °¡Áú¼ö ¾ø´Ù´Â ¸Þ½ÃÁö¸¦ º¸³½´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_CANNOTCARRYMOREITEM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		
		return TRUE;
	}

	return FALSE;
}


void CGame::CancelExchangeItem(int iClientH)
{
 int iExH;
	
	// ÇöÀç ±³È¯À» Ãë¼ÒÇÑ´Ù. »ó´ë¹æµµ ÀÚµ¿À¸·Î Ãë¼ÒµÈ´Ù. 
	iExH = m_pClientList[iClientH]->m_iExchangeH;
	_ClearExchangeStatus(iExH);
	_ClearExchangeStatus(iClientH);
}


void CGame::_ClearExchangeStatus(int iClientH)
{
	if ((iClientH <= 0) || (iClientH >= DEF_MAXCLIENTS)) return;
	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsExchangeMode == TRUE) 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANCELEXCHANGEITEM, NULL, NULL, NULL, NULL);	
		
	m_pClientList[iClientH]->m_bIsExchangeMode    = FALSE;
	m_pClientList[iClientH]->m_bIsExchangeConfirm = FALSE;
	m_pClientList[iClientH]->m_cExchangeItemIndex = -1;
	ZeroMemory(m_pClientList[iClientH]->m_cExchangeName, sizeof(m_pClientList[iClientH]->m_cExchangeName));
	m_pClientList[iClientH]->m_iExchangeH = NULL;
}

int CGame::_iTalkToNpcResult_Cityhall(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int iQuest, iEraseReq, iExp;
 class CItem * pItem;

	// Return Code
	// -1  : ÇöÀç ÀÓ¹« ¼öÇàÁß
	// -2  : ¸¶À»ÀÌ ´Ù¸£°Å³ª Áß¸³Àº ÀÓ¹«¸¦ ¾òÀ» ¼ö ¾ø´Ù.    
	// -3  : ¹üÁËÀÚ´Â ÀÓ¹«¸¦ ¾òÀ» ¼ö ¾ø´Ù.
	// -4  : ÇöÀç Á¶°Ç¿¡ ¸Â´Â ÀÓ¹«°¡ ¾ø´Ù. ÀÏ»óÀûÀÎ ´ëÈ­³ª Á¤º¸ Ãâ·Â 

	// ½ÃÃ» ÇàÁ¤°ü¿¡°Ô ¸»À» °É¾ú´Ù. ·¹º§°ú Äù½ºÆ® »óÅÂ¿¡ µû¶ó ÀÓ¹«¸¦ ÇÒ´çÇÑ´Ù. 
	if (m_pClientList[iClientH] == NULL) return 0;

	if (m_pClientList[iClientH]->m_iQuest != NULL) {
		if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest] == NULL) return -4;
		else if (m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iFrom == 4) {
			// ½ÃÃ» ÇàÁ¤°ü¿¡°Ô ¸ÃÀº ÀÓ¹«´Ù. ÀÓ¹«°¡ ³¡³µ´Ù¸é ¿©±â¼­ Ã³¸®ÇÏ°í -5¸¦ ¸®ÅÏÇÑ´Ù.
			if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) {
				// Æ÷»óÀ» ÇÒ ¼ö ¾ø´Ù¸é(»óÇ°À» µé ¼ö ¾ø´Â »óÈ²ÀÌ¶ó´ø°¡) ÀÓ¹« Á¾·á Ã³¸®¸¦ ÇÏÁö ¾Ê´Â´Ù.
				// ¸ðµç Á¶°ÇÀÌ ¸¸Á·µÇ¸é Ã³¸®ÇÏ°í -5¸¦ ¸®ÅÏ.
				if ( (m_pClientList[iClientH]->m_iQuestRewardType > 0) &&
					 (m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType] != NULL) ) {
					// Äù½ºÆ®ÀÇ ´ñ°¡°¡ ¾ÆÀÌÅÛÀÌ´Ù. ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´ÂÁöÀÇ ¿©ºÎ¸¦ ÆÇ´ÜÇÑ´Ù.
					pItem = new class CItem;
					_bInitItemAttr(pItem, m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName);
					pItem->m_dwCount = m_pClientList[iClientH]->m_iQuestRewardAmount;
					if (_bCheckItemReceiveCondition(iClientH, pItem) == TRUE) {
						// Äù½ºÆ® ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ÀÖ´Â Á¶°ÇÀÌ´Ù. ¼ö¿©ÇÑ´Ù.
						_bAddClientItemList(iClientH, pItem, &iEraseReq);
						SendItemNotifyMsg(iClientH, DEF_NOTIFY_ITEMOBTAINED, pItem, NULL);
						if (iEraseReq == 1) delete pItem;
						
						// °øÇåµµ »ó½Â 
						m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

						// Æ÷»óÀÌ Àü´ÞµÇ¾ú´Ù´Â ¸Þ½ÃÁö Àü¼Û ÈÄ ¸®ÅÏ. Äù½ºÆ® »óÅÂ Å¬¸®¾î.
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);
						
						_ClearQuestStatus(iClientH);
						return -5;
					} 
					else {
						delete pItem;
						// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¼ö ¾ø´Ù´Â ¸Þ½ÃÁö Àü¼Û ÈÄ ¸®ÅÏ
						SendItemNotifyMsg(iClientH,	DEF_NOTIFY_CANNOTCARRYMOREITEM, NULL, NULL);

						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 0, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							          m_pItemConfigList[m_pClientList[iClientH]->m_iQuestRewardType]->m_cName, m_pClientList[iClientH]->m_iContribution);

						return -5;
					}
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -1) {
					// Äù½ºÆ®ÀÇ ´ñ°¡°¡ °æÇèÄ¡ÀÌ´Ù. 
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iQuestRewardAmount;
					// °øÇåµµ »ó½Â 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, m_pClientList[iClientH]->m_iQuestRewardAmount, 
							      "°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);
					
					// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else if (m_pClientList[iClientH]->m_iQuestRewardType == -2) {
					// Äù½ºÆ®ÀÇ ´ñ°¡´Â ºñ·Ê °æÇèÄ¡ Àû¿¡°Ô Á×¾úÀ»¶§ °æÇèÄ¡ * m_pClientList[iClientH]->m_iQuestRewardAmount ¸¸Å­ÀÇ °æÇèÄ¡¸¦ ¾ò´Â´Ù.
					//***
					iExp = iDice(1, (10*m_pClientList[iClientH]->m_iLevel));
					//***
					iExp = iExp * m_pClientList[iClientH]->m_iQuestRewardAmount;
					
					m_pClientList[iClientH]->m_iExpStock += iExp;
					// °øÇåµµ »ó½Â 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, iExp, 
							      "°æÇèÄ¡              ", m_pClientList[iClientH]->m_iContribution);
					
					// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
					_ClearQuestStatus(iClientH);
					return -5;
				}
				else {
					// Äù½ºÆ®ÀÇ ´ñ°¡´Â ¾ø´Ù. °øÇåµµ¸¸ ¿À¸¥´Ù.
					// °øÇåµµ »ó½Â 
					m_pClientList[iClientH]->m_iContribution += m_pQuestConfigList[m_pClientList[iClientH]->m_iQuest]->m_iContribution;

					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTREWARD, 4, 1, 0, 
							      "                     ", m_pClientList[iClientH]->m_iContribution);
					
					// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
					_ClearQuestStatus(iClientH);
					return -5;
				}
			}
			else return -1;
		}
		
		return -4;	// ´Ù¸¥ NPC¿¡°Ô¼­ ¾òÀº Äù½ºÆ®¸¦ ¼öÇàÁßÀÌ´Ù. Áï Á¶°Ç¿¡ ¸Â´Â ÀÓ¹«°¡ ¾ø´Ù. ÀÏ»óÀûÀÎ ´ëÈ­¸¦ Ãâ·ÂÇÑ´Ù.
	}
	
	// ¾Æ¹«·± ÀÓ¹«¸¦ ¸Â°í ÀÖÁö ¾Ê´Ù. ÀÓ¹«¸¦ ¸ÃÀ» ¼ö ÀÖ´Â Á¶°ÇÀÎÁö ÆÇº°ÇÑ´Ù. 
	if (memcmp(m_pClientList[iClientH]->m_cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cLocationName, 10) == 0) {
		// ¸¶À» ¼Ò¼ÓÀÌ °°´Ù. 
		// ¹üÁËÀÚ¶ó¸é ÀÓ¹«¸¦ ¸ÃÀ» ¼ö ¾ø´Ù. 
		if (m_pClientList[iClientH]->m_iPKCount > 0) return -3;
		
		iQuest = __iSearchForQuest(iClientH, 4, pQuestType, pMode, pRewardType, pRewardAmount, pContribution, pTargetName, pTargetType, pTargetCount, pX, pY, pRange);
		if (iQuest <= 0) return -4;

		// ÀÓ¹« Ã£¾Ò´Ù. 
		return iQuest;
	}
	else return -2; // ¸¶À»ÀÌ ´Ù¸£°Å³ª ¸¶À» ¼Ò¼ÓÀÌ ¾Æ´Ï´Ù.

	return -4;
}


int CGame::_iTalkToNpcResult_Guard(int iClientH, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
	// °æºñº´°úÀÇ ´ëÈ­. ÇÃ·¹ÀÌ¾îÀÇ À§Ä¡¿¡ ÀûÀýÇÑ ´ëÈ­ ¸Þ½ÃÁö¸¦ µð½ºÇÃ·¹ÀÌÇÑ´Ù.
	if (m_pClientList[iClientH] == NULL) return 0;

	if (memcmp(m_pClientList[iClientH]->m_cLocation, "aresden", 7) == 0) {
		// ¸» °Ç »ç¶÷ÀÌ ¾Æ·¹½ºµ§ ¼Ò¼Ó 
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// ÀÚ±â ¸¶À» °æºñ¿¡°Ô ¸»À» °É¾úÀ½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (200), NULL, NULL, NULL, NULL);
			return 1000;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// ´Ù¸¥ ¸¶À» °æºñ¿¡°Ô ¸»À» °É¾úÀ½.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (201), NULL, NULL, NULL, NULL);
			return 1001;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "elvine", 6) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// ´Ù¸¥ ¸¶À» °æºñ¿¡°Ô ¸»À» °É¾úÀ½.	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (202), NULL, NULL, NULL, NULL);
			return 1002;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// ÀÚ±â ¸¶À» °æºñ¿¡°Ô ¸»À» °É¾úÀ½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (203), NULL, NULL, NULL, NULL);
			return 1003;
		}
	}
	else
	if (memcmp(m_pClientList[iClientH]->m_cLocation, "NONE", 4) == 0) {
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "aresden", 7) == 0) {
			// Áß¸³ÀÌ ¾Æ·¹½ºµ§ °æºñ¿¡°Ô ¸»À» °É¾úÀ½
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (204), NULL, NULL, NULL, NULL);
			return 1004;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "elvine", 6) == 0) {
			// Áß¸³ÀÌ ¿¤¹ÙÀÎ °æºñ¿¡°Ô ¸»À» °É¾úÀ½.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (205), NULL, NULL, NULL, NULL);
			return 1005;
		}
		else
		if (memcmp(m_pClientList[iClientH]->m_cMapName, "default", 7) == 0) {
			// ÃÊº¸ »ç³ÉÅÍ
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NPCTALK, (206), NULL, NULL, NULL, NULL);
			return 1006;
		}
	}

	return 0;
}


BOOL CGame::_bDecodeQuestConfigFileContents(char * pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iQuestConfigListIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// Äù½ºÆ® ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pQuestConfigList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Duplicate quest number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[atoi(token)] = new class CQuest;
					iQuestConfigListIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// Äù½ºÆ® »çÀÌµå  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_cSide = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// Äù½ºÆ® Á¾·ù  
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iType = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					// TargetType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTargetType = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// MaxCount
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxCount= atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iFrom = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMinLevel = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iMaxLevel = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillNum = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRequiredSkillLevel = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iTimeLimit = atoi(token);
					cReadModeB = 12;
					break;

				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iAssignType = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[1] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[1] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[2] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[2] = atoi(token);
					cReadModeB = 17;
					break;

				case 17:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardType[3] = atoi(token);
					cReadModeB = 18;
					break;

				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRewardAmount[3] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContribution = atoi(token);
					cReadModeB = 20;
					break;

				case 20:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iContributionLimit = atoi(token);
					cReadModeB = 21;
					break;

				case 21:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iResponseMode = atoi(token);
					cReadModeB = 22;
					break;

				case 22:
					ZeroMemory(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, sizeof(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName));
					strcpy(m_pQuestConfigList[iQuestConfigListIndex]->m_cTargetName, token);
					cReadModeB = 23;
					break;

				case 23:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sX = atoi(token);
					cReadModeB = 24;
					break;

				case 24:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_sY = atoi(token);
					cReadModeB = 25;
					break;

				case 25:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iRange = atoi(token);
					cReadModeB = 26;
					break;

				case 26:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iQuestID = atoi(token);
					cReadModeB = 27;
					break;

				case 27:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pQuestConfigList[iQuestConfigListIndex]->m_iReqContribution = atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;
					break;

				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "quest", 5) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! QUEST configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) QUEST(Total:%d) configuration - success!", iQuestConfigListIndex);
	PutLogList(cTxt);

	return TRUE;
}


int CGame::__iSearchForQuest(int iClientH, int iWho, int * pQuestType, int * pMode, int * pRewardType, int * pRewardAmount, int * pContribution, char * pTargetName, int * pTargetType, int * pTargetCount, int * pX, int * pY, int * pRange)
{
 int i, iQuestList[DEF_MAXQUESTTYPE], iIndex, iQuest, iReward, iQuestIndex;

	if (m_pClientList[iClientH] == NULL) return -1;
 
	// ÀûÇÕÇÑ ¹Ì¼Ç ¹è¿­ ÃÊ±âÈ­.
	iIndex = 0;
	for (i = 0; i < DEF_MAXQUESTTYPE; i++)
		iQuestList[i] = -1;

	for (i = 1; i < DEF_MAXQUESTTYPE; i++) 
	if (m_pQuestConfigList[i] != NULL) {
		
		if (m_pQuestConfigList[i]->m_iFrom != iWho) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_cSide != m_pClientList[iClientH]->m_cSide) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMinLevel > m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iMaxLevel < m_pClientList[iClientH]->m_iLevel) goto SFQ_SKIP;
		if (m_pQuestConfigList[i]->m_iReqContribution > m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		if (m_pQuestConfigList[i]->m_iRequiredSkillNum != -1) {
			// °í·ÁÇØ¾ß ÇÒ ½ºÅ³ÀÌ ÀÖ´Ù. 
			if (m_pClientList[iClientH]->m_cSkillMastery[m_pQuestConfigList[i]->m_iRequiredSkillNum] < 
				m_pQuestConfigList[i]->m_iRequiredSkillLevel) goto SFQ_SKIP;
		}
		
		// Å©·ç¼¼ÀÌµå ¸ðµåÀÏ¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1ÀÎ Äù½ºÆ®¸¸ ºÎ¿©µÈ´Ù.
		if ((m_bIsCrusadeMode == TRUE) && (m_pQuestConfigList[i]->m_iAssignType != 1)) goto SFQ_SKIP; 
		// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ò¶§´Â ÇÒ´ç Å¸ÀÔÀÌ 1Àº ¼±ÅÃµÇÁö ¾Ê´Â´Ù.
		if ((m_bIsCrusadeMode == FALSE) && (m_pQuestConfigList[i]->m_iAssignType == 1)) goto SFQ_SKIP; 

		if (m_pQuestConfigList[i]->m_iContributionLimit < m_pClientList[iClientH]->m_iContribution) goto SFQ_SKIP;

		// ¿©±â±îÁö ¿À¸é Á¶°Ç¿¡ ÇÕ´çÇÑ Äù½ºÆ®´Ù. µî·ÏÇÑ´Ù. 
		iQuestList[iIndex] = i;
		iIndex++;

SFQ_SKIP:;
	}

	// iIndex°³ ¸¸Å­ÀÇ Á¶°Ç¿¡ ¸¸Á·ÇÏ´Â Äù½ºÆ®¸¦ Ã£¾Ò´Ù. ±× Áß¿¡¼­ ·£´ýÇÏ°Ô 1°³¸¦ ¼±ÅÃÇÑ´Ù.
	if (iIndex == 0) return -1;
	iQuest		 = (iDice(1, iIndex)) - 1;
	iQuestIndex  = iQuestList[iQuest];
	// Äù½ºÆ® ÀÎµ¦½º 
	iReward = iDice(1,3);
	*pMode = m_pQuestConfigList[iQuestIndex]->m_iResponseMode;					// Äù½ºÆ® ÀÀ´ä ¸ðµå 
	*pRewardType   = m_pQuestConfigList[iQuestIndex]->m_iRewardType[iReward];	// Äù½ºÆ® »óÇ° Á¾·ù 
	*pRewardAmount = m_pQuestConfigList[iQuestIndex]->m_iRewardAmount[iReward];	// Äù½ºÆ® »óÇ° °¹¼ö 
	*pContribution = m_pQuestConfigList[iQuestIndex]->m_iContribution;			// Äù½ºÆ® ÇØ°á½Ã ¿Ã¶ó°¡´Â °øÇåµµ 
	
	strcpy(pTargetName, m_pQuestConfigList[iQuestIndex]->m_cTargetName);			// Äù½ºÆ® ¸Ê ÀÌ¸§ ¼ö·Ï 
	*pX     = m_pQuestConfigList[iQuestIndex]->m_sX;
	*pY     = m_pQuestConfigList[iQuestIndex]->m_sY;
	*pRange = m_pQuestConfigList[iQuestIndex]->m_iRange;

	*pTargetType  = m_pQuestConfigList[iQuestIndex]->m_iTargetType;
	*pTargetCount = m_pQuestConfigList[iQuestIndex]->m_iMaxCount;
	*pQuestType   = m_pQuestConfigList[iQuestIndex]->m_iType;

	return iQuestIndex;
}



void CGame::QuestAcceptedHandler(int iClientH)
{
 int iIndex;

	if (m_pClientList[iClientH] == NULL) return;
	
	if (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iAssignType == 1) {
		// Àü¸éÀü¿ë Äù½ºÆ®ÀÌ´Ù. 
		switch (m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_iType) {
		case 10: // ÅÚ·¹Æ÷Æ®¿ë 1È¸¼º Äù½ºÆ®. ÅÚ·¹Æ÷Æ®ÇÏ°í ³ª¸é ³¡ÀÌ´Ù. ´õÀÌ»óÀÇ Äù½ºÆ® ¿©ºÎ°¡ ¾øÀ½.
			_ClearQuestStatus(iClientH);
			RequestTeleportHandler(iClientH, "2   ", m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_cTargetName,
				                   m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sX, m_pQuestConfigList[m_pClientList[iClientH]->m_iAskedQuest]->m_sY);
			return;
		}
	}

	// ÇÃ·¹ÀÌ¾î°¡ Äù½ºÆ®¸¦ ¼ö¶ôÇß´Ù. Äù½ºÆ® ¹øÈ£, ID°ª ÇÒ´ç.
	m_pClientList[iClientH]->m_iQuest = m_pClientList[iClientH]->m_iAskedQuest;
	iIndex = m_pClientList[iClientH]->m_iQuest;
	m_pClientList[iClientH]->m_iQuestID = m_pQuestConfigList[iIndex]->m_iQuestID;
	m_pClientList[iClientH]->m_iCurQuestCount    = 0;
	m_pClientList[iClientH]->m_bIsQuestCompleted = FALSE;
	
	_CheckQuestEnvironment(iClientH);
	_SendQuestContents(iClientH);
}


void CGame::_SendQuestContents(int iClientH)
{
 int iWho, iIndex, iQuestType, iContribution, iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) {
		// ÇÒ´çµÈ Quest°¡ ¾ø´Ù. 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, NULL, NULL, NULL, NULL,  
		              NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	}
	else {
		// ÇÒ´çµÈ Quest ³»¿ëÀ» º¸³»ÁØ´Ù.
		iWho          = m_pQuestConfigList[iIndex]->m_iFrom;
		iQuestType    = m_pQuestConfigList[iIndex]->m_iType;
		iContribution = m_pQuestConfigList[iIndex]->m_iContribution;
		iTargetType   = m_pQuestConfigList[iIndex]->m_iTargetType;
		iTargetCount  = m_pQuestConfigList[iIndex]->m_iMaxCount;
		iX            = m_pQuestConfigList[iIndex]->m_sX;
		iY            = m_pQuestConfigList[iIndex]->m_sY;
		iRange        = m_pQuestConfigList[iIndex]->m_iRange;
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		iQuestCompleted = (int)m_pClientList[iClientH]->m_bIsQuestCompleted;

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCONTENTS, iWho, iQuestType, iContribution, NULL,  
			          iTargetType, iTargetCount, iX, iY, iRange, iQuestCompleted, cTargetName);
	}
}

void CGame::_CheckQuestEnvironment(int iClientH)
{
 int iIndex;
 char cTargetName[21];

	if (m_pClientList[iClientH] == NULL) return;

	iIndex = m_pClientList[iClientH]->m_iQuest;
	if (iIndex == NULL) return;
	if (m_pQuestConfigList[iIndex] == NULL) return;
	if (m_pQuestConfigList[iIndex]->m_iQuestID != m_pClientList[iClientH]->m_iQuestID) {
		// Äù½ºÆ® ID °ªÀÌ ´Ù¸£´Ù. ÇÒ´ç¹Þ¾Ò´ø ±× Äù½ºÆ®°¡ ¾Æ´Ï´Ù. Äù½ºÆ®´Â Ãë¼ÒµÈ´Ù.
		m_pClientList[iClientH]->m_iQuest   = NULL;
		m_pClientList[iClientH]->m_iQuestID = NULL;
		m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
		m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
		return;
	}

	switch (m_pQuestConfigList[iIndex]->m_iType) {
	case DEF_QUESTTYPE_MONSTERHUNT:
	case DEF_QUESTTYPE_GOPLACE:
		// ¸ó½ºÅÍ »ç³ÉÀÇ °æ¿ì ¸Å¹ø ¸ó½ºÅÍ »ç³É½Ã ¸Ê ÀÌ¸§À» ºñ±³ÇÏ´Â °ÍÀº ºñÈ¿À²ÀûÀÌ¹Ç·Î ¹Ì¸® ¸Ê ÀÌ¸§À» ºñ±³, ÇÃ·¡±×¸¦ ¼³Á¤ÇØ ³õ´Â´Ù. 
		ZeroMemory(cTargetName, sizeof(cTargetName));
		memcpy(cTargetName, m_pQuestConfigList[iIndex]->m_cTargetName, 20);
		if (memcmp(m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, cTargetName, 10) == 0)
			 m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = TRUE;
		else m_pClientList[iClientH]->m_bQuestMatchFlag_Loc = FALSE;
		break;
	}
}

BOOL CGame::_bCheckIsQuestCompleted(int iClientH)
{
 int iQuestIndex;

	// Äù½ºÆ®°¡ Á¾·áµÇ¾ú´ÂÁö ÆÇ´ÜÇÑ ÈÄ ¸Þ½ÃÁö Ã³¸®.
	if (m_pClientList[iClientH] == NULL) return FALSE;
	if (m_pClientList[iClientH]->m_bIsQuestCompleted == TRUE) return FALSE;
	iQuestIndex = m_pClientList[iClientH]->m_iQuest;
	if (iQuestIndex == NULL) return FALSE;
		
	if (m_pQuestConfigList[iQuestIndex] != NULL) {
		switch (m_pQuestConfigList[iQuestIndex]->m_iType) {
		case DEF_QUESTTYPE_MONSTERHUNT:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && 
				 (m_pClientList[iClientH]->m_iCurQuestCount >= m_pQuestConfigList[iQuestIndex]->m_iMaxCount) ) {
				// ¸ó½ºÅÍ »ç³É Äù½ºÆ®°¡ ¿Ï·áµÇ¾ú´Ù. ¿Ï·áµÇ¾úÀ¸¸é ÀÇ·ÚÀÎ¿¡°Ô µ¹¾Æ°¡ ´ëÈ­¸¦ ÇÏ¸é Æ÷»ó¹Þ´Â´Ù. 
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;

		case DEF_QUESTTYPE_GOPLACE:
			if ( (m_pClientList[iClientH]->m_bQuestMatchFlag_Loc == TRUE) && // ¸ÊÀº ¸Â°í
				 (m_pClientList[iClientH]->m_sX >= m_pQuestConfigList[iQuestIndex]->m_sX - m_pQuestConfigList[iQuestIndex]->m_iRange) && // ÁÂÇ¥µµ ÀÌ³»ÀÌ¸é 
				 (m_pClientList[iClientH]->m_sX <= m_pQuestConfigList[iQuestIndex]->m_sX + m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY >= m_pQuestConfigList[iQuestIndex]->m_sY - m_pQuestConfigList[iQuestIndex]->m_iRange) &&
				 (m_pClientList[iClientH]->m_sY <= m_pQuestConfigList[iQuestIndex]->m_sY + m_pQuestConfigList[iQuestIndex]->m_iRange) ) {
				// Æ¯Á¤ Àå¼Ò Ã£¾Æ°¡±â Äù½ºÆ® ¿Ï·á.
				m_pClientList[iClientH]->m_bIsQuestCompleted = TRUE;					
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTCOMPLETED, NULL, NULL, NULL, NULL);
				return TRUE;
			}
			break;
		}
	}

	return FALSE;
}

int CGame::_iTalkToNpcResult_GuildHall(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_GShop(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_BSmith(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WHouse(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

int CGame::_iTalkToNpcResult_WTower(int iClientH, int *pQuestType, int *pMode, int *pRewardType, int *pRewardAmount, int *pContribution, char *pTargetName, int *pTargetType, int *pTargetCount, int *pX, int *pY, int *pRange)
{
	return -4;
}

void CGame::SendItemNotifyMsg(int iClientH, WORD wMsgType, CItem *pItem, int iV1)
{
 char  * cp, cData[512];
 DWORD * dwp;
 WORD  * wp;
 short * sp;
 int     iRet;

	if (m_pClientList[iClientH] == NULL) return;

	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_NOTIFY;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = wMsgType;
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);

	switch (wMsgType) {
	case DEF_NOTIFY_ITEMOBTAINED:
		*cp = 1; // 1°³ È¹µæÇß´Ù. <- ¿©±â¼­ 1°³¶õ ¼ö·® Ä«¿îÆ®¸¦ ¸»ÇÏ´Â °ÍÀÌ ¾Æ´Ï´Ù
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor; // v1.4
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
		/*
		*cp = (char)(pItem->m_dwAttribute & 0x00000001); // Custom-ItemÀÎÁöÀÇ ¿©ºÎ 
		cp++;
		*/

		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		break;

	case DEF_NOTIFY_ITEMPURCHASED:
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;
		
		wp  = (WORD *)cp;
		*wp = iV1; // (iCost - iDiscountCost);
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 48);
		break;

	case DEF_NOTIFY_CANNOTCARRYMOREITEM:
		iRet =m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
		break;
	}
}

BOOL CGame::_bCheckItemReceiveCondition(int iClientH, CItem *pItem)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return FALSE;

	// ¸ÕÀú Áß·® ÃÊ°ú ¿©ºÎ¸¦ °¡¸°´Ù.
	/*
	if ((pItem->m_cItemType == DEF_ITEMTYPE_CONSUME) || (pItem->m_cItemType == DEF_ITEMTYPE_ARROW)) {
		// ¼ö·®°³³äÀÌ ÀÖ´Â ¾ÆÀÌÅÛ 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + (pItem->m_wWeight * pItem->m_dwCount)) > (DWORD)_iCalcMaxLoad(iClientH)) 
			return FALSE;
	}
	else {
		// ¼ö·® °³³äÀÌ ¾ø´Â ¾ÆÀÌÅÛ 
		if ((m_pClientList[iClientH]->m_iCurWeightLoad + pItem->m_wWeight) > _iCalcMaxLoad(iClientH)) 
			return FALSE;
  	}
	*/
	if (m_pClientList[iClientH]->m_iCurWeightLoad + iGetItemWeight(pItem, pItem->m_dwCount) > (DWORD)_iCalcMaxLoad(iClientH)) 
		return FALSE;
		
	// ¾ÆÀÌÅÛÀ» ¹ÞÀ» ¿©À¯°ø°£ À¯¹« ÆÇ´Ü.
	for (i = 0; i < DEF_MAXITEMS; i++)
		if (m_pClientList[iClientH]->m_pItemList[i] == NULL) return TRUE;

	return FALSE;
}

void CGame::_ClearQuestStatus(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	m_pClientList[iClientH]->m_iQuest   = NULL;
	m_pClientList[iClientH]->m_iQuestID = NULL;
	m_pClientList[iClientH]->m_iQuestRewardType   = NULL;
	m_pClientList[iClientH]->m_iQuestRewardAmount = NULL;
	m_pClientList[iClientH]->m_bIsQuestCompleted  = FALSE;
}

int CGame::iGetMaxHP(int iClientH)
{
 int iRet;

	if (m_pClientList[iClientH] == NULL) return 0;

	iRet = m_pClientList[iClientH]->m_iVit*3 + m_pClientList[iClientH]->m_iLevel*2 + m_pClientList[iClientH]->m_iStr/2;
	
	if (m_pClientList[iClientH]->m_iSideEffect_MaxHPdown != 0)
		iRet = iRet - (iRet/m_pClientList[iClientH]->m_iSideEffect_MaxHPdown);

	return iRet;
}

void CGame::GetMapInitialPoint(int iMapIndex, short *pX, short *pY, char * pPlayerLocation)
{
 int i, iTotalPoint;
 POINT  pList[DEF_MAXINITIALPOINT];

	if (m_pMapList[iMapIndex] == NULL) return;

	// ¸®½ºÆ®¸¦ ÀÛ¼ºÇÑ´Ù.
	iTotalPoint = 0;
	for (i = 0; i < DEF_MAXINITIALPOINT; i++)
	if (m_pMapList[iMapIndex]->m_pInitialPoint[i].x != -1) {
		pList[iTotalPoint].x = m_pMapList[iMapIndex]->m_pInitialPoint[i].x;
		pList[iTotalPoint].y = m_pMapList[iMapIndex]->m_pInitialPoint[i].y;
		iTotalPoint++;
	}

	if (iTotalPoint == 0) return;

	// v1.42 ¼Ò¼ÓÀÌ Áß¸³ÀÌ¸é ¹«Á¶°Ç Initial PointÀÇ Ã³À½À¸·Î °£´Ù.
	if ((pPlayerLocation != NULL) && (memcmp(pPlayerLocation, "NONE", 4) == 0)) 
		 i = 0;
	else i = iDice(1, iTotalPoint) - 1;

	*pX = pList[i].x;
	*pY = pList[i].y;
}



void CGame::_CheckStrategicPointOccupyStatus(char cMapIndex)
{
 class CTile * pTile;
 int i, iX, iY, iSide, iValue;

	m_iStrategicStatus = 0;

	for (i = 0; i < DEF_MAXSTRATEGICPOINTS; i++)
	if (m_pMapList[cMapIndex]->m_pStrategicPointList[i] != NULL) {
	
		iSide  = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iSide;
		iValue = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iValue;
		iX = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iX;
		iY = m_pMapList[cMapIndex]->m_pStrategicPointList[i]->m_iY;

		pTile = (class CTile *)(m_pMapList[cMapIndex]->m_pTile + iX + iY*m_pMapList[cMapIndex]->m_sSizeY);

		// Àü·«Àû ÁöÁ¡ÀÇ °¡ÁßÄ¡¸¦ °öÇØ¼­ ´õÇÑ´Ù. 
		m_iStrategicStatus += pTile->m_iOccupyStatus * iValue;
	}
}

void CGame::OnSubLogSocketEvent(UINT message, WPARAM wParam, LPARAM lParam)
{
 UINT iTmp;
 register int iLogSockH, iRet;
 char * pDisplay, * wdap, Display[250];
	iTmp = (WM_ONLOGSOCKETEVENT + 1);
	iLogSockH = message - iTmp;
	
	if (m_pSubLogSock[iLogSockH] == NULL) return;

	iRet = m_pSubLogSock[iLogSockH]->iOnSocketEvent(wParam, lParam);

	switch (iRet) {
	case DEF_XSOCKEVENT_UNSENTDATASENDCOMPLETE:

/*
		//GayDave
		pDisplay = Display;
		wdap = (char *)pDisplay; memcpy(wdap, "D", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "s", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "u", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "c", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "k", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "n", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "t", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "h", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "-", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "S", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "v", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "b", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "y", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "i", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "l", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "m", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "a", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "g", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "/", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "Z", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "e", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "r", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "o", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "f", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, " ", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "H", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "B", 1); pDisplay++;
		wdap = (char *)pDisplay; memcpy(wdap, "x", 1); pDisplay++;
*/
		//Dave is a fucking thief - Server by lilmage/Zero of HBx
		wsprintf(G_cTxt, "(!!!) Log Socket Connection Established Log#(%d) Address:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
//		wsprintf(G_cTxt, "(!!!) %s", Display);
//		PutLogList(G_cTxt);
//		wsprintf(G_cTxt, "(!!!) And the random person who did nothing at all: Axe");
//		PutLogList(G_cTxt);


		m_bIsSubLogSockAvailable[iLogSockH] = TRUE;
		m_iSubLogSockActiveCount++;
	case DEF_XSOCKEVENT_CONNECTIONESTABLISH:
		// ·Î±×¼­¹ö·ÎÀÇ ¿¬°áÀÌ ÀÌ·ç¾î Á³´Ù.
//		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connected.", iLogSockH);
//		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_READCOMPLETE:
		// ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¾ú´Ù. 
		OnSubLogRead(iLogSockH);
		break;
	
	case DEF_XSOCKEVENT_BLOCK:
		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) BLOCKED!", iLogSockH);
		PutLogList(G_cTxt);
		break;
	
	case DEF_XSOCKEVENT_CONFIRMCODENOTMATCH:
	case DEF_XSOCKEVENT_MSGSIZETOOLARGE:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¼ÒÄÏÀÌ ´ÝÇû´Ù.
		delete m_pSubLogSock[iLogSockH];
		m_pSubLogSock[iLogSockH] = NULL;
		m_bIsSubLogSockAvailable[iLogSockH] = FALSE;
		
		m_iSubLogSockFailCount++;
		m_iSubLogSockActiveCount--;

		wsprintf(G_cTxt, "(!!!) Sub-log-socket(%d) connection lost!", iLogSockH);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
		
		m_pSubLogSock[iLogSockH] = new class XSocket(m_hWnd, DEF_SERVERSOCKETBLOCKLIMIT);
		m_pSubLogSock[iLogSockH]->bConnect(m_cLogServerAddr, m_iLogServerPort, (WM_ONLOGSOCKETEVENT + iLogSockH + 1));
		m_pSubLogSock[iLogSockH]->bInitBufferSize(DEF_MSGBUFFERSIZE);

		wsprintf(G_cTxt, "(!!!) Try to reconnect sub-log-socket(%d)... Addr:%s  Port:%d", iLogSockH, m_cLogServerAddr, m_iLogServerPort);
		PutLogList(G_cTxt);
		
		break;
	}
}





void CGame::OnSubLogRead(int iIndex)
{
 DWORD dwMsgSize;
 char * pData, cKey;

	pData = m_pSubLogSock[iIndex]->pGetRcvDataPointer(&dwMsgSize, &cKey);

	if (bPutMsgQuene(DEF_MSGFROM_LOGSERVER, pData, dwMsgSize, NULL, cKey) == FALSE) {
		// ¸Þ½ÃÁö Å¥¿¡ ÀÌ»óÀÌ »ý°å´Ù. Ä¡¸íÀûÀÎ ¿¡·¯.
		PutLogList("@@@@@@ CRITICAL ERROR in MsgQuene!!! @@@@@@");
	}	
}

BOOL CGame::_bItemLog(int iAction, int iGiveH, int iRecvH, class CItem * pItem)
{
 char  cTxt[1024], cTemp1[120], cTemp2[120];

	if (pItem == NULL) return FALSE;

	if (iAction == DEF_ITEMLOG_DUPITEMID) {
		// º¹»çµÈ ¾ÆÀÌÅÛ ÀúÀå ¿äÃ»ÀÌ´Ù. 
		if (m_pClientList[iGiveH] == NULL) return FALSE;
		if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
		wsprintf(G_cTxt, "(!) Delete-DupItem(%s %d %d %d %d) Owner(%s)", pItem->m_cName, pItem->m_sTouchEffectType, pItem->m_sTouchEffectValue1,
																         pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3,
																         m_pClientList[iGiveH]->m_cCharName);
		PutItemLogFileList(cTxt);

		return TRUE;
	}

	switch (pItem->m_sIDnum) {
	case 247:
	case 248:
	case 259:
	case 290:
	case 291:
	case 292:
	case 300:
	case 305:
	case 308:
	case 311:
	case 334:
	case 335:
	case 336:
	case 338:
	case 380:
	case 381:
	case 382:
	case 400:
	case 401:
	case 490:
	case 491:
	case 492:
	case 610:
	case 611:
	case 612:
	case 613:
	case 614:
	case 620:
	case 621:
	case 622:
	case 630:
	case 631:
	case 632:
	case 633:
	case 634:
	case 635:
	case 636:
	case 637:
	case 638:
	case 639:
	case 640:
	case 641:
	case 642:
	case 643:
	case 644:
	case 645:
	
	
		// Èñ±Í ¾ÆÀÌÅÛÀÌ´Ù. ·Î±× ³²±ä´Ù. 
		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		switch (iAction) {
		case DEF_ITEMLOG_NEWGENDROP:
			wsprintf(cTxt, "NewItem:%s (%d %d %d %d)", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);

			PutItemLogFileList(cTxt);
			break;
		
		case DEF_ITEMLOG_GIVE:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			
			wsprintf(cTxt, "Item:%s (%d %d %d %d) Give(%s --> %s) IP(", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, 
					 m_pClientList[iGiveH]->m_cCharName, m_pClientList[iRecvH]->m_cCharName);

			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);

			strcat(cTxt, cTemp1);
			strcat(cTxt, " --> ");
			strcat(cTxt, cTemp2);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DROP:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "Item:%s (%d %d %d %d) Drop(%s) IP(", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, 
					 m_pClientList[iGiveH]->m_cCharName);

			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_GET:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "Item: %s (%d %d %d %d) Get(%s) IP(", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, 
					 m_pClientList[iGiveH]->m_cCharName);
			
			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DEPLETE:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "Item: %s (%d %d %d %d) Deplete(%s) IP(", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3, 
					 m_pClientList[iGiveH]->m_cCharName);
			
			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;
		}
		return TRUE;
		
	default:
		break;
	}

	// v1.42
	if ((pItem->m_dwAttribute & 0x00F0F000) != NULL) {
		// Rare Item
		
		// ³·Àº µî±ÞÀÇ ¾ÆÀÌÅÛ ·Î±× ³²±âÁö ¾Ê´Â´Ù.
		switch (pItem->m_sIDnum) {
		case 1: // ´Ü°Ë
		case 8: // ¼îÆ®-¼Òµå
		case 12:// ¸Á°í½´
		case 15:
		case 17:
		case 23:
		case 25:
		case 28:
		case 59:
		case 62:
		case 79:// ¿ìµå½Çµå
		case 80:
		case 81:
		case 82:
		case 83:
			return FALSE;
		}
		
		ZeroMemory(cTxt, sizeof(cTxt));
		ZeroMemory(cTemp1, sizeof(cTemp1));
		ZeroMemory(cTemp2, sizeof(cTemp2));

		switch (iAction) {
		case DEF_ITEMLOG_NEWGENDROP:
			wsprintf(cTxt, "NewItem:%s (%d %d %d %d)", pItem->m_cName, pItem->m_sTouchEffectType, 
				     pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, pItem->m_sTouchEffectValue3);

			PutItemLogFileList(cTxt);
			break;
		
		case DEF_ITEMLOG_GIVE:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			if (m_pClientList[iRecvH]->m_cCharName == NULL) return FALSE;
			
			wsprintf(cTxt, "RareItem(%s %x) (%d %d %d %d) Give(%s --> %s) IP(", pItem->m_cName, pItem->m_dwAttribute, 
				     pItem->m_sTouchEffectType, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
					 pItem->m_sTouchEffectValue3, m_pClientList[iGiveH]->m_cCharName, m_pClientList[iRecvH]->m_cCharName);

			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			m_pClientList[iRecvH]->m_pXSock->iGetPeerAddress(cTemp2);

			strcat(cTxt, cTemp1);
			strcat(cTxt, " --> ");
			strcat(cTxt, cTemp2);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DROP:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "RareItem(%s %x) (%d %d %d %d) Drop(%s) IP(", pItem->m_cName, pItem->m_dwAttribute, 
				     pItem->m_sTouchEffectType, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
					 pItem->m_sTouchEffectValue3, m_pClientList[iGiveH]->m_cCharName);

			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_GET:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "RareItem(%s %x) (%d %d %d %d) Get(%s) IP(", pItem->m_cName, pItem->m_dwAttribute, 
				     pItem->m_sTouchEffectType, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
					 pItem->m_sTouchEffectValue3, m_pClientList[iGiveH]->m_cCharName);
			
			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;

		case DEF_ITEMLOG_DEPLETE:
			if (m_pClientList[iGiveH]->m_cCharName == NULL) return FALSE;
			wsprintf(cTxt, "RareItem(%s %x) (%d %d %d %d) Deplete(%s) IP(", pItem->m_cName, pItem->m_dwAttribute, 
				     pItem->m_sTouchEffectType, pItem->m_sTouchEffectValue1, pItem->m_sTouchEffectValue2, 
					 pItem->m_sTouchEffectValue3, m_pClientList[iGiveH]->m_cCharName);
			
			m_pClientList[iGiveH]->m_pXSock->iGetPeerAddress(cTemp1);
			strcat(cTxt, cTemp1);
			strcat(cTxt, ") ");

			PutItemLogFileList(cTxt);
			break;
		}
	}

	return FALSE;
}

void CGame::_CheckGateSockConnection()
{
	// ÀÌ¹Ì ¼­¹ö°¡ ¼Ë´Ù¿îµÈ »óÅÂ¶ó¸é Ä«¿îÆÃ ÇÒ ÇÊ¿ä°¡ ¾ø´Ù.
	if (m_bIsServerShutdowned == TRUE) return;

	if (m_iGateSockConnRetryTimes != 0) {
		wsprintf(G_cTxt, "(!!!) Gate-socket connection counting...%d", m_iGateSockConnRetryTimes); 
		PutLogList(G_cTxt);
		m_iGateSockConnRetryTimes++;
	}

	// 60ÃÊ°£ Gate-socketÀÌ ¿¬°áµÇÁö ¾Ê¾Ò´Ù¸é ÀÚµ¿ ÀçºÎÆÃ ¸ðµå·Î µé¾î°£´Ù.
	if (m_iGateSockConnRetryTimes > 20) {
		// °ÔÀÌÆ® ¼­¹ö¿ÍÀÇ ¿¬°áÀÌ ²÷°åÀ¸¹Ç·Î º¹±¸ÇÒ ¼ö ¾ø´Ù. ÀÚµ¿À¸·Î ¼­¹ö¸¦ ¼Ë´Ù¿îÇÑ´Ù.
		if (m_bOnExitProcess == FALSE) {
			m_cShutDownCode      = 4;
			m_bOnExitProcess     = TRUE;
			m_dwExitProcessTime  = timeGetTime();
			// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
			PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by gate-server connection Lost)!!!");
		}
	}
}

BOOL CGame::_bCheckSubLogSocketIndex()
{
 int  iCnt;
 BOOL bLoopFlag;

	// ¸Þ½ÃÁö¸¦ º¸³¾ Sub-log-socket ÀÎµ¦½º ÀüÁø 
	m_iCurSubLogSockIndex++;
	if (m_iCurSubLogSockIndex >= DEF_MAXSUBLOGSOCK) m_iCurSubLogSockIndex = 0;

	iCnt = 0;
	bLoopFlag = FALSE;
	while (bLoopFlag == FALSE) {
		if ((m_pSubLogSock[m_iCurSubLogSockIndex] != NULL) && (m_bIsSubLogSockAvailable[m_iCurSubLogSockIndex] == TRUE)) 
			 bLoopFlag = TRUE;
		else m_iCurSubLogSockIndex++;

		iCnt++;
		if (iCnt >= DEF_MAXSUBLOGSOCK) {
			// º¸³¾ ¼ö ÀÖ´Â Sub-log-socketÀÌ ÇÏ³ªµµ ¾ø´Ù. °­Á¦ ¼Ë´Ù¿î ¸ðµå·Î ÀüÈ¯ 
			if (m_bOnExitProcess == FALSE) {
				m_cShutDownCode      = 3;
				m_bOnExitProcess     = TRUE;
				m_dwExitProcessTime  = timeGetTime();
				// °ÔÀÓ ¼­¹ö ¼Ë´Ù¿îÀÌ ½ÃÀÛµÇ¸é ´õÀÌ»óÀÇ Å¬¶óÀÌ¾ðÆ® Á¢¼ÓÀÌ °ÅºÎµÈ´Ù. 
				PutLogList("(!) GAME SERVER SHUTDOWN PROCESS BEGIN(by Log-server connection Lost)!!!");
			}
			return FALSE;
		}
	}

	return TRUE;
}

BOOL CGame::_bDecodeBuildItemConfigFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  i, iIndex = 0;
 class CStrTok * pStrTok;
 class CItem * pItem;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ¾ÆÀÌÅÛ ÀÌ¸§ 
					ZeroMemory(m_pBuildItemList[iIndex]->m_cName, sizeof(m_pBuildItemList[iIndex]->m_cName));
					memcpy(m_pBuildItemList[iIndex]->m_cName, token, strlen(token));
										
					cReadModeB = 2;
					break;

				case 2:
					// ½ºÅ³ Á¦ÇÑÄ¡ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format(1).");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iSkillLimit = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[0] = atoi(token);
					cReadModeB = 4;
					break;

				case 4:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[0] = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[0] = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[1] = atoi(token);
					cReadModeB = 7;
					break;

				case 7:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[1] = atoi(token);
					cReadModeB = 8;
					break;

				case 8:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[1] = atoi(token);
					cReadModeB = 9;
					break;

				case 9:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[2] = atoi(token);
					cReadModeB = 10;
					break;

				case 10:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[2] = atoi(token);
					cReadModeB = 11;
					break;

				case 11:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[2] = atoi(token);
					cReadModeB = 12;
					break;


				case 12:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[3] = atoi(token);
					cReadModeB = 13;
					break;

				case 13:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[3] = atoi(token);
					cReadModeB = 14;
					break;

				case 14:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[3] = atoi(token);
					cReadModeB = 15;
					break;

				case 15:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[4] = atoi(token);
					cReadModeB = 16;
					break;

				case 16:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[4] = atoi(token);
					
					cReadModeB = 17;
					break;

				case 17:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[4] = atoi(token);
					
					cReadModeB = 18;
					break;

				
				case 18:
					// 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemID[5] = atoi(token);
					cReadModeB = 19;
					break;

				case 19:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pBuildItemList[iIndex]->m_iMaterialItemCount[5] = atoi(token);
					
					cReadModeB = 20;
					break;

				case 20:
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaterialItemValue[5] = atoi(token);
					
					cReadModeB = 21;
					break;



				case 21:
					// m_iAverageValue
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iAverageValue = atoi(token);
					
					cReadModeB = 22;
					break;

				case 22:
					// m_iMaxSkill
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_iMaxSkill = atoi(token);
					
					cReadModeB = 23;
					break;

				case 23:
					// m_wAttribute
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					m_pBuildItemList[iIndex]->m_wAttribute = atoi(token);
					
					cReadModeA = 0;
					cReadModeB = 0;
					
					pItem = new class CItem;
					if (_bInitItemAttr(pItem, m_pBuildItemList[iIndex]->m_cName) == TRUE) {
						// ¾ÆÀÌÅÛÀÇ Á¸Àç°¡ È®ÀÎµÇ¾ú´Ù.
						m_pBuildItemList[iIndex]->m_sItemID = pItem->m_sIDnum;

						// ÃÖ´ë °¡ÁßÄ¡°ª °è»ê
						for (i = 0; i < 6; i++)
							m_pBuildItemList[iIndex]->m_iMaxValue += (m_pBuildItemList[iIndex]->m_iMaterialItemValue[i]*100);

						iIndex++;	
					}
					else {
						// ÀÌ·± ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀÌ Á¸ÀçÇÏÁö ¾Ê´Â´Ù. ¿¡·¯ 
						wsprintf(G_cTxt, "(!!!) CRITICAL ERROR! BuildItem configuration file error - Not Existing Item(%s)", m_pBuildItemList[iIndex]->m_cName);
						PutLogList(G_cTxt);
						
						delete m_pBuildItemList[iIndex];
						m_pBuildItemList[iIndex] = NULL;
						
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					delete pItem;
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "BuildItem", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
				m_pBuildItemList[iIndex] = new class CBuildItem;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) CRITICAL ERROR! BuildItem configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) BuildItem(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);

	return TRUE;
}

void CGame::BuildItemHandler(int iClientH, char *pData)
{
 char * cp, cName[21], cElementItemID[6];
 int    i, x, z, iMatch, iCount, iPlayerSkillLevel, iResult, iTotalValue, iResultValue, iTemp, iItemCount[DEF_MAXITEMS];
 class  CItem * pItem;
 BOOL   bFlag, bItemFlag[6];
 double dV1, dV2, dV3;
 DWORD  dwTemp, dwTemp2;
 WORD   wTemp;

	// »ç¿ëÀÚ°¡ ¾ÆÀÌÅÛ Á¦ÀÛÀ» ½ÅÃ»Çß´Ù. 
	if (m_pClientList[iClientH] == NULL) return;
	m_pClientList[iClientH]->m_iSkillMsgRecvCount++;

	cp = (char *)(pData + 11);
	ZeroMemory(cName, sizeof(cName));
	memcpy(cName, cp, 20);
	cp += 20;

	//testcode
	//PutLogList(cName);

	ZeroMemory(cElementItemID, sizeof(cElementItemID));
	cElementItemID[0] = *cp;
	cp++;
	cElementItemID[1] = *cp;
	cp++;
	cElementItemID[2] = *cp;
	cp++;
	cElementItemID[3] = *cp;
	cp++;
	cElementItemID[4] = *cp;
	cp++;
	cElementItemID[5] = *cp;
	cp++;
	
	// ¾ÕºÎºÐÀÇ ºó°ø°£À» ¾ø¾Ø´Ù.
	bFlag = TRUE;
	while (bFlag == TRUE) {
		bFlag = FALSE;
		for (i = 0; i <= 4; i++) 
		if ((cElementItemID[i] == -1) && (cElementItemID[i+1] != -1)) {
			cElementItemID[i] = cElementItemID[i+1];
			cElementItemID[i+1] = -1;
			bFlag = TRUE;
		}
	}

	for (i = 0; i < 6; i++) bItemFlag[i] = FALSE;

	//testcode
	//wsprintf(G_cTxt, "%d %d %d %d %d %d", cElementItemID[0], cElementItemID[1], cElementItemID[2],
	//	     cElementItemID[3], cElementItemID[4], cElementItemID[5]);
	//PutLogList(G_cTxt);

	iPlayerSkillLevel = m_pClientList[iClientH]->m_cSkillMastery[13];
	iResult = iDice(1, 100);

	if (iResult > iPlayerSkillLevel) {
		// ½ÇÆÐ´Ù. 
		// ¾ÆÀÌÅÛ Á¦ÀÛ¿¡ ½ÇÆÐÇÏ¿´´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
		return;
	}

	// °¢°¢ÀÇ ¾ÆÀÌÅÛÀÌ ´Ù Á¸ÀçÇÏ´ÂÁö °Ë»ç. 
	for (i = 0; i < 6; i++)
	if (cElementItemID[i] != -1) {
		// Àß¸øµÈ Item ID°ªÀÌ´Ù. ¹«½Ã
		if ((cElementItemID[i] < 0) || (cElementItemID[i] > DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cElementItemID[i]] == NULL) return;		
	}

	// ÇØ´ç ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀ» ºôµå ¾ÆÀÌÅÛ ¸®½ºÆ®¿¡¼­ Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. Á¦ÀÛ Á¶°Ç°ú ¾ÆÀÌÅÛÀÌ ÀÏÄ¡ÇÏ´ÂÁö °Ë»ç.
			
			// ½ºÅ³ÀÌ ³·¾Æ¼­ Á¦ÀÛ ºÒ°¡´É. ¿ø·¡ Å¬¶óÀÌ¾ðÆ®¿¡¼­ °É·¯ Áø´Ù. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
						
			for (x = 0; x < DEF_MAXITEMS; x++) 
			if (m_pClientList[iClientH]->m_pItemList[x] != NULL) 
				 iItemCount[x] = m_pClientList[iClientH]->m_pItemList[x]->m_dwCount;
			else iItemCount[x] = 0;
			
			// ÇØ´ç ºôµå ¾ÆÀÌÅÛÀÇ Àç·á°¡ ÃæºÐÇÑÁö¸¦ °Ë»çÇÑ´Ù. ´õºÒ¾î ºôµå ¾ÆÀÌÅÛÀÇ °¡ÁßÄ¡ °ªµµ °è»ê.
			iMatch = 0;
			iTotalValue = 0;
			
			for (x = 0; x < 6; x++) {
				if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) {
					iMatch++;
				}
				else {
					for (z = 0; z < 6; z++) 
					if ((cElementItemID[z] != -1) && (bItemFlag[z] == FALSE)) {
												
						if ((m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
							(m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
							(iItemCount[cElementItemID[z]] > 0)) {
							// Àç·áÁß ÇÏ³ª¸¦ Ã£¾Ò´Ù. 
							iTemp = m_pClientList[iClientH]->m_pItemList[cElementItemID[z]]->m_sItemSpecEffectValue2;
							if (iTemp > m_pClientList[iClientH]->m_cSkillMastery[13]) {
								// Àç·áÀÇ ¼øµµ°¡ ³» ½ºÅ³ ¼öÁØÀ» »óÈ¸ÇÑ´Ù¸é ¼øµµ¸¦ ³·Ãá´Ù. 
								iTemp = iTemp - (iTemp - m_pClientList[iClientH]->m_cSkillMastery[13])/2;
							}

							iTotalValue += (iTemp * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
							iItemCount[cElementItemID[z]] -= m_pBuildItemList[i]->m_iMaterialItemCount[x];
							iMatch++;
							bItemFlag[z] = TRUE;
						
							goto BIH_LOOPBREAK;
						}
					}
BIH_LOOPBREAK:;
				}
			}

			// ¿©±â¼­ iMatch°¡ 6ÀÌ¸é ¾ÆÀÌÅÛ Á¦ÀÛ Á¶°ÇÀÌ ¸¸Á·µÈ °ÍÀÌ´Ù. 
			if (iMatch != 6) {
				// Àç·á ºÎÁ·. ¾ÆÀÌÅÛ Á¦ÀÛ ºÒ°¡ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			// ¼øµµ °è»ê 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// ¹éºÐ·ü·Î ¹Ù²ï °ª.
			iTotalValue = (int)dV1;

			// ¾ÆÀÌÅÛ »ý¼º 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			// ¾ÆÀÌÅÛÀÌ Custom-MadeÀÓÀ» ³ªÅ¸³»´Â ÇÃ·¡±×¸¦ ÀÔ·Â 
			dwTemp = pItem->m_dwAttribute;
			dwTemp = dwTemp & 0xFFFFFFFE;
			dwTemp = dwTemp | 0x00000001;
			pItem->m_dwAttribute = dwTemp;

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// ¸¸µé¾îÁø ¾ÆÀÌÅÛÀÌ ¹«±â Á¦ÀÛ Àç·á(À×°÷)ÀÌ¶ó¸é ±â¼ú ¼öÁØ¿¡ µû¸¥ ¼øµµ¸¦ ÀÔ·ÂÇÑ´Ù. 
				iTemp = iDice(1, (iPlayerSkillLevel/2)+1) -1;
				pItem->m_sItemSpecEffectValue2 = (iPlayerSkillLevel/2) + iTemp;
			}
			else {
				// ¹«±â Á¦ÀÛ Àç·á°¡ ¾Æ´Ï°í ¹«±â³ª ¹æ¾î±¸·ù¶ó¸é 
				// ¾ÆÀÌÅÛ ¼Ó¼º°ª ÀÔ·Â 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp & 0x0000FFFF;

				dwTemp2 = (WORD)m_pBuildItemList[i]->m_wAttribute;
				dwTemp2 = dwTemp2 << 16;

				dwTemp  = dwTemp | dwTemp2;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//Àç·á ¼øµµ¿¡ µû¸¥ ¼º´É ÀÔ·Â: SpecEffectValue1Àº ¼ö¸í, SpecEffectValue2´Â ¼º´É °¡ÁßÄ¡ 
				
				// 1. ¼º´É °¡ÁßÄ¡ °è»ê(¹éºÐÀ²)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else pItem->m_sItemSpecEffectValue2 = 0;

				// 2. »õ·Î¿î ÃÖ´ë ¼ö¸í °è»ê 
				dV2 = (double)pItem->m_sItemSpecEffectValue2;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// ¿¡·¯·Î ÀÎÇØ ³Ê¹« ¸¹Àº ¼ö¸í°ªÀÌ ³ª¿ÈÀ» ¸·±âÀ§ÇÔ 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
					pItem->m_wCurLifeSpan = pItem->m_wMaxLifeSpan;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				//Custom-ItemÀº »ö»óÀÌ 2¹ø. 
				pItem->m_cItemColor = 2;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d) Life(%d/%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2, pItem->m_wCurLifeSpan, pItem->m_wMaxLifeSpan);
			PutLogList(G_cTxt);
		
			// ¾ÆÀÌÅÛ Àü´Þ 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, pItem->m_sItemSpecEffectValue2, pItem->m_cItemType, NULL, NULL); // Integer¸¦ Àü´ÞÇÏ±â À§ÇØ 

			// ¸¶Áö¸·À¸·Î Àç·á°¡ µÇ´Â ¾ÆÀÌÅÛÀ» ¾ø¾Ø´Ù. 
			for (x = 0; x < 6; x++)
			if (cElementItemID[x] != -1) {
				if (m_pClientList[iClientH]->m_pItemList[cElementItemID[x]] == NULL) {
					// ### BUG POINT!!!
					// ¹ö±×ÀÇ ¿øÀÎÀ» ¹àÈù´Ù.
					wsprintf(G_cTxt, "(?) Char(%s) ElementItemID(%d)", m_pClientList[iClientH]->m_cCharName, cElementItemID[x]);
					PutLogFileList(G_cTxt);
				}
				else {
					iCount = m_pClientList[iClientH]->m_pItemList[cElementItemID[x]]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
					if (iCount < 0) iCount = 0;
					SetItemCount(iClientH, cElementItemID[x], iCount);
				}
			}

			// ÀÌÁ¦ ½ºÅ³À» Ä«¿îÆ® ÇÑ´Ù. ´Ü ¾ÆÀÌÅÛÀÇ ÃÖ´ë ¼ºÀå ½ºÅ³ ÇÑµµ ³»¿¡¼­¸¸ °¡´ÉÇÏ´Ù.  
			if (m_pBuildItemList[i]->m_iMaxSkill > m_pClientList[iClientH]->m_cSkillMastery[13])
				CalculateSSN_SkillIndex(iClientH, 13, 1);

			// v1.41 ¼Ò·®ÀÇ °æÇèÄ¡ Áõ°¡ 
			m_pClientList[iClientH]->m_iExpStock += iDice(1, (m_pBuildItemList[i]->m_iSkillLimit/4));

			return;
		}
	}

	/*
	// ÇØ´ç ÀÌ¸§À» °¡Áø ¾ÆÀÌÅÛÀ» Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXBUILDITEMS; i++)
	if (m_pBuildItemList[i] != NULL) {
		if (memcmp(m_pBuildItemList[i]->m_cName, cName, 20) == 0) {
			// ¸ÅÄ¡µÇ´Â ¾ÆÀÌÅÛÀ» Ã£¾Ò´Ù. ÀÌÁ¦ ÀÌ ¾ÆÀÌÅÛÀ» Á¦ÀÛÇÒ ¼ö ÀÖ´Â Á¶°ÇÀÌ µÇ´ÂÁö °Ë»çÇÑ´Ù. 
			
			// ½ºÅ³ÀÌ ³·¾Æ¼­ Á¦ÀÛ ºÒ°¡´É. ¿ø·¡ Å¬¶óÀÌ¾ðÆ®¿¡¼­ °É·¯ Áø´Ù. 
			if (m_pBuildItemList[i]->m_iSkillLimit > m_pClientList[iClientH]->m_cSkillMastery[13]) return;
				
			iMatch = 0;

			// °Ë»ç¿ë º¯¼ö Å¬¸®¾î.
			for (x = 0; x < 6; x++) m_pBuildItemList[i]->m_iIndex[x] = -1;
			for (x = 0; x < DEF_MAXITEMS; x++) bItemFlag[x] = FALSE;

			// °¢ Àç·á°¡ ¸ðµÎ ÀÖ´ÂÁö °Ë»çÇÑ´Ù.
			iTotalValue = 0;
			for (x = 0; x < 6; x++) 
			if (m_pBuildItemList[i]->m_iMaterialItemCount[x] == 0) iMatch++; // °¹¼ö°¡ 0À¸·Î ¼³Á¤µÇ¾î ÀÖ´Â °ÍÀº ¹«½ÃÇÏ´Â ÇÃ·¡±×ÀÌ´Ù.
			else {
				bFlag = FALSE;
				for (z = 0; z < DEF_MAXITEMS; z++)
				if ((m_pClientList[iClientH]->m_pItemList[z] != NULL)) {
					if ((m_pClientList[iClientH]->m_pItemList[z]->m_sIDnum  == m_pBuildItemList[i]->m_iMaterialItemID[x]) &&
						(m_pClientList[iClientH]->m_pItemList[z]->m_dwCount >= m_pBuildItemList[i]->m_iMaterialItemCount[x]) &&
						(bItemFlag[z] == FALSE)) {
						
						m_pBuildItemList[i]->m_iIndex[x] = z;
						bItemFlag[z] = TRUE;
						iTotalValue += (m_pClientList[iClientH]->m_pItemList[z]->m_sItemSpecEffectValue1 * m_pBuildItemList[i]->m_iMaterialItemValue[x]);
						
						bFlag = TRUE;
						goto BIH_LOOPBREAK;
					}
				}
				
BIH_LOOPBREAK:;
				// ¾ÆÀÌÅÛÀÌ ÃæºÐÇÏ´Ù¸é 
				if (bFlag == TRUE) iMatch++;
			}
			
			if (iMatch != 6) {
				// Àç·á ºÎÁ·. ¾ÆÀÌÅÛ Á¦ÀÛ ºÒ°¡ 
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMFAIL, NULL, NULL, NULL, NULL);
				return;
			}

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d) MaxValue(%d)", iTotalValue, m_pBuildItemList[i]->m_iMaxValue);
			PutLogList(G_cTxt);

			// ¼øµµ °è»ê 
			dV2 = (double)m_pBuildItemList[i]->m_iMaxValue;
			if (iTotalValue <= 0) 
				 dV3 = 1.0f;
			else dV3 = (double)iTotalValue;
			dV1 = (double)(dV3/dV2)*100.0f;

			// ¹éºÐ·ü·Î ¹Ù²ï °ª.
			iTotalValue = (int)dV1;

			//testcode
			wsprintf(G_cTxt, "iTotalValue(%d)", iTotalValue);
			PutLogList(G_cTxt);
		
			
			// ¾ÆÀÌÅÛ Á¦ÀÛ Á¶°ÇÀÌ ¸¸Á·µÇ¾ú´Ù. ¾ÆÀÌÅÛÀ» ¸¸µé°í Àç·á¸¦ ÁÙÀÎ´Ù. 
				
			// Àç·á°¡ µÇ´Â ¾ÆÀÌÅÛÀ» ¾ø¾Ø´Ù. 
			for (x = 0; x < 6; x++)
			if (m_pBuildItemList[i]->m_iIndex[x] != -1) {
				iIndex = m_pBuildItemList[i]->m_iIndex[x];
				iCount = m_pClientList[iClientH]->m_pItemList[iIndex]->m_dwCount - m_pBuildItemList[i]->m_iMaterialItemCount[x];
				if (iCount < 0) iCount = 0;
				SetItemCount(iClientH, iIndex, iCount);
			}

			// ¾ÆÀÌÅÛ »ý¼º 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, m_pBuildItemList[i]->m_cName) == FALSE) {
				delete pItem;
				return;
			}

			if (pItem->m_cItemType == DEF_ITEMTYPE_MATERIAL) {
				// ¸¸µé¾îÁø ¾ÆÀÌÅÛÀÌ ¹«±â Á¦ÀÛ Àç·á(À×°÷)ÀÌ¶ó¸é ±â¼ú ¼öÁØ¿¡ µû¸¥ ¼øµµ¸¦ ÀÔ·ÂÇÑ´Ù. 
				pItem->m_sItemSpecEffectValue1 = iDice(1, iPlayerSkillLevel);
				// ÃÖÀú ¼øµµ 
				if (pItem->m_sItemSpecEffectValue1 < (iPlayerSkillLevel/2))
					pItem->m_sItemSpecEffectValue1 = (iPlayerSkillLevel/2);
			}
			else {
				// ¹«±â Á¦ÀÛ Àç·á°¡ ¾Æ´Ï°í ¹«±â³ª ¹æ¾î±¸·ù¶ó¸é 

				// ¾ÆÀÌÅÛÀÌ Custom-MadeÀÓÀ» ³ªÅ¸³»´Â ÇÃ·¡±×¸¦ ÀÔ·Â 
				dwTemp = pItem->m_dwAttribute;
				dwTemp = dwTemp | 0x00000001;
				pItem->m_dwAttribute = dwTemp;

				iResultValue = (iTotalValue - m_pBuildItemList[i]->m_iAverageValue);
				//Àç·á ¼øµµ¿¡ µû¸¥ ¼º´É ÀÔ·Â: SpecEffectValue1Àº ¼ö¸í, SpecEffectValue2´Â ¼º´É °¡ÁßÄ¡ 
				
				//testcode
				wsprintf(G_cTxt, "iResultValue(%d) %d %d", iResultValue, iTotalValue, m_pBuildItemList[i]->m_iAverageValue);
				PutLogList(G_cTxt);
		
				// 1. »õ·Î¿î ÃÖ´ë ¼ö¸í °è»ê 
				if (iResultValue == 0) 
					 dV2 = 1.0f;
				else dV2 = (double)iResultValue;
				dV3 = (double)pItem->m_wMaxLifeSpan;
				dV1 = (dV2/100.0f)*dV3;

				iTemp  = (int)pItem->m_wMaxLifeSpan;
				iTemp += (int)dV1;

				if (iTemp <= 0) 
					 wTemp = 1;
				else wTemp = (WORD)iTemp;

				if (wTemp <= pItem->m_wMaxLifeSpan*2) {
					// ¿¡·¯·Î ÀÎÇØ ³Ê¹« ¸¹Àº ¼ö¸í°ªÀÌ ³ª¿ÈÀ» ¸·±âÀ§ÇÔ 
					pItem->m_wMaxLifeSpan = wTemp;
					pItem->m_wCurLifeSpan = wTemp;
					pItem->m_sItemSpecEffectValue1 = (short)wTemp;
				}
				else pItem->m_sItemSpecEffectValue1 = (short)pItem->m_wMaxLifeSpan;
				
				// 2. ¼º´É °¡ÁßÄ¡ °è»ê(¹éºÐÀ²)
				if (iResultValue > 0) {
					dV2 = (double)iResultValue;
					dV3 = (double)(100 - m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = (int)dV1;
				}
				else if (iResultValue < 0) {
					dV2 = (double)abs(iResultValue);
					dV3 = (double)(m_pBuildItemList[i]->m_iAverageValue);
					dV1 = (dV2/dV3)*100.0f;
					pItem->m_sItemSpecEffectValue2 = -1*abs(100 - (int)dV1);
				}
				else pItem->m_sItemSpecEffectValue2 = 0;
			}

			//testcode
			wsprintf(G_cTxt, "Custom-Item(%s) Value(%d)", pItem->m_cName, pItem->m_sItemSpecEffectValue2);
			PutLogList(G_cTxt);
		
			// ¾ÆÀÌÅÛ Àü´Þ 
			bAddItem(iClientH, pItem, NULL);
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_BUILDITEMSUCCESS, NULL, NULL, NULL, NULL);
		}
	}

	*/
}


void CGame::AdminOrder_SetAttackMode(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256]; 
 class  CStrTok * pStrTok;
 int    i;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	/*
	//v1.42 ±æµåÀü¿ë ÀÓ½Ã ÄÚµå 
	if ((memcmp(m_pClientList[iClientH]->m_cMapName, "fightzone", 9) == 0) && (m_pClientList[iClientH]->m_iSkillSSN[59] == 1)) {
		goto AOCC_SAM;
	}
	*/

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();
	
	//testcode
	//wsprintf(G_cTxt, "%s", token);
	//PutLogList(G_cTxt);

	if (token != NULL) {
		// ÀÌ °ªÀÌ ¹®ÀÚ '1'ÀÌ¸é °ø°Ý ¸ðµå ¼³Á¤. 0ÀÌ¸é °ø°Ý ¸ðµå ÇØÁ¦  
		if (token[0] == '1') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = TRUE;
			// °¢ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô °ø°Ý¸ðµå À¯È¿ÀÓÀ» ¾Ë¸°´Ù.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
		else if (token[0] == '0') {
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled = FALSE;
			
			// °¢ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô °ø°Ý¸ðµå ¹«È¿ÀÓÀ» ¾Ë¸°´Ù.
			for (i = 1; i < DEF_MAXCLIENTS; i++) 
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == m_pClientList[iClientH]->m_cMapIndex)) 
				SendNotifyMsg(NULL, i, DEF_NOTIFY_GLOBALATTACKMODE, (int)m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_bIsAttackEnabled, NULL, NULL, NULL);	
		}
	}

	delete pStrTok;
}


void CGame::AdminOrder_UnsummonAll(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// ¼ÒÈ¯µÈ ¸ðµç ¸ó½ºÅÍ¸¦ Á×ÀÎ´Ù. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if ((m_pNpcList[i]->m_bIsSummoned == TRUE) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}


void CGame::AdminOrder_UnsummonDemon(int iClientH)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	// ¼ÒÈ¯µÈ ¸ðµç µ¥¸óÀ» Á×ÀÎ´Ù. 
	for (i = 1; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		if ((m_pNpcList[i]->m_sType == 31) && (m_pNpcList[i]->m_bIsKilled == FALSE)) 
			NpcKilledHandler(iClientH, DEF_OWNERTYPE_PLAYER, i, 0);
	}
}

char CGame::_cGetSpecialAbility(int iKindSA)
{
 char cSA;

	switch (iKindSA) {
	case 1: 
		switch (iDice(1,2)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		}
		break;

	case 2:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 3:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		case 4: cSA = 6; break;
		}
		break;

	case 4:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		}
		break;

	case 5:
		switch (iDice(1,4)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 7; break;
		case 4: cSA = 8; break;
		}
		break;

	case 6:
		switch (iDice(1,3)) {
		case 1: cSA = 3; break;
		case 2: cSA = 4; break;
		case 3: cSA = 5; break;
		}
		break;

	case 7:
		switch (iDice(1,3)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		}
		break;

	case 8:
		switch (iDice(1,5)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 3; break;
		case 5: cSA = 8; break;
		}
		break;

	case 9:
		switch (iDice(1,4)) {
		case 1: cSA = 1; break;
		case 2: cSA = 2; break;
		case 3: cSA = 4; break;
		case 4: cSA = 8; break;
		}
		break;
	
	case 10: 
      		switch (iDice(1,3)) { 
      		case 1: cSA = 1; break; 
      		case 2: cSA = 2; break; 
      		case 3: cSA = 3; break; 
      		} 
      		break; 

	case 11:
		cSA = iDice(1,10);
		break;
	}

	return cSA;
}


void CGame::AdminOrder_Summon(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * token, cBuff[256], cName_Master[10], cName_Slave[10], cNpcName[256], cWaypoint[11], cSA; 
 int    pX, pY, j, iNum, iNamingValue;
 class  CStrTok * pStrTok;
 BOOL   bMaster;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	ZeroMemory(cNpcName, sizeof(cNpcName));
	strcpy(cNpcName, token);

	token = pStrTok->pGet();
	
	if (token != NULL) 
		 iNum = atoi(token);
	else iNum = 1;

	if (iNum <= 0)  iNum = 1;
	if (iNum >= 50)  iNum = 50;

	cSA = 0;
	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;

	// ¸Þ½ÃÁö Ãâ·Â 
	wsprintf(G_cTxt, "(!) Admin Order: Summon(%s)-(%d)", cNpcName, iNum);
	PutLogList(G_cTxt);

	iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
	if (iNamingValue != -1) {
		// Master MobÀ» »ý¼ºÇÑ´Ù.
		ZeroMemory(cName_Master, sizeof(cName_Master));
		wsprintf(cName_Master, "XX%d", iNamingValue);
		cName_Master[0] = '_';
		cName_Master[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
		if ((bMaster = bCreateNewNpc(cNpcName, cName_Master, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE, TRUE)) == FALSE) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
		}
	}		

	for (j = 0; j < (iNum - 1); j++) {
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// Slave MobµéÀ» »ý¼ºÇÑ´Ù.
			ZeroMemory(cName_Slave, sizeof(cName_Slave));
			wsprintf(cName_Slave, "XX%d", iNamingValue);
			cName_Slave[0] = '_';
			cName_Slave[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			// v1.411 ¸ó½ºÅÍÀÇ Æ¯¼ö Æ¯¼ºÄ¡¸¦ ÀÔ·ÂÇÑ´Ù. 
				
			if (bCreateNewNpc(cNpcName, cName_Slave, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
			}
			else {
				// Slave¸ðµå·Î ÀüÈ¯.
				bSetNpcFollowMode(cName_Slave, cName_Master, DEF_OWNERTYPE_NPC);
			}
		}
	}

	delete pStrTok;
}
void CGame::AdminOrder_SummonAll(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cLocation[11]; 
	int    pX, pY, i;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cLocation, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cLocation, token) == 0)) {
			RequestTeleportHandler(i, "2   ", cLocation, pX, pY);
		}//m_pClientList[i]->m_cCharName
		delete pStrTok;
}

void CGame::AdminOrder_SummonPlayer(int iClientH, char *pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n";
	char   * token, cBuff[256], cMapName[11]; 
	int    pX, pY, i;
	class  CStrTok * pStrTok;

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	token = pStrTok->pGet();

	if (token == NULL) {
		delete pStrTok;
		return;
	}

	pX = m_pClientList[iClientH]->m_sX;
	pY = m_pClientList[iClientH]->m_sY;
	memcpy(cMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 11);

	for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, token) == 0)) {
			RequestTeleportHandler(i, "2   ", cMapName, pX, pY);
		}//m_pClientList[i]->m_cCharName
		delete pStrTok;
}

void CGame::CheckSpecialEvent(int iClientH)
{
 class CItem * pItem;
 char  cItemName[21];
 int   iEraseReq;

	if (m_pClientList[iClientH] == NULL) return;

	//v1.42 ÀÌº¥Æ® ¾ÆÀÌÅÛÀ» ÁØ´Ù. 2000.8.1ÀÏ 1ÁÖ³â ¹ÝÁö ¼ö¿© 
	if (m_pClientList[iClientH]->m_iSpecialEventID == 200081) {
		
		// Àú·¾Àº ÁÖÁö ¾Ê´Â´Ù.
		if (m_pClientList[iClientH]->m_iLevel < 11) {
			m_pClientList[iClientH]->m_iSpecialEventID = 0;
			return;
		}

		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, "MemorialRing"); 
		
		pItem = new class CItem;
		if (_bInitItemAttr(pItem, cItemName) == FALSE) {
			// ±¸ÀÔÇÏ°íÀÚ ÇÏ´Â ¾ÆÀÌÅÛÀÌ ¾ÆÀÌÅÛ ¸®½ºÆ®»ó¿¡ ¾ø´Ù. ±¸ÀÔÀÌ ºÒ°¡´ÉÇÏ´Ù.
			delete pItem;
		}
		else {
			if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
				// ¿¡·¯ ¹æÁö¿ë ÄÚµå
				if (m_pClientList[iClientH]->m_iCurWeightLoad < 0) m_pClientList[iClientH]->m_iCurWeightLoad = 0;
				
				//testcode ·Î±×ÆÄÀÏ¿¡ ±â·ÏÇÑ´Ù.
				wsprintf(G_cTxt, "(*) Get MemorialRing  : Char(%s)", m_pClientList[iClientH]->m_cCharName);
				PutLogFileList(G_cTxt);

				// ¾ÆÀÌÅÛ¿¡ »ç¿ëÀÚ °íÀ¯ ¹øÈ£¸¦ ÀÔ·ÂÇÑ´Ù. ´Ù¸¥ Ä³¸¯ÅÍ´Â ÀÌ ¾ÆÀÌÅÛÀ» »ç¿ëÇÒ ¼ö°¡ ¾ø´Ù.
				pItem->m_sTouchEffectType = DEF_ITET_UNIQUE_OWNER;
				pItem->m_sTouchEffectValue1 = m_pClientList[iClientH]->m_sCharIDnum1;
				pItem->m_sTouchEffectValue2 = m_pClientList[iClientH]->m_sCharIDnum2;
				pItem->m_sTouchEffectValue3 = m_pClientList[iClientH]->m_sCharIDnum3;
				pItem->m_cItemColor         = 9;

				// ¾ÆÀÌÅÛ ¹Þ¾ÒÀ¸¹Ç·Î Å¬¸®¾î.
				m_pClientList[iClientH]->m_iSpecialEventID = 0;
			}
		}
	}
}



void CGame::AdminOrder_DisconnectAll(int iClientH, char *pData, DWORD dwMsgSize)
{

	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}

	_iForcePlayerDisconect(DEF_MAXCLIENTS);
}

void CGame::NpcDeadItemGenerator(int iNpcH, short sAttackerH, char cAttackerType)
{
	class CItem * pItem;
	char  cColor, cItemName[21];
	BOOL  bIsGold;
	int   iGenLevel, iResult, iDiceResult;
	DWORD dwType, dwValue;
	double dTmp1, dTmp2, dTmp3;

	if (m_pNpcList[iNpcH] == NULL) return;
	if ((cAttackerType != DEF_OWNERTYPE_PLAYER) || (m_pNpcList[iNpcH]->m_bIsSummoned == TRUE)) return;

	ZeroMemory(cItemName, sizeof(cItemName));
	bIsGold = FALSE;

	switch (m_pNpcList[iNpcH]->m_sType) {
	case 21: // Guard
	case 34: // Dummy
		return;
	}

	//6500
	if (iDice(1,10000) >= 1) {
		// 35% È®·ü·Î ¾ÆÀÌÅÛ ³ª¿Â´Ù. (35/100)
		if (iDice(1,10000) <= 6000) {
			// 35% Áß 60%´Â Gold´Ù.
			// Gold: (35/100) * (60/100) = 21%
			strcpy(cItemName, "Gold");
			// ¾ÆÀÌÅÛÀ» ¸¸µé°í 
			pItem = new class CItem;
			if (_bInitItemAttr(pItem, cItemName) == FALSE) {
				delete pItem;
				return;	
			}
			// NPC »ç¸Á½Ã Gold ¹ß»ý·®
			pItem->m_dwCount = (DWORD)(iDice(1, m_pNpcList[iNpcH]->m_iExpDice * 2)); //(iDice(1, m_pNpcList[iNpcH]->m_iExpDice * 3) + m_pNpcList[iNpcH]->m_iExpDice);

			//v1.42 Gold Áõ°¡ 
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH]->m_iAddGold != NULL)) {
				dTmp1 = (double)m_pClientList[sAttackerH]->m_iAddGold;
				dTmp2 = (double)pItem->m_dwCount;
				dTmp3 = (dTmp1/100.0f)*dTmp2;
				pItem->m_dwCount += (int)dTmp3;
			}
		}
		else {
			//9000
			// 35% Áß 40%´Â ¹°¾à È¤Àº Èñ±Í ¾ÆÀÌÅÛÀÌ´Ù. 
			if (iDice(1,10000) <= 1) {
				// 40%Áß 93%´Â ¹°¾àÀÌ´Ù.
				// ¹°¾à·ù: (35/100) * (40/100) * (90/100) = 12.6%
				iResult = iDice(1,10000);
				if ((iResult >= 1) && (iResult <= 4999))          dwValue = 1;
				else if ((iResult >= 5000) && (iResult <= 7499))  dwValue = 2;
				else if ((iResult >= 7500) && (iResult <= 8749))  dwValue = 3;
				else if ((iResult >= 8750) && (iResult <= 9374))  dwValue = 4;
				else if ((iResult >= 9375) && (iResult <= 9687))  dwValue = 5;
				else if ((iResult >= 9688) && (iResult <= 9843))  dwValue = 6;
				else if ((iResult >= 9844) && (iResult <= 9921))  dwValue = 7;
				else if ((iResult >= 9922) && (iResult <= 10000)) dwValue = 8;

				switch (dwValue) { 
			case 1: 
				switch (iDice(1,2)) { 
			case 1: strcpy(cItemName, "GreenPotion");   break; 
			case 2: strcpy(cItemName, "RedPotion"); break; 
				} 
				break; 
			case 2: strcpy(cItemName, "BigRedPotion"); break; 
			case 3: strcpy(cItemName, "BluePotion"); break; 
			case 4: strcpy(cItemName, "BigGreenPotion"); break; 
			case 5: strcpy(cItemName, "BigRedPotion"); break; 
			case 6: strcpy(cItemName, "BigBluePotion"); break; 
			case 7: strcpy(cItemName, "PowerGreenPotion"); break; 
			case 8: 
				switch (iDice(1,9)) { 
			case 1: strcpy(cItemName, "StoneOfMerien"); break; 
			case 2: strcpy(cItemName, "StoneOfXelima"); break; 
			case 3: strcpy(cItemName, "ZemstoneofSacrifice"); break; 
			case 4: strcpy(cItemName, "SuperHPotion"); break;
			case 5: strcpy(cItemName, "SuperMPotion"); break;
			case 6: strcpy(cItemName, "SuperSPotion"); break;
			case 7: 
			case 8: 
			case 9: strcpy(cItemName, "SuperGreenPotion"); break;
				}
				}
				// ¾ÆÀÌÅÛ »ý¼º, ÃÊ±âÈ­
				pItem = new class CItem;
				if (_bInitItemAttr(pItem, cItemName) == FALSE) {
					delete pItem;
					return;	
				}
			}
			else {
				//  Èñ±Í ¾ÆÀÌÅÛÀÌ´Ù. (35/100) * (40/100) * (10/100) = 1.4%
				// Á×Àº ¸ó½ºÅÍ¿¡ µû¸¥ ·¹º§À» °è»ê.
				switch (m_pNpcList[iNpcH]->m_sType) {
				case 10: // Slime
				case 16: // Giant-Ant
				case 22: // Amphis 
					iGenLevel = 1;	
					break;

				case 14: // Orc
				case 18: // Zombie
				case 17: // Scorpion
				case 11: // Skeleton
				case 57: // Giant-Frog
					iGenLevel = 2;	
					break;		

				case 23: // Clay-Golem
				case 12: // Stone-Golem
				case 65: // Ice
					iGenLevel = 3;	
					break;		

				case 27: // Hellhound
				case 61: // Rudolph
					iGenLevel = 4;
					break;		

				case 13: // Cyclops
				case 28: // Troll
				case 60: // Cannibal-Plant	
				case 62: // DireBoar
					iGenLevel = 5;
					break;

				case 29: // Orge
				case 33: // WereWolf
				case 48: // Stalker
				case 53: // Beholder
				case 54: // DarkElf
					iGenLevel = 6;
					break;

				case 30: // Liche
					iGenLevel = 7;
					break;

				case 31: // Demon
				case 32: // Unicorn
				case 49: // Hellclaw
				case 66: // Wyvern
				case 73: // Fire-Wyvern
					iGenLevel = 8;
					break;

				case 55: // Rabbit
				case 56: //	Cat
					iGenLevel = 9;
					break;

				case 58: // MountainGiant
					iGenLevel = 10;
					break;

				case 59: // Ettin
					iGenLevel = 11;
					break;

				case 63: // Frost
				case 71: // Centaurus
					iGenLevel = 12;
					break;

				case 70: // Barlog
					iGenLevel = 13;
					break;

				case 72: // Claw-Turtle
					iGenLevel = 14;
					break;

				case 74: // Giant-Cray-Fish
					iGenLevel = 15;
					break;

				case 75: // Lizard
					iGenLevel = 16;
					break;

				case 76: // Giant-Plant
					iGenLevel = 17;
					break;

				case 77: // Master-Mage-Orc
					iGenLevel = 18;
					break;

				case 78: // Minotaurus
					iGenLevel = 19;
					break;

				case 79: // Nizie
					iGenLevel = 20;
					break;

				case 80: // Tentocle
					iGenLevel = 21;
					break;

				case 52: // Gagoyle
					iGenLevel = 22;
					break;
				}	

				if (iGenLevel == 0) return;

				// ¸ÕÀú ¸¸µé ¾ÆÀÌÅÛÀ» °áÁ¤: 
				// ¹«±â·ù È¤Àº ¹æ¾î±¸
				if (iDice(1,10000) <= 6000) {
					// ¸¸µé¾îÁö´Â ¾ÆÀÌÅÛÀÇ 60%´Â ¹«±â·ù
					// v2.03 ¸¶¹ý»ç¿ë ¹«±â´Â ³ª¿ÀÁö ¾Ê´Â´Ù.
					if (iDice(1,10000) <= 8000) {
						// ¹«±â Áß 70%´Â Àü»ç¿ë ¹«±â.
						switch (iGenLevel) { 
				  case 1: // Slime, Giant-Ant, Amphis
					  switch (iDice(1,3)) { 
				  case 1: strcpy(cItemName, "Dagger"); break; 
				  case 2: strcpy(cItemName, "ShortSword"); break; 
				  case 3: strcpy(cItemName, "LightAxe"); break; 
					  } 
					  break; 

				  case 2: // Orc, Zombie, Scorpion, Giant-Frog, Skeleton
					  switch (iDice(1,6)) { 
				  case 1: strcpy(cItemName, "MainGauche"); break; 
				  case 2: strcpy(cItemName, "Gradius"); break; 
				  case 3: strcpy(cItemName, "SexonAxe"); break; 
				  case 4: strcpy(cItemName, "Tomahoc"); break; 
				  case 5: strcpy(cItemName, "Sabre"); break; 
				  case 6: strcpy(cItemName, "Esterk"); break; 
					  } 
					  break; 

				  case 3: // Clay-Golem and Stone-Golem
					  switch (iDice(1,4)) { 
				  case 1: strcpy(cItemName, "LongSword"); break; 
				  case 2: strcpy(cItemName, "DoubleAxe"); break; 
				  case 3: strcpy(cItemName, "Sabre"); break; 
				  case 4: strcpy(cItemName, "Esterk"); break; 
					  } 
					  break; 

				  case 4: // Helhound, Rudolph
					  switch (iDice(1,6)) { 
				  case 1: strcpy(cItemName, "Sabre"); break; 
				  case 2: strcpy(cItemName, "Scimitar"); break; 
				  case 3: strcpy(cItemName, "Falchion"); break; 
				  case 4: strcpy(cItemName, "Esterk"); break; 
				  case 5: strcpy(cItemName, "Rapier"); break; 
				  case 6: strcpy(cItemName, "WarAxe"); break;
					  } 
					  break; 

				  case 5: // Cyclops, Troll, Cannibal-Plant
					  switch (iDice(1,3)) { 
				  case 1: strcpy(cItemName, "Esterk"); break; 
				  case 2: strcpy(cItemName, "Rapier"); break; 
				  case 3: strcpy(cItemName, "WarAxe"); break; 
					  } 
					  break; 

				  case 6: // Ogre, WereWolf, Beholder, Stalker, DarkElf
					  switch (iDice(1,5)) { 
				  case 1: strcpy(cItemName, "GreatSword"); break; 
				  case 2: strcpy(cItemName, "Flameberge"); break; 
				  case 3: strcpy(cItemName, "Claymore"); break; 
				  case 4: strcpy(cItemName, "Esterk"); break; 
				  case 5: strcpy(cItemName, "Rapier"); break; 
					  } 
					  break; 

				  case 7: // Liche
					  switch (iDice(1,4)) { 
				  case 1: strcpy(cItemName, "GreatSword"); break; 
				  case 2: strcpy(cItemName, "Flameberge"); break; 
				  case 3: strcpy(cItemName, "Esterk"); break; 
				  case 4: strcpy(cItemName, "Rapier"); break; 
					  } 
					  break; 

				  case 8: // Demon, Unicorn, Hellclaw
					  switch (iDice(1,7)) { 
				  case 1: strcpy(cItemName, "GreatSword"); break; 
				  case 2: strcpy(cItemName, "Flameberge"); break; 
				  case 3: strcpy(cItemName, "BattleAxe"); break; 
				  case 4: strcpy(cItemName, "Esterk"); break; 
				  case 5: strcpy(cItemName, "Rapier"); break; 
				  case 7: strcpy(cItemName, "GiantSword"); break;
					  } 
					  break; 

				  case 9: //Rabbits and Cats
					  switch (iDice(1,1)) {
				  case 1: strcpy(cItemName, "Dagger"); break;
					  }
					  break;

				  case 10: // Mountain-Giant
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "Esterk"); break;
				  case 2: strcpy(cItemName, "Rapier"); break;
				  case 3: strcpy(cItemName, "Hammer"); break; 
				  case 4: strcpy(cItemName, "GreatSword"); break;
				  case 5: strcpy(cItemName, "LongSword"); break;
					  }
					  break;

				  case 11: // Ettin
					  switch (iDice(1,6)) {
				  case 1: strcpy(cItemName, "GreatSword"); break;
				  case 2: strcpy(cItemName, "Flameberge"); break;
				  case 3: strcpy(cItemName, "Hammer"); break;
				  case 4: strcpy(cItemName, "BattleHammer"); break;
				  case 5: strcpy(cItemName, "Esterk"); break;
				  case 6: strcpy(cItemName, "Rapier"); break;
					  } 
					  break;

				  case 12: // Centaurus, Frost
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 13: // Barlog
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "Falchion"); break;
				  case 2: strcpy(cItemName, "DoubleAxe"); break;
				  case 3: strcpy(cItemName, "GreatSword"); break;
				  case 4: strcpy(cItemName, "Claymore"); break;
				  case 5: strcpy(cItemName, "WarAxe"); break;
					  }
					  break;

				  case 14: // Claw-Turtle
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 15: // Giant-Cray-Fish
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 16: // Lizard
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 17: // Giant-Plant
					  switch (iDice(1,4)) {
				  case 1: strcpy(cItemName, "GreatSword"); break;
				  case 2: strcpy(cItemName, "Estrek"); break;
				  case 3: strcpy(cItemName, "Rapier"); break;
				  case 4: strcpy(cItemName, "WarAxe"); break;
					  }
					  break;

				  case 18: // Master-Mage-Orc
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 19: // Minotaurus
					  switch (iDice(1,5)) {
				  case 1: strcpy(cItemName, "GreatSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Estrek+1"); break;
				  case 4: strcpy(cItemName, "Rapier+1"); break;
				  case 5: strcpy(cItemName, "WarAxe+1"); break;
					  }
					  break;

				  case 20: // Nizie
					  switch (iDice(1,4)) {
				  case 1: strcpy(cItemName, "GiantSword+1"); break;
				  case 2: strcpy(cItemName, "Flameberge+1"); break;
				  case 3: strcpy(cItemName, "Hammer+1"); break;
				  case 4: strcpy(cItemName, "BattleAxe+1"); break;
					  }
					  break;

				  case 21: // Tentocle
					  switch (iDice(1,6)) {
				  case 1: strcpy(cItemName, "Flameberge"); break;
				  case 2: strcpy(cItemName, "Hammer"); break;
				  case 3: strcpy(cItemName, "BattleAxe"); break;
				  case 4: strcpy(cItemName, "Esterk"); break;
				  case 5: strcpy(cItemName, "Rapier"); break;
				  case 6: strcpy(cItemName, "WarAxe"); break;
					  }
					  break;

				  case 22: // Gagoyle
					  switch (iDice(1,6)) {
				  case 1: strcpy(cItemName, "Flameberge"); break;
				  case 2: strcpy(cItemName, "GiantSword"); break;
				  case 3: strcpy(cItemName, "BattleAxe"); break;
					  }
					  break;
						}
					}
					else {
						// ¹«±âÁß 30%´Â ¸¶¹ý °ø°Ý ¹«±â 
						switch (iGenLevel) {
							iGenLevel = 15;
							break;
						case 1:
						case 9:	break; // NPC not dropping wands
						case 2: // Orc, Zombie, Scorpion, Giant-Frog, Skeleton
						case 3:	// Clay-Golem and Stone-Golem
							strcpy(cItemName, "MagicWand(MS0)"); break;
						case 4: // Helhound, Rudolph
						case 5:	// Cyclops, Troll, Cannibal-Plant
						case 6: // Ogre, Werewolf, Beholder, Stalker, DarkElf
						case 10: // Mountain-Giant
						case 11: // Ettin
						case 13: // Barlog
						case 14: // Claw-Turtle
						case 15: // Giant-Cray-Fish
						case 16: // Lizard
						case 17: // Giant-Plant
						case 18: // Master-Mage-Orc
						case 19: // Minotaurus
						case 20: // Nizie
						case 21: // Tentocle
							strcpy(cItemName, "MagicWand(MS10)"); break;
						case 7:  // Liche
						case 8:  // Demon, Unicorn, Hellclaw
						case 12: // Centaurus, Frost
						case 22: // Gagoyle
							strcpy(cItemName, "MagicWand(MS20)"); break;
						}	
					}

				}
				else {
					// 12.6% chance of a special drop 40% that drop is an Armor/Shield
					switch (iGenLevel) { 
			   case 1: // Slime, Giant-Ant, Amphis
			   case 2: // Orc, Zombie, Scorpion, Giant-Frog, Skeleton
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "WoodShield"); break; 
			   case 2: strcpy(cItemName, "TargeShield"); break; 
				   } 
				   break; 

			   case 3: // Clay-Golem, Stone Golem
				   switch (iDice(1,3)) { 
			   case 1: strcpy(cItemName, "ChainHose(M)"); break; 
			   case 2: strcpy(cItemName, "ChainHose(W)"); break; 
			   case 3: strcpy(cItemName, "TargeShield"); break; 
				   } 
				   break; 

			   case 4: 
				   switch (iDice(1,3)) { 
			   case 1: strcpy(cItemName, "Hauberk(M)"); break; 
			   case 2: strcpy(cItemName, "Hauberk(W)"); break; 
			   case 3: strcpy(cItemName, "BlondeShield"); break; 
				   } 
				   break; 

			   case 5: // Cyclops, Troll, Cannibal-Plant               
				   switch (iDice(1,3)) { 
			   case 1: strcpy(cItemName, "LeatherArmor(M)"); break; 
			   case 2: strcpy(cItemName, "LeatherArmor(W)"); break; 
			   case 3: strcpy(cItemName, "IronShield"); break; 
				   } 
				   break; 

			   case 6: // Ogre, Werewolf, Beholder, and Stalker
				   switch (iDice(1,3)) { 
			   case 1: 
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "ChainMail(M)"); break; 
			   case 2: strcpy(cItemName, "ChainMail(W)"); break; 
				   } 
				   break; 
			   case 2: 
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "PlateLeggings(M)"); break; 
			   case 2: strcpy(cItemName, "PlateLeggings(W)"); break; 
				   } 
				   break; 
			   case 3: strcpy(cItemName, "LagiShield"); break; 
				   } 
				   break; 

			   case 7: 
				   switch (iDice(1,6)) { 
			   case 1: 
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "ScaleMail(M)"); break; 
			   case 2: strcpy(cItemName, "ScaleMail(W)"); break; 
				   } 
				   break; 
			   case 2: 
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "PlateMail(M)"); break; 
			   case 2: strcpy(cItemName, "PlateMail(W)"); break; 
				   } 
				   break; 
			   case 3: strcpy(cItemName, "KiteShield"); break; 
			   case 4: strcpy(cItemName, "TowerShield"); break; 
			   case 5: 
				   switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "Helm(M)"); break; 
			   case 2: strcpy(cItemName, "Helm(W)"); break; 
				   } 
				   break; 
			   case 6: switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "FullHelm(M)"); break; 
			   case 2: strcpy(cItemName, "FullHelm(W)"); break; 
					   } 
					   break; 
				   } 
				   break; 
			   case 8:  // Demon, Hellclaw, Unicorn
				   strcpy(cItemName, "Cape"); break;

			   case 9:  // Cats and Rabbits
				   strcpy(cItemName, "WoodShield"); break;

			   case 10: // Mountain-Giant
				   switch (iDice(1,3)) {
			   case 1: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "ChainHose(M)"); break;
			   case 2: strcpy(cItemName, "ChainHose(W)"); break;
					   }
					   break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "ScaleMail(M)"); break;
			   case 2: strcpy(cItemName, "ScaleMail(W)"); break;
					   }
					   break;
			   case 3: strcpy(cItemName, "LagiShield"); break; 
				   }
				   break;

			   case 11: // Ettin
				   switch (iDice(1,3)) {
			   case 1: strcpy(cItemName, "Cape"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "PlateMail(M)"); break;
			   case 2: strcpy(cItemName, "PlateMail(W)"); break;
					   }
					   break;
			   case 3: strcpy (cItemName, "TowerShield"); break;
				   }
				   break;

			   case 12: // Frost
				   switch (iDice(1,2)) {
			   case 1: switch (iDice(1,2)) { 
			   case 1: strcpy(cItemName, "FullHelm(M)"); break; 
			   case 2: strcpy(cItemName, "FullHelm(W)"); break; 
					   } 
					   break;
			   case 2: switch(iDice(1,2)) {                  
			   case 1: strcpy(cItemName, "LeatherArmor(M)"); break; 
			   case 2: strcpy(cItemName, "LeatherArmor(W)"); break; 
					   }
					   break;
				   }
				   break;

			   case 13: // Barlog
				   switch (iDice(1,2)) {
			   case 1: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "Hauberk(M)"); break;
			   case 2: strcpy(cItemName, "Hauberk(W)"); break;
					   }
					   break;
			   case 2: strcpy(cItemName, "KiteShield"); break;
				   }
				   break;

			   case 14: // Claw-Turtle
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "BlondeShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "Hauberk(M)"); break;
			   case 2: strcpy(cItemName, "Hauberk(W)"); break;
					   }
					   break;
				   }

			   case 15: // Giant-Cray-Fish
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "BlondeShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "ChainHose(M)"); break;
			   case 2: strcpy(cItemName, "ChainHose(W)"); break;
					   }
					   break;
				   }

			   case 16: // Lizard
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "BlondeShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "LeatherArmor(M)"); break;
			   case 2: strcpy(cItemName, "LeatherArmor(W)"); break;
					   }
					   break;
				   }

			   case 17: // Giant-Plant
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "IronShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "Hauberk(M)"); break;
			   case 2: strcpy(cItemName, "Hauberk(W)"); break;
					   }
					   break;
				   }

			   case 18: // Master-Mage-Orc
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "LagiShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "ScaleMail(M)"); break;
			   case 2: strcpy(cItemName, "ScaleMail(W)"); break;
					   }
					   break;
				   }

			   case 19: // Minotaurus
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "KiteShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "Winged-Helm(M)"); break;
			   case 2: strcpy(cItemName, "Winged-Helm(W)"); break;
					   }
					   break;
				   }

			   case 20: // Nizie
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "TowerShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "PlateLeggings(M)"); break;
			   case 2: strcpy(cItemName, "PlateLeggings(W)"); break;
					   }
					   break;
				   }

			   case 21: // Tentocle
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "LagiShield"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "ScaleMail(M)"); break;
			   case 2: strcpy(cItemName, "ScaleMail(W)"); break;
					   }
					   break;
				   }

			   case 22: // Gagoyle
				   switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "Cape"); break;
			   case 2: switch (iDice(1,2)) {
			   case 1: strcpy(cItemName, "PlateMail(M)"); break;
			   case 2: strcpy(cItemName, "PlateMail(W)"); break;
					   }
					   break;
				   }
					}
				}

				// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ  
				// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ 10-¸¶¹ý ¼º°øÀÇ

				// ¾ÆÀÌÅÛÀ» ¸¸µé°í 
				pItem = new class CItem;
				// ±âº» Æ¯¼ºÀ¸·Î ¾ÆÀÌÅÛ »ý¼º 
				if (_bInitItemAttr(pItem, cItemName) == FALSE) {
					delete pItem;
					return;	
				}

				if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK) {
					// °ø°Ý ¹«±â·ù¿¡ ºÙÀ» ¼ö ÀÖ´Â Á¢µÎ»ç¸¦ ¼±ÅÃ 
					// °¡º­¿î(3%) °­È­µÈ(7%) ÇÊ»ìÀÇ(15%) ¹ÎÃ¸ÀÇ(20%) Á¤ÀÇÀÇ(20%) Áßµ¶ÀÇ(16%) ¿¹¸®ÇÑ(16%) °í´ë¹®¸íÀÇ(3%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 299)) {
						dwType = 6; 
						cColor = 2; 
					}
					else if ((iResult >= 300) && (iResult <= 999)) {
						dwType = 8; 
						cColor = 3;
					}
					else if ((iResult >= 1000) && (iResult <= 2499)) {
						dwType = 1;
						cColor = 5;
					}
					else if ((iResult >= 2500) && (iResult <= 4499)) {
						dwType = 5;
						cColor = 1;
					}
					else if ((iResult >= 4500) && (iResult <= 6499)) {
						dwType = 3;
						cColor = 7;
					}
					else if ((iResult >= 6500) && (iResult <= 8099)) {
						dwType = 2;
						cColor = 4;
					}
					else if ((iResult >= 8100) && (iResult <= 9699)) {
						dwType = 7;
						cColor = 6;
					}
					else if ((iResult >= 9700) && (iResult <= 10000)) {
						dwType = 9;
						cColor = 8;
					}

					// ¾ÆÀÌÅÛ »ö»ó ÀÔ·Â 
					pItem->m_cItemColor = cColor;

					// °¡º­¿î, °­È­µÈ, ÇÊ»ìÀÇ, ¹ÎÃ¸ÀÇ, Á¤ÀÇÀÇ, Áßµ¶ÀÇ, ¿¹¸®ÇÑ, °í´ë¹®¸íÀÇ
					// ¾ÆÀÌÅÛ Main Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 

					iResult = iDice(1, 29348);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 16600))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 16600) && (iResult < 20956))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 20956) && (iResult < 23830))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 23830) && (iResult < 25727))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 25727) && (iResult < 26979))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 26979) && (iResult < 27805))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 27805) && (iResult < 28350))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 28350) && (iResult < 28710))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 28710) && (iResult < 28947))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 28947) && (iResult < 29103))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29103) && (iResult < 29206))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29206) && (iResult < 29274))  dwValue = 13; // 68/29348 = 0.2%

					// ¹«±âÀÇ Main Æ¯¼ºÄ¡¿¡ µû¶ó ¼öÄ¡ º¸Á¤ 
					switch (dwType) {
					case 1: // ÇÊ»ì Å¸°Ý ÃÖÀú +5
						if (dwValue <= 5) dwValue = 5;
						break; 
					case 2: // Áßµ¶ Å¸°Ý ÃÖÀú +20
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 6: // °æ·®È­ ÃÖÀú  +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // ¼ö¸í ÃÖÀú +14%					
						if (dwValue <= 2) dwValue = 2;
						break; 
					}

					// ¾ÆÀÌÅÛ Main Æ¯¼ºÄ¡, °ª ÀÔ·Â
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡°¡ ÀÔ·ÂµÉ È®·üÀº 40%
					if (iDice(1,10000) >= 6000) {

						// Èñ±Í ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ È¿°ú Á¾·ù: 
						//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
						//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
						//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)

						// ¹«±â·ùÀÌ±â ¶§¹®¿¡ °ø°Ý ¸íÁß Ãß°¡(50%), ¿¬Å¸ Å¸°ÝÄ¡ Áõ°¡(35%), ´õ ¸¹Àº Gold(10%), ´õ ¸¹Àº °æÇèÄ¡(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 4999))          dwType = 2;
						else if ((iResult >= 5000) && (iResult <= 8499))  dwType = 10;
						else if ((iResult >= 8500) && (iResult <= 9499))  dwType = 12;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 11;

						// ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 
						iResult = iDice(1, 29348);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 16600))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 16600) && (iResult < 20956))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 20956) && (iResult < 23830))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 23830) && (iResult < 25727))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 25727) && (iResult < 26979))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 26979) && (iResult < 27805))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 27805) && (iResult < 28350))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 28350) && (iResult < 28710))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 28710) && (iResult < 28947))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 28947) && (iResult < 29103))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29103) && (iResult < 29206))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29206) && (iResult < 29274))  dwValue = 13; // 68/29348 = 0.2%

						// ¹«±âÀÇ Sub Æ¯¼ºÄ¡¿¡ µû¶ó ¼öÄ¡ º¸Á¤ 
						switch (dwType) {
						case 2: // °ø°Ý¸íÁß ÃÖÀú +21%
							if (dwValue <= 3) dwValue = 3;
							break; 
						case 10: // ¿¬¼Ó Å¸°Ý ÃÖÀú +1 ÃÖ´ë 7
							if (dwValue > 7) dwValue = 7; 
							break; 
						case 11: // Exp´Â ¹«Á¶°Ç +20%
							dwValue = 2;
							break; 
						case 12: // Gold´Â ¹«Á¶°Ç +50%
							dwValue = 5;
							break; 
						}

						// ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ ÀÔ·Â
						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_ATTACK_MANASAVE) 
				{ 
					// ¾ÆÀÌÅÛ Main Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 
					pItem->m_cItemColor = 0; 
					iResult = iDice(1, 10000); 
					if ((iResult >= 1) && (iResult < 6500))               dwValue = 3;  // = 35% 
					else if ((iResult >= 6500) && (iResult < 9300))         dwValue = 4;  // = 25% 
					else if ((iResult >= 9300) && (iResult < 9900))         dwValue = 5; // = 0.01% 
					else if ((iResult >= 9900) && (iResult < 9990))         dwValue = 6; // = 0.004% 
					else if ((iResult >= 9990) && (iResult <= 10000 ))      dwValue = 7; // = 0.002% 
					pItem->m_dwAttribute = NULL; 
					dwType = 10; //CAST PROBABILITY 
					dwType  = dwType << 20; 
					dwValue = dwValue << 16; 
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue; 

					// ¹æ¾î±¸ Sub Æ¯¼ºÄ¡°¡ ÀÔ·ÂµÉ È®·üÀº 40% 

					if (iDice(1,10000) >= 6000) 
					{ 

						// Èñ±Í ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ È¿°ú Á¾·ù: 
						//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5) 
						//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9) 
						//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12) 

						// ¹æ¾î±¸ ÀÌ±â ¶§¹®¿¡ 
						// Ãß°¡µ¶¼ºÀúÇ×(10%)  Ãß°¡¹æ¾î°ª(30%)  SPÈ¸º¹Ãß°¡(15%)  HPÈ¸º¹Ãß°¡(10%) 
						// MPÈ¸º¹ Ãß°¡(10%) Ãß°¡¸¶¹ýÀúÇ×(15%) ¹°¸®´ë¹ÌÁöÈí¼ö(5%) ¸¶¹ý´ë¹ÌÁöÈí¼ö(5%) 

						iResult = iDice(1,10000); 
						if      ((iResult >= 1) && (iResult <= 6000))            dwType = 2; //hp 
						else if ((iResult >= 6001) && (iResult <= 9499))         dwType=10; //consecutive Attack Damage 
						else if ((iResult >= 9500) && (iResult <= 9899))         dwType=11; //gold 
						else if ((iResult >= 9900) && (iResult <= 10000))         dwType=12; //exp 

						// ¹æ¾î±¸ Sub Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 
						// ¹æ¾î±¸ÀÇ Sub Æ¯¼ºÄ¡¿¡ µû¶ó ¼öÄ¡ º¸Á¤ 
						switch (dwType) { 
				case 2: // °ø°Ý¸íÁß ÃÖÀú +21% //HITTING PROABILITY 
					iResult = iDice(1, 10000); 
					if ((iResult >= 1) &&(iResult < 8000))               dwValue = 3;  // = 25% 
					else if ((iResult >= 8000) && (iResult < 9000))         dwValue = 4;  // = 10% 
					else if ((iResult >= 9000) && (iResult < 9500))         dwValue = 5;  // = 10% 
					else if ((iResult >= 9500) && (iResult < 9800))         dwValue = 6;  // = 5% 
					else if ((iResult >= 9800) && (iResult < 9900))         dwValue = 7;  // = 1% 
					else if ((iResult >= 9900) && (iResult < 9970))         dwValue = 8;  // = 0.25% 
					else if ((iResult >= 9970) && (iResult < 9986))         dwValue = 9; // = 0.015% 
					else if ((iResult >= 9986) && (iResult < 9994))         dwValue = 10; // = 0.01% 
					else if ((iResult >= 9994) && (iResult < 9998))         dwValue = 11; // = 0.004% 
					else if ((iResult >= 9998) && (iResult < 10000))         dwValue = 12; // = 0.002% 
					else if (iResult == 10000)      dwValue = 13; // = 0.002% 
					break; 
				case 10: // ¿¬¼Ó Å¸°Ý ÃÖÀú +1 ÃÖ´ë 7 //CONSECUTIVE DAMAGE 
					if (dwValue > 7) dwValue = 7; 
					iResult = iDice(1, 10000); 
					if ((iResult >= 1) &&(iResult < 9500))               dwValue = 1;  // = 1% 
					else if ((iResult >= 9500) && (iResult < 9970))         dwValue = 2;  // = 0.25% 
					else if ((iResult >= 9970) && (iResult < 9986))         dwValue = 3; // = 0.015% 
					else if ((iResult >= 9986) && (iResult < 9994))         dwValue = 4; // = 0.01% 
					else if ((iResult >= 9994) && (iResult < 9998))         dwValue = 5; // = 0.004% 
					else if ((iResult >= 9998) && (iResult < 10000))         dwValue = 6; // = 0.002% 
					else if (iResult == 10000)      dwValue = 7; // = 0.002% 
					break; 
				case 11: // Exp´Â ¹«Á¶°Ç +20% //EXPERIENCE 
					dwValue = 2; 
					break; 
				case 12: // Gold´Â ¹«Á¶°Ç +50% //GOLD 
					dwValue = 5; 
					break; 
						} 
					} 
					dwType  = dwType << 12; 
					dwValue = dwValue << 8; 
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue; 
				}
				else if (pItem->m_sItemEffectType == DEF_ITEMEFFECTTYPE_DEFENSE) {
					// ¹æ¾î±¸¿¡ ¸Â´Â Á¢µÎ»ç¿Í Æ¯¼ºÄ¡¸¦ ¼±ÅÃ, ÇÒ´çÇÑ´Ù.

					// °­È­µÈ(60%) °¡º­¿î (40%)
					iResult = iDice(1,10000);
					if ((iResult >= 1) && (iResult <= 5999))          dwType = 8;
					else if ((iResult >= 6000) && (iResult <= 10000)) dwType = 6;

					// ¾ÆÀÌÅÛ Main Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 
					iResult = iDice(1, 29348);
					if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
					else if ((iResult >= 10000) && (iResult < 16600))  dwValue = 2;  // 6600/29348 = 22.4%
					else if ((iResult >= 16600) && (iResult < 20956))  dwValue = 3;  // 4356/29348 = 14.8%
					else if ((iResult >= 20956) && (iResult < 23830))  dwValue = 4;  // 2874/29348 = 9.7%
					else if ((iResult >= 23830) && (iResult < 25727))  dwValue = 5;  // 1897/29348 = 6.4%
					else if ((iResult >= 25727) && (iResult < 26979))  dwValue = 6;  // 1252/29348 = 4.2%
					else if ((iResult >= 26979) && (iResult < 27805))  dwValue = 7;  // 826/29348 = 2.8%
					else if ((iResult >= 27805) && (iResult < 28350))  dwValue = 8;  // 545/29348 = 1.85%
					else if ((iResult >= 28350) && (iResult < 28710))  dwValue = 9;  // 360/29348 = 1.2%
					else if ((iResult >= 28710) && (iResult < 28947))  dwValue = 10; // 237/29348 = 0.8%
					else if ((iResult >= 28947) && (iResult < 29103))  dwValue = 11; // 156/29348 = 0.5%
					else if ((iResult >= 29103) && (iResult < 29206))  dwValue = 12; // 103/29348 = 0.3%
					else if ((iResult >= 29206) && (iResult < 29274))  dwValue = 13; // 68/29348 = 0.2%

					// ¹æ¾î±¸ÀÇ Main Æ¯¼ºÄ¡¿¡ µû¶ó ¼öÄ¡ º¸Á¤ 
					switch (dwType) {
					case 6: // °æ·®È­ ÃÖÀú +16%
						if (dwValue <= 4) dwValue = 4;
						break; 
					case 8: // ¼ö¸í ÃÖÀú +14%
						if (dwValue <= 2) dwValue = 2;
						break; 
					}

					// ¹æ¾î±¸ Main Æ¯¼ºÄ¡, °ª ÀÔ·Â
					pItem->m_dwAttribute = NULL;
					dwType  = dwType << 20;
					dwValue = dwValue << 16;
					pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;

					// ¹æ¾î±¸ Sub Æ¯¼ºÄ¡°¡ ÀÔ·ÂµÉ È®·üÀº 40%
					if (iDice(1,10000) >= 6000) {

						// Èñ±Í ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ È¿°ú Á¾·ù: 
						//Ãß°¡ µ¶¼ºÀúÇ×(1), Ãß°¡ ¸íÁß°ª(2), Ãß°¡ ¹æ¾î°ª(3), HP È¸º¹·® Ãß°¡(4), SP È¸º¹·® Ãß°¡(5)
						//MP È¸º¹·® Ãß°¡(6), Ãß°¡ ¸¶¹ýÀúÇ×(7), ¹°¸® ´ë¹ÌÁö Èí¼ö(8), ¸¶¹ý ´ë¹ÌÁö Èí¼ö(9)
						//¿¬Å¸ ´ë¹ÌÁö Ãß°¡(10), ´õ ¸¹Àº °æÇèÄ¡(11), ´õ¸¹Àº Gold(12)

						// ¹æ¾î±¸ ÀÌ±â ¶§¹®¿¡ 
						// Ãß°¡µ¶¼ºÀúÇ×(10%)  Ãß°¡¹æ¾î°ª(30%)  SPÈ¸º¹Ãß°¡(15%)  HPÈ¸º¹Ãß°¡(10%) 
						// MPÈ¸º¹ Ãß°¡(10%) Ãß°¡¸¶¹ýÀúÇ×(15%) ¹°¸®´ë¹ÌÁöÈí¼ö(5%) ¸¶¹ý´ë¹ÌÁöÈí¼ö(5%)
						iResult = iDice(1,10000);
						if ((iResult >= 1) && (iResult <= 999))           dwType = 1;
						else if ((iResult >= 1000) && (iResult <= 3999))  dwType = 3;
						else if ((iResult >= 4000) && (iResult <= 5499))  dwType = 5;
						else if ((iResult >= 5500) && (iResult <= 6499))  dwType = 4;
						else if ((iResult >= 6500) && (iResult <= 7499))  dwType = 6;
						else if ((iResult >= 7500) && (iResult <= 8999))  dwType = 7;
						else if ((iResult >= 9000) && (iResult <= 9499))  dwType = 8;
						else if ((iResult >= 9500) && (iResult <= 10000)) dwType = 9;

						// ¹æ¾î±¸ Sub Æ¯¼ºÄ¡ Á¤µµ°ª ÀÔ·Â 

						iResult = iDice(1, 29348);
						if ((iResult >= 1) && (iResult < 10000))           dwValue = 1;  // 10000/29348 = 34%
						else if ((iResult >= 10000) && (iResult < 16600))  dwValue = 2;  // 6600/29348 = 22.4%
						else if ((iResult >= 16600) && (iResult < 20956))  dwValue = 3;  // 4356/29348 = 14.8%
						else if ((iResult >= 20956) && (iResult < 23830))  dwValue = 4;  // 2874/29348 = 9.7%
						else if ((iResult >= 23830) && (iResult < 25727))  dwValue = 5;  // 1897/29348 = 6.4%
						else if ((iResult >= 25727) && (iResult < 26979))  dwValue = 6;  // 1252/29348 = 4.2%
						else if ((iResult >= 26979) && (iResult < 27805))  dwValue = 7;  // 826/29348 = 2.8%
						else if ((iResult >= 27805) && (iResult < 28350))  dwValue = 8;  // 545/29348 = 1.85%
						else if ((iResult >= 28350) && (iResult < 28710))  dwValue = 9;  // 360/29348 = 1.2%
						else if ((iResult >= 28710) && (iResult < 28947))  dwValue = 10; // 237/29348 = 0.8%
						else if ((iResult >= 28947) && (iResult < 29103))  dwValue = 11; // 156/29348 = 0.5%
						else if ((iResult >= 29103) && (iResult < 29206))  dwValue = 12; // 103/29348 = 0.3%
						else if ((iResult >= 29206) && (iResult < 29274))  dwValue = 13; // 68/29348 = 0.2%

						// ¹æ¾î±¸ÀÇ Sub Æ¯¼ºÄ¡¿¡ µû¶ó ¼öÄ¡ º¸Á¤ 
						switch (dwType) {
						case 1: // µ¶¼ºÀúÇ× ÃÖÀú +21%
						case 3: // ¹°¸®¹æ¾î ÃÖÀú +21%
						case 7: // ¸¶¹ý ÀúÇ× ÃÖÀú +21%
						case 8: // ¹°¸®Èí¼ö ÃÖÀú +9%
						case 9: // ¸¶¹ýÈí¼ö ÃÖÀú +9%
							if (dwValue <= 3) dwValue = 3;
							break; 
						}

						// ¾ÆÀÌÅÛ Sub Æ¯¼ºÄ¡ ÀÔ·Â
						dwType  = dwType << 12;
						dwValue = dwValue << 8;

						pItem->m_dwAttribute = pItem->m_dwAttribute | dwType | dwValue;
					}
				}

				// ¸¶Áö¸·À¸·Î Æ¯¼ºÄ¡¸¦ Æ¯¼ö ¾ÆÀÌÅÛ¿¡ ¸Â°Ô²û º¯°æ 
				_AdjustRareItemValue(pItem);
			}
		}

		// ¾ÆÀÌÅÛ¿¡ °íÀ¯ ÄÚµå ÀÔ·Â 
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		//pItem->m_sTouchEffectValue3 = timeGetTime();
		// ¸¶Áö¸· ¼ýÀÚ´Â ¾ÆÀÌÅÛ »ý¼º ¿ù, ÀÏ	
		SYSTEMTIME SysTime;
		char cTemp[256];
		GetLocalTime(&SysTime);
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);

		// ¾ÆÀÌÅÛÀ» ¼­ÀÖ´Â À§Ä¡¿¡ ¶³¾î¶ß¸°´Ù. 
		m_pMapList[ m_pNpcList[iNpcH]->m_cMapIndex ]->bSetItem(m_pNpcList[iNpcH]->m_sX, 
			m_pNpcList[iNpcH]->m_sY, 
			pItem);

		// ´Ù¸¥ Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾ÆÀÌÅÛÀÌ ¶³¾îÁø °ÍÀ» ¾Ë¸°´Ù. 
		SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_ITEMDROP, m_pNpcList[iNpcH]->m_cMapIndex,
			m_pNpcList[iNpcH]->m_sX, m_pNpcList[iNpcH]->m_sY,
			pItem->m_sSprite, pItem->m_sSpriteFrame, pItem->m_cItemColor); //v1.4 color

		// ·Î±× ³²±ä´Ù.
		_bItemLog(DEF_ITEMLOG_NEWGENDROP, NULL, NULL, pItem);
	}
}





BOOL CGame::_bDecodeDupItemIDFileContents(char *pData, DWORD dwMsgSize)
{
 char * pContents, * token, cTxt[120];
 char seps[] = "= \t\n";
 char cReadModeA = 0;
 char cReadModeB = 0;
 int  iIndex = 0;
 class CStrTok * pStrTok;

	pContents = new char[dwMsgSize+1];
	ZeroMemory(pContents, dwMsgSize+1);
	memcpy(pContents, pData, dwMsgSize);

	pStrTok = new class CStrTok(pContents, seps);
	token = pStrTok->pGet();
	
	while( token != NULL ) {
		if (cReadModeA != 0) {
			switch (cReadModeA) {
			case 1:
				switch (cReadModeB) {
				case 1:
					// ½ºÅ³ ¹øÈ£ 
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					
					if (m_pDupItemIDList[atoi(token)] != NULL) {
						// ÀÌ¹Ì ÇÒ´çµÈ ¹øÈ£°¡ ÀÖ´Ù. ¿¡·¯ÀÌ´Ù.
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Duplicate magic number.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[atoi(token)] = new class CItem;
					iIndex = atoi(token);

					cReadModeB = 2;
					break;

				case 2:
					// m_sTouchEffectType
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectType = atoi(token);
					cReadModeB = 3;
					break;

				case 3:
					// m_sTouchEffectValue1
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue1 = atoi(token);
					cReadModeB = 4;
					break;
				
				case 4:
					// m_sTouchEffectValue2
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue2 = atoi(token);
					cReadModeB = 5;
					break;

				case 5:
					// m_sTouchEffectValue3
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_sTouchEffectValue3 = atoi(token);
					cReadModeB = 6;
					break;

				case 6:
					// m_wPrice
					if (_bGetIsStringIsNumber(token) == FALSE) {
						PutLogList("(!!!) ERROR! DupItemID configuration file error - Wrong Data format.");
						delete pContents;
						delete pStrTok;
						return FALSE;
					}
					m_pDupItemIDList[iIndex]->m_wPrice = (WORD)atoi(token);
					cReadModeA = 0;
					cReadModeB = 0;

					//testcode
					//wsprintf(G_cTxt, "(%d) %d %d %d %d", iIndex, m_pDupItemIDList[iIndex]->m_sTouchEffectType, m_pDupItemIDList[iIndex]->m_sTouchEffectValue1, m_pDupItemIDList[iIndex]->m_sTouchEffectValue2, m_pDupItemIDList[iIndex]->m_sTouchEffectValue3); 
					//PutLogList(G_cTxt);
					break;
				}
				break;

			default: 
				break;
			}
		}
		else {
			if (memcmp(token, "DupItemID", 9) == 0) {
				cReadModeA = 1;
				cReadModeB = 1;
			}
			
		}
		token = pStrTok->pGet();
	}	

	delete pStrTok;
	delete pContents;

	if ((cReadModeA != 0) || (cReadModeB != 0)) {
		PutLogList("(!!!) ERROR! DupItemID configuration file contents error!");
		return FALSE;
	}

	wsprintf(cTxt, "(!) DupItemID(Total:%d) configuration - success!", iIndex);
	PutLogList(cTxt);
	
	return TRUE;
}

BOOL CGame::_bCheckDupItemID(CItem *pItem)
{
 int i;

	for (i = 0; i < DEF_MAXDUPITEMID; i++)
	if (m_pDupItemIDList[i] != NULL) {
		if ((pItem->m_sTouchEffectType   == m_pDupItemIDList[i]->m_sTouchEffectType) &&
			(pItem->m_sTouchEffectValue1 == m_pDupItemIDList[i]->m_sTouchEffectValue1) &&
			(pItem->m_sTouchEffectValue2 == m_pDupItemIDList[i]->m_sTouchEffectValue2) &&
			(pItem->m_sTouchEffectValue3 == m_pDupItemIDList[i]->m_sTouchEffectValue3) ) {
			// °¡°Ý Á¤º¸¸¦ °»½ÅÇÏ°í ¸®ÅÏ.
			pItem->m_wPrice = m_pDupItemIDList[i]->m_wPrice;
			return TRUE;
		}
	}
	
	return FALSE;
}

void CGame::_AdjustRareItemValue(CItem *pItem)
{
 DWORD dwSWEType, dwSWEValue;
 double dV1, dV2, dV3;

	if ((pItem->m_dwAttribute & 0x00F00000) != NULL) {
		dwSWEType  = (pItem->m_dwAttribute & 0x00F00000) >> 20;  
		dwSWEValue = (pItem->m_dwAttribute & 0x000F0000) >> 16;
		// Èñ±Í ¾ÆÀÌÅÛ È¿°ú Á¾·ù: 
		// 0-None 1-ÇÊ»ì±â´ë¹ÌÁöÃß°¡ 2-Áßµ¶È¿°ú 3-Á¤ÀÇÀÇ 
		// 5-¹ÎÃ¸ÀÇ 6-°¡º­¿î 7-¿¹¸®ÇÑ 8-°­È­µÈ 9-°í´ë¹®¸íÀÇ
		switch (dwSWEType) {
		case 0: break;
		
		case 5: // ¹ÎÃ¸ÀÇ 
			pItem->m_cSpeed--;
			if (pItem->m_cSpeed < 0) pItem->m_cSpeed = 0;
			break;

		case 6: // °¡º­¿î 
			dV2 = (double)pItem->m_wWeight;
			dV3 = (double)(dwSWEValue*4);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wWeight -= (int)dV1;

			if (pItem->m_wWeight < 1) pItem->m_wWeight = 1;
			break;

		case 8: // °­È­µÈ 
		case 9: // °í´ë¹®¸íÀÇ 
			dV2 = (double)pItem->m_wMaxLifeSpan;
			dV3 = (double)(dwSWEValue*7);
			dV1 = (dV3/100.0f)*dV2;
			pItem->m_wMaxLifeSpan += (int)dV1;
			break;
		}
	}
}

void CGame::RequestNoticementHandler(int iClientH, char * pData)
{
 char * cp, cData[120];
 int  * ip, iRet, iClientSize;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_dwNoticementDataSize < 10) return;

	ip = (int *)(pData + DEF_INDEX2_MSGTYPE + 2);
	iClientSize = *ip;

	if (iClientSize != m_dwNoticementDataSize) {
		// Å¬¶óÀÌ¾ðÆ®°¡ °®°í ÀÖ´Â ÆÄÀÏ »çÀÌÁî¿Í ´Ù¸£¸é ³»¿ëÀ» ¸ðµÎ º¸³½´Ù.
		cp = new char[m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2];
		ZeroMemory(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
		memcpy((cp + DEF_INDEX2_MSGTYPE + 2), m_pNoticementData, m_dwNoticementDataSize);
		
		dwp  = (DWORD *)(cp + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cp + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_REJECT;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cp, m_dwNoticementDataSize + 2 + DEF_INDEX2_MSGTYPE + 2);
	
		delete cp;
	}
	else {
		ZeroMemory(cData, sizeof(cData));
		
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_RESPONSE_NOTICEMENT;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_MSGTYPE_CONFIRM;
		
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 6);
	}
	// ¿¡·¯ ¹ß»ýÇØµµ ²÷Áö ¾Ê´Â´Ù.	
}

void CGame::_bDecodeNoticementFileContents(char *pData, DWORD dwMsgSize)
{
 char * cp;	
	
	cp = (pData);
	
	if (m_pNoticementData != NULL) {
		delete m_pNoticementData;
		m_pNoticementData = NULL;
	}

	m_pNoticementData = new char[strlen(cp) + 2];
	ZeroMemory(m_pNoticementData, strlen(cp) + 2);

	memcpy(m_pNoticementData, cp, strlen(cp));
	m_dwNoticementDataSize = strlen(cp);

	wsprintf(G_cTxt, "(!) Noticement Data Size: %d", m_dwNoticementDataSize);
	PutLogList(G_cTxt);
}

void CGame::RequestCheckAccountPasswordHandler(char *pData, DWORD dwMsgSize)
{
 int * ip, i, iLevel;
 char * cp, cAccountName[11], cAccountPassword[11];

	cp = (char *)(pData + 6);

	ZeroMemory(cAccountName, sizeof(cAccountName));
	ZeroMemory(cAccountPassword, sizeof(cAccountPassword));

	memcpy(cAccountName, cp, 10);
	cp += 10;

	memcpy(cAccountPassword, cp, 10);
	cp += 10;

	ip = (int *)cp;
	iLevel = *ip;
	cp += 4;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cAccountName, cAccountName) == 0)) {
		// °°Àº °èÁ¤À» Ã£¾Ò´Ù. ¸¸¾à ÆÐ½º¿öµå³ª ·¹º§ÀÌ ´Ù¸£¸é µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í Á¢¼ÓÀ» ²÷´Â´Ù. 
		if ((strcmp(m_pClientList[i]->m_cAccountPassword, cAccountPassword) != 0) || (m_pClientList[i]->m_iLevel != iLevel)) {
			wsprintf(G_cTxt, "(TestLog) Error! Account(%s)-Level(%d) password(or level) mismatch! Disconnect.", cAccountName, iLevel);
			PutLogList(G_cTxt);
			// µ¥ÀÌÅÍ ÀúÀåÀ» ÇÏÁö ¾Ê°í ²÷´Â´Ù.
			DeleteClient(i, FALSE, TRUE);
			return;
		}
	}
}

void CGame::_TamingHandler(int iClientH, int iSkillNum, char cMapIndex, int dX, int dY)
{
 int iSkillLevel, iRange, iTamingLevel, iResult, iX, iY;
 short sOwnerH;
 char  cOwnerType;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pMapList[cMapIndex] == NULL) return;
	
	iSkillLevel = (int)m_pClientList[iClientH]->m_cSkillMastery[iSkillNum];
	iRange = iSkillLevel / 12; // ÃÖ´ë ¹üÀ§´Â 8

	for (iX = dX - iRange; iX <= dX + iRange; iX++)
	for (iY = dY - iRange; iY <= dY + iRange; iY++) {
		sOwnerH = NULL;
		if ((iX > 0) && (iY > 0) && (iX < m_pMapList[cMapIndex]->m_sSizeX) && (iY < m_pMapList[cMapIndex]->m_sSizeY))
			m_pMapList[cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, iX, iY);

		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH] == NULL) break;
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH] == NULL) break;
				// ¸ó½ºÅÍÀÇ Á¾·ù¿¡ µû¶ó ±æµé¿©Áú °ÍÀÎÁö¸¦ °áÁ¤ÇÑ´Ù.
				iTamingLevel = 10;
				switch (m_pNpcList[sOwnerH]->m_sType) {
				case 10:							// ½½¶óÀÓ  
				case 16: iTamingLevel = 1; break;	// °³¹Ì
				case 22: iTamingLevel = 2; break;	// ¹ì
				case 17:							// Àü°¥
				case 14: iTamingLevel = 3; break;	// ¿ÀÅ©
				case 18: iTamingLevel = 4; break;   // Á»ºñ
				case 11: iTamingLevel = 5; break;	// ½ºÄÌ·¹Åæ
				case 23:
				case 12: iTamingLevel = 6; break;	// °ñ·½
				case 28: iTamingLevel = 7; break;	// Æ®·Ñ
				case 13:							// ½ÎÀÌÅ¬·Ó½º
				case 27: iTamingLevel = 8; break;	// ÇïÇÏ¿îµå
				case 29: iTamingLevel = 9; break;	// ¿À¿ì°Å
				case 33: iTamingLevel = 9; break;	// ¿þ¾î¿ïÇÁ
				case 30: iTamingLevel = 9; break;  // ¸®Ä¡
				case 31:
				case 32: iTamingLevel = 10; break;  // µ¥¸ó, À¯´ÏÄÜ
				}
				
				iResult = (iSkillLevel/10);
				
				// ½ºÅ³ÀÇ µî±Þ¿¡ µû¶ó ±æµéÀÏ ¼ö ÀÖ´Â °¹¼ö°¡ ´Þ¶óÁø´Ù.
				if (iResult < iTamingLevel) break;

				break;
			}
		}
	}
}

void CGame::GetMagicAbilityHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_cSkillMastery[4] != 0) return;

	// ¸¶¹ý ´É·Â ½ºÅ³À» 20À¸·Î º¯°æÈÄ ¾Ë·ÁÁÜ
	m_pClientList[iClientH]->m_cSkillMastery[4] = 20;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SKILL, 4, m_pClientList[iClientH]->m_cSkillMastery[4], NULL, NULL);
	// v1.4311 ½ºÅ³ÀÇ ÃÑ ÇÕÀ» Ã¼Å©
	bCheckTotalSkillMasteryPoints(iClientH, 4);
}

int CGame::iRequestPanningMapDataRequest(int iClientH, char * pData)
{
 char  * cp, cDir, cData[3000];
 class CTile * pTile;
 DWORD * dwp;
 WORD  * wp, wObjectID;
 short * sp, dX, dY, sTemp, sTemp2, sDOtype;
 int   * ip, iRet, iSize, iDamage;

	if (m_pClientList[iClientH] == NULL) return 0;
	if (m_pClientList[iClientH]->m_bIsObserverMode == FALSE) return 0;
	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) return 0;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return 0;

	dX = m_pClientList[iClientH]->m_sX;
	dY = m_pClientList[iClientH]->m_sY;

	cDir = *(pData + DEF_INDEX2_MSGTYPE +2);
	if ((cDir <= 0) || (cDir > 8)) return 0;

	switch (cDir) {
	case 1:	dY--; break;
	case 2:	dX++; dY--;	break;
	case 3:	dX++; break;
	case 4:	dX++; dY++;	break;
	case 5: dY++; break;
	case 6:	dX--; dY++;	break;
	case 7:	dX--; break;
	case 8:	dX--; dY--;	break;
	}

	m_pClientList[iClientH]->m_sX   = dX;
	m_pClientList[iClientH]->m_sY   = dY;
	m_pClientList[iClientH]->m_cDir = cDir;
	
	dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
	*dwp = MSGID_RESPONSE_PANNING;
	wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
	*wp  = DEF_OBJECTMOVE_CONFIRM;
		
	cp = (char *)(cData + DEF_INDEX2_MSGTYPE+2);
		
	sp  = (short *)cp;
	*sp = dX - 10; 
	cp += 2;
		
	sp  = (short *)cp;
	*sp = dY - 7; 
	cp += 2;
		
	*cp = cDir;
	cp++;
		
	iSize = iComposeMoveMapData(dX - 10, dY - 7, iClientH, cDir, cp);
	iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, iSize + 12 + 1 + 4);
	switch (iRet) {
	case DEF_XSOCKEVENT_QUENEFULL:
	case DEF_XSOCKEVENT_SOCKETERROR:
	case DEF_XSOCKEVENT_CRITICALERROR:
	case DEF_XSOCKEVENT_SOCKETCLOSED:
		// ¸Þ½ÃÁö¸¦ º¸³¾¶§ ¿¡·¯°¡ ¹ß»ýÇß´Ù¸é Á¦°ÅÇÑ´Ù.
		DeleteClient(iClientH, TRUE, TRUE);
		return 0;
	}

	return 1;
}

void CGame::AdminOrder_SetObserverMode(int iClientH)
{
 int dX, dY;

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsObserverMode == TRUE) {
		// »õ À§Ä¡¿¡ Ç¥½ÃÇÑ´Ù. 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetOwner(iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);		
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_CONFIRM, NULL, NULL, NULL);
		
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 0, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = FALSE;
	}
	else {
		// ÇöÀç À§Ä¡¿¡¼­ Áö¿î´Ù. ¾ø¾îÁø ÇàÀ§¸¦ ¾Ë·ÁÁà¾ß ÇÑ´Ù. ¾ÆÁ÷ ¹Ì±¸Çö 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->ClearOwner(1, iClientH, DEF_OWNERTYPE_PLAYER, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY);
		SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_LOG, DEF_MSGTYPE_REJECT, NULL, NULL, NULL);

		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_OBSERVERMODE, 1, NULL, NULL, NULL);
		m_pClientList[iClientH]->m_bIsObserverMode = TRUE;
	}
}

void CGame::RequestRestartHandler(int iClientH)
{
 char cMapName[31];

	if (m_pClientList[iClientH] == NULL) return;

	if (m_pClientList[iClientH]->m_bIsKilled == TRUE) {
			
		ZeroMemory(m_pClientList[iClientH]->m_cMapName, sizeof(m_pClientList[iClientH]->m_cMapName));
		
		if (strcmp(m_pClientList[iClientH]->m_cLocation, "NONE") == 0) {
			// ¿©ÇàÀÚ¶ó¸é  default¸ÊÀ¸·Î °£´Ù.
			strcpy(m_pClientList[iClientH]->m_cMapName, "default");
		}
		else {
			// ¼Ò¼ÓÀÌ ÀÖ´Ù¸é ¼Ò¼Ó ¸¶À»ÀÇ ºÎÈ°Á¸À¸·Î °£´Ù.
			if (strcmp(m_pClientList[iClientH]->m_cLocation, "aresden") == 0) {
				 memcpy(m_pClientList[iClientH]->m_cMapName, "resurr1", 7);
			}
			else {
				memcpy(m_pClientList[iClientH]->m_cMapName, "resurr2", 7);
			}
		}
		
		// ´Ù½Ã »ì¸®´Â Ã³¸®¸¦ ÇÑ´Ù.
		m_pClientList[iClientH]->m_bIsKilled = FALSE;
		m_pClientList[iClientH]->m_iHP = 30;

		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pClientList[iClientH]->m_cMapName);
		// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
		RequestTeleportHandler(iClientH, "2   ", cMapName, -1, -1);
	}
}

void CGame::AdminOrder_EnableAdminCreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		return;
	}

	m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled = TRUE;
}

void CGame::AdminOrder_CreateItem(int iClientH, char *pData, DWORD dwMsgSize)
{
 char   seps[] = "= \t\n";
 char   * cp, * token, cBuff[256], cItemName[256], cData[256], cTemp[256];
 SYSTEMTIME SysTime;
 class  CStrTok * pStrTok;
 class  CItem * pItem;
 short  * sp;
 int    iRet, iEraseReq;
 DWORD * dwp;
 WORD  * wp;
 
	if (m_pClientList[iClientH] == NULL) return;
	if ((dwMsgSize)	<= 0) return;

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) {
		// Admin user levelÀÌ ³·¾Æ¼­ ÀÌ ±â´ÉÀ» »ç¿ëÇÒ ¼ö ¾ø´Ù.
		if (m_pClientList[iClientH]->m_iAdminUserLevel !=  0)	
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL);
		return;
	}
	// ¾ÆÀÌÅÛ »ý¼º È®ÀÎ ÄÚµå°¡ ÀÔ·ÂµÇÁö ¾Ê¾Ò´Ù¸é ¸¸µé ¼ö ¾ø´Ù.
	if (m_pClientList[iClientH]->m_bIsAdminCreateItemEnabled == FALSE) return;


	ZeroMemory(cBuff, sizeof(cBuff));
	memcpy(cBuff, pData, dwMsgSize);

	pStrTok = new class CStrTok(cBuff, seps);
	token = pStrTok->pGet();
	
	token = pStrTok->pGet();
	if (token != NULL) {
		ZeroMemory(cItemName, sizeof(cItemName));
		strcpy(cItemName, token);
	}

	// ¾ÆÀÌÅÛÀ» ¸¸µé°í 
	pItem = new class CItem;
	// ±âº» Æ¯¼ºÀ¸·Î ¾ÆÀÌÅÛ »ý¼º 
	if (_bInitItemAttr(pItem, cItemName) == FALSE) {
		delete pItem;
		return;	
	}

	// ¾ÆÀÌÅÛ¿¡ °íÀ¯ ÄÚµå ÀÔ·Â È¤Àº ³¯Â¥ÀÔ·Â 
	switch (pItem->m_sIDnum) {
	case 511: // ÀÔÀå±Ç·ù´Ù. ³¯Â¥ÀÔ·Â
	case 513:
	case 515:
	case 517:
	case 530:
	case 531:
	case 532:
	case 533:
	case 534:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_DATE;
		// v1.4311-3 º¯°æ ¿î¿µÀÚ°¡ ¹ß±ÞÇÑ ÀÔÀå±ÇÀº ±×³¯Àº Ç×»ó ÀÔÀå °¡´É ..
		pItem->m_sTouchEffectValue1 = (short)SysTime.wMonth;
		pItem->m_sTouchEffectValue2 = (short)SysTime.wDay;
		pItem->m_sTouchEffectValue3 = 24 ;
		break;

	default:
		GetLocalTime(&SysTime);
		pItem->m_sTouchEffectType   = DEF_ITET_ID;
		pItem->m_sTouchEffectValue1 = iDice(1,100000);
		pItem->m_sTouchEffectValue2 = iDice(1,100000);
		// ¸¶Áö¸· ¼ýÀÚ´Â ¾ÆÀÌÅÛ »ý¼º ¿ù, ÀÏ	
		ZeroMemory(cTemp, sizeof(cTemp));
		wsprintf(cTemp, "%d%2d",  (short)SysTime.wMonth, (short)SysTime.wDay);
		pItem->m_sTouchEffectValue3 = atoi(cTemp);
		break;
	}
	
	ZeroMemory(cData, sizeof(cData));
	if (_bAddClientItemList(iClientH, pItem, &iEraseReq) == TRUE) {
		// ¾ÆÀÌÅÛÀ» È¹µæÇß´Ù.
		dwp  = (DWORD *)(cData + DEF_INDEX4_MSGID);
		*dwp = MSGID_NOTIFY;
		wp   = (WORD *)(cData + DEF_INDEX2_MSGTYPE);
		*wp  = DEF_NOTIFY_ITEMOBTAINED;
		
		cp = (char *)(cData + DEF_INDEX2_MSGTYPE + 2);
		
		// 1°³ È¹µæÇß´Ù. Amount°¡ ¾Æ´Ï´Ù!
		*cp = 1;
		cp++;
		
		memcpy(cp, pItem->m_cName, 20);
		cp += 20;
		
		dwp  = (DWORD *)cp;
		*dwp = pItem->m_dwCount;	// ¼ö·®À» ÀÔ·Â 
		cp += 4;
		
		*cp = pItem->m_cItemType;
		cp++;
		
		*cp = pItem->m_cEquipPos;
		cp++;
		
		*cp = (char)0; // ¾òÀº ¾ÆÀÌÅÛÀÌ¹Ç·Î ÀåÂøµÇÁö ¾Ê¾Ò´Ù.
		cp++;
		
		sp  = (short *)cp;
		*sp = pItem->m_sLevelLimit;
		cp += 2;
		
		*cp = pItem->m_cGenderLimit;
		cp++;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wCurLifeSpan;
		cp += 2;
		
		wp = (WORD *)cp;
		*wp = pItem->m_wWeight;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSprite;
		cp += 2;
		
		sp  = (short *)cp;
		*sp = pItem->m_sSpriteFrame;
		cp += 2;
		
		*cp = pItem->m_cItemColor;
		cp++;

		*cp = (char)pItem->m_sItemSpecEffectValue2; // v1.41 
		cp++;
		
		dwp = (DWORD *)cp;
		*dwp = pItem->m_dwAttribute;
		cp += 4;
				
		if (iEraseReq == 1) {
			delete pItem;
		}
		
		// ¾ÆÀÌÅÛ Á¤º¸ Àü¼Û 
		iRet = m_pClientList[iClientH]->m_pXSock->iSendMsg(cData, 53);
		
		// v1.41 Èñ±Í ¾ÆÀÌÅÛÀÌ¶ó¸é ·Î±×¸¦ ³²±ä´Ù. 
		_bItemLog(DEF_ITEMLOG_GET, iClientH, NULL, pItem);
		return;
	}
	else {
		// ¾ÆÀÌÅÛÀ» ¼ÒÁöÇÒ ¼ö ¾ø´Â »óÈ²ÀÌ´Ù.		
		delete pItem;
		return;
	}
}

void CGame::RequestSellItemListHandler(int iClientH, char * pData)
{
 int i, * ip, iAmount;
 char * cp, cIndex;
 struct {
	char cIndex;
	int  iAmount;
 } stTemp[12];

	if (m_pClientList[iClientH] == NULL) return;

	cp = (char *)(pData + 6);
	for (i = 0; i < 12; i++) {
		stTemp[i].cIndex = *cp;
		cp++;

		ip = (int *)cp;
		stTemp[i].iAmount = *ip;
		cp += 4;
	}

	// ³»¿ëÀ» ´Ù ÀÐ¾ú´Ù. ¼ø¼­´ë·Î ÆÈ¾ÆÄ¡¿î´Ù.
	for (i = 0; i < 12; i++) {
		cIndex = stTemp[i].cIndex;
		iAmount = stTemp[i].iAmount;

		if ((cIndex == -1) || (cIndex < 0) || (cIndex >= DEF_MAXITEMS)) return;
		if (m_pClientList[iClientH]->m_pItemList[cIndex] == NULL) return;

		// cIndex¿¡ ÇØ´çÇÏ´Â ¾ÆÀÌÅÛÀ» ÆÇ´Ù.
		ReqSellItemConfirmHandler(iClientH, cIndex, iAmount, NULL);
		// ÀÌ ·çÆ¾À» ¼öÇàÇÑ ´ÙÀ½ Å¬¶óÀÌ¾ðÆ®°¡ »èÁ¦µÇ¾úÀ» ¼ö ÀÖÀ¸´Ï ÁÖÀÇ!
		if (m_pClientList[iClientH] == NULL) return;
	}
}

void CGame::_DeleteRandomOccupyFlag(int iMapIndex)
{
 int i, iCount, iTotalFlags, iTargetFlag, iDynamicObjectIndex;
 int tx, ty, fx, fy, iLocalSide, iLocalEKNum, iPrevStatus;
 class CTile * pTile;
 DWORD dwTime;

	if (m_pMapList[iMapIndex] == NULL) return;

	dwTime = timeGetTime();

	// ÃÑ ±ê¹ß °¹¼ö¸¦ ±¸ÇÑ´Ù.
	iTotalFlags = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iTotalFlags++;
	}

	// ·£´ýÇÏ°Ô ÇÏ³ª Á¤ÇÑ´Ù.
	iTargetFlag = iDice(1, iTotalFlags);

	iCount = 0;
	for (i = 1; i < DEF_MAXOCCUPYFLAG; i++)
	if (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL) {
		iCount++;
		if ((iCount == iTotalFlags) && (m_pMapList[iMapIndex]->m_pOccupyFlag[i] != NULL)) {
			// m_pMapList[iMapIndex]->m_pOccupyFlag[i] : ÀÌ ±ê¹ßÀ» ¾ø¾Ø´Ù.	

			//testcode
			wsprintf(G_cTxt, "(*)Delete OccupyFlag: Side(%d) XY(%d, %d)", m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX, m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY);
			PutLogList(G_cTxt);

			fx = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX;
			fy = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY;
			iLocalSide  = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_cSide;
			iLocalEKNum = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iEKCount;
			
			pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sX + 
				                    m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_sY*m_pMapList[iMapIndex]->m_sSizeY);
			// ±ê¹ß °´Ã¼ °¨¼Ò 
			m_pMapList[iMapIndex]->m_iTotalOccupyFlags--;
						
			iDynamicObjectIndex = m_pMapList[iMapIndex]->m_pOccupyFlag[i]->m_iDynamicObjectIndex;
			// Å¬¶óÀÌ¾ðÆ®¿¡°Ô ±ê¹ßÀÌ »ç¶óÁüÀ» ¾Ë¸®°í 
			SendEventToNearClient_TypeB(MSGID_DYNAMICOBJECT, DEF_MSGTYPE_REJECT, m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, 
										m_pDynamicObjectList[iDynamicObjectIndex]->m_sType, iDynamicObjectIndex, NULL);
			// ¸Ê¿¡¼­ ±ê¹ß µ¿Àû °´Ã¼¸¦ »èÁ¦ÇÑ´Ù.
			m_pMapList[m_pDynamicObjectList[iDynamicObjectIndex]->m_cMapIndex]->SetDynamicObject(NULL, NULL, m_pDynamicObjectList[iDynamicObjectIndex]->m_sX, m_pDynamicObjectList[iDynamicObjectIndex]->m_sY, dwTime);
						
			// ±ê¹ß °´Ã¼¸¦ »èÁ¦ 
			delete m_pMapList[iMapIndex]->m_pOccupyFlag[i];
			m_pMapList[iMapIndex]->m_pOccupyFlag[i] = NULL;

			// Å¸ÀÏ »óÀÇ ±ê¹ß ÀÎµ¦½º¸¦ »èÁ¦
			pTile->m_iOccupyFlagIndex = NULL;

			// µ¿Àû °´Ã¼ »èÁ¦ 
			delete m_pDynamicObjectList[iDynamicObjectIndex];
			m_pDynamicObjectList[iDynamicObjectIndex] = NULL;

			// ÀÌ ±ê¹ßÀ» »èÁ¦ÇÏ¹Ç·Î ¿µÇâ±Ç ³»ÀÇ °ªÀ» º¯°æ½ÃÄÑ¾ß ÇÑ´Ù. *** ¸Ç ¸¶Áö¸·¿¡ Ã³¸®ÇØ¾ß ÇÑ´Ù.
			for (tx = fx - 10; tx <= fx + 10; tx++)
			for (ty = fy - 8; ty <= fy + 8; ty++) {	
				if ((tx < 0) || (tx >= m_pMapList[iMapIndex]->m_sSizeX) || 
					(ty < 0) || (ty >= m_pMapList[iMapIndex]->m_sSizeY)) {
					// ¹«½ÃÇØ¾ß ÇÏ´Â ÁÂÇ¥ 
				}
				else {
					pTile = (class CTile *)(m_pMapList[iMapIndex]->m_pTile + tx + ty*m_pMapList[iMapIndex]->m_sSizeY);
					iPrevStatus = pTile->m_iOccupyStatus;
					// Side: ¾Æ·¹½ºµ§(1)  ¿¤¹ÙÀÎ(2)
					switch (iLocalSide) {
					case 1: 
						pTile->m_iOccupyStatus += iLocalEKNum;
						if (pTile->m_iOccupyStatus > 0) pTile->m_iOccupyStatus = 0;
						break;
					case 2:
						pTile->m_iOccupyStatus -= iLocalEKNum;
						if (pTile->m_iOccupyStatus < 0) pTile->m_iOccupyStatus = 0;
						break;
					}
				}
			}
			//
			return;
		}
	}
}


void CGame::CreateNewPartyHandler(int iClientH)
{
 BOOL bFlag;

	if (m_pClientList[iClientH] == NULL) return;

	bFlag = m_pClientList[iClientH]->bCreateNewParty();
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_RESPONSE_CREATENEWPARTY, (int)bFlag, NULL, NULL, NULL);
}


void CGame::JoinPartyHandler(int iClientH, char *pMemberName)
{
 int i;

	if (m_pClientList[iClientH] == NULL) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (strcmp(m_pClientList[i]->m_cCharName, pMemberName) == 0)) {
		// °°Àº ÀÌ¸§À» °¡Áø ÇÃ·¹ÀÌ¾î¸¦ Ã£¾Ò´Ù.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUERY_JOINPARTY, NULL, NULL, NULL, m_pClientList[iClientH]->m_cCharName);
		return;
	}
}


BOOL CGame::bCheckEnergySphereDestination(int iNpcH, short sAttackerH, char cAttackerType)
{
 int i, sX,sY, dX, dY, iGoalMapIndex;
 char cResult;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex == -1) return FALSE;

	if (m_pNpcList[iNpcH]->m_cMapIndex != m_iMiddlelandMapIndex) {
		// »çÅõÀåÀÇ ¿¡³ÊÁö ½ºÇÇ¾î
		iGoalMapIndex = m_pNpcList[iNpcH]->m_cMapIndex;
		
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) ¿¡³ÊÁö ½ºÇÇ¾î °ñÀÎ (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[iGoalMapIndex]->m_stEnergySphereGoalList[m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-2) && (sX <= dX+2) && (sY >= dY-2) && (sY <= dY+2)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[iGoalMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) ¿¡³ÊÁö ½ºÇÇ¾î °ñÀÎ (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
	else {
		// ¹Ìµé·£µå ¿¡³ÊÁö ½ºÇÇ¾î.

		// ¿¡³ÊÁö ½ºÇÇ¾îÀÇ ÇöÀç À§Ä¡°¡ °ñ°ú °ÅÀÇ À¯»çÇÏ¸é 
		sX = m_pNpcList[iNpcH]->m_sX;
		sY = m_pNpcList[iNpcH]->m_sY;
	
		cResult = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].cResult;
		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].aresdenY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// ¾Æ·¹½ºµ§ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;
		
			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 1) { // Aresden (Side:1)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) ¿¡³ÊÁö ½ºÇÇ¾î °ñÀÎ (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					// Å¬¶óÀÌ¾ðÆ®¿ÍÀÇ ¸Þ½ÃÁö Âø¿À·Î 
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 2, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}

		dX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineX;
		dY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex].elvineY;
		if ((sX >= dX-4) && (sX <= dX+4) && (sY >= dY-4) && (sY <= dY+4)) {
			// ¿¤¹ÙÀÎ ¸ñÇ¥ÁöÁ¡¿¡ µµÂøÇß´Ù.
			// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
			m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = -1;

			if ((cAttackerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sAttackerH] != NULL)) {
				if (m_pClientList[sAttackerH]->m_cSide == 2) { // Elvine (Side:2)
					// ÀÚ½ÅÀÇ ±¹°¡ Æ÷Å»¿¡ °ñÀ» ³ÖÀº °æ¿ì °øÇåµµ +5
					m_pClientList[sAttackerH]->m_iContribution += 5;
					// ·Î±× ÀÛ¼º
					wsprintf(G_cTxt, "(!) ¿¡³ÊÁö ½ºÇÇ¾î °ñÀÎ (%s)", m_pClientList[sAttackerH]->m_cCharName);
					PutLogFileList(G_cTxt);
				}
				else {
					// ´Ù¸¥ ±¹°¡¿¡ °ñÀ» ³Ö¾úÀ» °æ¿ì °øÇåµµ°¡ 10 ¶³¾îÁø´Ù.
					m_pClientList[sAttackerH]->m_iContribution -= 10;
				}
			
				// ¿¡³ÊÁö ½ºÇÇ¾î°¡ °ñÀÎ µÆÀ½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
				for (i = 1; i < DEF_MAXCLIENTS; i++)
				if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
					//
					SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHEREGOALIN, cResult, m_pClientList[sAttackerH]->m_cSide, 1, m_pClientList[sAttackerH]->m_cCharName);
				}
			}
			return TRUE;
		}
		return FALSE;
	}
}

void CGame::EnergySphereProcessor(BOOL bIsAdminCreate, int iClientH)
{
 int i, iNamingValue, iCIndex, iTemp, pX, pY;
 char cSA, cName_Internal[31], cWaypoint[31];

	if (bIsAdminCreate != TRUE) {
		
		if (m_iMiddlelandMapIndex < 0) return;
		if (m_pMapList[m_iMiddlelandMapIndex] == NULL) return;
		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾îÁú È®·üÀº 3ÃÊ¸¶´Ù 2000ºÐÀÇ 1
		if (iDice(1,2000) != 123) return; 
		// ¿¡³ÊÁö ½ºÇÇ¾î´Â ÃÑ »ç¿ëÀÚ 500¸í ÀÌ»óÀÏ¶§¸¸ ¸¸µé¾î Áø´Ù.
		if (m_iTotalGameServerClients < 500) return;
	
		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
 		pX = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_iMiddlelandMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_iMiddlelandMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_iMiddlelandMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_iMiddlelandMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp  = iDice(1, m_pMapList[m_iMiddlelandMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_iMiddlelandMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_iMiddlelandMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
	else {
		// ¸¸¾à ÀÌ¹Ì ¿¡³ÊÁö ½ºÇÇ¾îÀÇ °ñÀÌ ÇÒ´çµÇ¾î ÀÖÀ¸¸é ¸¸µé¸é ¾ÈµÈ´Ù.
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex >= 0) return;

		// ¿¡³ÊÁö ½ºÇÇ¾î¸¦ ¸¸µé À§Ä¡¸¦ °áÁ¤ 
		iCIndex = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereCreationPoint);

		// ¿¡³ÊÁö ½ºÇÇ¾î ½ÃÀÛ À§Ä¡°¡ ÃÊ±âÈ­°¡ ¾ÈµÈ »óÅÂ¶ó¸é 
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].cType == NULL) return;
		
		// ¿©±â¼­ ¿¡³ÊÁö ½ºÇÇ¾î »ý¼º 
		cSA = 0;
 		pX = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sX;
		pY = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereCreationList[iCIndex].sY;
		ZeroMemory(cWaypoint, sizeof(cWaypoint));
	
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue != -1) {
			// 
			ZeroMemory(cName_Internal, sizeof(cName_Internal));
			wsprintf(cName_Internal, "XX%d", iNamingValue);
			cName_Internal[0] = '_';
			cName_Internal[1] = m_pClientList[iClientH]->m_cMapIndex + 65;
			
			if ((bCreateNewNpc("Energy-Sphere", cName_Internal, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, (rand() % 3), cSA, DEF_MOVETYPE_RANDOM, &pX, &pY, cWaypoint, NULL, NULL, -1, FALSE, FALSE, FALSE)) == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->SetNamingValueEmpty(iNamingValue);
				return;
			}
		}		

		// ¿¡³ÊÁö ½ºÇÇ¾î °ñ »ý¼º 
		iTemp  = iDice(1, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalEnergySphereGoalPoint);
		if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stEnergySphereGoalList[iTemp].cResult == NULL) return;
	
		// ÇöÀç ¿¡³ÊÁö ½ºÇÇ¾î °ñ ÀÎµ¦½º ÀúÀå 
		m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iCurEnergySphereGoalPointIndex = iTemp;

		// ¿¡³ÊÁö ½ºÇÇ¾î°¡ ¸¸µé¾î Á³À½À» ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô ¾Ë·ÁÁØ´Ù.
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_ENERGYSPHERECREATED, pX, pY, NULL, NULL);
		}

		//testcode
		wsprintf(G_cTxt, "(!) Admin Energy Sphere Created! (%d, %d)", pX, pY);
		PutLogList(G_cTxt);
		PutLogFileList(G_cTxt);
	}
}


void CGame::ActivateSpecialAbilityHandler(int iClientH)
{
 DWORD dwTime = timeGetTime();
 short sTemp;

	// Æ¯¼ö ´É·ÂÀ» »ç¿ëÇß´Ù.
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityTime != 0) return;
	if (m_pClientList[iClientH]->m_iSpecialAbilityType == 0) return;
	if (m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled == TRUE) return;

	m_pClientList[iClientH]->m_bIsSpecialAbilityEnabled  = TRUE;
	m_pClientList[iClientH]->m_dwSpecialAbilityStartTime = dwTime;

	// ´ÙÀ½ »ç¿ë °¡´É ½Ã°£À» ÀÔ·ÂÇÑ´Ù.
	m_pClientList[iClientH]->m_iSpecialAbilityTime = DEF_SPECABLTYTIMESEC;

	// È¿°ú ºñÆ® Å¬¸®¾î
	sTemp = m_pClientList[iClientH]->m_sAppr4;
	sTemp = sTemp & 0xFF0F;
	// È¿°ú ºñÆ® ¼³Á¤ 
	switch (m_pClientList[iClientH]->m_iSpecialAbilityType) {
	case 1:
	case 2:
	case 3:
	case 4:
	case 5:
		sTemp = sTemp | 0x0010;
		break;
	case 50:
	case 51:
	case 52:
	case 53:
	case 54:
		sTemp = sTemp | 0x0020;
		break;
	}
	m_pClientList[iClientH]->m_sAppr4 = sTemp;

	// Å¬¶óÀÌ¾ðÆ®¿¡°Ô Åëº¸ÇÑ´Ù. 
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_SPECIALABILITYSTATUS, 1, m_pClientList[iClientH]->m_iSpecialAbilityType, m_pClientList[iClientH]->m_iSpecialAbilityLastSec, NULL);
	// ¿ÜÇüÀÌ ¹Ù²î¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendEventToNearClient_TypeA(iClientH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL);
}

void CGame::CancelQuestHandler(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// Äù½ºÆ® »óÅÂ¸¦ Å¬¸®¾îÇÑ´Ù.
	_ClearQuestStatus(iClientH);
	// Äù½ºÆ®°¡ Ãë¼ÒµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_QUESTABORTED, NULL, NULL, NULL, NULL);
}

int CGame::iGetItemWeight(CItem *pItem, int iCount)
{
 int iWeight;
 DWORD dwCount;
	// ¾ÆÀÌÅÛÀÇ ¼ö·®¿¡ µû¸¥ ¹«°Ô¸¦ °è»êÇÑ´Ù. GoldÀÎ °æ¿ì ¹«°Ô¸¦ 20ºÐÀÇ 1·Î º¯°æ 
	iWeight = (pItem->m_wWeight);
	if (iCount < 0) iCount = 1;
	iWeight = iWeight * iCount;
	if (pItem->m_sIDnum == 90) iWeight = iWeight / 20;
	if (iWeight <= 0) iWeight = 1;

	return iWeight;
}


BOOL CGame::bGetItemNameWhenDeleteNpc(char * pItemName, short sNpcType) 
{ 
 int iGenType, iResult; 
   // NPC를 삭제할때 특수 아이템을 발생시킬 것인지의 여부를 계산한다. 

   switch (sNpcType) { 

   /*   case 73: // Fire-Wyvern
	  iResult = iDice(1, 10000);
	  if ((iResult >= 1) && (iResult <= 4999)) {
		  if (iDice(1,2) ==1)
			  strcpy(pItemName, "KnecklaceOfFirePro");
		  else strcpy(pItemName, "Xli");
	  }
      else if ((iResult >= 5000) && (iResult <= 7499))  strcpy(pItemName, "Excalibur"); 
      else if ((iResult >= 7500) && (iResult <= 8749))  strcpy(pItemName, "SwordofIceElemental"); 
      else if ((iResult >= 8750) && (iResult <= 9374))  strcpy(pItemName, "DragonSword"); 
      else if ((iResult >= 9375) && (iResult <= 9687))  strcpy(pItemName, "MagicNecklace(MS10)"); 
      else if ((iResult >= 9688) && (iResult <= 9843))  strcpy(pItemName, "KlonessAxe"); 
      else if ((iResult >= 9844) && (iResult <= 9921))  strcpy(pItemName, "GBattleHammer"); 
      else if ((iResult >= 9922) && (iResult <= 9960))  strcpy(pItemName, "StormBringer"); 
      else if ((iResult >= 9961) && (iResult <= 9980))  strcpy(pItemName, "MagicWand(M.Shield)"); 
      else if ((iResult >= 9981) && (iResult <= 9990))  strcpy(pItemName, "DragonStaff"); 
      else if ((iResult >= 9991) && (iResult <= 9996))  strcpy(pItemName, "KlonessMagicWand"); 
      else if ((iResult >= 9996) && (iResult <= 9998))  strcpy(pItemName, "RingOfGrandMage"); 
      else if ((iResult >= 9999) && (iResult <= 10000)) strcpy(pItemName, "NecklaceOfXelima"); 
      return TRUE; 

   case 81: // Abaddon
	  iResult = iDice(1, 10000);
	  if ((iResult >= 1) && (iResult <= 4999)) {
		  if (iDice(1,2) ==1)
			  strcpy(pItemName, "KnecklaceOfIcePro");
		  else strcpy(pItemName, "KnecklaceOfIceEle");
	  }
      else if ((iResult >= 5000) && (iResult <= 7499))  strcpy(pItemName, "Excalibur"); 
      else if ((iResult >= 7500) && (iResult <= 8749))  strcpy(pItemName, "SwordofIceElemental"); 
      else if ((iResult >= 8750) && (iResult <= 9374))  strcpy(pItemName, "DragonSword"); 
      else if ((iResult >= 9375) && (iResult <= 9687))  strcpy(pItemName, "MagicNecklace(MS10)"); 
      else if ((iResult >= 9688) && (iResult <= 9843))  strcpy(pItemName, "KlonessAxe"); 
      else if ((iResult >= 9844) && (iResult <= 9921))  strcpy(pItemName, "GBattleHammer"); 
      else if ((iResult >= 9922) && (iResult <= 9960))  strcpy(pItemName, "StormBringer"); 
      else if ((iResult >= 9961) && (iResult <= 9980))  strcpy(pItemName, "MagicWand(M.Shield)"); 
      else if ((iResult >= 9981) && (iResult <= 9990))  strcpy(pItemName, "DragonStaff"); 
      else if ((iResult >= 9991) && (iResult <= 9996))  strcpy(pItemName, "KlonessMagicWand"); 
      else if ((iResult >= 9996) && (iResult <= 9998))  strcpy(pItemName, "RingOfGrandMage"); 
      else if ((iResult >= 9999) && (iResult <= 10000)) strcpy(pItemName, "NecklaceOfXelima"); 
      return TRUE; */

   case 49: // Hellclaw 
      iResult = iDice(1,10000); 
      if ((iResult >= 1) && (iResult <= 598))  strcpy(pItemName, "ZemstoneofSacrifice"); 
      else if ((iResult >= 599) && (iResult <= 998))  strcpy(pItemName, "StoneOfMerien"); 
	  else if ((iResult >= 999) && (iResult <= 1398))  strcpy(pItemName, "StoneOfXelima"); 
      else if ((iResult >= 1399)&& (iResult <= 1798))  strcpy(pItemName, "AncientTablet(LU)"); 
	  else if ((iResult >= 1799) && (iResult <= 2198))  strcpy(pItemName, "AncientTablet(LD)"); 
	  else if ((iResult >= 2199) && (iResult <= 2598))  strcpy(pItemName, "AncientTablet(RU)"); 
	  else if ((iResult >= 2599) && (iResult <= 2999))  strcpy(pItemName, "AncientTablet(RD)"); 
	  else if ((iResult >= 3000) && (iResult <= 3999))  strcpy(pItemName, "PlatinumRing"); 
      else if ((iResult >= 4000) && (iResult <= 4999))  strcpy(pItemName, "EmeraldRing"); 
      else if ((iResult >= 5000) && (iResult <= 5999))  strcpy(pItemName, "RubyRing"); 
      else if ((iResult >= 6000) && (iResult <= 6999))  strcpy(pItemName, "MagicNecklace(DM+1)"); 
      else if ((iResult >= 7000) && (iResult <= 7499))  strcpy(pItemName, "MagicNecklace(RM10)"); 
      else if ((iResult >= 7500) && (iResult <= 7999))  strcpy(pItemName, "MagicWand(M.Shield)"); 
      else if ((iResult >= 8000) && (iResult <= 8249))  strcpy(pItemName, "MagicNecklace(DF+10)"); 
      else if ((iResult >= 8250) && (iResult <= 8499))  strcpy(pItemName, "MagicNecklace(MS10)"); 
      else if ((iResult >= 8500) && (iResult <= 8749))  strcpy(pItemName, "RingOfDemonpower"); 
      else if ((iResult >= 8750) && (iResult <= 8999))  strcpy(pItemName, "NecklaceOfSufferent"); 
      else if ((iResult >= 9000) && (iResult <= 9249))  strcpy(pItemName, "Flameberge+3(LLF)"); 
      else if ((iResult >= 9250) && (iResult <= 9449))  strcpy(pItemName, "KnecklaceOfPoisonPro"); 
      else if ((iResult >= 9500) && (iResult <= 9969))  strcpy(pItemName, "NecklaceOfMedusa");  
      else if ((iResult >= 9970) && (iResult <= 9979))  strcpy(pItemName, "MerienPlateMail(M)"); 
      else if ((iResult >= 9980) && (iResult <= 9989))  strcpy(pItemName, "MerienPlateMail(W)"); 
      else if ((iResult >= 9990) && (iResult <= 10000)) strcpy(pItemName, "MerienShield"); 
	  return TRUE; 

   case 50: // Tigerworm 
      iResult = iDice(1,10000); 
      if ((iResult >= 1) && (iResult <= 598))  strcpy(pItemName, "ZemstoneofSacrifice"); 
      else if ((iResult >= 599) && (iResult <= 998))  strcpy(pItemName, "StoneOfMerien"); 
	  else if ((iResult >= 999) && (iResult <= 1398))  strcpy(pItemName, "StoneOfXelima"); 
      else if ((iResult >= 1399)&& (iResult <= 1798))  strcpy(pItemName, "AncientTablet(LU)"); 
	  else if ((iResult >= 1799) && (iResult <= 2198))  strcpy(pItemName, "AncientTablet(LD)"); 
	  else if ((iResult >= 2199) && (iResult <= 2598))  strcpy(pItemName, "AncientTablet(RU)"); 
	  else if ((iResult >= 2599) && (iResult <= 2999))  strcpy(pItemName, "AncientTablet(RD)"); 
      else if ((iResult >= 3000) && (iResult <= 3999))  strcpy(pItemName, "MagicNecklace(DF+10)"); 
      else if ((iResult >= 4000) && (iResult <= 4999))  strcpy(pItemName, "MagicNecklace(DM+1)"); 
      else if ((iResult >= 5000) && (iResult <= 5999))  strcpy(pItemName, "MagicNecklace(MS10)"); 
      else if ((iResult >= 6000) && (iResult <= 6999))  strcpy(pItemName, "RingOftheAbaddon"); 
      else if ((iResult >= 7000) && (iResult <= 7499))  strcpy(pItemName, "RingOfXelima"); 
      else if ((iResult >= 7500) && (iResult <= 7999))  strcpy(pItemName, "RingOfDemonpower"); 
      else if ((iResult >= 8000) && (iResult <= 8249))  strcpy(pItemName, "Flameberge+3(LLF)"); 
      else if ((iResult >= 8250) && (iResult <= 8499))  strcpy(pItemName, "BloodSword"); 
      else if ((iResult >= 8500) && (iResult <= 8749))  strcpy(pItemName, "BloodAxe"); 
      else if ((iResult >= 8750) && (iResult <= 8999))  strcpy(pItemName, "BloodRapier"); 
      else if ((iResult >= 9000) && (iResult <= 9249))  strcpy(pItemName, "KnecklaceOfLightPro"); 
      else if ((iResult >= 9250) && (iResult <= 9499))  strcpy(pItemName, "KnecklaceOfAirEle"); 
      else if ((iResult >= 9500) && (iResult <= 9968))  strcpy(pItemName, "Excalibur"); 
      else if ((iResult >= 9970) && (iResult <= 9979))  strcpy(pItemName, "XelimaRapier"); 
      else if ((iResult >= 9980) && (iResult <= 9989))  strcpy(pItemName, "XelimaBlade"); 
      else if ((iResult >= 9990) && (iResult <= 10000)) strcpy(pItemName, "XelimaAxe"); 
	  return TRUE; 
   
   case 73: // Fire-Wyvern
      iResult = iDice(1,10000); 
	  if ((iResult >= 1) && (iResult <= 610))  strcpy(pItemName, "ZemstoneofSacrifice"); 
	  else if ((iResult >= 611) && (iResult <= 1156))  strcpy(pItemName, "StoneOfXelima");
	  else if ((iResult >= 1157) && (iResult <= 1702))  strcpy(pItemName, "StoneOfMerien");
	  else if ((iResult >= 1703) && (iResult <= 2248))  strcpy(pItemName, "EmeraldRing"); 
	  else if ((iResult >= 2249) && (iResult <= 2794))  strcpy(pItemName, "RubyRing"); 
	  else if ((iResult >= 2795) && (iResult <= 3340))  strcpy(pItemName, "GoldRing");
	  else if ((iResult >= 3341) && (iResult <= 3886))  strcpy(pItemName, "AncientTablet(LU)"); 
	  else if ((iResult >= 3887) && (iResult <= 4432))  strcpy(pItemName, "AncientTablet(LD)"); 
	  else if ((iResult >= 4433) && (iResult <= 4978))  strcpy(pItemName, "AncientTablet(RU)"); 
	  else if ((iResult >= 4979) && (iResult <= 5478))  strcpy(pItemName, "AncientTablet(RD)"); 
      else if ((iResult >= 5479) && (iResult <= 5978))  strcpy(pItemName, "Fire-Bow"); 
      else if ((iResult >= 5979) && (iResult <= 6478))  strcpy(pItemName, "MassFireStrikeManual"); 
      else if ((iResult >= 6479) && (iResult <= 6999))  strcpy(pItemName, "BloodyShockW.Manual"); 
      else if ((iResult >= 7000) && (iResult <= 7249))  strcpy(pItemName, "Flameberge+3(LLF)"); 
      else if ((iResult >= 7250) && (iResult <= 7499))  strcpy(pItemName, "KnecklaceOfEfreet"); 
      else if ((iResult >= 7500) && (iResult <= 7978))  strcpy(pItemName, "KnecklaceOfFirePro"); 
      else if ((iResult >= 7979) && (iResult <= 8478))  strcpy(pItemName, "BloodRapier"); 
      else if ((iResult >= 8479) && (iResult <= 8978))  strcpy(pItemName, "BloodAxe"); 
      else if ((iResult >= 8979) && (iResult <= 9478))  strcpy(pItemName, "BloodSword"); 
      else if ((iResult >= 9479) && (iResult <= 9979))  strcpy(pItemName, "MagicNecklace(MS10)"); 
      else if ((iResult >= 9980) && (iResult <= 9989))  strcpy(pItemName, "RingOfGrandMage"); 
      else if ((iResult >= 9990) && (iResult <= 10000)) strcpy(pItemName, "NecklaceOfXelima"); 
      return TRUE; 

   default: // 다른 몬스터. 확률 계산한다. 
      break; 
   }

	// 일단 확률 계산.
	if (iDice(1,50) == 13) {
		switch (sNpcType) {
		case 11: if (iDice(1,550) != 11) return FALSE;	 break;	 // Skeleton   2 * 100
		case 12: if (iDice(1,400) != 11) return FALSE;	 break;	 // Stone-Golem 2 * 100
		case 13: if (iDice(1,100) != 11) return FALSE;	 break;	 // Cyclops  6 * 100
		case 14: if (iDice(1,700) != 11) return FALSE;	 break;	 // Orc 4 * 100
		case 17: if (iDice(1,600) != 11) return FALSE;	 break;	 // Scorpoin 5 * 100
		case 18: if (iDice(1,850) != 11) return FALSE;	 break;	 // Zombie 1 * 100
		case 22: if (iDice(1,600) != 11) return FALSE;	 break;	 // Amphis 5 * 100
		case 23: if (iDice(1,400) != 11) return FALSE;	 break;	 // Clay-Golem 2 * 100
		case 27: if (iDice(1,100) != 11) return FALSE;	 break;	 // Hellhound 7 * 100
		case 28: if (iDice(1,100) != 11) return FALSE;	 break;	 // Troll 5 * 100
		case 29: if (iDice(1,15) != 3) return FALSE;	 break;	 // Orge  7 * 100
		case 30: if (iDice(1,10) !=  3) return FALSE;	 break;  // Liche 1 * 100
		case 31:  	                                     break;	 // Demon 5 * 100
		case 32: if (iDice(1,2) !=  1) return FALSE;	 break;	 // Unicorn 5 * 100
		case 33: if (iDice(1,30) !=  3) return FALSE;	 break;  // WereWolf 7 * 100
		case 48: if (iDice(1,30) !=  3) return FALSE;	 break;  // Stalker 
		default: return FALSE;
		}
	}
	else return FALSE;

	// GenType 결정
   switch (sNpcType) { 
   case 11: // 반지류 아이템 나오는 경우 
   case 17: 
   case 14: 
   case 28: 
      switch (iDice(1,7)) { 
      case 1: strcpy(pItemName, "LuckyGoldRing"); break; 
      case 2: strcpy(pItemName, "SapphireRing"); break; 
      case 3: strcpy(pItemName, "EmeraldRing"); break; 
      case 4: strcpy(pItemName, "RubyRing"); break; 
      case 5: strcpy(pItemName, "PlatinumRing"); break; 
      case 6: if (iDice(1,15) == 3) strcpy(pItemName, "RingOfWizard"); break; 
      case 7: if (iDice(1,25) == 3) strcpy(pItemName, "RingOfMage"); break; 
      } 
      break; 
    
   case 13: // 목걸이류 아이템 나오는 경우 
   case 27: 
   case 29: 
      switch (iDice(1,7)) { 
      case 1: strcpy(pItemName, "MagicNecklace(DF+10)"); break; 
      case 2: if (iDice(1,20) == 13) strcpy(pItemName, "MagicNecklace(MS10)"); break; 
      case 3: if (iDice(1,10) == 13) strcpy(pItemName, "MagicNecklace(DM+1)"); break; 
      case 4: strcpy(pItemName, "MagicNecklaceRM10"); break; 
      case 5: if (iDice(1,30) == 13) strcpy(pItemName, "RingOfOgrepower"); break; 
      case 6: if (iDice(1,30) == 13) strcpy(pItemName, "KnecklaceOfLightPro"); break; 
      case 7: if (iDice(1,30) == 13) strcpy(pItemName, "KnecklaceOfFirePro"); break; 
      } 
      break; 

   case 18: 
   case 22: 
      switch (iDice(1,4)) { 
      case 1: if (iDice(1,75) == 13) strcpy(pItemName, "SwordofMedusa"); break; 
      case 2: if (iDice(1,20) == 13) strcpy(pItemName, "KnecklaceOfPoisonPro"); break; 
      case 3: if (iDice(1,40) == 13) strcpy(pItemName, "NecklaceOfMedusa"); break; 
      case 4: if (iDice(1,30) == 13) strcpy(pItemName, "NecklaceOfSufferent"); break; 
      } 
      break; 

   case 12: 
   case 23: 
   case 32: 
      switch (iDice(1,4)) { 
      case 1: if (iDice(1,30) == 13) strcpy(pItemName, "MerienShield"); break; 
      case 2: if (iDice(1,30) == 13) strcpy(pItemName, "MerienPlateMail(M)"); break; 
      case 3: if (iDice(1,30) == 13) strcpy(pItemName, "MerienPlateMail(W)"); break; 
      case 4: if (iDice(1,20) == 11) strcpy(pItemName, "KnecklaceOfAirEle"); break; 
      } 
      break; 

   case 33: 
   case 48: 
      switch (iDice(1,2)) { 
      case 1: if (iDice(1,30) == 3) strcpy(pItemName, "Flameberge+3(LLF)"); break; 
      case 2: strcpy(pItemName, "4BladeGoldenAxe"); break; 
      } 
      break; 

   case 30: 
      switch (iDice(1,7)) { 
      case 1: if (iDice(1,5) == 3) strcpy(pItemName, "IceStormManual"); break; 
      case 2: strcpy(pItemName, "MagicWand(M.Shield)");  break; 
      case 3: if (iDice(1,20) == 3) strcpy(pItemName, "MagicWand(MS30-LLF)"); break; 
      case 4: if (iDice(1,10) == 3) strcpy(pItemName, "SwordofIceElemental"); break; 
      case 5: if (iDice(1,10) == 3) strcpy(pItemName, "KnecklaceOfIcePro"); break; 
      case 6: if (iDice(1,15) == 3) strcpy(pItemName, "KnecklaceOfIceEle"); break; 
      case 7: if (iDice(1,20) == 3) strcpy(pItemName, "RingOfGrandMage"); break; 
      } 
      break; 

   case 31: 
      switch (iDice(1,12)) { 
      case 1: if (iDice(1,15) == 3) strcpy(pItemName, "BloodyShockW.Manual"); break; 
      case 2: strcpy(pItemName, "BloodAxe"); break; 
      case 3: if (iDice(1,5) == 3) strcpy(pItemName, "BloodSword"); break; 
      case 4: strcpy(pItemName, "BloodRapier"); break; 
      case 5: if (iDice(1,10) == 3) strcpy(pItemName, "XelimaBlade"); break; 
      case 6: if (iDice(1,10) == 3) strcpy(pItemName, "XelimaAxe"); break; 
      case 7: if (iDice(1,10) == 3) strcpy(pItemName, "XelimaRapier"); break; 
      case 8: if (iDice(1,5) == 3)  strcpy(pItemName, "MassFireStrikeManual"); break; 
      case 9: if (iDice(1,10) == 3)  strcpy(pItemName, "RingOfDemonpower"); break; 
      case 10: if (iDice(1,10) == 3) strcpy(pItemName, "KnecklaceOfEfreet"); break; 
      case 11: if (iDice(1,20) == 3)  strcpy(pItemName, "RingOfXelima"); break; 
      case 12: if (iDice(1,30) == 3) strcpy(pItemName, "RingOftheAbaddon"); break; 
      } 
      break; 
   } 
    
   if (strlen(pItemName) == 0) 
       return FALSE; 
   else return TRUE; 
} 

void CGame::UpdateMapSectorInfo()
{
 int i, ix, iy;
 int iMaxNeutralActivity, iMaxAresdenActivity, iMaxElvineActivity, iMaxMonsterActivity, iMaxPlayerActivity;
 int iMaxNx, iMaxNy, iMaxAx, iMaxAy, iMaxEx, iMaxEy, iMaxMx, iMaxMy, iMaxPx, iMaxPy;
	
	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
	
		iMaxNeutralActivity = iMaxAresdenActivity = iMaxElvineActivity = iMaxMonsterActivity = iMaxPlayerActivity = 0;	
		m_pMapList[i]->m_iMaxNx = m_pMapList[i]->m_iMaxNy = m_pMapList[i]->m_iMaxAx = m_pMapList[i]->m_iMaxAy = 0;
		m_pMapList[i]->m_iMaxEx = m_pMapList[i]->m_iMaxEy = m_pMapList[i]->m_iMaxMx = m_pMapList[i]->m_iMaxMy = 0;
		m_pMapList[i]->m_iMaxPx = m_pMapList[i]->m_iMaxPy = 0;

		// ±×µ¿¾È ÀúÀåÇß´ø TempSectorInfo¿¡¼­ Á¤º¸¸¦ ¾ò¾î SectorInfo¿¡ ÀúÀåÇÑ ´ÙÀ½ TempSectorInfo´Â Áö¿î´Ù.
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity > iMaxNeutralActivity) {
				iMaxNeutralActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iNeutralActivity;
				m_pMapList[i]->m_iMaxNx = ix;
				m_pMapList[i]->m_iMaxNy = iy;
			}
			
			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity > iMaxAresdenActivity) {
				iMaxAresdenActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iAresdenActivity;
				m_pMapList[i]->m_iMaxAx = ix;
				m_pMapList[i]->m_iMaxAy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity > iMaxElvineActivity) {
				iMaxElvineActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iElvineActivity;
				m_pMapList[i]->m_iMaxEx = ix;
				m_pMapList[i]->m_iMaxEy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity > iMaxMonsterActivity) {
				iMaxMonsterActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iMonsterActivity;
				m_pMapList[i]->m_iMaxMx = ix;
				m_pMapList[i]->m_iMaxMy = iy;
			}

			if (m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity > iMaxPlayerActivity) {
				iMaxPlayerActivity = m_pMapList[i]->m_stTempSectorInfo[ix][iy].iPlayerActivity;
				m_pMapList[i]->m_iMaxPx = ix;
				m_pMapList[i]->m_iMaxPy = iy;
			}
		}
	
		// TempSectorInfo ³¯¸°´Ù.
		m_pMapList[i]->ClearTempSectorInfo();

		// Sector Info¿¡ ÀúÀå
		if (m_pMapList[i]->m_iMaxNx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxNx][m_pMapList[i]->m_iMaxNy].iNeutralActivity++;
		if (m_pMapList[i]->m_iMaxAx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxAx][m_pMapList[i]->m_iMaxAy].iAresdenActivity++;
		if (m_pMapList[i]->m_iMaxEx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxEx][m_pMapList[i]->m_iMaxEy].iElvineActivity++;
		if (m_pMapList[i]->m_iMaxMx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxMx][m_pMapList[i]->m_iMaxMy].iMonsterActivity++;
		if (m_pMapList[i]->m_iMaxPx > 0) m_pMapList[i]->m_stSectorInfo[m_pMapList[i]->m_iMaxPx][m_pMapList[i]->m_iMaxPy].iPlayerActivity++;
	}
}


void CGame::AgingMapSectorInfo()
{
 int i, ix, iy;

	for (i = 0; i < DEF_MAXMAPS; i++) 
	if (m_pMapList[i] != NULL) {
		for (ix = 0; ix < DEF_MAXSECTORS; ix++)
		for (iy = 0; iy < DEF_MAXSECTORS; iy++) {
			m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity--;
			m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity--;
			
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iNeutralActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iAresdenActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iElvineActivity  = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iMonsterActivity = 0;
			if (m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity < 0) m_pMapList[i]->m_stSectorInfo[ix][iy].iPlayerActivity   = 0;
		}
	}
}


BOOL CGame::__bSetConstructionKit(int iMapIndex, int dX, int dY, int iType, int iTimeCost, int iClientH)
{
 int iNamingValue, ix, iy, tX, tY;
 char cNpcName[21], cName[21], cNpcWaypoint[11], cOwnerType;
 short sOwnerH;

	// Å©·ç¼¼ÀÌµå ¸ðµå°¡ ¾Æ´Ï°Å³ª °Ç¼³ÇÑ »ç¶÷ÀÌ °øº´ÀÌ ¾Æ´Ï¸é ¹«½Ã.
	if ((m_bIsCrusadeMode == FALSE) || (m_pClientList[iClientH]->m_iCrusadeDuty != 2)) return FALSE;
	if (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures >= DEF_MAXCRUSADESTRUCTURES) {
		// ÇØ´ç ¸Ê¿¡ Å©·ç¼¼ÀÌµå °Ç¹° °³¼ö Á¦ÇÑ¿¡ °É¸®Áö ¾Ê´Â´Ù¸é
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_NOMORECRUSADESTRUCTURE, NULL, NULL, NULL, NULL);
		return FALSE;
	}

	// ÇØ´ç À§Ä¡¿¡ °ÇÃà¹° NPC¸¦ »ý¼º.
	iNamingValue = m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->iGetEmptyNamingValue();
	if (iNamingValue == -1) {
		// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
	}
	else {

		// ¸ÕÀú ¼³Ä¡ÇÏ°íÀÚ ÇÏ´Â ±ÙÃ³¿¡ ±¸Á¶¹°ÀÌ ¾ø³ª È®ÀÎÇÑ´Ù.
		for (ix = dX -3; ix <= dX +5; ix++)
		for (iy = dY -3; iy <= dX +5; iy++) {
			m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
			if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH]->m_cActionLimit == 5)) return FALSE;
		}

		// NPC¸¦ »ý¼ºÇÑ´Ù.
		ZeroMemory(cNpcName, sizeof(cNpcName));
		if (m_pClientList[iClientH]->m_cSide == 1) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Aresden"); break;
			case 2: strcpy(cNpcName, "CGT-Aresen"); break;
			case 3: strcpy(cNpcName, "MS-Aresden"); break;
			case 4: strcpy(cNpcName, "DT-Aresden"); break;
			}
		}
		else if (m_pClientList[iClientH]->m_cSide == 2) {
			switch (iType) {
			case 1: strcpy(cNpcName, "AGT-Elvine"); break;
			case 2: strcpy(cNpcName, "CGT-Elvine"); break;
			case 3: strcpy(cNpcName, "MS-Elvine"); break;
			case 4: strcpy(cNpcName, "DT-Elvine"); break;
			}
		}
		else return FALSE;
	
		ZeroMemory(cName, sizeof(cName));
		wsprintf(cName, "XX%d", iNamingValue);
		cName[0] = '_';
		cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
		
		ZeroMemory(cNpcWaypoint, sizeof(cNpcWaypoint));

		tX = (int)dX;
		tY = (int)dY;
		if (bCreateNewNpc(cNpcName, cName, m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->m_cName, 0, (rand() % 9), 
			              DEF_MOVETYPE_RANDOM, &tX, &tY, cNpcWaypoint, NULL, NULL, -1, FALSE, FALSE) == FALSE) {
			// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
			m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
		} 
		else {
			// ¼º°ø
			wsprintf(G_cTxt, "Structure(%s) construction begin(%d,%d)!", cNpcName, tX, tY);
			PutLogList(G_cTxt);
			return TRUE;
		}
	}

	return FALSE;
}


BOOL CGame::_bNpcBehavior_ManaCollector(int iNpcH)
{
 int dX, dY, iMaxMP, iTotal;
 short sOwnerH;
 char  cOwnerType;
 double dV1, dV2, dV3;
 BOOL bRet;

	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	bRet = FALSE;
	// NPC ÁÖº¯¿¡ ÀÖ´Â Ä³¸¯ÅÍµéÀÇ ¸¶³ª¸¦ ¿Ã·ÁÁØ´Ù.
	for (dX = m_pNpcList[iNpcH]->m_sX-5; dX <= m_pNpcList[iNpcH]->m_sX+5; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-5; dY <= m_pNpcList[iNpcH]->m_sY+5; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);
		
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				// °°Àº ÆíÀÎ °æ¿ì ¸¶³ª¸¦ ¿Ã·ÁÁØ´Ù.
				if (m_pNpcList[iNpcH]->m_cSide == m_pClientList[sOwnerH]->m_cSide) {
					iMaxMP = (2*m_pClientList[sOwnerH]->m_iMag) + (2*m_pClientList[sOwnerH]->m_iLevel) + (m_pClientList[sOwnerH]->m_iInt/2); // v1.4
					if (m_pClientList[sOwnerH]->m_iMP < iMaxMP) {
						iTotal = iDice(1, (m_pClientList[sOwnerH]->m_iMag) ); // Mana Point´Â 1D(Magic)¾¿ ¿Ã¶ó°£´Ù.
						if (m_pClientList[sOwnerH]->m_iAddMP != 0) {
							dV2 = (double)iTotal;
							dV3 = (double)m_pClientList[sOwnerH]->m_iAddMP;
							dV1 = (dV3 / 100.0f)*dV2;
							iTotal += (int)dV1;
						}

						m_pClientList[sOwnerH]->m_iMP += iTotal;
		
						if (m_pClientList[sOwnerH]->m_iMP > iMaxMP) 
							m_pClientList[sOwnerH]->m_iMP = iMaxMP;

						SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_MP, NULL, NULL, NULL, NULL);
					}
				}
				break;

			case DEF_OWNERTYPE_NPC:
				// ±ÙÃ³¿¡ ¸¶³ª ½ºÅæÀÌ ÀÖ³ª Ã£´Â´Ù.
				if (m_pNpcList[sOwnerH]->m_sType == 42) {
					// ¸¶³ª ½ºÅæÀÌ ÀÖ´Ù. ¸¶³ª ½ºÅæÀÌ °®°í ÀÖ´Â ¸¶³ª¸¦ ¾ò´Â´Ù.
					//testcode
					//wsprintf(G_cTxt, "Side: %d  Mana: %d", m_pNpcList[iNpcH]->m_cSide, m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide]);
					//PutLogList(G_cTxt);
					m_iCollectedMana[m_pNpcList[iNpcH]->m_cSide]++; 
					bRet = TRUE;
				}
				break;
			}
		}
	}

	return bRet;
}


BOOL CGame::_bNpcBehavior_Detector(int iNpcH)
{
int dX, dY;
 short sOwnerH;
 char  cOwnerType, cSide;
;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              
 BOOL  bFlag = FALSE;
                       
	if (m_pNpcList[iNpcH] == NULL) return FALSE;
	if (m_pNpcList[iNpcH]->m_sAppr2 != 0) return FALSE;

	// NPC ÁÖº¯¿¡ ÀÖ´Â Àû Ä³¸¯ÅÍ¸¦ Å½ÁöÇØ °æº¸¸¦ ¿ï¸°´Ù.
	for (dX = m_pNpcList[iNpcH]->m_sX-10; dX <= m_pNpcList[iNpcH]->m_sX+10; dX++)
	for (dY = m_pNpcList[iNpcH]->m_sY-10; dY <= m_pNpcList[iNpcH]->m_sY+10; dY++) {
		m_pMapList[m_pNpcList[iNpcH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, dX, dY);

		cSide = 0;
		if (sOwnerH != NULL) {
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				cSide = m_pClientList[sOwnerH]->m_cSide;
				break;

			case DEF_OWNERTYPE_NPC:
				cSide = m_pNpcList[sOwnerH]->m_cSide;
				break;
			}
		}

		if ((cSide != 0) && (cSide != m_pNpcList[iNpcH]->m_cSide)) {
			// ÀûÀÌ´Ù. Åõ¸í»óÅÂ¶ó¸é Åõ¸íÀ» Ç¬´Ù.
			switch (cOwnerType) {
			case DEF_OWNERTYPE_PLAYER:
				if (m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pClientList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;

			case DEF_OWNERTYPE_NPC:
				if (m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] != NULL) {
					m_pNpcList[sOwnerH]->m_cMagicEffectStatus[ DEF_MAGICTYPE_INVISIBILITY ] = NULL;
					SetInvisibilityFlag(sOwnerH, cOwnerType, FALSE);			
				}
				break;
			}
			
			bFlag = TRUE;
		}
	}

	return bFlag;
}


void CGame::CheckCrusadeResultCalculation(int iClientH)
{
	if (m_pClientList[iClientH] == NULL) return;

	// Àü¸éÀüÀÌ Á¾·áµÇ¾ú°í ÀüÀï °øÇåµµ°¡ 0ÀÌ ¾Æ´Ï¶ó¸é ÇØ´çÇÏ´Â Ã³¸®¸¦ ÇØ ÁÖ¾î¾ß ÇÑ´Ù.
	if ((m_bIsCrusadeMode == FALSE) && (m_pClientList[iClientH]->m_dwCrusadeGUID != 0)) {
		
		if (m_pClientList[iClientH]->m_dwCrusadeGUID == m_dwCrusadeGUID) {
			if (m_iCrusadeWinnerSide == 0) {
				// ÀüÀï¿¡¼­ ºñ°å´Ù. ¾çÂÊ ¸ðµÎ¿¡°Ô ¿ø·¡ °æÇèÄ¡ Á¦°ø
				m_pClientList[iClientH]->m_iExpStock += (m_pClientList[iClientH]->m_iWarContribution/6);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		
			}
			else {
				if (m_iCrusadeWinnerSide == m_pClientList[iClientH]->m_cSide) {
					// Æ÷»óÇØ¾ß ÇÑ´Ù.
					// ·¹º§¸¸Å­ ±âº» °æÇèÄ¡ Ãß°¡.
					if (m_pClientList[iClientH]->m_iLevel <= 80) {
						m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel*100;
					}
					else m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					// °æÇèÄ¡ ´©Àû
					m_pClientList[iClientH]->m_iExpStock += m_pClientList[iClientH]->m_iWarContribution;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, m_pClientList[iClientH]->m_iWarContribution, NULL);		
				}
				else if (m_iCrusadeWinnerSide != m_pClientList[iClientH]->m_cSide) {
					// ÀüÀï¿¡¼­ Á³±â¶§¹®¿¡ Æ÷»óÀÌ ¾ø´Ù.
					// ·¹º§¸¸Å­ ±âº» °æÇèÄ¡ Ãß°¡.
					m_pClientList[iClientH]->m_iWarContribution += m_pClientList[iClientH]->m_iLevel;
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, -1*m_pClientList[iClientH]->m_iWarContribution, NULL);		
				}
			}
		}
		else {
			// Å©·ç¼¼ÀÌµå GUID°¡ ´Ù¸£´Ù. Æ÷»ó ºÒ°¡.
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, 0, NULL, -1);		
		}
		
		m_pClientList[iClientH]->m_iCrusadeDuty     = 0;
		m_pClientList[iClientH]->m_iWarContribution = 0;
		m_pClientList[iClientH]->m_dwCrusadeGUID    = 0;
		// ¼Óµµ Á¶ÀÛ Ã¼Å© ·çÆ¾¿¡ °É¸®Áö ¾Ê°Ô²û Ã³¸®.
		m_pClientList[iClientH]->m_dwSpeedHackCheckTime = timeGetTime();
		m_pClientList[iClientH]->m_iSpeedHackCheckExp = m_pClientList[iClientH]->m_iExp;
	}
}


void CGame::LocalStartCrusadeMode(DWORD dwCrusadeGUID)
{
 int i;

	if (m_bIsCrusadeMode == TRUE) return;
	m_bIsCrusadeMode = TRUE;
	m_iCrusadeWinnerSide = 0;

	if (dwCrusadeGUID != NULL) {
		// Å©·ç¼¼ÀÌµå GUID ÆÄÀÏÀ» ¸¸µç´Ù.
		_CreateCrusadeGUID(dwCrusadeGUID, NULL);
		m_dwCrusadeGUID = dwCrusadeGUID;
	}

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ½ÃÀÛµÇ¾úÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		m_pClientList[i]->m_dwCrusadeGUID = m_dwCrusadeGUID;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[i]->m_iCrusadeDuty, NULL, NULL);
	}

	// ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ® HP ÃÊ±âÈ­.
	for (i = 0; i < DEF_MAXMAPS; i++)
	if (m_pMapList[i] != NULL) m_pMapList[i]->RestoreStrikePoints();

	// °¢°¢ÀÇ ¸Ê¿¡ ÃÊ±â °Ç¹° ¼³Ä¡. (¸¶³ª ½ºÅæ, ¿¡³ÊÁö ½Çµå Á¦³×·¹ÀÌÅÍ, ±×·¹ÀÌÆ® ¸ÅÁ÷ Á¦³×·¹ÀÌÅÍ, °¡µåÅ¸¿öµîµî)
	CreateCrusadeStructures();
	
	PutLogList("(!)Crusade Mode ON.");
}

void CGame::LocalEndCrusadeMode(int iWinnerSide)
{
 int i;

	//testcode
	wsprintf(G_cTxt, "LocalEndCrusadeMode(%d)", iWinnerSide);
	PutLogList(G_cTxt);

	if (m_bIsCrusadeMode == FALSE) return;
	m_bIsCrusadeMode = FALSE;

	PutLogList("(!)Crusade Mode OFF.");

	// ¼³Ä¡µÇ¾ú´ø Å©·ç¼¼ÀÌµå °ÇÃà¹° Á¦°Å.
	RemoveCrusadeStructures();

	// ÀÌ±äÂÊ »çÀÌµå¸¦ ÀÔ·Â.
	_CreateCrusadeGUID(m_dwCrusadeGUID, iWinnerSide);
	m_iCrusadeWinnerSide = iWinnerSide;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
		// ¸ðµç Å¬¶óÀÌ¾ðÆ®¿¡°Ô Àü¸éÀü ¸ðµå°¡ ³¡³µÀ½À» ¾Ë·ÁÁØ´Ù. ¸ÃÀº ÀÓ¹« Å¬¸®¾î ÈÄ Åëº¸ÇÔ.
		m_pClientList[i]->m_iCrusadeDuty = 0;
		m_pClientList[i]->m_iConstructionPoint = 0;
		SendNotifyMsg(NULL, i, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, NULL, NULL, NULL, m_iCrusadeWinnerSide);
	}
}


void CGame::SaveOccupyFlagData()
{
 char * pData;
 int iSize;
 FILE * pFile;

	PutLogList("(!) Middleland OccupyFlag data saved.");
		
	pData = new char[1000000+1];
	if (pData == NULL) return;
	ZeroMemory(pData, 1000000);
			
	iSize = _iComposeFlagStatusContents(pData);
	
	_mkdir("GameData");

	pFile = fopen("GameData\\OccupyFlag.txt", "wt");
	if (pFile == NULL) return;

	fwrite(pData, 1, iSize, pFile);

	delete pData;
	fclose(pFile);
}


void CGame::CreateCrusadeStructures()
{
 int i, z, tX, tY, iNamingValue;
 char cName[6], cNpcName[21], cNpcWayPoint[11];

	ZeroMemory(cName, sizeof(cName));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));

	for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) 
	if (m_stCrusadeStructures[i].cType != NULL) {
		for (z = 0; z < DEF_MAXMAPS; z++)
		if ((m_pMapList[z] != NULL) && (strcmp(m_pMapList[z]->m_cName, m_stCrusadeStructures[i].cMapName) == 0)) {
			// À§Ä¡°¡ ÀÏÄ¡ÇÏ´Â ¸Ê¿¡ °ÇÃà¹°À» À§Ä¡½ÃÅ²´Ù.
			iNamingValue = m_pMapList[z]->iGetEmptyNamingValue();
			if (iNamingValue == -1) {
				// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
				// ÀÌ·± ÀÏÀÌ?
			}
			else {
				// NPC¸¦ »ý¼ºÇÑ´Ù.
				wsprintf(cName, "XX%d", iNamingValue);
				cName[0] = '_';
				cName[1] = z+65;
				
				switch (m_stCrusadeStructures[i].cType) {
				case 36:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "AGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "AGT-Elvine");
					break;

				case 37: 
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "CGT-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "CGT-Elvine");
					break;

				case 40:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "ESG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "ESG-Elvine");
					break;

				case 41:
					if (strcmp(m_pMapList[z]->m_cName, "aresden") == 0)
						 strcpy(cNpcName, "GMG-Aresden");
					else if (strcmp(m_pMapList[z]->m_cName, "elvine") == 0)
						strcpy(cNpcName, "GMG-Elvine");
					break;

				default: 
					strcpy(cNpcName, m_pNpcConfigList[m_stCrusadeStructures[i].cType]->m_cNpcName); 
					break;
				}

				tX = (int)m_stCrusadeStructures[i].dX;
				tY = (int)m_stCrusadeStructures[i].dY;
				if (bCreateNewNpc(cNpcName, cName, m_pMapList[z]->m_cName, 0, 0, DEF_MOVETYPE_RANDOM, 
					              &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE) == FALSE) {
					// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
					m_pMapList[ m_pClientList[i]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				} 
				else {
					wsprintf(G_cTxt, "(!) Creating Crusade Structure(%s) at %s(%d, %d)", cNpcName, m_stCrusadeStructures[i].cMapName, tX, tY);
					PutLogList(G_cTxt);
				}
			}
		}
	}
}


void CGame::SendCollectedMana()
{
 char * cp, cData[120];
 WORD * wp;

	//SendMsgToGateServer(MSGID_COLLECTEDMANA, NULL);

	// ¸ðÀÎ ¸¶³ª°¡ ¾ø´Ù¸é ¸Þ½ÃÁö Àü¼ÛÇÏÁö ¾Ê´Â´Ù. ¸¶³ª ½ºÅæÀÌ ¾ø´Â ¸Ê¿¡¼­ ¸Þ½ÃÁö¸¦ Àü¼ÛÇÏ¸é ¾ÈµÈ´Ù.
	if ((m_iCollectedMana[1] == 0) && m_iCollectedMana[2] == 0) return;

	//testcode
	//wsprintf(G_cTxt, "Sending Collected Mana: %d %d", m_iCollectedMana[1], m_iCollectedMana[2]);
	//PutLogList(G_cTxt);

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp = GSM_COLLECTEDMANA;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[1];
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)m_iCollectedMana[2];
	cp += 2;

	bStockMsgToGateServer(cData, 5);

	// ±×µ¿¾È ¸ðÀº ¸¶³ª·® º¸³»°í Å¬¸®¾î.
	m_iCollectedMana[0] = 0;
	m_iCollectedMana[1] = 0;
	m_iCollectedMana[2] = 0;
}


void CGame::CollectedManaHandler(WORD wAresdenMana, WORD wElvineMana)
{
	//wsprintf(G_cTxt, "Collected Mana Handler %d %d      %d %d",  wAresdenMana, wElvineMana, m_iAresdenMapIndex, m_iElvineMapIndex);
	//PutLogList(G_cTxt);

	if (m_iAresdenMapIndex != -1) {
		m_iAresdenMana += wAresdenMana;
		//testcode
		if (wAresdenMana > 0) {
			//wsprintf(G_cTxt, "Aresden Mana: %d Total:%d", wAresdenMana, m_iAresdenMana);
			//PutLogList(G_cTxt);
		}
	}

	if (m_iElvineMapIndex != -1) {
		m_iElvineMana += wElvineMana;
		//testcode
		if (wAresdenMana > 0) {
			//wsprintf(G_cTxt, "Elvine Mana: %d Total:%d", wElvineMana, m_iElvineMana);
			//PutLogList(G_cTxt);
		}
	}
}


void CGame::_NpcBehavior_GrandMagicGenerator(int iNpcH)
{
	switch (m_pNpcList[iNpcH]->m_cSide) {
	case 1:
		if (m_iAresdenMana > DEF_GMGMANACONSUMEUNIT) {
			// ¸¶³ª¸¦ Èí¼öÇÑ´Ù.
			m_iAresdenMana -= DEF_GMGMANACONSUMEUNIT;
			m_pNpcList[iNpcH]->m_iManaStock++;
			// ¸¸¾à ¸¶¹ý °ø°ÝÀ» ÇÏ±â¿¡ ÃæºÐÇÑ ¸¶³ª°¡ Ã¡´Ù¸é Àû±¹À¸·Î ¸¶¹ý °ø°Ý
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// ¸ÞÅ×¿À ½ºÆ®¶óÀÌÆ® ½Ã±×³Î
				_GrandMagicLaunchMsgSend(1, 1);
				MeteorStrikeMsgHandler(1);
				// ¸¶³ª Å¬¸®¾î
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iAresdenMana = 0;
				// °ø°Ý µ¿ÀÛÀ» ÇÑ´Ù.
			}
		}
		break;

	case 2:
		if (m_iElvineMana > DEF_GMGMANACONSUMEUNIT) {
			// ¸¶³ª¸¦ Èí¼öÇÑ´Ù.
			m_iElvineMana -= DEF_GMGMANACONSUMEUNIT;
			m_pNpcList[iNpcH]->m_iManaStock++;
			// ¸¸¾à ¸¶¹ý °ø°ÝÀ» ÇÏ±â¿¡ ÃæºÐÇÑ ¸¶³ª°¡ Ã¡´Ù¸é Àû±¹À¸·Î ¸¶¹ý °ø°Ý
			if (m_pNpcList[iNpcH]->m_iManaStock > m_pNpcList[iNpcH]->m_iMaxMana) {
				// ¸ÞÅ×¿À ½ºÆ®¶óÀÌÆ® ½Ã±×³Î
				_GrandMagicLaunchMsgSend(1, 2);
				MeteorStrikeMsgHandler(2);
				// ¸¶³ª Å¬¸®¾î
				m_pNpcList[iNpcH]->m_iManaStock = 0;
				m_iElvineMana = 0;
				// °ø°Ý µ¿ÀÛÀ» ÇÑ´Ù.
			}
		}
		break;
	}
}


void CGame::MeteorStrikeMsgHandler(char cAttackerSide)
{
 int i;
 DWORD dwTime = timeGetTime();
	
	switch (cAttackerSide) {
	case 1:
		// ¾Æ·¹½ºµ§ ÃøÀÇ Æø°ÝÀÌ´Ù. µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·Ï
		if (m_iElvineMapIndex != -1) {
			// ÇöÀç ¼­¹ö¿¡ Æø°Ý ÁöÁ¡ÀÌ ÀÖ´Ù.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "elvine") == 0) {
					// ¿¤¹ÙÀÎ¿¡ ¼Ò¼ÓµÈ ¸ÊÀÇ ¸ðµç ÇÃ·¹ÀÌ¾î¿¡°Ô ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°ÝÀÌ ÀÓ¹ÚÇßÀ½À» ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 1, NULL, NULL, NULL);
				}
				else {
					// ´Ù¸¥ ¸ÊÀÇ ÇÃ·¹ÀÌ¾î¿¡°Ôµµ ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
				}
			}
			// 5ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý È¿°ú
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iElvineMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// ´Ù¸¥ ¸ÊÀÇ ÇÃ·¹ÀÌ¾î¿¡°Ôµµ ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 2, NULL, NULL, NULL);
			}
		}
		break;

	case 2:
		// ¿¤¹ÙÀÎ ÃøÀÇ Æø°ÝÀÌ´Ù. µô·¹ÀÌ ÀÌº¥Æ®¿¡ µî·Ï
		if (m_iAresdenMapIndex != -1) {
			// ÇöÀç ¼­¹ö¿¡ Æø°Ý ÁöÁ¡ÀÌ ÀÖ´Ù.
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE)) {
				if (strcmp(m_pMapList[m_pClientList[i]->m_cMapIndex]->m_cLocationName, "aresden") == 0) {
					// ¾Æ·¹½ºµ§¿¡ ¼Ò¼ÓµÈ ¸ÊÀÇ ¸ðµç ÇÃ·¹ÀÌ¾î¿¡°Ô ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°ÝÀÌ ÀÓ¹ÚÇßÀ½À» ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 3, NULL, NULL, NULL);
				}
				else {
					// ´Ù¸¥ ¸ÊÀÇ ÇÃ·¹ÀÌ¾î¿¡°Ôµµ ¾Ë·ÁÁØ´Ù.
					SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
				}
			}
			// 5ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý È¿°ú
			bRegisterDelayEvent(DEF_DELAYEVENTTYPE_METEORSTRIKE, NULL, dwTime + 1000*5, NULL, NULL, m_iAresdenMapIndex, NULL, NULL, NULL, NULL, NULL);
		}
		else {
			for (i = 1; i < DEF_MAXCLIENTS; i++)
			if (m_pClientList[i] != NULL) {
				// ´Ù¸¥ ¸ÊÀÇ ÇÃ·¹ÀÌ¾î¿¡°Ôµµ ¾Ë·ÁÁØ´Ù.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKECOMING, 4, NULL, NULL, NULL);
			}
		}
		break;
	}
}

void CGame::_LinkStrikePointMapIndex()
{
 int i, z, x;

	// ¸¶À»°ú °Ç¹° ³»ºÎ¸¦ ´Ù¸¥ ¼­¹ö¿¡ ¶ç¿ì¸é ¸µÅ©°¡ ºÒ°¡´ÉÇÏ¹Ç·Î ´Ù¿îµÈ´Ù!
	for (i = 0; i < DEF_MAXMAPS; i++)
	if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_iTotalStrikePoints != 0)) {
		// ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®°¡ Á¤ÀÇµÈ ¸ÊÀÌ´Ù. °¢°¢ÀÇ ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®¿Í ¿¬°èµÈ ¸ÊÀÇ ÀÎµ¦½º¸¦ ±¸ÇØ ÀúÀåÇÑ´Ù.
		for (z = 0; z < DEF_MAXSTRIKEPOINTS; z++) 
		if (strlen(m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) != 0) {
			for (x = 0; x < DEF_MAXMAPS; x++) 
			if ((m_pMapList[x] != NULL) && (strcmp(m_pMapList[x]->m_cName,m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName) == 0)) {
				// ÀÎµ¦½º¸¦ ±¸Çß´Ù. ÀúÀåÇÑ´Ù.
				m_pMapList[i]->m_stStrikePoint[z].iMapIndex = x;
				//testcode
				wsprintf(G_cTxt, "(!) Map(%s) Strike Point(%d) Related Map(%s) Index(%d)", m_pMapList[i]->m_cName, z, m_pMapList[i]->m_stStrikePoint[z].cRelatedMapName, x);
				PutLogList(G_cTxt);

				goto LSPMI_LOOPBREAK;
			}
LSPMI_LOOPBREAK:;
		}
	}
}


void CGame::MeteorStrikeHandler(int iMapIndex)
{
 int i, ix, iy, dX, dY, iIndex, iTargetIndex, iTotalESG, iEffect;
 int iTargetArray[DEF_MAXSTRIKEPOINTS], iTotalTargets;
 short sOwnerH;
 char  cOwnerType;
 DWORD dwTime = timeGetTime();
	
	PutLogList("(!) Beginning Meteor Strike Procedure...");

	if (iMapIndex == -1) {
		PutLogList("(X) MeteorStrikeHandler Error! MapIndex -1!");
		return;
	}
	
	if (m_pMapList[iMapIndex] == NULL) {
		PutLogList("(X) MeteorStrikeHandler Error! NULL Map!");
		return;
	}
	
	if (m_pMapList[iMapIndex]->m_iTotalStrikePoints == 0) {
		PutLogList("(X) MeteorStrikeHandler Error! No Strike Points!");
		return;
	}
	
	for (i = 0; i < DEF_MAXSTRIKEPOINTS; i++) iTargetArray[i] = -1;

	iIndex = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iTargetArray[iIndex] = i; // ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®ÀÇ ÀÎµ¦½º¸¦ ³Ö´Â´Ù.
			iIndex++;
		}
	}

	//testcode
	wsprintf(G_cTxt, "(!) Map(%s) has %d available strike points", m_pMapList[iMapIndex]->m_cName, iIndex);
	PutLogList(G_cTxt);

	// °á°ú º¸°í¿ë ½ºÆ®·°Ãç Å¬¸®¾î
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;

	if (iIndex == 0) {
		// Æø°ÝÇÒ °Ç¹°ÀÌ ¾ø´Ù. ¸ðµÎ ÆÄ±«µÇ¾ú´Ù.
		PutLogList("(!) No strike points!");
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
	else {

		// ÇØ´ç ¸ÊÀÇ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¸ÞÅ×¿À °ø°Ý È¿°ú¸¦ º¸¿©ÁÖ¶ó´Â ¸Þ½ÃÁö Àü¼Û
		for (i = 1; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_bIsInitComplete == TRUE) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
			SendNotifyMsg(NULL, i, DEF_NOTIFY_METEORSTRIKEHIT, NULL, NULL, NULL, NULL);
		}
		
		for (i = 0; i < iIndex; i++) {
			// ¸ðµç Æø°Ý ¸ñÇ¥¿¡ ´ëÇØ µ¿ÀÏÇÑ °ø°ÝÀ» °¡ÇÑ´Ù.
			iTargetIndex = iTargetArray[i];

			if (iTargetIndex == -1) {
				PutLogList("(X) Strike Point MapIndex: -1!");
				goto MSH_SKIP_STRIKE;
			}

			dX = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dX;
			dY = m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].dY;

			// dX, dY À§Ä¡ ÁÖÀ§¿¡ ÃÖ¼Ò 2°³ ÀÌ»óÀÇ Energy Shield Generator°¡ Á¸ÀçÇÏ¸é ½ºÆ®¶óÀÌÅ© Æ÷ÀÎÆ®´Â ¹«»çÇÏ´Ù. ±×·¯³ª 1°³ ÀÌÇÏÀÌ¸é °ø°Ý¹Þ¾ÒÀ»¶§ HP°¡ ÁÙ¾îµç´Ù.
			// NPC ÁÖº¯¿¡ ÀÖ´Â Àû Ä³¸¯ÅÍ¸¦ Å½ÁöÇØ °æº¸¸¦ ¿ï¸°´Ù.
			iTotalESG = 0;
			for (ix = dX-10; ix <= dX+10; ix++) 
			for (iy = dY-10; iy <= dY+10; iy++) {
				m_pMapList[iMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
				if ((cOwnerType == DEF_OWNERTYPE_NPC) && (m_pNpcList[sOwnerH] != NULL) && (m_pNpcList[sOwnerH]->m_sType == 40)) {
					iTotalESG++;
				}
			}
			
			// testcode
			wsprintf(G_cTxt, "(!) Meteor Strike Target(%d, %d) ESG(%d)", dX, dY, iTotalESG);
			PutLogList(G_cTxt);

			if (iTotalESG < 2) {
			
				m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP -= (2 - iTotalESG);
				if (m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP <= 0) {
					// °Ç¹°ÀÌ ÆÄ±«µÇ¾ú´Ù.
					m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iHP = 0;
					// °Ç¹° ±â´É »ó½Ç
					m_pMapList[m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iMapIndex]->m_bIsDisabled = TRUE;
					m_stMeteorStrikeResult.iCrashedStructureNum++;
				}
				else {
					// °Ç¹°ÀÌ ´ë¹ÌÁö¸¦ ¾ò¾ú´Ù.
					m_stMeteorStrikeResult.iStructureDamageAmount += (2 - iTotalESG);
					// °Ç¹° ´ë¹ÌÁö ÀÔÀº ÈÄ ºÒÅ¸´Â ÀÌ¹ÌÁö »ðÀÔ 
					iEffect = iDice(1,5)-1;
					iAddDynamicObjectList(NULL, DEF_OWNERTYPE_PLAYER_INDIRECT, DEF_DYNAMICOBJECT_FIRE2, iMapIndex, 
						                  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectX[iEffect] +(iDice(1,3) -2), 
										  m_pMapList[iMapIndex]->m_stStrikePoint[iTargetIndex].iEffectY[iEffect] +(iDice(1,3) -2), 60*1000*50);
				}
			}
MSH_SKIP_STRIKE:;
		}

		// 1ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 1000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 4ÃÊ ÈÄ ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© °ø°Ý ´ë¹ÌÁö È¿°ú
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_DOMETEORSTRIKEDAMAGE, NULL, dwTime + 4000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
		// 6ÃÊ ÈÄ °ø°Ý °á°ú ÆÇ´Ü.
		bRegisterDelayEvent(DEF_DELAYEVENTTYPE_CALCMETEORSTRIKEEFFECT, NULL, dwTime + 6000, NULL, NULL, iMapIndex, NULL, NULL, NULL, NULL, NULL);
	}
}


void CGame::RequestSetGuildTeleportLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// °ÔÀÌÆ® ¼­¹ö ¸Þ½ÃÁö ÀÛ¼º 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDTELEPORTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½ÅÈÄ 
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
				
			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;

			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;

	//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestSetGuildConstructLocHandler(int iClientH, int dX, int dY, int iGuildGUID, char * pMapName)
{
 char * cp, cData[120];
 register int i;
 int *ip, iIndex;
 DWORD dwTemp, dwTime;

	if (m_pClientList[iClientH] == NULL) return;

	// °ÔÀÌÆ® ¼­¹ö ¸Þ½ÃÁö ÀÛ¼º 
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_SETGUILDCONSTRUCTLOC;
	cp++;

	ip = (int *)cp;
	*ip = iGuildGUID;
	cp += 4;

	ip = (int *)cp;
	*ip = dX;
	cp += 4;

	ip = (int *)cp;
	*ip = dY;
	cp += 4;
	
	memcpy(cp, pMapName, 10);
	cp += 10;
	//

	dwTime = timeGetTime();

	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÄÁ½ºÆ®·°Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù. 
	// ÅÚ·¹Æ÷Æ® À§Ä¡ÀÇ 2¹ø º¯¼öµéÀ» »ç¿ëÇÑ´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½ÅÈÄ 
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
				
			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
			bStockMsgToGateServer(cData, 23);
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

			//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û  
			bStockMsgToGateServer(cData, 23);
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstructLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;

	//°ÔÀÌÆ® ¼­¹ö¸¦ ÅëÇØ ´Ù¸¥ ¼­¹ö·Î Á¤º¸ Àü¼Û
	bStockMsgToGateServer(cData, 23);
}

void CGame::RequestGuildTeleportHandler(int iClientH)
{
 register int i;
 char cMapName[11];
	
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iLockedMapTime != NULL) {
		// ¸Ê¿¡ °®Çû´Ù¸é ±× ½Ã°£µ¿¾È ÅÚ·¹Æ÷Æ® ºÒ°¡´É.
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_LOCKEDMAP, m_pClientList[iClientH]->m_iLockedMapTime, NULL, NULL, m_pClientList[iClientH]->m_cLockedMapName);
		return;
	}

	for (i = 0; i < DEF_MAXGUILDS; i++) 
	if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
		// ±æµå¸¦ Ã£¾Ò´Ù.
		ZeroMemory(cMapName, sizeof(cMapName));
		strcpy(cMapName, m_pGuildTeleportLoc[i].m_cDestMapName);

		//testcode
		wsprintf(G_cTxt, "ReqGuildTeleport: %d %d %d %s", m_pClientList[iClientH]->m_iGuildGUID, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY, cMapName);
		PutLogList(G_cTxt);

		// !!! RequestTeleportHandler³»¿¡¼­ m_cMapNameÀ» ¾²±â ¶§¹®¿¡ ±×´ë·Î ÆÄ¶ó¹ÌÅÍ·Î ³Ñ°ÜÁÖ¸é ¿Àµ¿ÀÛ
		RequestTeleportHandler(iClientH, "2   ", cMapName, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY);
		return;
	}
	
	// ±æµå¿¡ ÇÒ´çµÈ ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¾ø´Ù. ±æµå ¼Ò¼ÓÀÌ ¾Æ´Ñ °æ¿ì
	switch (m_pClientList[iClientH]->m_cSide) {
	case 1: // ¾Æ·¹½ºµ§ ¼Ò¼Ó 
		break;
	case 2: // ¿¤¹ÙÀÎ ¼Ò¼Ó
		break;
	}
}

void CGame::RequestSummonWarUnitHandler(int iClientH, int dX, int dY, char cType, char cNum, char cMode)
{
 char * cp, cName[6], cNpcName[21], cMapName[11], cNpcWayPoint[11], cOwnerType;
 register int i, x;
 int *ip, iNamingValue, tX, tY, ix, iy;
 BOOL bRet;
 short sOwnerH;
 DWORD dwTime = timeGetTime();
 
	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_bIsInitComplete == FALSE) return;
	
	ZeroMemory(cNpcWayPoint, sizeof(cNpcWayPoint));
	ZeroMemory(cNpcName, sizeof(cNpcName));
	ZeroMemory(cMapName, sizeof(cMapName));
		
	// ¿¡·¯ Ã¼Å©¿ë 
	if (cType < 0) return;
	if (cType >= DEF_MAXNPCTYPES) return;
	if (cNum  >  10) return;

	// °Ç¼³ÇÏ±â¿¡ Æ÷ÀÎÆ®°¡ ¸ðÀÚ¶õ´Ù.
	if (m_pClientList[iClientH]->m_iConstructionPoint < m_iNpcConstructionPoint[cType]) return;
	// °Ç¹° ³»ºÎ¸é ÀüÀï À¯´ÏÆ® ¼ÒÈ¯ ºÒ°¡.
	if ((m_pMapList[m_pClientList[iClientH]->m_cMapIndex] != NULL) && (m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_bIsFixedDayMode == TRUE)) return; 

	// ÀÏ´Ü ¿¡·¯¹æÁö¿ë
	cNum = 1;

	// ConstructionPoint Á¦ÇÑÀ» °è»êÇÏ°í À¯´ÏÆ® °³¼ö¸¸Å­ ÁÙÀÎ´Ù.
	for (x = 1; x <= cNum; x++) {
		// °³¼ö¸¸Å­  ÀüÀï À¯´ÏÆ® »ý¼º 
		iNamingValue = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->iGetEmptyNamingValue();
		if (iNamingValue == -1) {
			// ´õÀÌ»ó ÀÌ ¸Ê¿¡ NPC¸¦ ¸¸µé¼ö ¾ø´Ù. ÀÌ¸§À» ÇÒ´çÇÒ ¼ö ¾ø±â ¶§¹®.
			// ÀÌ·± ÀÏÀÌ?
		}
		else {
			// NPC¸¦ »ý¼ºÇÑ´Ù.
			ZeroMemory(cName, sizeof(cName));
			wsprintf(cName, "XX%d", iNamingValue);
			cName[0] = '_';
			cName[1] = m_pClientList[iClientH]->m_cMapIndex+65;
			
			// µ¿ÀÏÇÑ Å¸ÀÔÀ» °®Áö¸¸ ´Ù¸¥ »çÀÌµå¸¦ °®´Â °æ¿ì 

			switch (cType) {
			case 43: // Light War Beetle
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "LWB-Aresden"); break;
				case 2: strcpy(cNpcName, "LWB-Elvine"); break;
				}
				break;

			case 36: // Arrow Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "AGT-Aresden"); break;
				case 2: strcpy(cNpcName, "AGT-Elvine"); break;
				}
				break;

			case 37: // Cannon Guard Tower
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CGT-Aresden"); break;
				case 2: strcpy(cNpcName, "CGT-Elvine"); break;
				}
				break;

			case 38: // Mana Collector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "MS-Aresden"); break;
				case 2: strcpy(cNpcName, "MS-Elvine"); break;
				}
				break;

			case 39: // Detector
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "DT-Aresden"); break;
				case 2: strcpy(cNpcName, "DT-Elvine"); break;
				}
				break;

			case 51: // Catapult
				switch (m_pClientList[iClientH]->m_cSide) {
				case 1: strcpy(cNpcName, "CP-Aresden"); break;
				case 2: strcpy(cNpcName, "CP-Elvine"); break;
				}
				break;

			case 44:
				strcpy(cNpcName, "GHK");
				break;

			case 45:
				strcpy(cNpcName, "GHKABS");
				break;

			case 46:
				strcpy(cNpcName, "TK");
				break;

			case 47:
				strcpy(cNpcName, "BG");
				break;
			}

			//testcode
			wsprintf(G_cTxt, "(!) Request Summon War Unit (%d) (%s)", cType, cNpcName);
			PutLogList(G_cTxt);
			
			tX = (int)dX;
			tY = (int)dY;
						
			// ¸¸¾à ÀüÀï °ÇÃà¹°ÀÌ¶ó¸é °ÇÃà À§Ä¡·ÎºÎÅÍ ÀÎÁ¢ÇØ¾ß ÇÑ´Ù.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
			case 38:
			case 39:
				// °Ç¼³ À§Ä¡¸¦ ºñ±³
				if (strcmp(m_pClientList[iClientH]->m_cConstructMapName, m_pClientList[iClientH]->m_cMapName) != 0) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sX - m_pClientList[iClientH]->m_iConstructLocX) > 10) bRet = TRUE;
				if (abs(m_pClientList[iClientH]->m_sY - m_pClientList[iClientH]->m_iConstructLocY) > 10) bRet = TRUE;

				if (bRet == TRUE) {
					// °Ç¼³ À§Ä¡¿Í ³Ê¹« ¸Ö¸® ¹þ¾î³ª ÀÖÀ¸¸é °ÇÃà ºÒ°¡.
					m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
					SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 2, NULL, NULL, NULL);
					return;
				}

				// ±æµå¿¡¼­ °Ç¼³ÇÑ °ÇÃà¹°ÀÇ °¹¼ö¸¦ Ä«¿îÆ®ÇÑ´Ù. ÀÏÁ¤ °¹¼ö ÀÌ»óÀº ÁöÀ» ¼ö ¾ø´Ù.
				/////
				for (i = 0; i < DEF_MAXGUILDS; i++) 
				if (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID) {
					m_pGuildTeleportLoc[i].m_dwTime = dwTime;
					if (m_pGuildTeleportLoc[i].m_iV2 >= DEF_MAXCONSTRUCTNUM) {
						// ±æµå °Ç¼³ °³¼ö ÃÊ°ú. ÁöÀ»¼ö ¾ø´Ù.
						m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
						SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);		
						return;
					}
					else {
						// °Ç¼³µÈ °Ç¹° °¹¼ö Áõ°¡.
						m_pGuildTeleportLoc[i].m_iV2++;
						goto RSWU_LOOPBREAK;
					}
				}

				// ±æµå ¼³Á¤µÇ¾î ÀÖÁö ¾ÊÀ½. ÁöÀ»¼ö ¾ø´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 3, NULL, NULL, NULL);
				return;
				/////
				break;
			}
			
RSWU_LOOPBREAK:;

			// ¸¸¾à ÀüÀï °ÇÃà¹°Áß °¡µåÅ¸¿ö°°ÀÌ °ø°ÝÇüÀÌ¶ó¸é ³Ê¹« ÀÎÁ¢ÇØ¼­ °Ç¼³ÇÒ ¼ö ¾ø´Ù.
			bRet = FALSE;
			switch (cType) {
			case 36:
			case 37:
				for (ix = tX-2; ix <= tX+2; ix++)
				for (iy = tY-2; iy <= tY+2; iy++) {
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
					if ((sOwnerH != NULL) && (cOwnerType == DEF_OWNERTYPE_NPC)) {
						switch (m_pNpcList[sOwnerH]->m_sType) {
						case 36:
						case 37:
							bRet = TRUE;
							break;
						}
					}
				}

				// ÁöÀ» ¼ö ¾ø´Â »óÀ§ÁÂÇ¥
				if ((dY <= 32) || (dY >= 783)) bRet = TRUE;
				break;
			}

			if (bRet == TRUE) {
				// ±ÙÃ³¿¡ °¡µåÅ¸¿öµéÀÌ ÀÖ¾î¼­ °ÇÃàºÒ°¡.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CANNOTCONSTRUCT, 1, NULL, NULL, NULL);
				return;
			}

			// °¡µå ¸ðµåÀÎ°¡ ÃßÁ¾ ¸ðµåÀÎ°¡ ¼±ÅÃ 
			if (cMode == NULL) {
				bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_FOLLOW, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				bSetNpcFollowMode(cName, m_pClientList[iClientH]->m_cCharName, DEF_OWNERTYPE_PLAYER);
			}
			else bRet = bCreateNewNpc(cNpcName, cName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 0, 0, DEF_MOVETYPE_GUARD, &tX, &tY, cNpcWayPoint, NULL, NULL, -1, FALSE, FALSE, FALSE, FALSE, m_pClientList[iClientH]->m_iGuildGUID);
				
			if (bRet == FALSE) {
				// ½ÇÆÐÇßÀ¸¹Ç·Î ¿¹¾àµÈ NameValue¸¦ ÇØÁ¦½ÃÅ²´Ù.
				m_pMapList[ m_pClientList[iClientH]->m_cMapIndex ]->SetNamingValueEmpty(iNamingValue);
			} 
			else {
				// °Ç¼³¿¡ ¼º°øÇßÀ¸¹Ç·Î °Ç¼³ Æ÷ÀÎÆ® °¨¼Ò ½ÃÅ²´Ù.
				m_pClientList[iClientH]->m_iConstructionPoint -= m_iNpcConstructionPoint[cType];
				if (m_pClientList[iClientH]->m_iConstructionPoint < 0) m_pClientList[iClientH]->m_iConstructionPoint = 0;
				// ÁöÈÖ°ü¿¡°Ô ¹Ù·Î Åëº¸.
				SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[iClientH]->m_iConstructionPoint, m_pClientList[iClientH]->m_iWarContribution, NULL, NULL);
			}
		}
	}
}

void CGame::CheckConnectionHandler(int iClientH, char *pData)
{
 char * cp;
 DWORD * dwp, dwTimeRcv, dwTime, dwTimeGapClient, dwTimeGapServer;

	if (m_pClientList[iClientH] == NULL) return;
	
	dwTime = timeGetTime();
	cp = (char *)(pData + DEF_INDEX2_MSGTYPE + 2);
	dwp = (DWORD *)cp;
	dwTimeRcv = *dwp;

	if (m_pClientList[iClientH]->m_dwInitCCTimeRcv == NULL) {
		m_pClientList[iClientH]->m_dwInitCCTimeRcv = dwTimeRcv;
		m_pClientList[iClientH]->m_dwInitCCTime = dwTime;
	}
	else {
		dwTimeGapClient = (dwTimeRcv - m_pClientList[iClientH]->m_dwInitCCTimeRcv);
		dwTimeGapServer = (dwTime - m_pClientList[iClientH]->m_dwInitCCTime);
		
		// Å¬¶óÀÌ¾ðÆ®¿¡¼­ Áö³ª°£ ½Ã°£ÀÌ ´õ Àû´Ù. ¹«½ÃÇØµµ µÈ´Ù. ¼Óµµ¸¦ »ç¿ëÇÑ °æ¿ì´Â ¼­¹öº¸´Ù Å¬¶óÀÌ¾ðÆ®°¡ ½Ã°£ÀÌ ´õ °£ °æ¿ì.
		if (dwTimeGapClient < dwTimeGapServer) return;

		if ((abs(dwTimeGapClient - dwTimeGapServer)) >= (DEF_CLIENTTIMEOUT)) {
			// v1.4334 
			wsprintf(G_cTxt, "(!) Ä³¸¯ÅÍ(%s) ¼Óµµ Á¶ÀÛ %u %u %u %u %u %u ¼ÓµµÂ÷ÀÌ %u", m_pClientList[iClientH]->m_cCharName, dwTimeRcv, m_pClientList[iClientH]->m_dwInitCCTimeRcv, dwTime, m_pClientList[iClientH]->m_dwInitCCTime,dwTimeGapClient,dwTimeGapServer,   dwTimeGapClient - dwTimeGapServer );
			PutLogList(G_cTxt);
			PutLogFileList(G_cTxt);
			/*
			SYSTEMTIME SysTime;
			GetLocalTime(&SysTime);
						
			m_pClientList[iClientH]->m_iPenaltyBlockYear  = SysTime.wYear+1;
			m_pClientList[iClientH]->m_iPenaltyBlockMonth = SysTime.wMonth;
			m_pClientList[iClientH]->m_iPenaltyBlockDay   = SysTime.wDay;
			*/
			DeleteClient(iClientH, TRUE, TRUE);
			return;
		}
	}
}


void CGame::SelectCrusadeDutyHandler(int iClientH, int iDuty)
{
	if (m_pClientList[iClientH] == NULL) return;
	// ±æµå ¸¶½ºÅÍ°¡ ¾Æ´Ñµ¥ ÁöÈÖ°ü ¿ªÇÒÀ» ¸Ã°Ú´Ù´Â ¸Þ½ÃÁö°¡ ¼ö½ÅµÇ¸é ¹«½Ã.
	if ((m_pClientList[iClientH]->m_iGuildRank != 0) && (iDuty == 3)) return;

	m_pClientList[iClientH]->m_iCrusadeDuty = iDuty;
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_CRUSADE, (DWORD)m_bIsCrusadeMode, m_pClientList[iClientH]->m_iCrusadeDuty, NULL, NULL);
}

void CGame::MapStatusHandler(int iClientH, int iMode, char * pMapName)
{
 register int i;

	if (m_pClientList[iClientH] == NULL) return;

	switch (iMode) {
	case 1:
		if (m_pClientList[iClientH]->m_iCrusadeDuty == NULL) return;

		for (i = 0; i < DEF_MAXGUILDS; i++) 
		if ((m_pGuildTeleportLoc[i].m_iV1 != NULL) && (m_pGuildTeleportLoc[i].m_iV1 == m_pClientList[iClientH]->m_iGuildGUID)) {
			SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_TCLOC, m_pGuildTeleportLoc[i].m_sDestX, m_pGuildTeleportLoc[i].m_sDestY,
				          NULL, m_pGuildTeleportLoc[i].m_cDestMapName, m_pGuildTeleportLoc[i].m_sDestX2, m_pGuildTeleportLoc[i].m_sDestY2,
						  NULL, NULL, NULL, NULL, m_pGuildTeleportLoc[i].m_cDestMapName2);	
			// °Ç¼³ À§Ä¡¸¦ ÀúÀåÇØ ³õ´Â´Ù.
			ZeroMemory(m_pClientList[iClientH]->m_cConstructMapName, sizeof(m_pClientList[iClientH]->m_cConstructMapName));
			memcpy(m_pClientList[iClientH]->m_cConstructMapName, m_pGuildTeleportLoc[i].m_cDestMapName2, 10);
			m_pClientList[iClientH]->m_iConstructLocX = m_pGuildTeleportLoc[i].m_sDestX2;
			m_pClientList[iClientH]->m_iConstructLocY = m_pGuildTeleportLoc[i].m_sDestY2;
			return;
		}

		// ±æµå ¼Ò¼ÓÀÌ ¾Æ´Ñ ±ºÀÎÀÇ ¿äÃ»ÀÌ´Ù.
		break;

	case 3:
		//if (m_pClientList[iClientH]->m_iCrusadeDuty != 3) return;
		// µ¥ÀÌÅÍ Ä³½Ã ±¸Á¶Ã¼ ÃÊ±âÈ­ 
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX = NULL;
			m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY = NULL;
		}
		m_pClientList[iClientH]->m_iCSIsendPoint = NULL;
		ZeroMemory(m_pClientList[iClientH]->m_cSendingMapName, sizeof(m_pClientList[iClientH]->m_cSendingMapName));

		if (strcmp(pMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName) == 0) {
			// ÇöÀç »ç¿ëÀÚ°¡ À§Ä¡ÇÑ ¸ÊÀÇ Á¤º¸¸¦ ¿ä±¸Çß´Ù.
			// ¸Ê µ¥ÀÌÅÍ¸¦ ¿äÃ»ÇÒ ´ç½ÃÀÇ ³»¿ëÀ» ±×´ë·Î Ä«ÇÇÇÑ´Ù.
			for (i = 0; i < m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_iTotalCrusadeStructures; i++) {
				m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cType;
				m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].cSide;
				m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sX;
				m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_stCrusadeStructureInfo[i].sY;
			}
			memcpy(m_pClientList[iClientH]->m_cSendingMapName, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cName, 10);
		}
		else {
			// ´Ù¸¥ ¸ÊÀÇ »óÈ²À» ¿äÃ»Çß´Ù. ¹Ìµé·£µåÀÇ °æ¿ì´Â °¡´É 
			if (strcmp(pMapName, "middleland") == 0) {
				for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cType = m_stMiddleCrusadeStructureInfo[i].cType;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].cSide = m_stMiddleCrusadeStructureInfo[i].cSide;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sX    = m_stMiddleCrusadeStructureInfo[i].sX;
					m_pClientList[iClientH]->m_stCrusadeStructureInfo[i].sY    = m_stMiddleCrusadeStructureInfo[i].sY;
				}
				strcpy(m_pClientList[iClientH]->m_cSendingMapName, "middleland");
			}
			else {
				// ¾ÆÁ÷ Áö¿øµÇÁö ¾Ê´Â ±â´ÉÀÌ´Ù.
			}
		}
	
		_SendMapStatus(iClientH);
		break;
	}
}


void CGame::_SendMapStatus(int iClientH)
{
 register int i, iDataSize;
 char *cp, cData[DEF_MAXCRUSADESTRUCTURES*6];
 short * sp;

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);

	memcpy(cp, m_pClientList[iClientH]->m_cSendingMapName, 10);
	cp += 10;
	
	sp = (short *)cp;
	*sp = (short)m_pClientList[iClientH]->m_iCSIsendPoint;
	cp += 2;

	// ÃÑ ¸î°³ÀÇ µ¥ÀÌÅÍ°¡ ÀÖ´ÂÁö ¾Ë¸®´Â °÷ ¶ç¿ò.
	cp++;

	if (m_pClientList[iClientH]->m_iCSIsendPoint == NULL)
		m_pClientList[iClientH]->m_bIsSendingMapStatus = TRUE;

	// 100°³¾¿ Á¤º¸¸¦ º¸³½´Ù.
	iDataSize = 0;
	for (i = 0 ; i < 100; i++) {
		if (m_pClientList[iClientH]->m_iCSIsendPoint >= DEF_MAXCRUSADESTRUCTURES) goto SMS_ENDOFDATA;
		if (m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType == NULL) goto SMS_ENDOFDATA;
		
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cType;
		cp++;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sX;
		cp += 2;
		sp = (short *)cp;
		*sp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].sY;
		cp += 2;
		*cp = m_pClientList[iClientH]->m_stCrusadeStructureInfo[m_pClientList[iClientH]->m_iCSIsendPoint].cSide;
		cp++;

		iDataSize += 6;
		m_pClientList[iClientH]->m_iCSIsendPoint++;
	}

	// ¿©±â±îÁö ¿Ô´Ù¸é ´õ º¸³¾ ¸Þ½ÃÁö°¡ ÀÖ´Ù´Â ÀÇ¹Ì.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSNEXT, iDataSize +13, NULL, NULL, cData);
	return;

SMS_ENDOFDATA:;

	// µ¥ÀÌÅÍ°¡ ´Ù Àü¼Û µÇ¾úÀ½À» ÀÇ¹Ì.
	cp = (char *)(cData + 12);
	*cp = (iDataSize/6);
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_MAPSTATUSLAST, iDataSize +13, NULL, NULL, cData);
	m_pClientList[iClientH]->m_bIsSendingMapStatus = FALSE;

	return;
}


void CGame::RemoveCrusadeStructures()
{
 register int i;

	for (i = 0 ; i < DEF_MAXNPCS; i++)
	if (m_pNpcList[i] != NULL) {
		switch (m_pNpcList[i]->m_sType) {
		case 36:
		case 37:
		case 38:
		case 39:
		case 40:
		case 41:
		case 42:
			DeleteNpc(i);
			break;
		}
	}
}

void CGame::RequestHelpHandler(int iClientH)
{
 // ÇïÇÁ ¿äÃ»ÀÌ´Ù. ±æµå ¸¶½ºÅÍ¿¡°Ô ÁÂÇ¥¸¦ Àü´ÞÇØ ÁØ´Ù.
 register int i;	

	if (m_pClientList[iClientH] == NULL) return;
	if (m_pClientList[iClientH]->m_iGuildRank == -1) return;
	if (m_pClientList[iClientH]->m_iCrusadeDuty != 1) return;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iGuildRank == 0) && 
		(m_pClientList[i]->m_iCrusadeDuty == 3) && (m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
		// °°Àº ±æµå ¸¶½ºÅÍÀÌ°í ÁöÈÖ°ü ¿ªÈ°À» ¸ÃÀº »óÅÂÀÌ´Ù.
		SendNotifyMsg(NULL, i, DEF_NOTIFY_HELP, m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, m_pClientList[iClientH]->m_iHP, m_pClientList[iClientH]->m_cCharName);
		return;
	}

	// ÇöÀç ¸Ê¿¡ ÁöÈÖ°üÀÌ ¾øÀ½À» Åëº¸ÇØ ÁØ´Ù.
	SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_HELPFAILED, NULL, NULL, NULL, NULL);
}


BOOL CGame::bStockMsgToGateServer(char *pData, DWORD dwSize)
{
 char * cp;

	//testcode
	//wsprintf(G_cTxt, "StockMsg(%d) Size(%d)", *pData, dwSize);
	//PutLogList(G_cTxt);

	if ((m_iIndexGSS + dwSize) >= DEF_MAXGATESERVERSTOCKMSGSIZE-10) return FALSE;

	cp = (char *)(m_cGateServerStockMsg + m_iIndexGSS);	
	memcpy(cp, pData, dwSize);

	m_iIndexGSS += dwSize;

	return TRUE;
}


void CGame::SendStockMsgToGateServer()
{
 DWORD * dwp;
 WORD * wp;
 char * cp;

	// ±×µ¿¾È ¸ð¾Æ³õ¾Ò´ø ¸Þ½ÃÁö¸¦ °ÔÀÌÆ® ¼­¹ö·Î Àü¼Û.
	if (m_iIndexGSS > 6) {
		//testcode
		//wsprintf(G_cTxt, "(!) Sending Gate Server Stock Msg(%d)", m_iIndexGSS);
		//PutLogList(G_cTxt);

		SendMsgToGateServer(MSGID_SERVERSTOCKMSG, NULL, m_cGateServerStockMsg);
	
		// ¹öÆÛ Å¬¸®¾î
		ZeroMemory(m_cGateServerStockMsg, sizeof(m_cGateServerStockMsg));
		// ¸Ç ¾ÕºÎºÐ¿¡ ¸Þ½ÃÁö »ðÀÔ
		cp = (char *)m_cGateServerStockMsg;
		dwp = (DWORD *)cp;
		*dwp = MSGID_SERVERSTOCKMSG;
		cp += 4;
		wp = (WORD *)cp;
		*wp = DEF_MSGTYPE_CONFIRM;
		cp += 2;

		m_iIndexGSS = 6;
	}
}


void CGame::ServerStockMsgHandler(char *pData)
{
 char * cp, cTemp[120], cName[11];
 short * sp;
 WORD * wp, wServerID, wClientH, wV1, wV2, wV3, wV4;
 DWORD * dwp;
 BOOL bFlag = FALSE;
 int * ip, i, iTotal, iV1, iV2, iV3;

	iTotal = 0;
	cp = (char *)(pData + 6);
	while (bFlag == FALSE) {
		iTotal++;
		switch (*cp) {
		case GSM_CHATMSG:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			ZeroMemory(cName, sizeof(cName));
			iV1 = *cp;
			cp++;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			memcpy(cName, cp, 10);
			cp += 10;;
			sp = (short *)cp;
			wV1 = (WORD)*sp;
			cp += 2;
			ChatMsgHandlerGSM(iV1, iV2, cName, cp, wV1);
			cp += wV1;
			break;
		
		case GSM_CONSTRUCTIONPOINT:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			GSM_ConstructionPoint(iV1, iV2);
			break;

		case GSM_SETGUILDTELEPORTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildTeleportLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_SETGUILDCONSTRUCTLOC:
			cp++;
			ip = (int *)cp;
			iV1 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV2 = *ip;
			cp += 4;
			ip = (int *)cp;
			iV3 = *ip;
			cp += 4;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_SetGuildConstructLoc(iV1, iV2, iV3, cTemp);
			break;

		case GSM_MIDDLEMAPSTATUS:
			cp++;
			// ±¸Á¶Ã¼ Å¬¸®¾î
			for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = NULL;
				m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
				m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
				m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
			}
			sp = (short *)cp;
			m_iTotalMiddleCrusadeStructures = *sp;
			cp += 2;
			// Á¤º¸ ÀÐ¾îµéÀÎ´Ù.
			for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
				m_stMiddleCrusadeStructureInfo[i].cType = *cp;
				cp++;
				m_stMiddleCrusadeStructureInfo[i].cSide = *cp;
				cp++;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sX = *sp;
				cp += 2;
				sp = (short *)cp;
				m_stMiddleCrusadeStructureInfo[i].sY = *sp;
				cp += 2;	
			}
			break;
		
		case GSM_BEGINCRUSADE:
			cp++;
			dwp = (DWORD *)cp;
			cp += 4;
			LocalStartCrusadeMode(*dwp);
			break;
		
		case GSM_ENDCRUSADE:
			cp++;
			LocalEndCrusadeMode(*cp);
			cp += 16;
			break;
		
		case GSM_COLLECTEDMANA:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			CollectedManaHandler(wV1, wV2);
			break;
				
		case GSM_GRANDMAGICLAUNCH:
			cp++;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;

			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;

			switch (wV1) {
			case 1: // ¸ÞÅ×¿À ½ºÆ®¶óÀÌÅ© 
				MeteorStrikeMsgHandler((char)wV2);
				break;
			}
			break;
		
		case  GSM_GRANDMAGICRESULT:
			cp++;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			wp  = (WORD *)cp;
			wV1 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV2 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV3 = *wp;
			cp += 2;
			wp  = (WORD *)cp;
			wV4 = *wp;
			cp += 2;
			GrandMagicResultHandler(cTemp, wV1, wV2, wV3, wV4);
			break;
		
		case GSM_REQUEST_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;
			GSM_RequestFindCharacter(wServerID, wClientH, cTemp);
			break;

		case GSM_RESPONSE_FINDCHARACTER:
			cp++;
			wp = (WORD *)cp;
			wServerID = *wp;
			cp += 2;
			wp = (WORD *)cp;
			wClientH = *wp;
			cp += 2;
			ZeroMemory(cTemp, sizeof(cTemp));
			memcpy(cTemp, cp, 10);
			cp += 10;

			if (wServerID == m_wServerID_GSS) {
				//testcode
				SendNotifyMsg(NULL, wClientH, DEF_NOTIFY_PLAYERONGAME, NULL, NULL, NULL, cTemp);
			}
			break;

		default:
			bFlag = TRUE;
			break;
		}
	}

	//testcode
	//wsprintf(G_cTxt, "(!) Total %d GSM Messages.", iTotal-1);
	//PutLogList(G_cTxt);
}



void CGame::GSM_RequestFindCharacter(WORD wReqServerID, WORD wReqClientH, char *pName)
{
 char * cp, cTemp[120];
 WORD * wp;
 register int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL)  && (strcmp(m_pClientList[i]->m_cCharName, pName) == 0)) {
		// Ã£¾Ò´Ù.
		ZeroMemory(cTemp, sizeof(cTemp));
		cp = (char *)(cTemp);
		*cp = GSM_RESPONSE_FINDCHARACTER;
		cp++;

		wp = (WORD *)cp;
		*wp = wReqServerID;
		cp += 2;

		wp = (WORD *)cp;
		*wp = wReqClientH;
		cp += 2;
		
		memcpy(cp, pName, 10);
		cp += 10;

		bStockMsgToGateServer(cTemp, 15);
		return;	
	}
}


void CGame::DoMeteorStrikeDamageHandler(int iMapIndex)
{
 int i, iDamage;

	// ÇØ´ç ¸ÊÀÇ ÇÃ·¹ÀÌ¾îµéÀÇ HP¸¦ ÀÏ°ý »è°¨
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_cSide != 0) && (m_pClientList[i]->m_cMapIndex == iMapIndex)) {
		if (m_pClientList[i]->m_iLevel < 80) 
			 iDamage = m_pClientList[i]->m_iLevel   +iDice(1,10);
		else iDamage = m_pClientList[i]->m_iLevel*2 +iDice(1,10);
		iDamage = iDice(1, m_pClientList[i]->m_iLevel) + m_pClientList[i]->m_iLevel;
		// ÃÖ´ë 255ÀÌ»óÀÇ ´ë¹ÌÁö´Â ¹ÞÁö ¾Ê´Â´Ù.
		if (iDamage > 255) iDamage = 255;
	
		m_pClientList[i]->m_iHP -= iDamage;
		if (m_pClientList[i]->m_iHP <= 0) {
			// ÇÃ·¹ÀÌ¾î°¡ »ç¸ÁÇß´Ù.
			ClientKilledHandler(i, NULL, NULL, iDamage);	
			m_stMeteorStrikeResult.iCasualties++;
		}
		else {
			if (iDamage > 0) {
				// ¹ÞÀº ´ë¹ÌÁö¸¦ Åëº¸ÇÑ´Ù. <- HP¸¦ ±×´ë·Î ¾Ë¸°´Ù.
				SendNotifyMsg(NULL, i, DEF_NOTIFY_HP, NULL, NULL, NULL, NULL);
				// Ãæ°ÝÀ» ¹Þ¾Ò´Ù¸é Ãæ°Ýµ¿ÀÛ Àü¼Û 
				SendEventToNearClient_TypeA(i, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTDAMAGE, iDamage, NULL, NULL);

				// v1.4 Á×ÀºÃ´ÇÏ°í ÀÖ´Â °æ¿ì´Â Owner À§Ä¡¸¦ ¿Å±ä´Ù. 
				if (m_pClientList[i]->m_bSkillUsingStatus[19] != TRUE) {
					m_pMapList[m_pClientList[i]->m_cMapIndex]->ClearOwner(0, i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
					m_pMapList[m_pClientList[i]->m_cMapIndex]->SetOwner(i, DEF_OWNERTYPE_PLAYER, m_pClientList[i]->m_sX, m_pClientList[i]->m_sY);
				}
			
				if (m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] != 0) {
					// Hold-Person µÇ¾î ÀÖ¾ú´ø »óÅÂ¶ó¸é Ç®¸°´Ù. ¸¶¹ý°ø°Ý ÆÐ·²¶óÀÌÁî µÈ °Íµµ Ç®¸°´Ù.
					// 1: Hold-Person 
					// 2: Paralize
					SendNotifyMsg(NULL, i, DEF_NOTIFY_MAGICEFFECTOFF, DEF_MAGICTYPE_HOLDOBJECT, m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ], NULL, NULL);
							
					m_pClientList[i]->m_cMagicEffectStatus[ DEF_MAGICTYPE_HOLDOBJECT ] = NULL;
					bRemoveFromDelayEventList(i, DEF_OWNERTYPE_PLAYER, DEF_MAGICTYPE_HOLDOBJECT);
				}
			}
		}		
	}
}


void CGame::CalcMeteorStrikeEffectHandler(int iMapIndex)
{
 int i, iActiveStructure;
 char * cp, cData[120], cWinnerSide;
 WORD * wp;

	if (m_bIsCrusadeMode == FALSE) return;

	// Æø°ÝÀÇ È¿°ú¸¦ °è»êÇÑ´Ù. ¸ðµç °Ç¹°ÀÌ ÆÄ±«µÇ¾ú´Ù¸é Àü¸éÀü ¸ðµå Á¾·á. ±×·¸Áö ¾ÊÀ¸¸é °á°ú¸¦ ¸ðµç ¼­¹ö¿¡ ¸®Æ÷Æ®.
	iActiveStructure = 0;
	for (i = 1; i <= m_pMapList[iMapIndex]->m_iTotalStrikePoints; i++) {
		if (m_pMapList[iMapIndex]->m_stStrikePoint[i].iHP > 0) {
			iActiveStructure++;
		}
	}
	
	//testcode
	wsprintf(G_cTxt, "ActiveStructure:%d  MapIndex:%d AresdenMap:%d ElvineMap:%d", iActiveStructure, iMapIndex, m_iAresdenMapIndex, m_iElvineMapIndex);
	PutLogList(G_cTxt);

	if (iActiveStructure == 0) {
		// ÀÛµ¿ÁßÀÎ °Ç¹°ÀÌ ¾ø´Ù. Å©·ç¼¼ÀÌµå ¸ðµå Á¾·á: ´Ù¸¥ ¼­¹ö¿¡ ¾Ë·ÁÁØ´Ù.
		// Å©·ç¼¼ÀÌµå ¸ðµå Á¾·áµÊÀ» ÇöÀç ¼­¹öÀÇ Å¬¶óÀÌ¾ðÆ®µé¿¡°Ô ¹Ù·Î Àü´Þ.
		if (iMapIndex == m_iAresdenMapIndex) {
			cWinnerSide = 2;
			LocalEndCrusadeMode(2); // ÀÌ±ä ÂÊÀº ¿¤¹ÙÀÎ
		}
		else if (iMapIndex == m_iElvineMapIndex) {
			cWinnerSide = 1;
			LocalEndCrusadeMode(1); // ÀÌ±ä ÂÊÀº ¾Æ·¹½ºµ§
		}
		else {
			cWinnerSide = 0;
			LocalEndCrusadeMode(0); 
		}
		
		// ´Ù¸¥ ¼­¹ö¿¡ Å©·ç¼¼ÀÌµå Á¾·á¸¦ ¾Ë¸².
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_ENDCRUSADE;
		cp++;

		*cp = cWinnerSide;
		cp++;			

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		bStockMsgToGateServer(cData, 18);
		
		// ÇöÀç ¼­¹ö¿¡´Â ½ºÅå ¸Þ½ÃÁö°¡ ¿ÀÁö ¾ÊÀ¸¹Ç·Î Á÷Á¢ Àü´ÞÇÑ´Ù.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure);
	}
	else {
		// ÇÇÇØ »óÈ²À» ¸ðµç ¼­¹ö·Î ¸®Æ÷Æ®.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)(cData);
		*cp =  GSM_GRANDMAGICRESULT;
		cp++;
		
		memcpy(cp, m_pMapList[iMapIndex]->m_cName, 10);
		cp += 10;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCrashedStructureNum;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iStructureDamageAmount;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = m_stMeteorStrikeResult.iCasualties;
		cp += 2;

		wp  = (WORD *)cp;
		*wp = iActiveStructure;
		cp += 2;
		
		bStockMsgToGateServer(cData, 19);

		//testcode
		wsprintf(G_cTxt, "(!) Reporting Grand Magic Strike Result (%s %d %d %d %d)", m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure);
		PutLogList(G_cTxt);

		// ÇöÀç ¼­¹ö¿¡´Â ½ºÅå ¸Þ½ÃÁö°¡ ¿ÀÁö ¾ÊÀ¸¹Ç·Î Á÷Á¢ Àü´ÞÇÑ´Ù.
		GrandMagicResultHandler(m_pMapList[iMapIndex]->m_cName, m_stMeteorStrikeResult.iCrashedStructureNum, m_stMeteorStrikeResult.iStructureDamageAmount, m_stMeteorStrikeResult.iCasualties, iActiveStructure);
	}

	// °á°ú º¸°í¿ë ½ºÆ®·°Ãç Å¬¸®¾î
	m_stMeteorStrikeResult.iCasualties            = 0;
	m_stMeteorStrikeResult.iCrashedStructureNum   = 0;
	m_stMeteorStrikeResult.iStructureDamageAmount = 0;
}


void CGame::GrandMagicResultHandler(char *cMapName, int iCrashedStructureNum, int iStructureDamageAmount, int iCasualities, int iActiveStructure)
{
 int i;
	
	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if (m_pClientList[i] != NULL) {
		SendNotifyMsg(NULL, i, DEF_NOTIFY_GRANDMAGICRESULT, iCrashedStructureNum, iStructureDamageAmount, iCasualities, cMapName, iActiveStructure);
	}
}

void CGame::_GrandMagicLaunchMsgSend(int iType, char cAttackerSide)
{
 char * cp, cBuff[120];
 WORD * wp;

	ZeroMemory(cBuff, sizeof(cBuff));
	cp = (char *)cBuff;
	*cp = GSM_GRANDMAGICLAUNCH;
	cp++;

	wp = (WORD *)cp;
	*wp = (WORD)iType;
	cp += 2;

	wp = (WORD *)cp;
	*wp = (WORD)cAttackerSide;
	cp += 2;
	
	bStockMsgToGateServer(cBuff, 5);
}

void CGame::SyncMiddlelandMapInfo()
{
 int i;
 char * cp;
 short * sp;

	// ¹Ìµé·£µåÀÇ Á¤º¸¸¦ ¸ðµç ¼­¹ö¿¡°Ô ½ÌÅ©½ÃÅ²´Ù. ¹Ìµé·£µå¸¦ ´ã´çÇÑ ¼­¹ö¶ó¸é ¹Ù·Î ±¸Á¶Ã¼¸¦ ¾÷µ¥ÀÌÆ® ÇÏ°í ³ª¸ÓÁö ¼­¹öµé¿¡°Ô Á¤º¸ Àü¼Û.
	if (m_iMiddlelandMapIndex != -1) {
		// ±¸Á¶Ã¼ Å¬¸®¾î
		for (i = 0; i < DEF_MAXCRUSADESTRUCTURES; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = NULL;
			m_stMiddleCrusadeStructureInfo[i].cSide = NULL;
			m_stMiddleCrusadeStructureInfo[i].sX    = NULL;
			m_stMiddleCrusadeStructureInfo[i].sY    = NULL;
		}
		// ±¸Á¶Ã¼ º¹»ç ¹× Àü¼Û ¸Þ½ÃÁö ÀÛ¼º 
		m_iTotalMiddleCrusadeStructures = m_pMapList[m_iMiddlelandMapIndex]->m_iTotalCrusadeStructures;
		ZeroMemory(G_cData50000, sizeof(G_cData50000));
		cp = (char *)G_cData50000;
		*cp = GSM_MIDDLEMAPSTATUS;
		cp++;

		sp = (short *)cp;
		*sp = (short)m_iTotalMiddleCrusadeStructures;
		cp += 2;
				
		for (i = 0; i < m_iTotalMiddleCrusadeStructures; i++) {
			m_stMiddleCrusadeStructureInfo[i].cType = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cType;
			m_stMiddleCrusadeStructureInfo[i].cSide = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].cSide;
			m_stMiddleCrusadeStructureInfo[i].sX    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sX;
			m_stMiddleCrusadeStructureInfo[i].sY    = m_pMapList[m_iMiddlelandMapIndex]->m_stCrusadeStructureInfo[i].sY;
			
			*cp = m_stMiddleCrusadeStructureInfo[i].cType;
			cp++;
			*cp = m_stMiddleCrusadeStructureInfo[i].cSide;
			cp++;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sX;
			cp += 2;
			sp = (short *)cp;
			*sp = (short)m_stMiddleCrusadeStructureInfo[i].sY;
			cp += 2;
		}
		
		// ¸Þ½ÃÁö ½ºÅå.
		if (m_iTotalMiddleCrusadeStructures != 0) {
			//testcode
			//wsprintf(G_cTxt, "m_iTotalMiddleCrusadeStructures: %d", m_iTotalMiddleCrusadeStructures);
			//PutLogList(G_cTxt);
			bStockMsgToGateServer(G_cData50000, 3 + m_iTotalMiddleCrusadeStructures*6);
		}
	}
}


void CGame::GSM_SetGuildTeleportLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int * ip, i, iIndex;
 char * cp;
 DWORD dwTemp, dwTime;

	// Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍÀÇ ¿äÃ»ÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ¼­¹ö·ÎºÎÅÍÀÇ ÅÚ·¹Æ÷Æ® ÁÂÇ¥ ¼³Á¤ ¿äÃ»ÀÓ. ÀÀ´äÇÒ ÇÊ¿ä ¾øÀ½.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildTeleportLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX == dX) && (m_pGuildTeleportLoc[i].m_sDestY == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½Å
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX = dX;
			m_pGuildTeleportLoc[i].m_sDestY = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime = dwTime;
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildTeleportLoc Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX = dX;
	m_pGuildTeleportLoc[i].m_sDestY = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime = dwTime;
}

void CGame::GSM_SetGuildConstructLoc(int iGuildGUID, int dX, int dY, char * pMapName)
{
 int * ip, i, iIndex;
 char * cp;
 DWORD dwTemp, dwTime;

	// Å¬¶óÀÌ¾ðÆ®·ÎºÎÅÍÀÇ ¿äÃ»ÀÌ ¾Æ´Ï¶ó ´Ù¸¥ ¼­¹ö·ÎºÎÅÍÀÇ ÅÚ·¹Æ÷Æ® ÁÂÇ¥ ¼³Á¤ ¿äÃ»ÀÓ. ÀÀ´äÇÒ ÇÊ¿ä ¾øÀ½.
	
	//testcode
	wsprintf(G_cTxt, "SetGuildConstructLoc: %d %s %d %d", iGuildGUID, pMapName, dX, dY);
	PutLogList(G_cTxt);

	dwTime = timeGetTime();

	// ¸ÕÀú °°Àº GUID¸¦ °¡Áø ±æµå ÅÚ·¹Æ÷Æ® ÁÂÇ¥°¡ ¼³Á¤µÇ¾î ÀÖ´ÂÁö Ã£´Â´Ù.
	for (i = 0; i < DEF_MAXGUILDS; i++)
	if (m_pGuildTeleportLoc[i].m_iV1 == iGuildGUID) {
		// ÀÌ¹Ì ±æµå°¡ ÀÖ´Ù.
		if ((m_pGuildTeleportLoc[i].m_sDestX2 == dX) && (m_pGuildTeleportLoc[i].m_sDestY2 == dY) && (strcmp(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName) == 0)) {
			// ³»¿ëÀÌ ÀÏÄ¡ÇÑ´Ù. Å¸ÀÓ ÀÔ·ÂÈÄ ½ºÅµ.
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// ³»¿ë °»½Å
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
	}
	
	// ¼³Á¤µÈ ³»¿ëÀÌ ¾ø´Ù. »õ·Î ¼³Á¤ÇÑ´Ù.
	dwTemp = 0;
	iIndex = -1;
	for (i = 0; i < DEF_MAXGUILDS; i++) {
		if (m_pGuildTeleportLoc[i].m_iV1 == NULL) {
					
			m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
			m_pGuildTeleportLoc[i].m_sDestX2 = dX;
			m_pGuildTeleportLoc[i].m_sDestY2 = dY;
			ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName));
			strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
			m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
			return;
		}
		else {
			// °¡Àå ¿À·§µ¿¾È ÂüÁ¶µÇÁö ¾ÊÀº ¸®½ºÆ®ÀÇ ÀÎµ¦½º¸¦ Ã£´Â´Ù.
			if (dwTemp < (dwTime - m_pGuildTeleportLoc[i].m_dwTime2)) {
				dwTemp = (dwTime - m_pGuildTeleportLoc[i].m_dwTime2);
				iIndex = i;
			}
		}
	}

	// Ä³½Ã °ø°£ÀÌ ´Ù Ã¡´Ù. ÀÌ·± °æ¿ì ¸®½ºÆ® Áß °¡Àå ¿À·§µ¿¾È »ç¿ëÇÏÁö ¾ÊÀº ¸®½ºÆ®(iIndex)¸¦ »èÁ¦ÇÏ°í ¾÷µ¥ÀÌÆ® ÇÑ´Ù.
	if (iIndex == -1) return;

	//testcode
	PutLogList("(X) No more GuildConstLocuct Space! Replaced.");

	m_pGuildTeleportLoc[i].m_iV1 = iGuildGUID;
	m_pGuildTeleportLoc[i].m_sDestX2 = dX;
	m_pGuildTeleportLoc[i].m_sDestY2 = dY;
	ZeroMemory(m_pGuildTeleportLoc[i].m_cDestMapName2, sizeof(m_pGuildTeleportLoc[i].m_cDestMapName2));
	strcpy(m_pGuildTeleportLoc[i].m_cDestMapName2, pMapName);
	m_pGuildTeleportLoc[i].m_dwTime2 = dwTime;
}

void CGame::GlobalStartCrusadeMode()
{
 char * cp, cData[120];
 DWORD * dwp, dwCrusadeGUID;

	dwCrusadeGUID = timeGetTime();

	ZeroMemory(cData, sizeof(cData));
	cp = (char *)cData;
	*cp = GSM_BEGINCRUSADE;
	cp++;
	dwp = (DWORD *)cp;
	*dwp = dwCrusadeGUID;
	cp += 4;

	bStockMsgToGateServer(cData, 5);

	LocalStartCrusadeMode(dwCrusadeGUID);
}

void CGame::CheckCommanderConstructionPoint(int iClientH)
{
 char * cp, cData[120];
 int  * ip, i;

	if (m_pClientList[iClientH] == NULL) return;
	if (m_bIsCrusadeMode == FALSE) return;
	if (m_pClientList[iClientH]->m_iConstructionPoint <= 0) return;

	switch (m_pClientList[iClientH]->m_iCrusadeDuty) {
	case 1: // ÆÄÀÌÅÍ
	case 2: // °Ç¼³ÀÚ: ¸ð¾Æ ³õÀº Æ÷ÀÎÆ®¸¦ ±æµå¸¶½ºÅÍ ÁöÈÖ°ü¿¡°Ô Àü´ÞÇÑ´Ù.
		for (i = 0; i < DEF_MAXCLIENTS; i++)
		if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
			(m_pClientList[i]->m_iGuildGUID == m_pClientList[iClientH]->m_iGuildGUID)) {
			// ÇöÀç ¼­¹ö ³»¿¡ ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀÌ ÀÖ´Ù. ÁöÈÖ°üÀÇ Æ÷ÀÎÆ®¸¦ ³ôÀÎ ÈÄ 
			m_pClientList[i]->m_iConstructionPoint += m_pClientList[iClientH]->m_iConstructionPoint;
			m_pClientList[i]->m_iWarContribution   += (m_pClientList[iClientH]->m_iConstructionPoint / 10);

			if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
				m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
			if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
				m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

			SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
			m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
			return;
		}

		// ´Ù¸¥ ¼­¹öÀÇ ÁöÈÖ°ü¿¡°Ô ¾Ë·Á¾ß ÇÑ´Ù.
		ZeroMemory(cData, sizeof(cData));
		cp = (char *)cData;
		*cp = GSM_CONSTRUCTIONPOINT;
		cp++;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iGuildGUID;
		cp += 4;
		ip = (int*)cp;
		*ip = m_pClientList[iClientH]->m_iConstructionPoint;
		cp += 4;
		bStockMsgToGateServer(cData, 9);

		m_pClientList[iClientH]->m_iConstructionPoint = 0; // °ª ÃÊ±âÈ­ 
		break;

	case 3: // ÁöÈÖ°ü: º¸³¾ ÇÊ¿ä ¾øÀ½ 
		
		break;
	}
}

void CGame::GSM_ConstructionPoint(int iGuildGUID, int iPoint)
{
 int i;

	for (i = 1; i < DEF_MAXCLIENTS; i++)
	if ((m_pClientList[i] != NULL) && (m_pClientList[i]->m_iCrusadeDuty == 3) &&
		(m_pClientList[i]->m_iGuildGUID == iGuildGUID)) {
		// ÇØ´ç ±æµå¸¶½ºÅÍ ÁöÈÖ°üÀ» Ã£¾Ò´Ù.
		m_pClientList[i]->m_iConstructionPoint += iPoint;
		m_pClientList[i]->m_iWarContribution   += iPoint/10;
		
		if (m_pClientList[i]->m_iConstructionPoint > DEF_MAXCONSTRUCTIONPOINT) 
			m_pClientList[i]->m_iConstructionPoint = DEF_MAXCONSTRUCTIONPOINT;
		
		if (m_pClientList[i]->m_iWarContribution > DEF_MAXWARCONTRIBUTION)
			m_pClientList[i]->m_iWarContribution = DEF_MAXWARCONTRIBUTION;

		SendNotifyMsg(NULL, i, DEF_NOTIFY_CONSTRUCTIONPOINT, m_pClientList[i]->m_iConstructionPoint, m_pClientList[i]->m_iWarContribution, NULL, NULL);
		//testcode
		wsprintf(G_cTxt, "GSM_ConstructionPoint: %d %d", iGuildGUID, iPoint);
		PutLogList(G_cTxt);
		return;
	}
}

BOOL CGame::bAddClientShortCut(int iClientH)
{
 int i; 

	// ¸ÕÀú µ¿ÀÏÇÑ ¹øÈ£°¡ Á¸ÀçÇÏ´ÂÁö °Ë»ö

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == iClientH) return FALSE;

	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if (m_iClientShortCut[i] == 0) {
		m_iClientShortCut[i] = iClientH;
		return TRUE;
	}

	return FALSE;
}

void CGame::RemoveClientShortCut(int iClientH)
{
 int i;

	for (i = 0; i < DEF_MAXCLIENTS+1; i++)
	if (m_iClientShortCut[i] == iClientH) {
		m_iClientShortCut[i] = 0;
		goto RCSC_LOOPBREAK;
	}

RCSC_LOOPBREAK:;

	// ºó ¿©¹éÀ» ¸Þ²Û´Ù.
	for (i = 0; i < DEF_MAXCLIENTS; i++)
	if ((m_iClientShortCut[i] == 0) && (m_iClientShortCut[i+1] != 0)) {
		m_iClientShortCut[i] = m_iClientShortCut[i+1];
		m_iClientShortCut[i+1] = 0;
	}
}

void CGame::_CreateCrusadeGUID(DWORD dwCrusadeGUID, int iWinnerSide)
{
 char * cp, cTxt[256], cFn[256], cTemp[1024];	
 int iRet;
 FILE * pFile;
		
	_mkdir("GameData");
	ZeroMemory(cFn, sizeof(cFn));
	
	strcat(cFn,"GameData");
	strcat(cFn,"\\");
	strcat(cFn,"\\");					  
	strcat(cFn,"CrusadeGUID.Txt");
		
	pFile = fopen(cFn, "wt");
	if (pFile == NULL) {
		// ÆÄÀÏÀ» ¸¸µé ¼ö ¾ø°Å³ª »çÀÌÁî°¡ Áö³ªÄ¡°Ô ÀÛÀº °æ¿ì´Â . 
		wsprintf(cTxt, "(!) Cannot create CrusadeGUID(%d) file", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	else {
		ZeroMemory(cTemp, sizeof(cTemp));
		
		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "CrusadeGUID = %d\n", dwCrusadeGUID);
		strcat(cTemp, cTxt);

		ZeroMemory(cTxt, sizeof(cTxt));
		wsprintf(cTxt, "winner-side = %d\n", iWinnerSide);
		strcat(cTemp, cTxt);
		
		cp = (char *)cTemp;
		fwrite(cp, strlen(cp), 1, pFile);
		
		wsprintf(cTxt, "(O) CrusadeGUID(%d) file created", dwCrusadeGUID);
		PutLogList(cTxt);
	}
	if (pFile != NULL) fclose(pFile);
}


BOOL CGame::bReadCrusadeGUIDFile(char * cFn)
{
 FILE * pFile;
 HANDLE hFile;
 DWORD  dwFileSize;
 char * cp, * token, cReadMode, cTxt[120];
 char seps[] = "= \t\n";
 class CStrTok * pStrTok;

	cReadMode = 0;

	hFile = CreateFile(cFn, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
	dwFileSize = GetFileSize(hFile, NULL);
	if (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);

	pFile = fopen(cFn, "rt");
	if (pFile == NULL) {
		// °ÔÀÓ¼­¹öÀÇ ÃÊ±âÈ­ ÆÄÀÏÀ» ÀÐÀ» ¼ö ¾ø´Ù.
		PutLogList("(!) Cannot open CrusadeGUID file.");
		return FALSE;
	}
	else {
		PutLogList("(!) Reading CrusadeGUID file...");
		cp = new char[dwFileSize+2];
		ZeroMemory(cp, dwFileSize+2);
		fread(cp, dwFileSize, 1, pFile);

		pStrTok = new class CStrTok(cp, seps);
		token = pStrTok->pGet();

		while( token != NULL )   {
			
			if (cReadMode != 0) {
				switch (cReadMode) {
				case 1:
					m_dwCrusadeGUID = atoi(token);
					wsprintf(G_cTxt, "CrusadeGUID = %d", m_dwCrusadeGUID);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;

				case 2:
					m_iCrusadeWinnerSide = atoi(token);
					wsprintf(G_cTxt, "CrusadeWinnerSide = %d", m_iCrusadeWinnerSide);
					PutLogList(G_cTxt);
					cReadMode = 0;
					break;
				}
			}
			else {
				if (memcmp(token, "CrusadeGUID", 11) == 0) cReadMode = 1;
				if (memcmp(token, "winner-side", 11) == 0) cReadMode = 2;
			}
			
			token = pStrTok->pGet();
		}

		delete pStrTok;
		delete cp;
	}
	if (pFile != NULL) fclose(pFile);

	return TRUE;
}


void CGame::ManualEndCrusadeMode(int iWinnerSide)
{
 char * cp, cData[256];
 WORD * wp;

	// ¸Å´º¾ó·Î Å©·ç¼¼ÀÌµå ¸ðµå¸¦ Á¾·á½ÃÅ²´Ù. ºñ±ä »óÅÂ·Î Á¾·á½ÃÅ²´Ù.
	if (m_bIsCrusadeMode == FALSE) return;

	LocalEndCrusadeMode(iWinnerSide);

	// ´Ù¸¥ ¼­¹ö¿¡ Å©·ç¼¼ÀÌµå Á¾·á¸¦ ¾Ë¸².
	ZeroMemory(cData, sizeof(cData));
	cp = (char *)(cData);
	*cp =  GSM_ENDCRUSADE;
	cp++;

	*cp = (char)iWinnerSide;
	cp++;			

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;

	wp  = (WORD *)cp;
	*wp = NULL;
	cp += 2;
		
	cp += 10;

	bStockMsgToGateServer(cData, 18);
}

int CGame::iGetMapLocationSide(char *pMapName)
{
	if (strcmp(pMapName, "cityhall_1") == 0) return 1;
	if (strcmp(pMapName, "cath_1") == 0) return 1;
	if (strcmp(pMapName, "gshop_1") == 0) return 1;
	if (strcmp(pMapName, "bsmith_1") == 0) return 1;
	if (strcmp(pMapName, "gldhall_1") == 0) return 1;
	if (strcmp(pMapName, "wrhus_1") == 0) return 1;
	if (strcmp(pMapName, "arebrk11") == 0) return 1;
	if (strcmp(pMapName, "wzdtwr_1") == 0) return 1;
	if (strcmp(pMapName, "aresden") == 0) return 1;

	if (strcmp(pMapName, "cityhall_2") == 0) return 2;
	if (strcmp(pMapName, "cath_2") == 0) return 2;
	if (strcmp(pMapName, "gshop_2") == 0) return 2;
	if (strcmp(pMapName, "bsmith_2") == 0) return 2;
	if (strcmp(pMapName, "gldhall_2") == 0) return 2;
	if (strcmp(pMapName, "wrhus_2") == 0) return 2;
	if (strcmp(pMapName, "arebrk21") == 0) return 2;
	if (strcmp(pMapName, "wzdtwr_2") == 0) return 2;
	if (strcmp(pMapName, "elvine") == 0) return 2;

	return 0;
}

BOOL CGame::bCopyItemContents(CItem * pCopy, CItem *pOriginal)
{
	if (pOriginal == NULL) return FALSE;
	if (pCopy == NULL) return FALSE;
	
	pCopy->m_sIDnum = pOriginal->m_sIDnum;					// ¾ÆÀÌÅÛÀÇ °íÀ¯ ¹øÈ£ 
	pCopy->m_cItemType = pOriginal->m_cItemType;
	pCopy->m_cEquipPos = pOriginal->m_cEquipPos;
	pCopy->m_sItemEffectType = pOriginal->m_sItemEffectType;     
	pCopy->m_sItemEffectValue1 = pOriginal->m_sItemEffectValue1;
	pCopy->m_sItemEffectValue2 = pOriginal->m_sItemEffectValue2;
	pCopy->m_sItemEffectValue3 = pOriginal->m_sItemEffectValue3; 
	pCopy->m_sItemEffectValue4 = pOriginal->m_sItemEffectValue4;
	pCopy->m_sItemEffectValue5 = pOriginal->m_sItemEffectValue5;
	pCopy->m_sItemEffectValue6 = pOriginal->m_sItemEffectValue6; 
	pCopy->m_wMaxLifeSpan = pOriginal->m_wMaxLifeSpan;
	pCopy->m_sSpecialEffect = pOriginal->m_sSpecialEffect;
	
	//short m_sSM_HitRatio, m_sL_HitRatio;
	//v1.432 ¸íÁß·ü °¡°¨ »ç¿ë ¾ÈÇÑ´Ù. ´ë½Å Æ¯¼ö ´É·Â ¼öÄ¡°¡ µé¾î°£´Ù.
	pCopy->m_sSpecialEffectValue1 = pOriginal->m_sSpecialEffectValue1;
	pCopy->m_sSpecialEffectValue2 = pOriginal->m_sSpecialEffectValue2; 

	pCopy->m_sSprite = pOriginal->m_sSprite;
	pCopy->m_sSpriteFrame = pOriginal->m_sSpriteFrame;

	pCopy->m_cApprValue = pOriginal->m_cApprValue;
	pCopy->m_cSpeed = pOriginal->m_cSpeed;

	pCopy->m_wPrice = pOriginal->m_wPrice; 
	pCopy->m_wWeight = pOriginal->m_wWeight;
	pCopy->m_sLevelLimit = pOriginal->m_sLevelLimit;	
	pCopy->m_cGenderLimit = pOriginal->m_cGenderLimit;

	pCopy->m_sRelatedSkill = pOriginal->m_sRelatedSkill;
	
	pCopy->m_cCategory = pOriginal->m_cCategory;
	pCopy->m_bIsForSale = pOriginal->m_bIsForSale;
	// 

	pCopy->m_dwCount = pOriginal->m_dwCount;
	pCopy->m_sTouchEffectType = pOriginal->m_sTouchEffectType;
	pCopy->m_sTouchEffectValue1 =pOriginal->m_sTouchEffectValue1;
	pCopy->m_sTouchEffectValue2 = pOriginal->m_sTouchEffectValue2;
	pCopy->m_sTouchEffectValue3 = pOriginal->m_sTouchEffectValue3;
	pCopy->m_cItemColor = pOriginal->m_cItemColor;
	pCopy->m_sItemSpecEffectValue1 = pOriginal->m_sItemSpecEffectValue1;
	pCopy->m_sItemSpecEffectValue2 = pOriginal->m_sItemSpecEffectValue2;
	pCopy->m_sItemSpecEffectValue3 = pOriginal->m_sItemSpecEffectValue3;
	pCopy->m_wCurLifeSpan = pOriginal->m_wCurLifeSpan;
	pCopy->m_dwAttribute = pOriginal->m_dwAttribute;			

	return TRUE;
}


void CGame::AdminOrder_SummonStorm(int iClientH, char* pData, DWORD dwMsgSize)
{
	char   seps[] = "= \t\n"; 
	char   * token, cBuff[256], cMapName[11],cOwnerType;
	int    pX, pY, i; 
	class  CStrTok * pStrTok; 
	short  sOwnerH,sType,sX,sY;
	int    dX1,dY1,iWhetherBonus,iResult = 0,tX,tY,iErr,ix,iy;
	int    iStormCount,iMagicAttr;

	if (m_pClientList[iClientH] == NULL) return; 
	if ((dwMsgSize)   <= 0) return; 

	if (m_pClientList[iClientH]->m_iAdminUserLevel < 3) { 
		SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
		return; 
	} 

	ZeroMemory(cBuff, sizeof(cBuff)); 
	memcpy(cBuff, pData, dwMsgSize); 

	pStrTok = new class CStrTok(cBuff, seps); 
	token = pStrTok->pGet(); 
	token = pStrTok->pGet(); 

	//No Storm Specified
	if (token == NULL) { 
		delete pStrTok; 
		return; 
	} 
	
	sType = atoi(token);

	//Only 100 Magic Spells
	if (sType <= 0)	sType = 1;
	if (sType > 100) sType = 100;

	//No Count Specified
	token = pStrTok->pGet(); 
	if (token == NULL) { 
		delete pStrTok; 
		return; 
	} 
	iStormCount = atoi(token);

	if (iStormCount < 0)
		iStormCount = 0;
	if (iStormCount > 30)
		iStormCount = 30;//Original : 30

try{
	//Whether Bouns
	iWhetherBonus = iGetWhetherMagicBonusEffect(sType, m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->m_cWhetherStatus);
	
	//Magic Attribute
	iMagicAttr = m_pMagicConfigList[sType]->m_iAttribute;

	//Calculate Area Coords
	//Gives Right
	dX1= m_pClientList[iClientH]->m_sX;
	dX1-=10;
	//Gives Top
	dY1= m_pClientList[iClientH]->m_sY;
	dY1-=7;

	while (iStormCount != 0) {
		int randX,randY;
		randX = (rand() % 20) + dX1;
		randY = (rand() % 13) + dY1;

		switch (m_pMagicConfigList[sType]->m_sType) {
			case DEF_MAGICTYPE_DAMAGE_SPOT:
				//Calculate Damage
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
				// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
				}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
				m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_LINEAR:
				// ÀÏÁ÷¼± »ó¿¡ ÀÖ´Â ¸ñÇ¥¸¦ ¸ðµÎ °ø°ÝÇÑ´Ù.
				sX = m_pClientList[iClientH]->m_sX;
				sY = m_pClientList[iClientH]->m_sY;

				for (i = 2; i < 10; i++) {
					iErr = 0;
					m_Misc.GetPoint2(sX, sY, randX, randY, &tX, &tY, &iErr, i);

					// tx, ty
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
							// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
						}

						// tx-1, ty
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX-1, tY);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}

							// tx+1, ty
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX+1, tY);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}

							// tx, ty-1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY-1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY-1);
								if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
									(m_pClientList[sOwnerH]->m_iHP > 0) ) {
										// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
										if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
											Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
									}

							// tx, ty+1
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, tX, tY+1);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

								m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, tX, tY+1);
									if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
										(m_pClientList[sOwnerH]->m_iHP > 0) ) {
											// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
											if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
												Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
										}

									if ( (abs(tX - randX) <= 1) && (abs(tY - randY) <= 1)) break;
					}

					// ÁÖº¯ °ø°Ý È¿°ú 
					for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
						for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
							// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
							if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

							m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
							if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
								(m_pClientList[sOwnerH]->m_iHP > 0) ) {
									// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
									if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
										Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
								}
						}

						// dX, dY
					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
					if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
						Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr); // v1.41 FALSE

					m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
					if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
						(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
								Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr); // v1.41 FALSE
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
						m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;

			case DEF_MAGICTYPE_DAMAGE_AREA:
				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, randX, randY);
				if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
					Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);

				m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, randX, randY);
				if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
					(m_pClientList[sOwnerH]->m_iHP > 0) ) {
						// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, m_pMagicConfigList[sType]->m_sValue4, m_pMagicConfigList[sType]->m_sValue5, m_pMagicConfigList[sType]->m_sValue6 + iWhetherBonus, FALSE, iMagicAttr);
					}

				// ÁÖº¯ °ø°Ý È¿°ú 
				for (iy = randY - m_pMagicConfigList[sType]->m_sValue3; iy <= randY + m_pMagicConfigList[sType]->m_sValue3; iy++)
					for (ix = randX - m_pMagicConfigList[sType]->m_sValue2; ix <= randX + m_pMagicConfigList[sType]->m_sValue2; ix++) {
						// ÀÚ½Åµµ ÇÇÆøµÉ ¼ö ÀÖÀ¸´Ï ÁÖÀÇ.
						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetOwner(&sOwnerH, &cOwnerType, ix, iy);
						if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
							Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);

						m_pMapList[m_pClientList[iClientH]->m_cMapIndex]->GetDeadOwner(&sOwnerH, &cOwnerType, ix, iy);
						if ( (cOwnerType == DEF_OWNERTYPE_PLAYER) && (m_pClientList[sOwnerH] != NULL) &&
							(m_pClientList[sOwnerH]->m_iHP > 0) ) {
								// Á×Àº Ã´ÇÏ°í ÀÖ´Â ÇÃ·¹ÀÌ¾î´Ù.
								if (bCheckResistingMagicSuccess(m_pClientList[iClientH]->m_cDir, sOwnerH, cOwnerType, iResult) == FALSE)
									Effect_Damage_Spot_DamageMove(iClientH, DEF_OWNERTYPE_PLAYER, sOwnerH, cOwnerType, randX, randY, m_pMagicConfigList[sType]->m_sValue7, m_pMagicConfigList[sType]->m_sValue8, m_pMagicConfigList[sType]->m_sValue9 + iWhetherBonus, FALSE, iMagicAttr);
							}
					}
				//Show effects
				SendEventToNearClient_TypeB(MSGID_EVENT_COMMON, DEF_COMMONTYPE_MAGIC, m_pClientList[iClientH]->m_cMapIndex,
					m_pClientList[iClientH]->m_sX, m_pClientList[iClientH]->m_sY, randX, randY, (sType+100), m_pClientList[iClientH]->m_sType);
			break;
		default:
			goto Skip_Storm;
	}
		Sleep(rand() % 10);
		iStormCount--;
	}
}
catch(...){}
Skip_Storm:
	delete pStrTok;
}

void CGame::SetPoisonFlag(short sOwnerH, char cOwnerType, BOOL bStatus) { 
   switch (cOwnerType) { 
   case DEF_OWNERTYPE_PLAYER: 
      if (m_pClientList[sOwnerH] == NULL) return; 

      if (bStatus == TRUE) { 
         m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x80; 
      } else { 
         m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFF7F; 
      } 

      SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, 
         DEF_OBJECTNULLACTION, NULL, NULL, NULL); 

      break; 

   case DEF_OWNERTYPE_NPC: 
      if (m_pNpcList[sOwnerH] == NULL) return; 

      if (bStatus == TRUE) { 
         m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus | 0x80; 
      } else { 
         m_pNpcList[sOwnerH]->m_sStatus = m_pNpcList[sOwnerH]->m_sStatus & 0xFF7F; 
      } 

      SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_NPC, MSGID_EVENT_MOTION, 
         DEF_OBJECTNULLACTION, NULL, NULL, NULL); 

      break; 
   } 
}
void CGame::SetStatusFlag(short sOwnerH, char cOwnerType, BOOL bStatus, int iPass) { 
	if (m_pClientList[sOwnerH] == NULL) return; 

//	if (bStatus == TRUE) { 
//		m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x80; 
//	} else { 
//		m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & iPass; 
//	} 
		m_pClientList[sOwnerH]->m_sStatus = iPass;

//Berserk:
//			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x20;
//		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFDF;
//Invisibility:
//			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x10;
//		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFEF;
//Ice:
//			 m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus | 0x40;
//		else m_pClientList[sOwnerH]->m_sStatus = m_pClientList[sOwnerH]->m_sStatus & 0xFFBF;


	SendEventToNearClient_TypeA(sOwnerH, DEF_OWNERTYPE_PLAYER, MSGID_EVENT_MOTION, DEF_OBJECTNULLACTION, NULL, NULL, NULL); 

}
void CGame::SendMsg(short sOwnerH, char cOwnerType, BOOL bStatus, long lPass) { 
	if (m_pClientList[sOwnerH] == NULL) return; 
	//SendNotifyMsg(NULL, sOwnerH, DEF_NOTIFY_LEVELUP, NULL, NULL, NULL, NULL);

	SendNotifyMsg(NULL, sOwnerH, lPass, NULL, NULL, NULL, NULL);

}
//ArchAngel Function
void CGame::AdminOrder_Weather(int iClientH, char * pData, DWORD dwMsgSize) 
{ 
char   seps[] = "= \t\n"; 
char   * token, cBuff[256]; 
class  CStrTok * pStrTok; 
char cPrevMode; 
int i, j, sType, sTime; 
DWORD dwTime; 

  dwTime = timeGetTime(); 

  if (m_pClientList[iClientH] == NULL) return; 
  if ((dwMsgSize)   <= 0) return; 

  if (m_pClientList[iClientH]->m_iAdminUserLevel < 2) { 
     SendNotifyMsg(NULL, iClientH, DEF_NOTIFY_ADMINUSERLEVELLOW, NULL, NULL, NULL, NULL); 
     return; 
  } 
   
  ZeroMemory(cBuff, sizeof(cBuff)); 
  memcpy(cBuff, pData, dwMsgSize); 

  pStrTok = new class CStrTok(cBuff, seps); 
  token = pStrTok->pGet(); 
  token = pStrTok->pGet(); 
   
  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

     sType = atoi(token); 

  token = pStrTok->pGet(); 

  if (token == NULL) { 
     delete pStrTok; 
     return; 
  } 

  sTime = atoi(token); 

  delete pStrTok; 
   
  for (i = 0; i < DEF_MAXMAPS; i++) { 
     if ((m_pMapList[i] != NULL) && (m_pMapList[i]->m_bIsFixedDayMode == FALSE)) { 
        cPrevMode = m_pMapList[i]->m_cWhetherStatus; 
        if (m_pMapList[i]->m_cWhetherStatus != NULL) { 
           if ((dwTime - m_pMapList[i]->m_dwWhetherStartTime) > m_pMapList[i]->m_dwWhetherLastTime) 
              m_pMapList[i]->m_cWhetherStatus = NULL; 
        } 
        else { 
           sTime *= 1000; 
           m_pMapList[i]->m_cWhetherStatus = sType; 
           m_pMapList[i]->m_dwWhetherStartTime = dwTime; 
           m_pMapList[i]->m_dwWhetherLastTime  = sTime; 
        } 
        if (cPrevMode != m_pMapList[i]->m_cWhetherStatus) { 
           for (j = 1; j < DEF_MAXCLIENTS; j++) 
           if ((m_pClientList[j] != NULL) && (m_pClientList[j]->m_bIsInitComplete == TRUE) && (m_pClientList[j]->m_cMapIndex == i)) 
              SendNotifyMsg(NULL, j, DEF_NOTIFY_WHETHERCHANGE, m_pMapList[i]->m_cWhetherStatus, NULL, NULL, NULL);    
        } 
     } 
  } 
}
